============================= test session starts ==============================
platform linux -- Python 3.12.6, pytest-8.3.3, pluggy-1.5.0 -- /testbed/.venv/bin/python3
cachedir: .pytest_cache
metadata: {'Python': '3.12.6', 'Platform': 'Linux-4.4.0-x86_64-with-glibc2.35', 'Packages': {'pytest': '8.3.3', 'pluggy': '1.5.0'}, 'Plugins': {'json-report': '1.5.0', 'metadata': '3.1.1', 'cov': '5.0.0', 'hypothesis': '6.112.1'}}
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase(PosixPath('/testbed/.hypothesis/examples'))
rootdir: /testbed
configfile: setup.cfg
plugins: json-report-1.5.0, metadata-3.1.1, cov-5.0.0, hypothesis-6.112.1
collecting ... collected 383 items

test.py::test_encoding_detection[tests/windows-1252/_ude_2.txt-windows-1252] FAILED [  0%]
test.py::test_encoding_detection[tests/windows-1252/github_bug_9.txt-windows-1252] FAILED [  0%]
test.py::test_encoding_detection[tests/windows-1252/_mozilla_bug421271_text.html-windows-1252] FAILED [  0%]
test.py::test_encoding_detection[tests/windows-1252/_ude_1.txt-windows-1252] FAILED [  1%]
test.py::test_encoding_detection[tests/UTF-32BE/plane1-utf-32be.html-utf-32be] FAILED [  1%]
test.py::test_encoding_detection[tests/UTF-32BE/nobom-utf32be.txt-utf-32be] FAILED [  1%]
test.py::test_encoding_detection[tests/UTF-16BE/plane1-utf-16be.html-utf-16be] FAILED [  1%]
test.py::test_encoding_detection[tests/UTF-16BE/nobom-utf16be.txt-utf-16be] FAILED [  2%]
test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.9.xml-windows-1251] FAILED [  2%]
test.py::test_encoding_detection[tests/windows-1251-russian/_chromium_windows-1251_with_no_encoding_specified.html-windows-1251] FAILED [  2%]
test.py::test_encoding_detection[tests/windows-1251-russian/_ude_1.txt-windows-1251] FAILED [  2%]
test.py::test_encoding_detection[tests/windows-1251-russian/aviaport.ru.xml-windows-1251] FAILED [  3%]
test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.8.xml-windows-1251] FAILED [  3%]
test.py::test_encoding_detection[tests/windows-1251-russian/money.rin.ru.xml-windows-1251] FAILED [  3%]
test.py::test_encoding_detection[tests/windows-1251-russian/anthropology.ru.xml-windows-1251] FAILED [  3%]
test.py::test_encoding_detection[tests/windows-1251-russian/music.peeps.ru.xml-windows-1251] FAILED [  4%]
test.py::test_encoding_detection[tests/windows-1251-russian/aif.ru.health.xml-windows-1251] FAILED [  4%]
test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.6.xml-windows-1251] FAILED [  4%]
test.py::test_encoding_detection[tests/windows-1251-russian/newsru.com.xml-windows-1251] FAILED [  4%]
test.py::test_encoding_detection[tests/windows-1251-russian/blog.mlmaster.com.xml-windows-1251] FAILED [  5%]
test.py::test_encoding_detection[tests/windows-1251-russian/aug32.hole.ru.xml-windows-1251] FAILED [  5%]
test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.4.xml-windows-1251] FAILED [  5%]
test.py::test_encoding_detection[tests/windows-1251-russian/janulalife.blogspot.com.xml-windows-1251] FAILED [  6%]
test.py::test_encoding_detection[tests/windows-1251-russian/intertat.ru.xml-windows-1251] FAILED [  6%]
test.py::test_encoding_detection[tests/windows-1251-russian/greek.ru.xml-windows-1251] FAILED [  6%]
test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.1.xml-windows-1251] FAILED [  6%]
test.py::test_encoding_detection[tests/windows-1251-russian/kapranoff.ru.xml-windows-1251] FAILED [  7%]
test.py::test_encoding_detection[tests/GB2312/softsea.net.xml-gb2312] FAILED [  7%]
test.py::test_encoding_detection[tests/GB2312/chen56.blogcn.com.xml-gb2312] FAILED [  7%]
test.py::test_encoding_detection[tests/GB2312/pda.blogsome.com.xml-gb2312] FAILED [  7%]
test.py::test_encoding_detection[tests/GB2312/luciferwang.blogcn.com.xml-gb2312] FAILED [  8%]
test.py::test_encoding_detection[tests/GB2312/bbs.blogsome.com.xml-gb2312] FAILED [  8%]
test.py::test_encoding_detection[tests/GB2312/cindychen.com.xml-gb2312] FAILED [  8%]
test.py::test_encoding_detection[tests/GB2312/_chromium_gb18030_with_no_encoding_specified.html.xml-gb2312] FAILED [  8%]
test.py::test_encoding_detection[tests/GB2312/14.blog.westca.com.xml-gb2312] FAILED [  9%]
test.py::test_encoding_detection[tests/GB2312/_mozilla_bug171813_text.html-gb2312] FAILED [  9%]
test.py::test_encoding_detection[tests/GB2312/xy15400.blogcn.com.xml-gb2312] FAILED [  9%]
test.py::test_encoding_detection[tests/GB2312/lily.blogsome.com.xml-gb2312] FAILED [  9%]
test.py::test_encoding_detection[tests/GB2312/w3cn.org.xml-gb2312] FAILED [ 10%]
test.py::test_encoding_detection[tests/GB2312/jjgod.3322.org.xml-gb2312] FAILED [ 10%]
test.py::test_encoding_detection[tests/GB2312/coverer.com.xml-gb2312] FAILED [ 10%]
test.py::test_encoding_detection[tests/GB2312/godthink.blogsome.com.xml-gb2312] FAILED [ 10%]
test.py::test_encoding_detection[tests/GB2312/acnnewswire.net.xml-gb2312] FAILED [ 11%]
test.py::test_encoding_detection[tests/GB2312/eighthday.blogspot.com.xml-gb2312] FAILED [ 11%]
test.py::test_encoding_detection[tests/GB2312/cappuccinos.3322.org.xml-gb2312] FAILED [ 11%]
test.py::test_encoding_detection[tests/GB2312/2.blog.westca.com.xml-gb2312] FAILED [ 12%]
test.py::test_encoding_detection[tests/GB2312/cnblog.org.xml-gb2312] FAILED [ 12%]
test.py::test_encoding_detection[tests/MacCyrillic/music.peeps.ru.xml-maccyrillic] FAILED [ 12%]
test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.4.xml-maccyrillic] FAILED [ 12%]
test.py::test_encoding_detection[tests/MacCyrillic/koi.kinder.ru.xml-maccyrillic] FAILED [ 13%]
test.py::test_encoding_detection[tests/MacCyrillic/_ude_1.txt-maccyrillic] FAILED [ 13%]
test.py::test_encoding_detection[tests/MacCyrillic/aviaport.ru.xml-maccyrillic] FAILED [ 13%]
test.py::test_encoding_detection[tests/MacCyrillic/intertat.ru.xml-maccyrillic] FAILED [ 13%]
test.py::test_encoding_detection[tests/MacCyrillic/aug32.hole.ru.xml-maccyrillic] FAILED [ 14%]
test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.8.xml-maccyrillic] FAILED [ 14%]
test.py::test_encoding_detection[tests/MacCyrillic/aif.ru.health.xml-maccyrillic] FAILED [ 14%]
test.py::test_encoding_detection[tests/MacCyrillic/blog.mlmaster.com.xml-maccyrillic] FAILED [ 14%]
test.py::test_encoding_detection[tests/MacCyrillic/money.rin.ru.xml-maccyrillic] FAILED [ 15%]
test.py::test_encoding_detection[tests/MacCyrillic/newsru.com.xml-maccyrillic] FAILED [ 15%]
test.py::test_encoding_detection[tests/MacCyrillic/greek.ru.xml-maccyrillic] FAILED [ 15%]
test.py::test_encoding_detection[tests/MacCyrillic/susu.ac.ru.xml-maccyrillic] FAILED [ 15%]
test.py::test_encoding_detection[tests/MacCyrillic/kapranoff.ru.xml-maccyrillic] FAILED [ 16%]
test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.6.xml-maccyrillic] FAILED [ 16%]
test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.9.xml-maccyrillic] FAILED [ 16%]
test.py::test_encoding_detection[tests/IBM866/greek.ru.xml-ibm866] FAILED [ 16%]
test.py::test_encoding_detection[tests/IBM866/_ude_1.txt-ibm866] FAILED  [ 17%]
test.py::test_encoding_detection[tests/IBM866/aviaport.ru.xml-ibm866] FAILED [ 17%]
test.py::test_encoding_detection[tests/IBM866/aug32.hole.ru.xml-ibm866] FAILED [ 17%]
test.py::test_encoding_detection[tests/IBM866/kapranoff.ru.xml-ibm866] FAILED [ 18%]
test.py::test_encoding_detection[tests/IBM866/music.peeps.ru.xml-ibm866] FAILED [ 18%]
test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.4.xml-ibm866] FAILED [ 18%]
test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.8.xml-ibm866] FAILED [ 18%]
test.py::test_encoding_detection[tests/IBM866/blog.mlmaster.com.xml-ibm866] FAILED [ 19%]
test.py::test_encoding_detection[tests/IBM866/money.rin.ru.xml-ibm866] FAILED [ 19%]
test.py::test_encoding_detection[tests/IBM866/janulalife.blogspot.com.xml-ibm866] FAILED [ 19%]
test.py::test_encoding_detection[tests/IBM866/intertat.ru.xml-ibm866] FAILED [ 19%]
test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.9.xml-ibm866] FAILED [ 20%]
test.py::test_encoding_detection[tests/IBM866/susu.ac.ru.xml-ibm866] FAILED [ 20%]
test.py::test_encoding_detection[tests/IBM866/newsru.com.xml-ibm866] FAILED [ 20%]
test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.6.xml-ibm866] FAILED [ 20%]
test.py::test_encoding_detection[tests/IBM866/aif.ru.health.xml-ibm866] FAILED [ 21%]
test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.1.xml-ibm866] FAILED [ 21%]
test.py::test_encoding_detection[tests/Big5/myblog.pchome.com.tw.xml-big5] FAILED [ 21%]
test.py::test_encoding_detection[tests/Big5/blog.worren.net.xml-big5] FAILED [ 21%]
test.py::test_encoding_detection[tests/Big5/marilynwu.blogspot.com.xml-big5] FAILED [ 22%]
test.py::test_encoding_detection[tests/Big5/coolloud.org.tw.xml-big5] FAILED [ 22%]
test.py::test_encoding_detection[tests/Big5/ebao.us.xml-big5] FAILED     [ 22%]
test.py::test_encoding_detection[tests/Big5/_ude_1.txt-big5] FAILED      [ 22%]
test.py::test_encoding_detection[tests/Big5/upsaid.com.xml-big5] FAILED  [ 23%]
test.py::test_encoding_detection[tests/Big5/leavesth.blogspot.com.xml-big5] FAILED [ 23%]
test.py::test_encoding_detection[tests/Big5/oui-design.com.xml-big5] FAILED [ 23%]
test.py::test_encoding_detection[tests/Big5/kafkatseng.blogspot.com.xml-big5] FAILED [ 24%]
test.py::test_encoding_detection[tests/Big5/_chromium_Big5_with_no_encoding_specified.html-big5] FAILED [ 24%]
test.py::test_encoding_detection[tests/Big5/sinica.edu.tw.xml-big5] FAILED [ 24%]
test.py::test_encoding_detection[tests/Big5/ke207.blogspot.com.xml-big5] FAILED [ 24%]
test.py::test_encoding_detection[tests/Big5/linyijen.blogspot.com.xml-big5] FAILED [ 25%]
test.py::test_encoding_detection[tests/Big5/tlkkuo.blogspot.com.xml-big5] FAILED [ 25%]
test.py::test_encoding_detection[tests/Big5/carbonxiv.blogspot.com.xml-big5] FAILED [ 25%]
test.py::test_encoding_detection[tests/Big5/0804.blogspot.com.xml-big5] FAILED [ 25%]
test.py::test_encoding_detection[tests/Big5/willythecop.blogspot.com.xml-big5] FAILED [ 26%]
test.py::test_encoding_detection[tests/Big5/sylvia1976.blogspot.com.xml-big5] FAILED [ 26%]
test.py::test_encoding_detection[tests/Big5/fudesign.blogspot.com.xml-big5] FAILED [ 26%]
test.py::test_encoding_detection[tests/Big5/digitalwall.com.xml-big5] FAILED [ 26%]
test.py::test_encoding_detection[tests/Big5/catshadow.blogspot.com.xml-big5] FAILED [ 27%]
test.py::test_encoding_detection[tests/Big5/sanwenji.blogspot.com.xml-big5] FAILED [ 27%]
test.py::test_encoding_detection[tests/Big5/letterlego.blogspot.com.xml-big5] FAILED [ 27%]
test.py::test_encoding_detection[tests/Big5/unoriginalblog.com.xml-big5] FAILED [ 27%]
test.py::test_encoding_detection[tests/Big5/ytc.blogspot.com.xml-big5] FAILED [ 28%]
test.py::test_encoding_detection[tests/UTF-16LE/nobom-utf16le.txt-utf-16le] FAILED [ 28%]
test.py::test_encoding_detection[tests/UTF-16LE/plane1-utf-16le.html-utf-16le] FAILED [ 28%]
test.py::test_encoding_detection[tests/iso-2022-jp/_ude_1.txt-iso-2022-jp] FAILED [ 28%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.4.xml-windows-1251] FAILED [ 29%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/ecloga.cult.bg.xml-windows-1251] FAILED [ 29%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.xml-windows-1251] FAILED [ 29%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/linux-bg.org.xml-windows-1251] FAILED [ 30%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/rinennor.org.xml-windows-1251] FAILED [ 30%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/ide.li.xml-windows-1251] FAILED [ 30%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.xml-windows-1251] FAILED [ 30%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.news.xml-windows-1251] FAILED [ 31%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.2.xml-windows-1251] FAILED [ 31%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.3.xml-windows-1251] FAILED [ 31%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/informator.org.xml-windows-1251] FAILED [ 31%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.xml-windows-1251] FAILED [ 32%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.9.xml-windows-1251] FAILED [ 32%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.comments.xml-windows-1251] FAILED [ 32%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/bbc.co.uk.popshow.xml-windows-1251] FAILED [ 32%]
test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.medusa.4.xml-windows-1251] FAILED [ 33%]
test.py::test_encoding_detection[tests/EUC-KR/willis.egloos.com.xml-euc-kr] FAILED [ 33%]
test.py::test_encoding_detection[tests/EUC-KR/xenix.egloos.com.xml-euc-kr] FAILED [ 33%]
test.py::test_encoding_detection[tests/EUC-KR/ittrend.egloos.com.xml-euc-kr] FAILED [ 33%]
test.py::test_encoding_detection[tests/EUC-KR/zangsalang.egloos.com.xml-euc-kr] FAILED [ 34%]
test.py::test_encoding_detection[tests/EUC-KR/_ude_euc1.txt-euc-kr] FAILED [ 34%]
test.py::test_encoding_detection[tests/EUC-KR/lennon81.egloos.com.xml-euc-kr] FAILED [ 34%]
test.py::test_encoding_detection[tests/EUC-KR/sparcs.kaist.ac.kr.xml-euc-kr] FAILED [ 34%]
test.py::test_encoding_detection[tests/EUC-KR/poliplus.egloos.com.xml-euc-kr] FAILED [ 35%]
test.py::test_encoding_detection[tests/EUC-KR/blog.rss.naver.com.xml-euc-kr] FAILED [ 35%]
test.py::test_encoding_detection[tests/EUC-KR/blog.empas.com.xml-euc-kr] FAILED [ 35%]
test.py::test_encoding_detection[tests/EUC-KR/birder.egloos.com.xml-euc-kr] FAILED [ 36%]
test.py::test_encoding_detection[tests/EUC-KR/blog.bd-lab.com.xml-euc-kr] FAILED [ 36%]
test.py::test_encoding_detection[tests/EUC-KR/_chromium_windows-949_with_no_encoding_specified.html-euc-kr] FAILED [ 36%]
test.py::test_encoding_detection[tests/EUC-KR/oroll.egloos.com.xml-euc-kr] FAILED [ 36%]
test.py::test_encoding_detection[tests/EUC-KR/console.linuxstudy.pe.kr.xml-euc-kr] FAILED [ 37%]
test.py::test_encoding_detection[tests/EUC-KR/alogblog.com.xml-euc-kr] FAILED [ 37%]
test.py::test_encoding_detection[tests/EUC-KR/_mozilla_bug9357_text.html-euc-kr] FAILED [ 37%]
test.py::test_encoding_detection[tests/EUC-KR/epitaph.egloos.com.xml-euc-kr] FAILED [ 37%]
test.py::test_encoding_detection[tests/EUC-KR/arts.egloos.com.xml-euc-kr] FAILED [ 38%]
test.py::test_encoding_detection[tests/EUC-KR/acnnewswire.net.xml-euc-kr] FAILED [ 38%]
test.py::test_encoding_detection[tests/EUC-KR/_ude_euc2.txt-euc-kr] FAILED [ 38%]
test.py::test_encoding_detection[tests/EUC-KR/chisato.info.xml-euc-kr] FAILED [ 38%]
test.py::test_encoding_detection[tests/EUC-KR/tori02.egloos.com.xml-euc-kr] FAILED [ 39%]
test.py::test_encoding_detection[tests/EUC-KR/critique.or.kr.xml-euc-kr] FAILED [ 39%]
test.py::test_encoding_detection[tests/EUC-KR/siwoo.org.xml-euc-kr] FAILED [ 39%]
test.py::test_encoding_detection[tests/EUC-KR/jely.egloos.com.xml-euc-kr] FAILED [ 39%]
test.py::test_encoding_detection[tests/EUC-KR/yunho.egloos.com.xml-euc-kr] FAILED [ 40%]
test.py::test_encoding_detection[tests/EUC-KR/calmguy.egloos.com.xml-euc-kr] FAILED [ 40%]
test.py::test_encoding_detection[tests/EUC-KR/jely.pe.kr.xml-euc-kr] FAILED [ 40%]
test.py::test_encoding_detection[tests/EUC-KR/jowchung.oolim.net.xml-euc-kr] FAILED [ 40%]
test.py::test_encoding_detection[tests/EUC-KR/kina.egloos.com.xml-euc-kr] FAILED [ 41%]
test.py::test_encoding_detection[tests/EUC-KR/scarletkh2.egloos.com.xml-euc-kr] FAILED [ 41%]
test.py::test_encoding_detection[tests/KOI8-R/susu.ac.ru.xml-koi8-r] FAILED [ 41%]
test.py::test_encoding_detection[tests/KOI8-R/_ude_1.txt-koi8-r] FAILED  [ 42%]
test.py::test_encoding_detection[tests/KOI8-R/kapranoff.ru.xml-koi8-r] FAILED [ 42%]
test.py::test_encoding_detection[tests/KOI8-R/newsru.com.xml-koi8-r] FAILED [ 42%]
test.py::test_encoding_detection[tests/KOI8-R/music.peeps.ru.xml-koi8-r] FAILED [ 42%]
test.py::test_encoding_detection[tests/KOI8-R/aviaport.ru.xml-koi8-r] FAILED [ 43%]
test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.6.xml-koi8-r] FAILED [ 43%]
test.py::test_encoding_detection[tests/KOI8-R/janulalife.blogspot.com.xml-koi8-r] FAILED [ 43%]
test.py::test_encoding_detection[tests/KOI8-R/_chromium_KOI8-R_with_no_encoding_specified.html-koi8-r] FAILED [ 43%]
test.py::test_encoding_detection[tests/KOI8-R/aif.ru.health.xml-koi8-r] FAILED [ 44%]
test.py::test_encoding_detection[tests/KOI8-R/intertat.ru.xml-koi8-r] FAILED [ 44%]
test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.9.xml-koi8-r] FAILED [ 44%]
test.py::test_encoding_detection[tests/KOI8-R/aug32.hole.ru.xml-koi8-r] FAILED [ 44%]
test.py::test_encoding_detection[tests/KOI8-R/blog.mlmaster.com.xml-koi8-r] FAILED [ 45%]
test.py::test_encoding_detection[tests/KOI8-R/koi.kinder.ru.xml-koi8-r] FAILED [ 45%]
test.py::test_encoding_detection[tests/KOI8-R/greek.ru.xml-koi8-r] FAILED [ 45%]
test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.1.xml-koi8-r] FAILED [ 45%]
test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.4.xml-koi8-r] FAILED [ 46%]
test.py::test_encoding_detection[tests/KOI8-R/money.rin.ru.xml-koi8-r] FAILED [ 46%]
test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.8.xml-koi8-r] FAILED [ 46%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he3.txt-windows-1255] FAILED [ 46%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/halemo.net.edoar.xml-windows-1255] FAILED [ 47%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.8.xml-windows-1255] FAILED [ 47%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/hydepark.hevre.co.il.7957.xml-windows-1255] FAILED [ 47%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/exego.net.2.xml-windows-1255] FAILED [ 48%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/maakav.org.xml-windows-1255] FAILED [ 48%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/neviim.net.xml-windows-1255] FAILED [ 48%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/infomed.co.il.xml-windows-1255] FAILED [ 48%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/_chromium_ISO-8859-8_with_no_encoding_specified.html-windows-1255] FAILED [ 49%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/whatsup.org.il.xml-windows-1255] FAILED [ 49%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/hagada.org.il.xml-windows-1255] FAILED [ 49%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he2.txt-windows-1255] FAILED [ 49%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/sharks.co.il.xml-windows-1255] FAILED [ 50%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.7.xml-windows-1255] FAILED [ 50%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/pcplus.co.il.xml-windows-1255] FAILED [ 50%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.50.xml-windows-1255] FAILED [ 50%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.6.xml-windows-1255] FAILED [ 51%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/hevra.org.il.xml-windows-1255] FAILED [ 51%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/law.co.il.xml-windows-1255] FAILED [ 51%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he1.txt-windows-1255] FAILED [ 51%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/info.org.il.xml-windows-1255] FAILED [ 52%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/_chromium_windows-1255_with_no_encoding_specified.html-windows-1255] FAILED [ 52%]
test.py::test_encoding_detection[tests/windows-1255-hebrew/carshops.co.il.xml-windows-1255] FAILED [ 52%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.wld.xml-iso-8859-7] FAILED [ 53%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/disabled.gr.xml-iso-8859-7] XFAIL [ 53%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.fin.xml-iso-8859-7] FAILED [ 53%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrt.xml-iso-8859-7] FAILED [ 53%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.cmm.xml-iso-8859-7] FAILED [ 54%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.bus.xml-iso-8859-7] FAILED [ 54%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_2.txt-iso-8859-7] FAILED [ 54%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.spo.xml-iso-8859-7] FAILED [ 54%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/_chromium_ISO-8859-7_with_no_encoding_specified.html-iso-8859-7] FAILED [ 55%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrk.xml-iso-8859-7] FAILED [ 55%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_greek.txt-iso-8859-7] FAILED [ 55%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_3.txt-iso-8859-7] FAILED [ 55%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/hotstation.gr.xml-iso-8859-7] FAILED [ 56%]
test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_1.txt-iso-8859-7] FAILED [ 56%]
test.py::test_encoding_detection[tests/UTF-16/bom-utf-16-be.srt-utf-16] FAILED [ 56%]
test.py::test_encoding_detection[tests/UTF-16/bom-utf-16-le.srt-utf-16] FAILED [ 56%]
test.py::test_encoding_detection[tests/CP949/ricanet.com.xml-cp949] FAILED [ 57%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/music.peeps.ru.xml-iso-8859-5] FAILED [ 57%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/intertat.ru.xml-iso-8859-5] FAILED [ 57%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/aviaport.ru.xml-iso-8859-5] FAILED [ 57%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.1.xml-iso-8859-5] FAILED [ 58%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.4.xml-iso-8859-5] FAILED [ 58%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/aug32.hole.ru.xml-iso-8859-5] FAILED [ 58%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/janulalife.blogspot.com.xml-iso-8859-5] FAILED [ 59%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/money.rin.ru.xml-iso-8859-5] FAILED [ 59%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/_chromium_ISO-8859-5_with_no_encoding_specified.html-iso-8859-5] FAILED [ 59%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.8.xml-iso-8859-5] FAILED [ 59%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/greek.ru.xml-iso-8859-5] FAILED [ 60%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/susu.ac.ru.xml-iso-8859-5] FAILED [ 60%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.6.xml-iso-8859-5] FAILED [ 60%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/aif.ru.health.xml-iso-8859-5] FAILED [ 60%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.9.xml-iso-8859-5] FAILED [ 61%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/kapranoff.ru.xml-iso-8859-5] FAILED [ 61%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/blog.mlmaster.com.xml-iso-8859-5] FAILED [ 61%]
test.py::test_encoding_detection[tests/iso-8859-5-russian/newsru.com.xml-iso-8859-5] FAILED [ 61%]
test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.analyse1.xml-tis-620] FAILED [ 62%]
test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.healthinfo-ne.xml-tis-620] FAILED [ 62%]
test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.centerlab.xml-tis-620] FAILED [ 62%]
test.py::test_encoding_detection[tests/TIS-620/opentle.org.xml-tis-620] FAILED [ 62%]
test.py::test_encoding_detection[tests/TIS-620/trickspot.boxchart.com.xml-tis-620] FAILED [ 63%]
test.py::test_encoding_detection[tests/TIS-620/_mozilla_bug488426_text.html-tis-620] FAILED [ 63%]
test.py::test_encoding_detection[tests/EUC-TW/_ude_euc-tw1.txt-euc-tw] PASSED [ 63%]
test.py::test_encoding_detection[tests/utf-8/anitabee.blogspot.com.xml-utf-8] FAILED [ 63%]
test.py::test_encoding_detection[tests/utf-8/_ude_2.txt-utf-8] FAILED    [ 64%]
test.py::test_encoding_detection[tests/utf-8/_chromium_UTF-8_with_no_encoding_specified.html-utf-8] FAILED [ 64%]
test.py::test_encoding_detection[tests/utf-8/_ude_3.txt-utf-8] FAILED    [ 64%]
test.py::test_encoding_detection[tests/utf-8/weblabor.hu.2.xml-utf-8] FAILED [ 65%]
test.py::test_encoding_detection[tests/utf-8/balatonblog.typepad.com.xml-utf-8] FAILED [ 65%]
test.py::test_encoding_detection[tests/utf-8/_ude_he3.txt-utf-8] FAILED  [ 65%]
test.py::test_encoding_detection[tests/utf-8/_ude_5.txt-utf-8] FAILED    [ 65%]
test.py::test_encoding_detection[tests/utf-8/_ude_greek.txt-utf-8] FAILED [ 66%]
test.py::test_encoding_detection[tests/utf-8/_ude_he2.txt-utf-8] FAILED  [ 66%]
test.py::test_encoding_detection[tests/utf-8/linuxbox.hu.xml-utf-8] FAILED [ 66%]
test.py::test_encoding_detection[tests/utf-8/_ude_russian.txt-utf-8] FAILED [ 66%]
test.py::test_encoding_detection[tests/utf-8/pihgy.hu.xml-utf-8] FAILED  [ 67%]
test.py::test_encoding_detection[tests/utf-8/weblabor.hu.xml-utf-8] FAILED [ 67%]
test.py::test_encoding_detection[tests/utf-8/_mozilla_bug426271_text-utf-8.html-utf-8] FAILED [ 67%]
test.py::test_encoding_detection[tests/utf-8/boobooo.blogspot.com.xml-utf-8] FAILED [ 67%]
test.py::test_encoding_detection[tests/utf-8/_ude_1.txt-utf-8] FAILED    [ 68%]
test.py::test_encoding_detection[tests/utf-8/_mozilla_bug306272_text.html-utf-8] FAILED [ 68%]
test.py::test_encoding_detection[tests/utf-8/_ude_he1.txt-utf-8] FAILED  [ 68%]
test.py::test_encoding_detection[tests/UTF-32/bom-utf-32-be.srt-utf-32] FAILED [ 68%]
test.py::test_encoding_detection[tests/UTF-32/bom-utf-32-le.srt-utf-32] FAILED [ 69%]
test.py::test_encoding_detection[tests/iso-8859-1/_ude_2.txt-iso-8859-1] FAILED [ 69%]
test.py::test_encoding_detection[tests/iso-8859-1/_ude_1.txt-iso-8859-1] FAILED [ 69%]
test.py::test_encoding_detection[tests/iso-8859-1/_ude_4.txt-iso-8859-1] FAILED [ 69%]
test.py::test_encoding_detection[tests/iso-8859-1/_ude_6.txt-iso-8859-1] FAILED [ 70%]
test.py::test_encoding_detection[tests/iso-8859-1/_ude_5.txt-iso-8859-1] FAILED [ 70%]
test.py::test_encoding_detection[tests/iso-8859-1/_ude_3.txt-iso-8859-1] FAILED [ 70%]
test.py::test_encoding_detection[tests/Johab/iyagi-readme.txt-johab] FAILED [ 71%]
test.py::test_encoding_detection[tests/Johab/hlpro-readme.txt-johab] FAILED [ 71%]
test.py::test_encoding_detection[tests/Johab/mdir-doc.txt-johab] FAILED  [ 71%]
test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.6.xml-ibm855] FAILED [ 71%]
test.py::test_encoding_detection[tests/IBM855/_ude_1.txt-ibm855] FAILED  [ 72%]
test.py::test_encoding_detection[tests/IBM855/blog.mlmaster.com.xml-ibm855] FAILED [ 72%]
test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.1.xml-ibm855] FAILED [ 72%]
test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.9.xml-ibm855] FAILED [ 72%]
test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.8.xml-ibm855] FAILED [ 73%]
test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.4.xml-ibm855] FAILED [ 73%]
test.py::test_encoding_detection[tests/IBM855/kapranoff.ru.xml-ibm855] FAILED [ 73%]
test.py::test_encoding_detection[tests/IBM855/janulalife.blogspot.com.xml-ibm855] FAILED [ 73%]
test.py::test_encoding_detection[tests/IBM855/aviaport.ru.xml-ibm855] FAILED [ 74%]
test.py::test_encoding_detection[tests/IBM855/aif.ru.health.xml-ibm855] FAILED [ 74%]
test.py::test_encoding_detection[tests/IBM855/newsru.com.xml-ibm855] FAILED [ 74%]
test.py::test_encoding_detection[tests/IBM855/greek.ru.xml-ibm855] FAILED [ 74%]
test.py::test_encoding_detection[tests/IBM855/music.peeps.ru.xml-ibm855] FAILED [ 75%]
test.py::test_encoding_detection[tests/IBM855/aug32.hole.ru.xml-ibm855] FAILED [ 75%]
test.py::test_encoding_detection[tests/IBM855/intertat.ru.xml-ibm855] FAILED [ 75%]
test.py::test_encoding_detection[tests/IBM855/money.rin.ru.xml-ibm855] FAILED [ 75%]
test.py::test_encoding_detection[tests/IBM855/susu.ac.ru.xml-ibm855] FAILED [ 76%]
test.py::test_encoding_detection[tests/utf-8-sig/bom-utf-8.srt-utf-8-sig] FAILED [ 76%]
test.py::test_encoding_detection[tests/utf-8-sig/_ude_4.txt-utf-8-sig] FAILED [ 76%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/doncho.net.comments.xml-iso-8859-5] FAILED [ 77%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.xml-iso-8859-5] FAILED [ 77%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/ide.li.xml-iso-8859-5] FAILED [ 77%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.9.xml-iso-8859-5] FAILED [ 77%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.xml-iso-8859-5] FAILED [ 78%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/ecloga.cult.bg.xml-iso-8859-5] FAILED [ 78%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.news.xml-iso-8859-5] FAILED [ 78%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/aero-bg.com.xml-iso-8859-5] FAILED [ 78%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.4.xml-iso-8859-5] FAILED [ 79%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/linux-bg.org.xml-iso-8859-5] FAILED [ 79%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.medusa.4.xml-iso-8859-5] FAILED [ 79%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.2.xml-iso-8859-5] FAILED [ 79%]
test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bbc.co.uk.popshow.xml-iso-8859-5] FAILED [ 80%]
test.py::test_encoding_detection[tests/ascii/_mozilla_bug638318_text.html-ascii] FAILED [ 80%]
test.py::test_encoding_detection[tests/ascii/howto.diveintomark.org.xml-ascii] FAILED [ 80%]
test.py::test_encoding_detection[tests/ascii/_chromium_iso-8859-1_with_no_encoding_specified.html-ascii] FAILED [ 80%]
test.py::test_encoding_detection[tests/iso-2022-kr/_ude_iso1.txt-iso-2022-kr] FAILED [ 81%]
test.py::test_encoding_detection[tests/iso-2022-kr/_ude_iso2.txt-iso-2022-kr] FAILED [ 81%]
test.py::test_encoding_detection[tests/UTF-32LE/nobom-utf32le.txt-utf-32le] FAILED [ 81%]
test.py::test_encoding_detection[tests/UTF-32LE/plane1-utf-32le.html-utf-32le] FAILED [ 81%]
test.py::test_encoding_detection[tests/iso-8859-9-turkish/wikitop_tr_ISO-8859-9.txt-iso-8859-9] XFAIL [ 82%]
test.py::test_encoding_detection[tests/iso-8859-9-turkish/_ude_1.txt-iso-8859-9] XFAIL [ 82%]
test.py::test_encoding_detection[tests/iso-8859-9-turkish/_ude_2.txt-iso-8859-9] XFAIL [ 82%]
test.py::test_encoding_detection[tests/iso-8859-9-turkish/subtitle.srt-iso-8859-9] XFAIL [ 83%]
test.py::test_encoding_detection[tests/iso-8859-9-turkish/divxplanet.com.xml-iso-8859-9] XFAIL [ 83%]
test.py::test_encoding_detection[tests/EUC-JP/overcube.com.xml-euc-jp] FAILED [ 83%]
test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug620106_text.html-euc-jp] FAILED [ 83%]
test.py::test_encoding_detection[tests/EUC-JP/rdf.ycf.nanet.co.jp.xml-euc-jp] FAILED [ 84%]
test.py::test_encoding_detection[tests/EUC-JP/_ude_1.txt-euc-jp] FAILED  [ 84%]
test.py::test_encoding_detection[tests/EUC-JP/tls.org.xml-euc-jp] FAILED [ 84%]
test.py::test_encoding_detection[tests/EUC-JP/aivy.co.jp.xml-euc-jp] FAILED [ 84%]
test.py::test_encoding_detection[tests/EUC-JP/yukiboh.moo.jp.xml-euc-jp] FAILED [ 85%]
test.py::test_encoding_detection[tests/EUC-JP/bphrs.net.xml-euc-jp] FAILED [ 85%]
test.py::test_encoding_detection[tests/EUC-JP/misuzilla.org.xml-euc-jp] FAILED [ 85%]
test.py::test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.xml-euc-jp] FAILED [ 85%]
test.py::test_encoding_detection[tests/EUC-JP/aristrist.s57.xrea.com.xml-euc-jp] FAILED [ 86%]
test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug431054_text.html-euc-jp] FAILED [ 86%]
test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug426271_text-euc-jp.html-euc-jp] FAILED [ 86%]
test.py::test_encoding_detection[tests/EUC-JP/club.h14m.org.xml-euc-jp] FAILED [ 86%]
test.py::test_encoding_detection[tests/EUC-JP/siesta.co.jp.aozora.xml-euc-jp] FAILED [ 87%]
test.py::test_encoding_detection[tests/EUC-JP/ch.kitaguni.tv.xml-euc-jp] FAILED [ 87%]
test.py::test_encoding_detection[tests/EUC-JP/contents-factory.com.xml-euc-jp] FAILED [ 87%]
test.py::test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.atom.xml-euc-jp] FAILED [ 87%]
test.py::test_encoding_detection[tests/EUC-JP/atom.ycf.nanet.co.jp.xml-euc-jp] FAILED [ 88%]
test.py::test_encoding_detection[tests/EUC-JP/arclamp.jp.xml-euc-jp] FAILED [ 88%]
test.py::test_encoding_detection[tests/EUC-JP/furusatonoeki.cutegirl.jp.xml-euc-jp] FAILED [ 88%]
test.py::test_encoding_detection[tests/EUC-JP/pinkupa.com.xml-euc-jp] FAILED [ 89%]
test.py::test_encoding_detection[tests/EUC-JP/artifact-jp.com.xml-euc-jp] FAILED [ 89%]
test.py::test_encoding_detection[tests/EUC-JP/azoz.org.xml-euc-jp] FAILED [ 89%]
test.py::test_encoding_detection[tests/EUC-JP/akaname.main.jp.xml-euc-jp] FAILED [ 89%]
test.py::test_encoding_detection[tests/EUC-JP/mimizun.com.xml-euc-jp] FAILED [ 90%]
test.py::test_encoding_detection[tests/EUC-JP/manana.moo.jp.xml-euc-jp] FAILED [ 90%]
test.py::test_encoding_detection[tests/EUC-JP/azito.under.jp.xml-euc-jp] FAILED [ 90%]
test.py::test_encoding_detection[tests/EUC-JP/overcube.com.atom.xml-euc-jp] FAILED [ 90%]
test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_1.txt-shift_jis] FAILED [ 91%]
test.py::test_encoding_detection[tests/SHIFT_JIS/accessories-brand.com.xml-shift_jis] FAILED [ 91%]
test.py::test_encoding_detection[tests/SHIFT_JIS/setsuzei119.jp.xml-shift_jis] FAILED [ 91%]
test.py::test_encoding_detection[tests/SHIFT_JIS/dogsinn.jp.xml-shift_jis] FAILED [ 91%]
test.py::test_encoding_detection[tests/SHIFT_JIS/nextbeaut.com.xml-shift_jis] FAILED [ 92%]
test.py::test_encoding_detection[tests/SHIFT_JIS/ooganemochi.com.xml-shift_jis] FAILED [ 92%]
test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_2.txt-shift_jis] FAILED [ 92%]
test.py::test_encoding_detection[tests/SHIFT_JIS/clickablewords.com.xml-shift_jis] FAILED [ 92%]
test.py::test_encoding_detection[tests/SHIFT_JIS/bloglelife.com.xml-shift_jis] FAILED [ 93%]
test.py::test_encoding_detection[tests/SHIFT_JIS/perth-on.net.xml-shift_jis] FAILED [ 93%]
test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.money.xml-shift_jis] FAILED [ 93%]
test.py::test_encoding_detection[tests/SHIFT_JIS/tamuyou.haun.org.xml-shift_jis] FAILED [ 93%]
test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_4.txt-shift_jis] FAILED [ 94%]
test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.xml-shift_jis] FAILED [ 94%]
test.py::test_encoding_detection[tests/SHIFT_JIS/blog.inkase.net.xml-shift_jis] FAILED [ 94%]
test.py::test_encoding_detection[tests/SHIFT_JIS/_chromium_Shift-JIS_with_no_encoding_specified.html-shift_jis] FAILED [ 95%]
test.py::test_encoding_detection[tests/SHIFT_JIS/sakusaka-silk.net.xml-shift_jis] FAILED [ 95%]
test.py::test_encoding_detection[tests/SHIFT_JIS/yasuhisa.com.xml-shift_jis] FAILED [ 95%]
test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.inami.xml-shift_jis] FAILED [ 95%]
test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_3.txt-shift_jis] FAILED [ 96%]
test.py::test_encoding_detection[tests/SHIFT_JIS/amefoot.net.xml-shift_jis] FAILED [ 96%]
test.py::test_encoding_detection[tests/SHIFT_JIS/10e.org.xml-shift_jis] FAILED [ 96%]
test.py::test_encoding_detection[tests/SHIFT_JIS/grebeweb.net.xml-shift_jis] FAILED [ 96%]
test.py::test_encoding_detection[tests/SHIFT_JIS/blog.paseri.ne.jp.xml-shift_jis] FAILED [ 97%]
test.py::test_encoding_detection[tests/SHIFT_JIS/1affliate.com.xml-shift_jis] FAILED [ 97%]
test.py::test_encoding_detection[tests/SHIFT_JIS/do.beginnersrack.com.xml-shift_jis] FAILED [ 97%]
test.py::test_encoding_detection[tests/SHIFT_JIS/celeb.lalalu.com.xml-shift_jis] FAILED [ 97%]
test.py::test_encoding_detection[tests/SHIFT_JIS/milliontimes.jp.xml-shift_jis] FAILED [ 98%]
test.py::test_encoding_detection[tests/SHIFT_JIS/moon-light.ne.jp.xml-shift_jis] FAILED [ 98%]
test.py::test_encoding_detection[tests/SHIFT_JIS/brag.zaka.to.xml-shift_jis] FAILED [ 98%]
test.py::test_encoding_detection[tests/CP932/y-moto.com.xml-cp932] FAILED [ 98%]
test.py::test_encoding_detection[tests/CP932/hardsoft.at.webry.info.xml-cp932] FAILED [ 99%]
test.py::test_encoding_detection[tests/CP932/www2.chuo-u.ac.jp-suishin.xml-cp932] FAILED [ 99%]
test.py::test_never_fails_to_detect_if_there_is_a_valid_encoding XFAIL   [ 99%]
test.py::test_detect_all_and_detect_one_should_agree FAILED              [100%]

=================================== FAILURES ===================================
_____ test_encoding_detection[tests/windows-1252/_ude_2.txt-windows-1252] ______

file_name = 'tests/windows-1252/_ude_2.txt', encoding = 'windows-1252'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'Stipan Arkadiewitsch was tegenover zich zelf tamelijk oprecht. Hij kon niet liegen en zich zelf verzekeren...t: Leef zoo, dat gij elken dag zijn recht geeft, tracht u zelf te vergeten en te bedwelmen in den droom des levens.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/windows-1252/github_bug_9.txt-windows-1252] ___

file_name = 'tests/windows-1252/github_bug_9.txt', encoding = 'windows-1252'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'Then he said, \x93The names Bod, James Bond.\x94\nto be \x93me\x94\nSpam, beans, spam \x96 served every day\nbeans, spam, beans, \x97 served every other day\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1252/_mozilla_bug421271_text.html-windows-1252] _

file_name = 'tests/windows-1252/_mozilla_bug421271_text.html'
encoding = 'windows-1252'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-tra...ways<br>Doncaster/Stranraer/Rushden &amp; Diamonds<br>and 50p on all nine results.<br>GET IN THERE.</p></body></html>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/windows-1252/_ude_1.txt-windows-1252] ______

file_name = 'tests/windows-1252/_ude_1.txt', encoding = 'windows-1252'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'Die Deutsche Schule geh\xf6rt zum Netzwerk der mehr als 140 Deutschen Auslandsschulen, die von der Zentral...entralstelle f\xfcr Auslandsschulwesen gef\xf6rdert.\nKurz gefasst 10\x80. Weltkarte Deutsche Schulen international\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/UTF-32BE/plane1-utf-32be.html-utf-32be] _____

file_name = 'tests/UTF-32BE/plane1-utf-32be.html', encoding = 'utf-32be'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\x00\x00\x00<\x00\x00\x00!\x00\x00\x00D\x00\x00\x00O\x00\x00\x00C\x00\x00\x00T\x00\x00\x00Y\x00\x00\x00P\x...00\x00\x00<\x00\x00\x00/\x00\x00\x00h\x00\x00\x00t\x00\x00\x00m\x00\x00\x00l\x00\x00\x00>\x00\x00\x00\r\x00\x00\x00\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/UTF-32BE/nobom-utf32be.txt-utf-32be] ______

file_name = 'tests/UTF-32BE/nobom-utf32be.txt', encoding = 'utf-32be'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\x00\x00\x00D\x00\x00\x00a\x00\x00\x00t\x00\x00\x00e\x00\x00\x00T\x00\x00\x00i\x00\x00\x00m\x00\x00\x00e\x...00\x00\x001\x00\x00\x00.\x00\x00\x000\x00\x00\x008\x00\x00\x003\x00\x00\x005\x00\x00\x003\x00\x00\x00\r\x00\x00\x00\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/UTF-16BE/plane1-utf-16be.html-utf-16be] _____

file_name = 'tests/UTF-16BE/plane1-utf-16be.html', encoding = 'utf-16be'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\x00<\x00!\x00D\x00O\x00C\x00T\x00Y\x00P\x00E\x00 \x00H\x00T\x00M\x00L\x00 \x00P\x00U\x00B\x00L\x00I\x00C\...0\x002\x00-\x002\x004\x00.\x00\r\x00\n\x00<\x00/\x00p\x00>\x00\r\x00\n\x00<\x00/\x00h\x00t\x00m\x00l\x00>\x00\r\x00\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/UTF-16BE/nobom-utf16be.txt-utf-16be] ______

file_name = 'tests/UTF-16BE/nobom-utf16be.txt', encoding = 'utf-16be'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\x00D\x00a\x00t\x00e\x00T\x00i\x00m\x00e\x00,\x00B\x00i\x00d\x00,\x00A\x00s\x00k\x00\r\x00\n\x000\x007\x00...\x000\x00.\x003\x001\x009\x00,\x001\x00.\x000\x008\x003\x000\x007\x00,\x001\x00.\x000\x008\x003\x005\x003\x00\r\x00\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.9.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/forum.template-toolkit.ru.9.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_9....9.rss">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/_chromium_windows-1251_with_no_encoding_specified.html-windows-1251] _

file_name = 'tests/windows-1251-russian/_chromium_windows-1251_with_no_encoding_specified.html'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html>\n <head>\n  <title> windows-1251 </title>\n </head>\n\n <body>\n  \xcc\xce\xd1\xca\xc2\xc0, 9 \xff\...\xee \xef\xf0\xe5\xf0\xe2\xe0\xed\xed\xfb\xe5 \xe4\xe2\xe0 \xe4\xed\xff \xed\xe0\xe7\xe0\xe4 ...\n </body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/_ude_1.txt-windows-1251] __

file_name = 'tests/windows-1251-russian/_ude_1.txt', encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xc2 \xe3\xe8\xec\xed\xe0\xe7\xe8\xe8 \xee\xed \xed\xe5 \xe1\xfb\xeb \xe2 \xf7\xe8\xf1\xeb\xe5 \xef\xe5\xf...xf2\xf2\xe5\xf1\xf2\xe0\xf2 \xe8 \xef\xee\xe2\xf2\xee\xf0\xe8\xf2\xfc \xef\xee\xf1\xf2\xf3\xef\xeb\xe5\xed\xe8\xe5.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/aviaport.ru.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/aviaport.ru.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://www.aviaport.ru/news/yandex_export.xml...d\xed\xee\xe9 \xf1\xf2\xf0\xe0\xf5\xee\xe2\xea\xe8.\n\t\t\t</yandex:full-text>\n\t\t</item>\n\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.8.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/forum.template-toolkit.ru.8.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_8....8.rss">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/money.rin.ru.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/money.rin.ru.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://money.rin.ru/news/rss/\nExpect: window...  (N 1080 \xee\xf2 17 \xed\xee\xff\xe1\xf0\xff 2005 \xe3\xee\xe4\xe0).</description>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/anthropology.ru.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/anthropology.ru.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Windows-1251"?>\n<!--\nSource: http://anthropology.ru/ru/rss20.xml\nExpect: ...4\xe8\xe8 \xea\xf3\xeb\xfc\xf2\xf3\xf0\xfb\xbb</a></strong>]]></description>\n\t\t</item>\n\n\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/music.peeps.ru.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/music.peeps.ru.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://music.peeps.ru/news/action_rss.xml\nEx...\xe4\xed\xfb\xf5 \xef\xe0\xed\xea-\xe3\xf0\xf3\xef\xef 90-\xf5. </description>\n\t\t</item>\n\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/aif.ru.health.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/aif.ru.health.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://www.aif.ru/info/rss.php?magazine=healt...f0\xe0\xeb\xfc\xed\xfb\xf5 \xef\xf0\xee\xe4\xf3\xea\xf2\xee\xe2.\t\t</description>\n\t</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.6.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/forum.template-toolkit.ru.6.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_6....6.rss">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/newsru.com.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/newsru.com.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://www.newsru.com/plain/rss/all.xml\nExpe...="http://www.newsru.com/pict/id/large/819577_20060103092327.gif" type="image/jpeg"/>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/blog.mlmaster.com.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/blog.mlmaster.com.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://blog.mlmaster.com/wp-rss2.php\nExpect:...\t\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/aug32.hole.ru.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/aug32.hole.ru.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://aug32.hole.ru/afisha/feed.php\nExpect:...&gt;</description>\n          <link>http://aug32.hole.ru/afisha.htm</link>\n        </item>\n    </channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.4.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/forum.template-toolkit.ru.4.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_4....-4.rss">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/janulalife.blogspot.com.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/janulalife.blogspot.com.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger....\xee\xe8.\n<br/>\n</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/intertat.ru.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/intertat.ru.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://intertat.ru/myyandex.php\nExpect: wind...\xe8\xe4\xe5\xf2\xe5\xeb\xfc\xf1\xf2\xe2\xee \xee \xf0\xe5\xe3\xe8\xf1\xf2\xf0\xe0\xf6\xe8\xe8 \xd1\xcc\xc8 \xdd\xeb ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/greek.ru.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/greek.ru.xml', encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://www.greek.ru/news/ya/yagreek\nExpect: ...e8. \xd0\xee\xe2\xed\xee 29 \xeb\xe5\xf2 \xed\xe0\xe7\xe0\xe4 \xe2 \xf5\xee\xe4\xe5 \xee\xef\xe5\xf0\xe0\xf6\xe8\xe8 ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.1.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/forum.template-toolkit.ru.1.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_1....1.rss">http://forum.template-toolkit.ru/view_topic/topic_id-93.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-russian/kapranoff.ru.xml-windows-1251] _

file_name = 'tests/windows-1251-russian/kapranoff.ru.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://kapranoff.ru/index.rdf\nExpect: window...dc:subject/>\n<dc:creator>kappa</dc:creator>\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\n</item>\n\n\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/GB2312/softsea.net.xml-gb2312] _________

file_name = 'tests/GB2312/softsea.net.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312"?>\n<!--\nSource: http://www.softsea.net/rss/3.xml > softsea.net.xml\...w.softsea.net/soft/108440.htm</guid>\n<pubDate>Mon, 19 Dec 2005 16:00:00 GMT</pubDate>\n</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/GB2312/chen56.blogcn.com.xml-gb2312] ______

file_name = 'tests/GB2312/chen56.blogcn.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0"  encoding="gb2312" ?>\n<!--\nSource: http://www.blogcn.com/rss.asp?uid=chen56\nExpect:...ckback.asp?mydiary=285759 target=_blank>\xd2\xfd\xd3\xc3\xb4\xcb\xce\xc4</a>)]]>    </description>  </item></rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/GB2312/pda.blogsome.com.xml-gb2312] _______

file_name = 'tests/GB2312/pda.blogsome.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312"?><!-- generator="wordpress/1.5.1-alpha" -->\n<!--\nSource: http://pd...description>\n\t\t<link>http://pda.blogsome.com/2004/12/29/e-tencdhaieoum500/</link>\n\t</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/GB2312/luciferwang.blogcn.com.xml-gb2312] ____

file_name = 'tests/GB2312/luciferwang.blogcn.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0"  encoding="gb2312" ?>\n<!--\nSource: http://www.blogcn.com/rss.asp?uid=luciferwang\nEx...back.asp?mydiary=25452215 target=_blank>\xd2\xfd\xd3\xc3\xb4\xcb\xce\xc4</a>)]]>    </description>  </item></rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/GB2312/bbs.blogsome.com.xml-gb2312] _______

file_name = 'tests/GB2312/bbs.blogsome.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312"?><!-- generator="wordpress/1.5.1-alpha" -->\n<!--\nSource: http://bb...c0\xb4\n\n </description>\n\t\t<link>http://bbs.blogsome.com/2004/12/26/aoae/</link>\n\t</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/GB2312/cindychen.com.xml-gb2312] ________

file_name = 'tests/GB2312/cindychen.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="GB2312"?>\n<!--\nSource: http://www.cindychen.com/dynamic/wp-rss2.php\nExpec...mentRSS>http://www.cindychen.com/dynamic/wp-commentsrss2.php?p=32</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/GB2312/_chromium_gb18030_with_no_encoding_specified.html.xml-gb2312] _

file_name = 'tests/GB2312/_chromium_gb18030_with_no_encoding_specified.html.xml'
encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<!DOCTYPE html PUBLIC "-//W3C//DTD Xhtml 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-tra...3\xb0\xbf\xaa\xca\xbc\xbd\xf8\xc8\xeb\xb3\xc9\xca\xec\xb5\xc4\xb4\xf3\xc6\xac\xca\xb1\xb4\xfa\xa3\xbb\n</body></html>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/GB2312/14.blog.westca.com.xml-gb2312] ______

file_name = 'tests/GB2312/14.blog.westca.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312" ?><!-- generator="b2evolution/0.8.6.2" -->\n<!--\nSource: http://blo...c\xb7\xa3\xac\xd5\xe2\xc3\xce\xb2\xbb\xd7\xf7\xd2\xb2\xb0\xd5\xa1\xa3</p>]]></content:encoded>\n</item>\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/GB2312/_mozilla_bug171813_text.html-gb2312] ___

file_name = 'tests/GB2312/_mozilla_bug171813_text.html', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<body leftmargin="0" topmargin="0" bgcolor="#fffeeb">\n<table border=0 cellpadding=0 cellspacing=0 height=...ec\xcc\xec\xd7\xee\xb5\xcd6\xc3\xab/\xd0\xa1\xca\xb1</a></div>\n    </td>\n  </tr>\n  <tbody> </tbody> \n</table>\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/GB2312/xy15400.blogcn.com.xml-gb2312] ______

file_name = 'tests/GB2312/xy15400.blogcn.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0"  encoding="gb2312" ?>\n<!--\nSource: http://www.blogcn.com/rss.asp?uid=xyl5400\nExpect...kback.asp?mydiary=5368356 target=_blank>\xd2\xfd\xd3\xc3\xb4\xcb\xce\xc4</a>)]]>    </description>  </item></rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/GB2312/lily.blogsome.com.xml-gb2312] ______

file_name = 'tests/GB2312/lily.blogsome.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312"?>\n<!--\nSource: http://lily.blogsome.com/feed/rss2/\nExpect: GB1803...:commentRSS>http://lily.blogsome.com/2004/12/15/hello_world/feed/</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/GB2312/w3cn.org.xml-gb2312] ___________

file_name = 'tests/GB2312/w3cn.org.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312" ?>\n<!--\nSource: http://www.w3cn.org/article/rss.xml\nExpect: GB180...:54</pubDate>\n\t<guid>http://www.w3cn.org/article/translate/2004/89.html</guid>\n  </item>\n\n  </channel>\n  </rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/GB2312/jjgod.3322.org.xml-gb2312] ________

file_name = 'tests/GB2312/jjgod.3322.org.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312"?>\n<!--\nSource: http://jjgod.3322.org/feed/rss2/\nExpect: GB18030\n...\t\t<wfw:commentRSS>http://jjgod.3322.org/2005/11/09/dojo/feed/</wfw:commentRSS>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/GB2312/coverer.com.xml-gb2312] _________

file_name = 'tests/GB2312/coverer.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312"?>\n<!--\nSource: http://www.coverer.com/index.xml\nExpect: GB18030\n...a\xb6\xe0php\xb0\xae\xba\xc3\xd5\xdf\xb5\xc4\xb9\xd8\xd7\xa2......</description>\n    </item>\n\n  </channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/GB2312/godthink.blogsome.com.xml-gb2312] ____

file_name = 'tests/GB2312/godthink.blogsome.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312"?><!-- generator="wordpress/1.5.1-alpha" -->\n<!--\nSource: http://go...n </description>\n\t\t<link>http://godthink.blogsome.com/2004/12/27/uuodhdha/</link>\n\t</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/GB2312/acnnewswire.net.xml-gb2312] _______

file_name = 'tests/GB2312/acnnewswire.net.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312" ?>\n<!--\nSource: http://www.acnnewswire.net/rss2/press_rss_20c.asp\...t/Article.Asp?lang=_c&amp;Art_ID=29689</guid><pubDate>Tue, 22 Nov 2005 14:59:44+0900</pubDate></item></channel></rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/GB2312/eighthday.blogspot.com.xml-gb2312] ____

file_name = 'tests/GB2312/eighthday.blogspot.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="GB2312" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/st...c8\xb8\xd4\xbe~~~~</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/GB2312/cappuccinos.3322.org.xml-gb2312] _____

file_name = 'tests/GB2312/cappuccinos.3322.org.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="GB2312"?>\n<!--\nSource: http://cappuccinos.3322.org/wp-rss2.php\nExpect: GB...:commentRSS>http://cappuccinos.3322.org/wp-commentsrss2.php?p=126</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/GB2312/2.blog.westca.com.xml-gb2312] ______

file_name = 'tests/GB2312/2.blog.westca.com.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312" ?><!-- generator="b2evolution/0.8.6.2" -->\n<!--\nSource: http://blo...2\xda\xc3\xc0\xd4\xaa\xa1\xa3(\xd7\xf7\xd5\xdf\xa3\xba \xd1\xcf\xd9\xb2 )]]></content:encoded>\n</item>\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/GB2312/cnblog.org.xml-gb2312] __________

file_name = 'tests/GB2312/cnblog.org.xml', encoding = 'gb2312'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="gb2312"?>\n<!--\nSource: http://www.cnblog.org/blog/cache/cnblog.xml\nExpect...xbc\xbc\xca\xf5\xb7\xc7\xd3\xaa\xc0\xfb\xd0\xd4\xd7\xe9\xd6\xaf]]></description>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/MacCyrillic/music.peeps.ru.xml-maccyrillic] ___

file_name = 'tests/MacCyrillic/music.peeps.ru.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://music.peeps.ru/news/action_rss.xml\nExp...\xe4\xed\xfb\xf5 \xef\xe0\xed\xea-\xe3\xf0\xf3\xef\xef 90-\xf5. </description>\n\t\t</item>\n\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.4.xml-maccyrillic] _

file_name = 'tests/MacCyrillic/forum.template-toolkit.ru.4.xml'
encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_4.r...-4.rss">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/MacCyrillic/koi.kinder.ru.xml-maccyrillic] ___

file_name = 'tests/MacCyrillic/koi.kinder.ru.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://koi.kinder.ru/rss/kinder_news_koi8.xml\...>\n\n<item>\n<title>\x83\xe0\xe7\xe5\xf2\xe0-\xe0\xeb\xfc\xec\xe0\xed\xe0\xf5 (\xf1\xe0\xe9\xf2 \xf8\xea\xee\xeb\xfb ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/MacCyrillic/_ude_1.txt-maccyrillic] _______

file_name = 'tests/MacCyrillic/_ude_1.txt', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\x82 \xe3\xe8\xec\xed\xe0\xe7\xe8\xe8 \xee\xed \xed\xe5 \xe1\xfb\xeb \xe2 \xf7\xe8\xf1\xeb\xe5 \xef\xe5\xf...xf2\xf2\xe5\xf1\xf2\xe0\xf2 \xe8 \xef\xee\xe2\xf2\xee\xf0\xe8\xf2\xfc \xef\xee\xf1\xf2\xf3\xef\xeb\xe5\xed\xe8\xe5.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/MacCyrillic/aviaport.ru.xml-maccyrillic] ____

file_name = 'tests/MacCyrillic/aviaport.ru.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://www.aviaport.ru/news/yandex_export.xml\...d\xed\xee\xe9 \xf1\xf2\xf0\xe0\xf5\xee\xe2\xea\xe8.\n\t\t\t</yandex:full-text>\n\t\t</item>\n\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/MacCyrillic/intertat.ru.xml-maccyrillic] ____

file_name = 'tests/MacCyrillic/intertat.ru.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://intertat.ru/myyandex.php\nExpect: MacCy...\xe8\xe4\xe5\xf2\xe5\xeb\xfc\xf1\xf2\xe2\xee \xee \xf0\xe5\xe3\xe8\xf1\xf2\xf0\xe0\xf6\xe8\xe8 \x91\x8c\x88 \x9d\xeb ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/MacCyrillic/aug32.hole.ru.xml-maccyrillic] ___

file_name = 'tests/MacCyrillic/aug32.hole.ru.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://aug32.hole.ru/afisha/feed.php\nExpect: ...&gt;</description>\n          <link>http://aug32.hole.ru/afisha.htm</link>\n        </item>\n    </channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.8.xml-maccyrillic] _

file_name = 'tests/MacCyrillic/forum.template-toolkit.ru.8.xml'
encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_8.r...8.rss">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/MacCyrillic/aif.ru.health.xml-maccyrillic] ___

file_name = 'tests/MacCyrillic/aif.ru.health.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://www.aif.ru/info/rss.php?magazine=health...f0\xe0\xeb\xfc\xed\xfb\xf5 \xef\xf0\xee\xe4\xf3\xea\xf2\xee\xe2.\t\t</description>\n\t</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/MacCyrillic/blog.mlmaster.com.xml-maccyrillic] _

file_name = 'tests/MacCyrillic/blog.mlmaster.com.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://blog.mlmaster.com/wp-rss2.php\nExpect: ...\t\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/MacCyrillic/money.rin.ru.xml-maccyrillic] ____

file_name = 'tests/MacCyrillic/money.rin.ru.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://money.rin.ru/news/rss/\nExpect: MacCyri...  (N 1080 \xee\xf2 17 \xed\xee\xdf\xe1\xf0\xdf 2005 \xe3\xee\xe4\xe0).</description>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/MacCyrillic/newsru.com.xml-maccyrillic] _____

file_name = 'tests/MacCyrillic/newsru.com.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://www.newsru.com/plain/rss/all.xml\nExpec...="http://www.newsru.com/pict/id/large/819577_20060103092327.gif" type="image/jpeg"/>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/MacCyrillic/greek.ru.xml-maccyrillic] ______

file_name = 'tests/MacCyrillic/greek.ru.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://www.greek.ru/news/ya/yagreek\nExpect: M...e8. \x90\xee\xe2\xed\xee 29 \xeb\xe5\xf2 \xed\xe0\xe7\xe0\xe4 \xe2 \xf5\xee\xe4\xe5 \xee\xef\xe5\xf0\xe0\xf6\xe8\xe8 ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/MacCyrillic/susu.ac.ru.xml-maccyrillic] _____

file_name = 'tests/MacCyrillic/susu.ac.ru.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://susu.ac.ru/ru/news/rss\nExpect: MacCyri...5\xed\xe8\xdf \xef\xee\xe1\xe5\xe4\xe8\xf2\xe5\xeb\xe5\xe9 \xea\xee\xed\xea\xf3\xf0\xf1\xe0 \xf1\xe0\xe9\xf2\xee\xe2 ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/MacCyrillic/kapranoff.ru.xml-maccyrillic] ____

file_name = 'tests/MacCyrillic/kapranoff.ru.xml', encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://kapranoff.ru/index.rdf\nExpect: MacCyri...dc:subject/>\n<dc:creator>kappa</dc:creator>\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\n</item>\n\n\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.6.xml-maccyrillic] _

file_name = 'tests/MacCyrillic/forum.template-toolkit.ru.6.xml'
encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_6.r...6.rss">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.9.xml-maccyrillic] _

file_name = 'tests/MacCyrillic/forum.template-toolkit.ru.9.xml'
encoding = 'maccyrillic'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="MacCyrillic"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_9.r...9.rss">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/IBM866/greek.ru.xml-ibm866] ___________

file_name = 'tests/IBM866/greek.ru.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://www.greek.ru/news/ya/yagreek\nExpect: IBM866...e1 \xae\xe1\xe2\xe0\xae\xa2\xa0 \x91\xaf\xa5\xe6\xa5\xe1... \n</description>\n    </item>                \n\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___________ test_encoding_detection[tests/IBM866/_ude_1.txt-ibm866] ____________

file_name = 'tests/IBM866/_ude_1.txt', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\x82 \xa3\xa8\xac\xad\xa0\xa7\xa8\xa8 \xae\xad \xad\xa5 \xa1\xeb\xab \xa2 \xe7\xa8\xe1\xab\xa5 \xaf\xa5\xe...xe2\xe2\xa5\xe1\xe2\xa0\xe2 \xa8 \xaf\xae\xa2\xe2\xae\xe0\xa8\xe2\xec \xaf\xae\xe1\xe2\xe3\xaf\xab\xa5\xad\xa8\xa5.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/IBM866/aviaport.ru.xml-ibm866] _________

file_name = 'tests/IBM866/aviaport.ru.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://www.aviaport.ru/news/yandex_export.xml\nExpe...d\xa8\xa8 \xa0\xed\xe0\xae\xaf\xae\xe0\xe2\xa0, \xe1\xae\xae\xa1\xe9\xa0\xa5\xe2 \x93\xaa\xe0\xa0\xf5\xad\xe1\xec\xaa')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/IBM866/aug32.hole.ru.xml-ibm866] ________

file_name = 'tests/IBM866/aug32.hole.ru.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://aug32.hole.ru/afisha/feed.php\nExpect: IBM86...&gt;</description>\n          <link>http://aug32.hole.ru/afisha.htm</link>\n        </item>\n    </channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/IBM866/kapranoff.ru.xml-ibm866] _________

file_name = 'tests/IBM866/kapranoff.ru.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://kapranoff.ru/index.rdf\nExpect: IBM866\n-->\...dc:subject/>\n<dc:creator>kappa</dc:creator>\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\n</item>\n\n\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/IBM866/music.peeps.ru.xml-ibm866] ________

file_name = 'tests/IBM866/music.peeps.ru.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://music.peeps.ru/news/action_rss.xml\nExpect: ...\xa4\xad\xeb\xe5 \xaf\xa0\xad\xaa-\xa3\xe0\xe3\xaf\xaf 90-\xe5. </description>\n\t\t</item>\n\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.4.xml-ibm866] _

file_name = 'tests/IBM866/forum.template-toolkit.ru.4.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_4.rss\nE...-4.rss">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.8.xml-ibm866] _

file_name = 'tests/IBM866/forum.template-toolkit.ru.8.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_8.rss\nE...8.rss">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/IBM866/blog.mlmaster.com.xml-ibm866] ______

file_name = 'tests/IBM866/blog.mlmaster.com.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://blog.mlmaster.com/wp-rss2.php\nExpect: IBM86...\t\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/IBM866/money.rin.ru.xml-ibm866] _________

file_name = 'tests/IBM866/money.rin.ru.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://money.rin.ru/news/rss/\nExpect: IBM866\n-->\...  (N 1080 \xae\xe2 17 \xad\xae\xef\xa1\xe0\xef 2005 \xa3\xae\xa4\xa0).</description>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/IBM866/janulalife.blogspot.com.xml-ibm866] ___

file_name = 'tests/IBM866/janulalife.blogspot.com.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/st...\xae\xa8.\n<br/>\n</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/IBM866/intertat.ru.xml-ibm866] _________

file_name = 'tests/IBM866/intertat.ru.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://intertat.ru/myyandex.php\nExpect: IBM866\n--...\xa8\xa4\xa5\xe2\xa5\xab\xec\xe1\xe2\xa2\xae \xae \xe0\xa5\xa3\xa8\xe1\xe2\xe0\xa0\xe6\xa8\xa8 \x91\x8c\x88 \x9d\xab ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.9.xml-ibm866] _

file_name = 'tests/IBM866/forum.template-toolkit.ru.9.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_9.rss\nE...9.rss">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/IBM866/susu.ac.ru.xml-ibm866] __________

file_name = 'tests/IBM866/susu.ac.ru.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://susu.ac.ru/ru/news/rss\nExpect: IBM866\n-->\...ad\xad\xae\xe1\xe2\xa8&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=""http://model.exponenta.ru/""&gt;Model.Exponenta.Ru ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/IBM866/newsru.com.xml-ibm866] __________

file_name = 'tests/IBM866/newsru.com.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://www.newsru.com/plain/rss/all.xml\nExpect: IB...="http://www.newsru.com/pict/id/large/819577_20060103092327.gif" type="image/jpeg"/>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.6.xml-ibm866] _

file_name = 'tests/IBM866/forum.template-toolkit.ru.6.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_6.rss\nE...6.rss">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/IBM866/aif.ru.health.xml-ibm866] ________

file_name = 'tests/IBM866/aif.ru.health.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://www.aif.ru/info/rss.php?magazine=health\nExp...e0\xa0\xab\xec\xad\xeb\xe5 \xaf\xe0\xae\xa4\xe3\xaa\xe2\xae\xa2.\t\t</description>\n\t</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.1.xml-ibm866] _

file_name = 'tests/IBM866/forum.template-toolkit.ru.1.xml', encoding = 'ibm866'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM866"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_1.rss\nE...1.rss">http://forum.template-toolkit.ru/view_topic/topic_id-93.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/Big5/myblog.pchome.com.tw.xml-big5] _______

file_name = 'tests/Big5/myblog.pchome.com.tw.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Big5"?>\n<!--\nSource: http://myblog.pchome.com.tw/_/myblog/rss.php?blog_id=...=07&amp;an=163&amp;acn=140\n</link>\n<pubDate>Wed, 06 Jul 2005 06:13:20 GMT</pubDate> \n</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/Big5/blog.worren.net.xml-big5] _________

file_name = 'tests/Big5/blog.worren.net.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Big5"?>\n<!--\nSource: http://blog.worren.net/wp-atom.php\nExpect: Big5\n-->...acO\xa7A\xaa\xba\xa4F! \xc1\xd9\xacO\xa7\xd6\xb7Q\xb7Q\xa7O\xaa\xba\xa8\xc6\xa7a !  </summary>\n\t</entry>\n\t</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/Big5/marilynwu.blogspot.com.xml-big5] ______

file_name = 'tests/Big5/marilynwu.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...83/1600/IMG_23481.JPG"&gt;</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/Big5/coolloud.org.tw.xml-big5] _________

file_name = 'tests/Big5/coolloud.org.tw.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="big5"?>\n<!--\nSource: http://www.coolloud.org.tw/index.xml\nExpect: Big5\n-...tor>\n  <dc:date>2005-12-29T12:42:34+08:00</dc:date>\n  <category>\xa9\xca\xa7O</category>\n  </item>\n</rdf:RDF>\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____________ test_encoding_detection[tests/Big5/ebao.us.xml-big5] _____________

file_name = 'tests/Big5/ebao.us.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5"?>\n<!--\nSource: http://www.ebao.us/xml/rssgen/rssgen_LatestNews.asp\n...4\xa2\xaf\xa2H </description> \n  <pubDate>Fri, 16 Dec 2005 14:19:19 GMT</pubDate>\n  </item>\n  </channel>\n  </rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____________ test_encoding_detection[tests/Big5/_ude_1.txt-big5] ______________

file_name = 'tests/Big5/_ude_1.txt', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xba\xfb\xb0\xf2\xa4j\xa8\xe5\xa1]Wikipedia\xa1^\xaa\xcc\xa1A\xba\xf4\xb8\xf4\xac\xb0\xc2\xa6\xa1F\xb6\xb0...c1n\xb6H\xacM\xc5T\xa1A\xa8\xe3\xbf\xfd\xa9\xf3\xba\xfb\xb0\xf2\xa6@\xa8\xc9\xa1J\xba\xfb\xb0\xf2\xa4j\xa8\xe5\xa1C\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___________ test_encoding_detection[tests/Big5/upsaid.com.xml-big5] ____________

file_name = 'tests/Big5/upsaid.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="big5" ?>\n<!--\nSource: http://www.upsaid.com/isis/index.rdf\nExpect: Big5\n...\t<dc:date>2005-09-29T01:03:27+07:00</dc:date>\n\t\t\t<slash:comments>0</slash:comments>\n\t\t</item>\n\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/Big5/leavesth.blogspot.com.xml-big5] ______

file_name = 'tests/Big5/leavesth.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...G | Jedi.org</a>\n</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/Big5/oui-design.com.xml-big5] __________

file_name = 'tests/Big5/oui-design.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="big5" ?>\n<!--\nSource: http://www.oui-design.com/fpcode/rss.php\nExpect: Bi... 2:27 pm</date>\n<link>http://www.oui-design.com/fpcode/news.php?story_id=259</link>\n</item>\n\t\t\n\n</rdf:RDF>\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/Big5/kafkatseng.blogspot.com.xml-big5] _____

file_name = 'tests/Big5/kafkatseng.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...F&lt;br /&gt;\xc6g\xb0\xd5</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/Big5/_chromium_Big5_with_no_encoding_specified.html-big5] _

file_name = 'tests/Big5/_chromium_Big5_with_no_encoding_specified.html'
encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html>\n <head>\n  <title> Big5 </title>\n </head>\n\n <body>\n  \xa5x\xa5_\xac\xdd\xa6u\xa9\xd2\xacQ\xa4\...a1u\xa8I\xc0q\xa7\xdc\xc4\xb3\xa1v\xa1A\xaa\xfc\xab\xf3\xaa\xed\xa5\xdc\xb7|\xa6\xd2\xbc{\xa1C\n </body>\n</html>\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/Big5/sinica.edu.tw.xml-big5] __________

file_name = 'tests/Big5/sinica.edu.tw.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl.../>\n<br/> \n<br/> </div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/Big5/ke207.blogspot.com.xml-big5] ________

file_name = 'tests/Big5/ke207.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...,\xa1\xcf,\xa1\xcf</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/Big5/linyijen.blogspot.com.xml-big5] ______

file_name = 'tests/Big5/linyijen.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...\xa6n\xaa\xba\xa1C</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/Big5/tlkkuo.blogspot.com.xml-big5] _______

file_name = 'tests/Big5/tlkkuo.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl.../&gt;\xc1\xc2\xc1\xc2\xa7A</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/Big5/carbonxiv.blogspot.com.xml-big5] ______

file_name = 'tests/Big5/carbonxiv.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...\xd2\xb7R</span>\n</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/Big5/0804.blogspot.com.xml-big5] ________

file_name = 'tests/Big5/0804.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...xa4\xb7N!</span>\n</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/Big5/willythecop.blogspot.com.xml-big5] _____

file_name = 'tests/Big5/willythecop.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...I</a>\n</strong>\n</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/Big5/sylvia1976.blogspot.com.xml-big5] _____

file_name = 'tests/Big5/sylvia1976.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...n\xa6\xd1\xc1\xf3\xaeQ\xb7\xc7\xb3\xc6\xaa\xba\xa4\xe9\xa6\xa1\xb1\xdf\xc0\\\xc5o\xa1I</content>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/Big5/fudesign.blogspot.com.xml-big5] ______

file_name = 'tests/Big5/fudesign.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...fullpost"&gt;&lt;/span&gt;</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/Big5/digitalwall.com.xml-big5] _________

file_name = 'tests/Big5/digitalwall.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="big5" ?>\r\n<!--\nSource: http://www.digitalwall.com/rss20/rss_cht.xml\nExpe...pts/display.asp?UID=321</guid>\r\n<pubDate>Sat, 17 Dec 2005 15:21:36 GMT</pubDate>\r\n</item>\r\n</channel>\r\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/Big5/catshadow.blogspot.com.xml-big5] ______

file_name = 'tests/Big5/catshadow.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...\xae\xc8\xb5{\xa1K</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/Big5/sanwenji.blogspot.com.xml-big5] ______

file_name = 'tests/Big5/sanwenji.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...a\xa1\xaa\xba\xa1C</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/Big5/letterlego.blogspot.com.xml-big5] _____

file_name = 'tests/Big5/letterlego.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...;&lt;br /&gt;&lt;/span&gt;</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/Big5/unoriginalblog.com.xml-big5] ________

file_name = 'tests/Big5/unoriginalblog.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Big5"?>\n<!--\nSource: http://unoriginalblog.com/feed/\nExpect: Big5\n-->\n<...fw:commentRSS>http://unoriginalblog.com/2005/11/another-day/feed/</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/Big5/ytc.blogspot.com.xml-big5] _________

file_name = 'tests/Big5/ytc.blogspot.com.xml', encoding = 'big5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="BIG5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/styl...7\xda\xbb\xa1\xa1C</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/UTF-16LE/nobom-utf16le.txt-utf-16le] ______

file_name = 'tests/UTF-16LE/nobom-utf16le.txt', encoding = 'utf-16le'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'D\x00a\x00t\x00e\x00T\x00i\x00m\x00e\x00,\x00B\x00i\x00d\x00,\x00A\x00s\x00k\x00\r\x00\n\x000\x007\x00/\x0...0\x00.\x003\x001\x009\x00,\x001\x00.\x000\x008\x003\x000\x007\x00,\x001\x00.\x000\x008\x003\x005\x003\x00\r\x00\n\x00')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/UTF-16LE/plane1-utf-16le.html-utf-16le] _____

file_name = 'tests/UTF-16LE/plane1-utf-16le.html', encoding = 'utf-16le'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<\x00!\x00D\x00O\x00C\x00T\x00Y\x00P\x00E\x00 \x00H\x00T\x00M\x00L\x00 \x00P\x00U\x00B\x00L\x00I\x00C\x00 ...02\x00-\x002\x004\x00.\x00\r\x00\n\x00<\x00/\x00p\x00>\x00\r\x00\n\x00<\x00/\x00h\x00t\x00m\x00l\x00>\x00\r\x00\n\x00')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/iso-2022-jp/_ude_1.txt-iso-2022-jp] _______

file_name = 'tests/iso-2022-jp/_ude_1.txt', encoding = 'iso-2022-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'========================================================================\n    \x1b$B%3%s%=!<%k\x1b(J \x1b$...!<%9ItJ,$r<($7$^$9!#\x1b(J\n\n/////////////////////////////////////////////////////////////////////////////\n\n\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.4.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.4.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://bpm.cult.bg/logs/rdf.php?id=4\nExpect:....log)</dc:subject>\n<dc:creator>dubka</dc:creator>\n<dc:date>2005-10-09T11:10:26+02:00</dc:date>\n</item>\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/ecloga.cult.bg.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/ecloga.cult.bg.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://ecloga.cult.bg/log/wp-rss.php\nExpect:...ption>\n            <link>http://ecloga.cult.bg/log/index.php?p=242</link>\n        </item>\n    </channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://bpm.cult.bg/services/rss/ezine.php\nEx...subject>*bpm . ezine / social</dc:subject>\n<dc:creator>oleole</dc:creator>\n<dc:date></dc:date>\n</item>\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/linux-bg.org.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/linux-bg.org.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://linux-bg.org/linux-bg-news.rdf\nExpect...=news&amp;key=378326293</link>\n</item>\n\n \n <skipHours>\n <hour>1</hour>\n </skipHours>\n \n </channel>\n </rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/rinennor.org.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/rinennor.org.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Windows-1251"?>\n<!--\nSource: http://www.rinennor.org/backend_full.php\nExp...ing session.bug_compat_42 or session.bug_compat_warn to off, respectively. in <b>Unknown</b> on line <b>0</b><br />\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/ide.li.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/ide.li.xml', encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://www.ide.li/backend.php\nExpect: window...b\xe3\xe0\xf0\xe8\xed \xc8\xe2\xe0\xed \xcf\xee\xeb\xee\xe2\xed\xfe\xea.</description>\n</item>\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/doncho.net.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://doncho.net/blog/wp-rss2.php\nExpect: w...\n\t\t<wfw:commentRSS>http://blog.doncho.net/?feed=rss2&amp;p=384</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.news.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/debian.gabrovo.com.news.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://debian.gabrovo.com/backend/debianbg-ne...p://debian.gabrovo.com/show.php?id=56&amp;tablica=news&amp;sub=\xd2\xe5\xec\xe0</link>\n</item>\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.2.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.2.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://bpm.cult.bg/logs/rdf.php?id=2\nExpect:....log)</dc:subject>\n<dc:creator>snark</dc:creator>\n<dc:date>2005-12-12T18:12:01+02:00</dc:date>\n</item>\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.3.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.3.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://bpm.cult.bg/logs/rdf.php?id=3\nExpect:...log)</dc:subject>\n<dc:creator>Lucash</dc:creator>\n<dc:date>2005-06-14T18:06:01+02:00</dc:date>\n</item>\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/informator.org.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/informator.org.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://www.informator.org/html/backend.php\nE...tp://www.informator.org/html/modules.php?name=News&amp;file=article&amp;sid=173</link>\n</item>\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/debian.gabrovo.com.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://debian.gabrovo.com/backend/debianbg-ar.../debian.gabrovo.com/show.php?id=5&amp;tablica=articles&amp;sub=\xd2\xe5\xec\xe0</link>\n</item>\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.9.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.9.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://bpm.cult.bg/logs/rdf.php?id=9\nExpect:...og)</dc:subject>\n<dc:creator>Kaladan</dc:creator>\n<dc:date>2004-12-03T19:12:22+02:00</dc:date>\n</item>\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.comments.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/doncho.net.comments.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://blog.doncho.net/wp-commentsrss2.php\nE...ort of my favourite password manager! Thanks a lot!</p>\n]]></content:encoded>\n\t\t\t\t</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/bbc.co.uk.popshow.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/bbc.co.uk.popshow.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://www.bbc.co.uk/bulgarian/popshow/index....r>worldservice.com/bulgarian</dc:publisher>\n      <dc:type>External Link, Pop Show</dc:type>\n   </item>\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.medusa.4.xml-windows-1251] _

file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.medusa.4.xml'
encoding = 'windows-1251'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1251"?>\n<!--\nSource: http://bpm.cult.bg/medusa/logs/rdf.php?id=4\n....log)</dc:subject>\n<dc:creator>dubka</dc:creator>\n<dc:date>2005-10-09T11:10:26+02:00</dc:date>\n</item>\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/EUC-KR/willis.egloos.com.xml-euc-kr] ______

file_name = 'tests/EUC-KR/willis.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://willis.egloos.com/index.xml\nExpect: EUC-KR...t<category>- Work</category>\n\t\t<pubDate>Mon, 28 Nov 2005 01:29:49 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/EUC-KR/xenix.egloos.com.xml-euc-kr] _______

file_name = 'tests/EUC-KR/xenix.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://xenix.egloos.com/index.xml\nExpect: EUC-KR\...\xb0\xed \xa2\xc6</category>\n\t\t<pubDate>Sun, 18 Dec 2005 10:53:17 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/EUC-KR/ittrend.egloos.com.xml-euc-kr] ______

file_name = 'tests/EUC-KR/ittrend.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://ittrend.egloos.com/index.xml\nExpect: EUC-K...5\xb5\xbf\xc7\xe2</category>\n\t\t<pubDate>Sat, 26 Nov 2005 07:21:50 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/EUC-KR/zangsalang.egloos.com.xml-euc-kr] ____

file_name = 'tests/EUC-KR/zangsalang.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://zangsalang.egloos.com/index.xml\nExpect: EU...xc3\xa2\xb0\xed**</category>\n\t\t<pubDate>Thu, 24 Jun 2004 12:04:11 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/EUC-KR/_ude_euc1.txt-euc-kr] __________

file_name = 'tests/EUC-KR/_ude_euc1.txt', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xbf\xaa\xbb\xe7\xc0\xfb \xbf\xb9\xbc\xf6 \xbf\xac\xb1\xb8\xc0\xda\xb5\xe9\xc0\xba \xba\xb9\xc0\xbd\xbc\xa...b4\xeb\xc7\xd1 \xbf\xac\xb1\xb8 \xbc\xba\xb0\xfa\xb5\xe9\xc0\xbb \xbc\xd2\xb0\xb3\xc7\xcf\xb0\xed \xc0\xd6\xb4\xd9.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/EUC-KR/lennon81.egloos.com.xml-euc-kr] _____

file_name = 'tests/EUC-KR/lennon81.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://lennon81.egloos.com/index.xml\nExpect: EUC-...c\xbe\xdf\xb1\xe2</category>\n\t\t<pubDate>Fri, 20 May 2005 10:49:24 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/EUC-KR/sparcs.kaist.ac.kr.xml-euc-kr] ______

file_name = 'tests/EUC-KR/sparcs.kaist.ac.kr.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0"  encoding="EUC-KR" ?>\n<!--\nSource: http://sparcs.kaist.ac.kr/~ari/article.rss.xml\nE...12:17:44 +0900</pubDate>\n<category>article</category>\n<author>ari</author>\n</item>\n\n\n\n</channel>\n</rss>\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/EUC-KR/poliplus.egloos.com.xml-euc-kr] _____

file_name = 'tests/EUC-KR/poliplus.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://poliplus.egloos.com/index.xml\nExpect: EUC-...cc\xba\xd0\xb7\xf9</category>\n\t\t<pubDate>Thu, 8 Dec 2005 15:51:56 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/EUC-KR/blog.rss.naver.com.xml-euc-kr] ______

file_name = 'tests/EUC-KR/blog.rss.naver.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-KR" ?>\n<!--\nSource: http://blog.rss.naver.com/alphathinker.xml\nExpect...<pubDate>Mon, 05 Apr 2004 16:05:52 +0900</pubDate>\n\t\t\t\t</item>\n\n\t\t\t\t\n\t\t\n\t\t\n\t\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-KR/blog.empas.com.xml-euc-kr] ________

file_name = 'tests/EUC-KR/blog.empas.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr"?>\n<!--\nSource: http://blog.empas.com/limpidly/rss.xml\nExpect: EUC...xb4\xd9. \xbe\xc8\xb3\xe7\xc8\xf7 \xb0\xe8\xbd\xca\xbd\xc3\xbf\xc0. </description>\n\t\t</item>\n\t</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/EUC-KR/birder.egloos.com.xml-euc-kr] ______

file_name = 'tests/EUC-KR/birder.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://birder.egloos.com/index.xml\nExpect: EUC-KR... \xc8\xb2\xc8\xa6</category>\n\t\t<pubDate>Wed, 29 Jun 2005 13:38:22 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-KR/blog.bd-lab.com.xml-euc-kr] _______

file_name = 'tests/EUC-KR/blog.bd-lab.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-KR"?>\n<!--\nSource: http://blog.bd-lab.com/blog/index.xml\nExpect: EUC-...e\xb1\xd7\xb7\xa1\xb9\xd6</dc:subject>\n<dc:date>2005-04-18T18:09:24+09:00</dc:date>\n</item>\n\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/EUC-KR/_chromium_windows-949_with_no_encoding_specified.html-euc-kr] _

file_name = 'tests/EUC-KR/_chromium_windows-949_with_no_encoding_specified.html'
encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html>\n <head>\n  <title> windows-949 </title>\n </head>\n\n <body>\n  \xc7\xd1\xb3\xaa\xb6\xf3\xb4\xe7\x...\xcf\xb6\xf3\xb4\xc2 \xb0\xf8\xb9\xae\xc0\xbb \xb0\xa2\xb0\xa2 \xb9\xdf\xbc\xdb\xc7\xdf\xb4\xd9.\n </body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/EUC-KR/oroll.egloos.com.xml-euc-kr] _______

file_name = 'tests/EUC-KR/oroll.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\r\n<!--\nSource: http://oroll.egloos.com/index.xml\nExpect: EUC-K...xa2\xbe</category>\r\n\t\t<pubDate>Sat, 30 Apr 2005 02:43:14 GMT</pubDate>\r\n\t</item>\r\n\t</channel>\r\n</rss>\r\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/EUC-KR/console.linuxstudy.pe.kr.xml-euc-kr] ___

file_name = 'tests/EUC-KR/console.linuxstudy.pe.kr.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://console.linuxstudy.pe.kr/blog/index.xml\nEx...xb0\xed \xbd\xcd\xc0\xba \xbf\xb5\xc8\xad. \xc4\xe7. \xc4\xe7. \xc4\xe7.</description>\n</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/EUC-KR/alogblog.com.xml-euc-kr] _________

file_name = 'tests/EUC-KR/alogblog.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-KR"?>\n<!--\nSource: http://alogblog.com/blog/index.xml\nExpect: EUC-KR\...\xb1 \xc0\xfa\xb7\xb1</category>\n<pubDate>Sat, 23 Oct 2004 14:16:00 +0900</pubDate>\n</item>\n\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/EUC-KR/_mozilla_bug9357_text.html-euc-kr] ____

file_name = 'tests/EUC-KR/_mozilla_bug9357_text.html', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<!DOCTYPE html>\n<html>\n<head>\n <title>EUC-KR test</title>\n</head>\n<body>\n <p>\xbf\xe4\xc3\xbb\xc7\xc...b8\xa6 \xc0\xcc\xbf\xeb\xc7\xcf\xbd\xc3\xb1\xe2 \xb9\xd9\xb6\xf8\xb4\xcf\xb4\xd9 </p>\n</body>\n</html>\n\n\n\n\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/EUC-KR/epitaph.egloos.com.xml-euc-kr] ______

file_name = 'tests/EUC-KR/epitaph.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://epitaph.egloos.com/index.xml\nExpect: EUC-K...c\xbe\xdf\xb1\xe2</category>\n\t\t<pubDate>Wed, 24 Aug 2005 23:40:18 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-KR/arts.egloos.com.xml-euc-kr] _______

file_name = 'tests/EUC-KR/arts.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://arts.egloos.com/index.xml\nExpect: EUC-KR\n...c\xba\xd0\xb7\xf9</category>\n\t\t<pubDate>Sat, 19 Feb 2005 12:08:16 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-KR/acnnewswire.net.xml-euc-kr] _______

file_name = 'tests/EUC-KR/acnnewswire.net.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://www.acnnewswire.net/rss2/press_rss_20k.asp\.../Article.Asp?lang=_k&amp;Art_ID=29771</guid><pubDate>Thu, 21 July 2005 14:00:00+0900</pubDate></item></channel></rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/EUC-KR/_ude_euc2.txt-euc-kr] __________

file_name = 'tests/EUC-KR/_ude_euc2.txt', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b"\xba\xcf\xc1\xb6\xbc\xb1 \xbb\xe7\xb6\xf7\xb5\xe9\xc0\xba \xc8\xe7\xc8\xf7 \xc0\xda\xb1\xb9\xc0\xbb \xc1\x...) \xba\xcf\xc2\xca\'\xc0\xbb \xc0\xc7\xb9\xcc\xc7\xcf\xb4\xc2 North Korea\xb6\xf3\xb0\xed \xba\xce\xb8\xa5\xb4\xd9.\n")
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/EUC-KR/chisato.info.xml-euc-kr] _________

file_name = 'tests/EUC-KR/chisato.info.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://chisato.info/blog/index.xml\nExpect: EUC-KR...or>\xc7\xcf\xb3\xeb\xbe\xc6</author>\n<pubDate>Thu,  1 Sep 2005 22:35:29 +0900</pubDate>\n</item>\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/EUC-KR/tori02.egloos.com.xml-euc-kr] ______

file_name = 'tests/EUC-KR/tori02.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://tori02.egloos.com/index.xml\nExpect: EUC-KR...9\xc0\xcc\xbc\xc7</category>\n\t\t<pubDate>Sat, 19 Mar 2005 01:47:31 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-KR/critique.or.kr.xml-euc-kr] ________

file_name = 'tests/EUC-KR/critique.or.kr.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://www.critique.or.kr/tt/index.xml\nExpect: EU...category>\n<author>slowhand</author>\n<pubDate>Fri, 09 Dec 2005 20:06:41 +0900</pubDate>\n</item>\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/EUC-KR/siwoo.org.xml-euc-kr] __________

file_name = 'tests/EUC-KR/siwoo.org.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://siwoo.org/tt/index.xml\nExpect: EUC-KR\n-->...n</category>\n<author>siwoo</author>\n<pubDate>Wed, 15 Jun 2005 10:18:21 +0900</pubDate>\n</item>\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-KR/jely.egloos.com.xml-euc-kr] _______

file_name = 'tests/EUC-KR/jely.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://jely.egloos.com/index.xml\nExpect: EUC-KR\n...category>planning</category>\n\t\t<pubDate>Thu, 15 Dec 2005 00:48:44 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/EUC-KR/yunho.egloos.com.xml-euc-kr] _______

file_name = 'tests/EUC-KR/yunho.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://yunho.egloos.com/index.xml\nExpect: EUC-KR\...7\xb7\xa1\xb9\xd6</category>\n\t\t<pubDate>Sun, 23 Oct 2005 13:20:39 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/EUC-KR/calmguy.egloos.com.xml-euc-kr] ______

file_name = 'tests/EUC-KR/calmguy.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://calmguy.egloos.com/index.xml\nExpect: EUC-K...c\xba\xd0\xb7\xf9</category>\n\t\t<pubDate>Tue, 14 Jun 2005 04:24:28 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/EUC-KR/jely.pe.kr.xml-euc-kr] __________

file_name = 'tests/EUC-KR/jely.pe.kr.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-KR"?>\n<!--\nSource: http://jely.pe.kr/index.xml\nExpect: EUC-KR\n-->\n<...d>\n<dc:subject>monologue</dc:subject>\n<dc:date>2004-10-19T08:53:44+09:00</dc:date>\n</item>\n\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/EUC-KR/jowchung.oolim.net.xml-euc-kr] ______

file_name = 'tests/EUC-KR/jowchung.oolim.net.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\r\n<!--\nSource: http://jowchung.oolim.net/index.xml\nExpect: EUC...ory>\r\n<author>JWC</author>\r\n<pubDate>Fri, 23 Sep 2005 02:43:10 +0900</pubDate>\r\n</item>\r\n</channel>\r\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-KR/kina.egloos.com.xml-euc-kr] _______

file_name = 'tests/EUC-KR/kina.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://kina.egloos.com/index.xml\nExpect: EUC-KR\n...c\xba\xd0\xb7\xf9</category>\n\t\t<pubDate>Sun, 16 May 2004 08:59:23 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/EUC-KR/scarletkh2.egloos.com.xml-euc-kr] ____

file_name = 'tests/EUC-KR/scarletkh2.egloos.com.xml', encoding = 'euc-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<!--\nSource: http://scarletkh2.egloos.com/index.xml\nExpect: EU...c\xba\xd0\xb7\xf9</category>\n\t\t<pubDate>Fri, 22 Jul 2005 04:46:07 GMT</pubDate>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/KOI8-R/susu.ac.ru.xml-koi8-r] __________

file_name = 'tests/KOI8-R/susu.ac.ru.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r"?>\n<!--\nSource: http://susu.ac.ru/ru/news/rss\nExpect: KOI8-R\n-->\...de\xc1\xcc\xcf \xd7 13.00.</yandex:full-text>\n<guid>http://susu.ac.ru/ru/news/1321</guid>\n</item>\n</channel></rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___________ test_encoding_detection[tests/KOI8-R/_ude_1.txt-koi8-r] ____________

file_name = 'tests/KOI8-R/_ude_1.txt', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xf7 \xc7\xc9\xcd\xce\xc1\xda\xc9\xc9 \xcf\xce \xce\xc5 \xc2\xd9\xcc \xd7 \xde\xc9\xd3\xcc\xc5 \xd0\xc5\xd...xd4\xd4\xc5\xd3\xd4\xc1\xd4 \xc9 \xd0\xcf\xd7\xd4\xcf\xd2\xc9\xd4\xd8 \xd0\xcf\xd3\xd4\xd5\xd0\xcc\xc5\xce\xc9\xc5.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/KOI8-R/kapranoff.ru.xml-koi8-r] _________

file_name = 'tests/KOI8-R/kapranoff.ru.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r"?>\n<!--\nSource: http://kapranoff.ru/index.rdf\nExpect: KOI8-R\n-->\.../dc:subject>\n<dc:creator>kappa</dc:creator>\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\n</item>\n\n\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/KOI8-R/newsru.com.xml-koi8-r] __________

file_name = 'tests/KOI8-R/newsru.com.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r"?>\n<!--\nSource: http://www.newsru.com/plain/rss/all.xml\nExpect: KO..."http://www.newsru.com/pict/id/large/819577_20060103092327.gif" type="image/jpeg" />\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/KOI8-R/music.peeps.ru.xml-koi8-r] ________

file_name = 'tests/KOI8-R/music.peeps.ru.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r"?>\n<!--\nSource: http://music.peeps.ru/news/action_rss.xml\nExpect: ...\xc4\xce\xd9\xc8 \xd0\xc1\xce\xcb-\xc7\xd2\xd5\xd0\xd0 90-\xc8. </description>\n\t\t</item>\n\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/KOI8-R/aviaport.ru.xml-koi8-r] _________

file_name = 'tests/KOI8-R/aviaport.ru.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r"?>\n<!--\nSource: http://www.aviaport.ru/news/yandex_export.xml\nExpe...xcf\xca \xd3\xd4\xd2\xc1\xc8\xcf\xd7\xcb\xc9.\n\t\t\t</yandex:full-text>\n\t\t</item>\n\n\t</channel>\n</rss>\n\t\t\t')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.6.xml-koi8-r] _

file_name = 'tests/KOI8-R/forum.template-toolkit.ru.6.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r" ?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_6.rss\n...6.rss">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/KOI8-R/janulalife.blogspot.com.xml-koi8-r] ___

file_name = 'tests/KOI8-R/janulalife.blogspot.com.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="KOI8-R" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/st...\xcf\xc9.\n<br/>\n</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/KOI8-R/_chromium_KOI8-R_with_no_encoding_specified.html-koi8-r] _

file_name = 'tests/KOI8-R/_chromium_KOI8-R_with_no_encoding_specified.html'
encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html>\n <head>\n  <title> KOI8-R </title>\n </head>\n\n <body>\n  \xed\xef\xf3\xeb\xf7\xe1, 9 \xd1\xce\xd...\xcf \xd0\xd2\xc5\xd2\xd7\xc1\xce\xce\xd9\xc5 \xc4\xd7\xc1 \xc4\xce\xd1 \xce\xc1\xda\xc1\xc4 ...\n </body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/KOI8-R/aif.ru.health.xml-koi8-r] ________

file_name = 'tests/KOI8-R/aif.ru.health.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r"?>\n<!--\nSource: http://www.aif.ru/info/rss.php?magazine=health\nExp...d2\xc1\xcc\xd8\xce\xd9\xc8 \xd0\xd2\xcf\xc4\xd5\xcb\xd4\xcf\xd7.\t\t</description>\n\t</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/KOI8-R/intertat.ru.xml-koi8-r] _________

file_name = 'tests/KOI8-R/intertat.ru.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r"?>\n<!--\nSource: http://intertat.ru/myyandex.php\nExpect: KOI8-R\n--...\xca \xc9\xce\xc6\xcf\xd2\xcd\xc1\xc3\xc9\xc9.                           </yandex:full-text></item></channel></rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.9.xml-koi8-r] _

file_name = 'tests/KOI8-R/forum.template-toolkit.ru.9.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r" ?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_9.rss\n...9.rss">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/KOI8-R/aug32.hole.ru.xml-koi8-r] ________

file_name = 'tests/KOI8-R/aug32.hole.ru.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="KOI8-R" ?>\n<!--\nSource: http://aug32.hole.ru/afisha/feed.php\nExpect: KOI8...</description>\n          <link>http://aug32.hole.ru/afisha.htm</link>\n        </item>\n    </channel>\n</rss>\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/KOI8-R/blog.mlmaster.com.xml-koi8-r] ______

file_name = 'tests/KOI8-R/blog.mlmaster.com.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r"?>\n<!--\nSource: http://blog.mlmaster.com/wp-rss2.php\nExpect: KOI8-...\t\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/KOI8-R/koi.kinder.ru.xml-koi8-r] ________

file_name = 'tests/KOI8-R/koi.kinder.ru.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="KOI8-R"?>\n<!--\nSource: http://koi.kinder.ru/rss/kinder_news_koi8.xml\nExpe...ubDate>Mon, 04 Oct 2004 16:28:31 +0300</pubDate>\n<author>otter@kinder.ru</author>\n</item>\n\n</channel>\n</rss>\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/KOI8-R/greek.ru.xml-koi8-r] ___________

file_name = 'tests/KOI8-R/greek.ru.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r"?>\n<!--\nSource: http://www.greek.ru/news/ya/yagreek\nExpect: KOI8-R...d3 \xcf\xd3\xd4\xd2\xcf\xd7\xc1 \xf3\xd0\xc5\xc3\xc5\xd3... \n</description>\n    </item>                \n\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.1.xml-koi8-r] _

file_name = 'tests/KOI8-R/forum.template-toolkit.ru.1.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r" ?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_1.rss\n...1.rss">http://forum.template-toolkit.ru/view_topic/topic_id-93.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.4.xml-koi8-r] _

file_name = 'tests/KOI8-R/forum.template-toolkit.ru.4.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r" ?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_4.rss\n...-4.rss">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/KOI8-R/money.rin.ru.xml-koi8-r] _________

file_name = 'tests/KOI8-R/money.rin.ru.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="KOI8-R"?>\n<!--\nSource: http://money.rin.ru/news/rss/\nExpect: KOI8-R\n-->\..."   (N 1080 \xcf\xd4 17 \xce\xcf\xd1\xc2\xd2\xd1 2005 \xc7\xcf\xc4\xc1).</description>\n</item>\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.8.xml-koi8-r] _

file_name = 'tests/KOI8-R/forum.template-toolkit.ru.8.xml', encoding = 'koi8-r'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="koi8-r" ?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_8.rss\n...8.rss">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/_ude_he3.txt-windows-1255] _

file_name = 'tests/windows-1255-hebrew/_ude_he3.txt', encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xe0\xe9\xef \xeb\xee\xf2\xe8 \xf0\xe9\xe1\xe9\xed \xe0\xe6\xe5\xf8\xe9\xe9\xed \xf2\xe1\xf8\xe9\xe9\xed. ...\xe8\xe9\xed), \xe0\xe5\xec\xed \xf9\xe5\xf0\xe9 \xe6\xe4 \xe0\xe9\xf0\xe5 \xe2\xe3\xe5\xec (\xe9\xe7\xf1\xe9\xfa).\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/halemo.net.edoar.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/halemo.net.edoar.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://halemo.net/edoar/rss.xml\nExpect: wind...xf0\xe5\xfa \xe7\xe1\xf8\xfa \xee\xe9\xf7\xf8\xe5\xf1\xe5\xf4\xe8.\n</description>\n</item>\n\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.8.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/notes.co.il.8.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.notes.co.il/rss.asp?b=8\nExpect: w...\xe5? \xe0\xe5 \xf9...&lt;/div&gt;</description><pubDate>2005-10-20T12:47:00+02:00</pubDate></item></channel></rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/hydepark.hevre.co.il.7957.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/hydepark.hevre.co.il.7957.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://hydepark.hevre.co.il/hydepark/rss1.asp.../><br/>\xfa\xe5\xf7\xef \xf2\xec \xe9\xe3\xe9 - babyfish - 01/01/2006 5:47:57]]></description></item></channel></rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/exego.net.2.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/exego.net.2.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.exego.net/forums/forumRSS.asp?f=2\...\xe9\xed \xec\xe4\xed?&lt;/div&gt;</description><pubDate>2005-12-28T21:54:00+02:00</pubDate></item></channel></rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/maakav.org.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/maakav.org.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.maakav.org/edunuke/html/backend.ph...9\xee\xe4</title>\n<link>http://www.maakav.org/edunuke/html/article.php?sid=448</link>\n</item>\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/neviim.net.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/neviim.net.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.neviim.net/wp-rss2.php\nExpect: wi...t\t<wfw:commentRSS>http://www.neviim.net/wp-commentsrss2.php?p=74</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/infomed.co.il.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/infomed.co.il.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255" ?> \n<!--\nSource: http://infomed.co.il/rss/rss.xml\nExpect: w...ion>\n   <category>\xf9\xe0\xec\xe5\xfa \xe5\xfa\xf9\xe5\xe1\xe5\xfa</category>\n</item>\n</channel>\n</rss>\n\n\n \n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/_chromium_ISO-8859-8_with_no_encoding_specified.html-windows-1255] _

file_name = 'tests/windows-1255-hebrew/_chromium_ISO-8859-8_with_no_encoding_specified.html'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html>\n <head>\n  <title> ISO-8859-8 </title>\n </head>\n\n <body dir="rtl">\n  \xe1\xee\xf7\xe1\xe9\xec ...xed \xe2\xe5\xf8\xed \xe7\xe9\xf6\xe5\xf0\xe9 \xe9\xf7\xe1\xf2 \xe0\xfa \xe6\xeb\xe5\xfa\xe4 ...\n </body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/whatsup.org.il.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/whatsup.org.il.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.whatsup.org.il/backend.php\nExpect...0\xe6\xe5\xf8\xe9\xed \xe0\xe7\xf8\xe9\xed \xe1\xf2\xe5\xec\xed...&quot;</description>\n</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/hagada.org.il.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/hagada.org.il.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.hagada.org.il/hagada/html/backend....p;file=article&amp;sid=4177</link>\n<description><span dir="rtl"></span></description>\n</item>\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/_ude_he2.txt-windows-1255] _

file_name = 'tests/windows-1255-hebrew/_ude_he2.txt', encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xe4\xf2\xe1\xf8\xe9\xfa \xe4\xe9\xe0 \xf9\xf4\xe4 \xe4\xee\xf9\xfa\xe9\xe9\xeb\xfa \xec\xf7\xe1\xe5\xf6\x... \xe1\xe9\xee\xe9 \xe4\xe1\xe9\xf0\xe9\xe9\xed \xe4\xe9\xe0 \xee\xf9\xf4\xe7\xfa \xe0\xe1\xef \xfa\xe9\xe1\xe5\xef.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/sharks.co.il.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/sharks.co.il.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.sharks.co.il/backend2.php\nExpect:...8\xe5 - \xe6\xe5\xe4\xe9 \xe4\xf7\xec\xe9\xee\xe0\xef 50KCC.&lt;/div&gt;</description>\n</item>\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.7.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/notes.co.il.7.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.notes.co.il/rss.asp?b=7\nExpect: w...c\xe4\xe9\xf2\xec\xe1?&lt;/div&gt;</description><pubDate>2004-11-11T00:42:00+02:00</pubDate></item></channel></rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/pcplus.co.il.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/pcplus.co.il.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.pcplus.co.il/rss.php\nExpect: wind...e5\xf4\xe8</title>\n\n<link>http://www.pcplus.co.il/opinions.php?id=139</link>\n\n</item>\n\n\n</channel>\n\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.50.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/notes.co.il.50.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.notes.co.il/rss.asp?b=50\nExpect: ...f="http://www.notes...&lt;/div&gt;</description><pubDate>2005-12-03T08:00:00+02:00</pubDate></item></channel></rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.6.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/notes.co.il.6.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.notes.co.il/rss.asp?b=6\nExpect: w...d \xe0\xfa \xe4\xee...&lt;/div&gt;</description><pubDate>2005-07-14T08:14:00+02:00</pubDate></item></channel></rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/hevra.org.il.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/hevra.org.il.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://hevra.org.il/backend.php\nExpect: wind...link>http://www.hevra.org.il/modules.php?name=News&amp;file=article&amp;sid=830</link>\n</item>\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/law.co.il.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/law.co.il.xml', encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.law.co.il/rss.php\nExpect: windows..., \xf2\xe5&amp;quot;\xe3 \xe9\xe4\xe5\xe3\xe4 \xe8\xe5\xf0\xe9\xf7.\n</description>\n   </item>\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/_ude_he1.txt-windows-1255] _

file_name = 'tests/windows-1255-hebrew/_ude_he1.txt', encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xe4\xf9\xed \xf2\xe1\xf8 \xee\xe5\xf4\xe9\xf2 \xe1\xfa\xf0"\xea \xeb\xf9\xee\xe5 \xf9\xec \xf1\xe1\xe5 \x...\xfa \xf9\xee\xe5 \xf9\xec \xe4\xf0\xe9\xe1 \xf9\xe3\xe5\xe1\xf8 \xe1\xe0\xe6\xe5\xf8 \xe9\xf8\xe5\xf9\xec\xe9\xed.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/info.org.il.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/info.org.il.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="WINDOWS-1255"?>\n<!--\nSource: http://www.info.org.il/rss/rss.php\nExpect: w...Indows-1255.</description>\n<link>http://www.info.org.il/rss/index.php#90165987</link>\n</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/_chromium_windows-1255_with_no_encoding_specified.html-windows-1255] _

file_name = 'tests/windows-1255-hebrew/_chromium_windows-1255_with_no_encoding_specified.html'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html>\n <head>\n  <title> windows-1255 </title>\n </head>\n\n <body dir="rtl">\n  \xe1\xee\xf7\xe1\xe9\xe...xed \xe2\xe5\xf8\xed \xe7\xe9\xf6\xe5\xf0\xe9 \xe9\xf7\xe1\xf2 \xe0\xfa \xe6\xeb\xe5\xfa\xe4 ...\n </body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/windows-1255-hebrew/carshops.co.il.xml-windows-1255] _

file_name = 'tests/windows-1255-hebrew/carshops.co.il.xml'
encoding = 'windows-1255'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="windows-1255"?>\n<!--\nSource: http://www.carshops.co.il/rss2.php\nExpect: w...]></description>\n    <pubDate><![CDATA[Fri, 27 Aug 2004 00:00:00 +0300]]></pubDate>\n  </item>\n  </channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.wld.xml-iso-8859-7] _

file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.wld.xml'
encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-7"?>\n<!--\nSource: http://www.naftemporiki.gr/news/static/rss/news....gr (\xc7 \xcd\xc1\xd5\xd4\xc5\xcc\xd0\xcf\xd1\xc9\xca\xc7 ON LINE)</author>\n</item>\n\n\n\n</channel>\n</rss>\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.fin.xml-iso-8859-7] _

file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.fin.xml'
encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-7"?>\n<!--\nSource: http://www.naftemporiki.gr/news/static/rss/news...\n<description></description>\n<author>editor@ana.gr (\xc1\xd0\xc5)</author>\n</item>\n\n\n\n</channel>\n</rss>\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrt.xml-iso-8859-7] _

file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.mrt.xml'
encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-7"?>\n<!--\nSource: http://www.naftemporiki.gr/news/static/rss/news...emporiki.gr (\xc7 \xcd\xc1\xd5\xd4\xc5\xcc\xd0\xcf\xd1\xc9\xca\xc7)</author>\n</item>\n\n\n\n</channel>\n</rss>\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.cmm.xml-iso-8859-7] _

file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.cmm.xml'
encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-7"?>\n<!--\nSource: http://www.naftemporiki.gr/news/static/rss/news...emporiki.gr (\xc7 \xcd\xc1\xd5\xd4\xc5\xcc\xd0\xcf\xd1\xc9\xca\xc7)</author>\n</item>\n\n\n\n</channel>\n</rss>\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.bus.xml-iso-8859-7] _

file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.bus.xml'
encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-7"?>\n<!--\nSource: http://www.naftemporiki.gr/news/static/rss/news...emporiki.gr (\xc7 \xcd\xc1\xd5\xd4\xc5\xcc\xd0\xcf\xd1\xc9\xca\xc7)</author>\n</item>\n\n\n\n</channel>\n</rss>\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/iso-8859-7-greek/_ude_2.txt-iso-8859-7] _____

file_name = 'tests/iso-8859-7-greek/_ude_2.txt', encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xc4\xf9\xf1\xe5\xdc\xed \xf3\xf4\xef \xcf\xe9 \xb6\xed\xe5\xec\xef\xe9, \xf4\xef \xcc\xde\xed\xf5\xec\xe1...1\xe3\xfc\xed\xe9\xe1 \xe1\xeb\xeb\xdc \xe4\xe5 \xf6\xe1\xdf\xed\xe5\xf4\xe1\xe9 \xed\xe1 \xec\xf0\xef\xf1\xe5\xdf.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.spo.xml-iso-8859-7] _

file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.spo.xml'
encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-7"?>\n<!--\nSource: http://www.naftemporiki.gr/news/static/rss/news...\n<description></description>\n<author>editor@ana.gr (\xc1\xd0\xc5)</author>\n</item>\n\n\n\n</channel>\n</rss>\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-7-greek/_chromium_ISO-8859-7_with_no_encoding_specified.html-iso-8859-7] _

file_name = 'tests/iso-8859-7-greek/_chromium_ISO-8859-7_with_no_encoding_specified.html'
encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html>\n <head>\n  <title> ISO-8859-7 </title>\n </head>\n\n <body>\n  \xcc\xe5 \xef\xec\xe9\xeb\xdf\xe1 \...e5\xe9\xf2 \xf4\xef\xf5 \xca\xca\xc5 \xe3\xe9\xe1 \xf4\xef \xe1\xe3\xf1\xef\xf4\xe9\xea\xfc, ...\n </body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrk.xml-iso-8859-7] _

file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.mrk.xml'
encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-7"?>\n<!--\nSource: http://www.naftemporiki.gr/news/static/rss/news...emporiki.gr (\xc7 \xcd\xc1\xd5\xd4\xc5\xcc\xd0\xcf\xd1\xc9\xca\xc7)</author>\n</item>\n\n\n\n</channel>\n</rss>\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/iso-8859-7-greek/_ude_greek.txt-iso-8859-7] ___

file_name = 'tests/iso-8859-7-greek/_ude_greek.txt', encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xc7 \xe5\xeb\xeb\xe7\xed\xe9\xea\xde \xe1\xf0\xef\xf4\xe5\xeb\xe5\xdf \xf4\xe7 \xec\xe7\xf4\xf1\xe9\xea\x...xfe\xf3\xf3\xe1 \xe5\xdf\xed\xe1\xe9 \xe3\xfd\xf1\xf9 \xf3\xf4\xe1 20 \xe5\xea\xe1\xf4\xef\xec\xec\xfd\xf1\xe9\xe1.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/iso-8859-7-greek/_ude_3.txt-iso-8859-7] _____

file_name = 'tests/iso-8859-7-greek/_ude_3.txt', encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xc7 \xe5\xeb\xeb\xe7\xed\xe9\xea\xde \xe1\xf0\xef\xf4\xe5\xeb\xe5\xdf \xf4\xe7 \xec\xe7\xf4\xf1\xe9\xea\x...xfe\xf3\xf3\xe1 \xe5\xdf\xed\xe1\xe9 \xe3\xfd\xf1\xf9 \xf3\xf4\xe1 20 \xe5\xea\xe1\xf4\xef\xec\xec\xfd\xf1\xe9\xe1.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-7-greek/hotstation.gr.xml-iso-8859-7] _

file_name = 'tests/iso-8859-7-greek/hotstation.gr.xml', encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-7"?>\n<!--\nSource: http://www.hotstation.gr/backend.php\nExpect: I...ink>http://www.HotStation.gr/modules.php?name=News&amp;file=article&amp;sid=855</link>\n</item>\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/iso-8859-7-greek/_ude_1.txt-iso-8859-7] _____

file_name = 'tests/iso-8859-7-greek/_ude_1.txt', encoding = 'iso-8859-7'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xb8\xed\xe1\xf2 \xe4\xe9\xe1\xe4\xe9\xea\xf4\xf5\xe1\xea\xfc\xf2 \xec\xe1\xf2 \xf6\xdf\xeb\xef\xf2, \xf4\...xea\xdc \xe1\xe9\xf3\xe8\xde\xec\xe1\xf4\xe1 \xf0\xf1\xef\xf2 \xf4\xef\xed \xe1\xf0\xef\xe8\xe1\xed\xfc\xed\xf4\xe1. ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/UTF-16/bom-utf-16-be.srt-utf-16] ________

file_name = 'tests/UTF-16/bom-utf-16-be.srt', encoding = 'utf-16'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b"\xfe\xff\x001\x00\n\x000\x000\x00:\x000\x000\x00:\x000\x006\x00,\x005\x000\x000\x00 \x00-\x00-\x00>\x00 \x...\x00 \x00g\x00l\x00o\x00b\x00a\x00l\x00 \x00a\x00w\x00a\x00r\x00e\x00n\x00e\x00s\x00s\x00 \x00d\x00a\x00y\x00\n\x00\n")
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/UTF-16/bom-utf-16-le.srt-utf-16] ________

file_name = 'tests/UTF-16/bom-utf-16-le.srt', encoding = 'utf-16'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b"\xff\xfe1\x00\n\x000\x000\x00:\x000\x000\x00:\x000\x006\x00,\x005\x000\x000\x00 \x00-\x00-\x00>\x00 \x000\... \x00g\x00l\x00o\x00b\x00a\x00l\x00 \x00a\x00w\x00a\x00r\x00e\x00n\x00e\x00s\x00s\x00 \x00d\x00a\x00y\x00\n\x00\n\x00")
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/CP949/ricanet.com.xml-cp949] __________

file_name = 'tests/CP949/ricanet.com.xml', encoding = 'cp949'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-kr" ?>\n<rss version=\'0.92\'>\n<channel>\n<docs></docs>\n<title>\xb8\xa...--end-->]]></description>\n<link>http://ricanet.com/new/view.php?id=blog/100206</link>\n</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/music.peeps.ru.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/music.peeps.ru.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://music.peeps.ru/news/action_rss.xml\nExpe...\xd4\xdd\xeb\xe5 \xdf\xd0\xdd\xda-\xd3\xe0\xe3\xdf\xdf 90-\xe5. </description>\n\t\t</item>\n\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/intertat.ru.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/intertat.ru.xml', encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://intertat.ru/myyandex.php\nExpect: ISO-88...\xd8\xd4\xd5\xe2\xd5\xdb\xec\xe1\xe2\xd2\xde \xde \xe0\xd5\xd3\xd8\xe1\xe2\xe0\xd0\xe6\xd8\xd8 \xc1\xbc\xb8 \xcd\xdb ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/aviaport.ru.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/aviaport.ru.xml', encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://www.aviaport.ru/news/yandex_export.xml\n...\xd8 \xd2\xe1\xd5\xe5 \xd8\xe1\xdf\xeb\xe2\xd0\xdd\xd8\xd9 - \xd8 \xdc\xd0\xe8\xd8\xdd\xeb, \xd8 \xdb\xee\xd4\xd5\xd9')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.1.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/forum.template-toolkit.ru.1.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_1.rs...1.rss">http://forum.template-toolkit.ru/view_topic/topic_id-93.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.4.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/forum.template-toolkit.ru.4.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_4.rs...-4.rss">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/aug32.hole.ru.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/aug32.hole.ru.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://aug32.hole.ru/afisha/feed.php\nExpect: I...&gt;</description>\n          <link>http://aug32.hole.ru/afisha.htm</link>\n        </item>\n    </channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/janulalife.blogspot.com.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/janulalife.blogspot.com.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.co...\xde\xd8.\n<br/>\n</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/money.rin.ru.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/money.rin.ru.xml', encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://money.rin.ru/news/rss/\nExpect: ISO-8859...  (N 1080 \xde\xe2 17 \xdd\xde\xef\xd1\xe0\xef 2005 \xd3\xde\xd4\xd0).</description>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/_chromium_ISO-8859-5_with_no_encoding_specified.html-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/_chromium_ISO-8859-5_with_no_encoding_specified.html'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html>\n <head>\n  <title> ISO-8859-5 </title>\n </head>\n\n <body>\n  \xbc\xbe\xc1\xba\xb2\xb0, 9 \xef\xd...\xde \xdf\xe0\xd5\xe0\xd2\xd0\xdd\xdd\xeb\xd5 \xd4\xd2\xd0 \xd4\xdd\xef \xdd\xd0\xd7\xd0\xd4 ...\n </body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.8.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/forum.template-toolkit.ru.8.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_8.rs...8.rss">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/iso-8859-5-russian/greek.ru.xml-iso-8859-5] ___

file_name = 'tests/iso-8859-5-russian/greek.ru.xml', encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://www.greek.ru/news/ya/yagreek\nExpect: IS...d8. \xc0\xde\xd2\xdd\xde 29 \xdb\xd5\xe2 \xdd\xd0\xd7\xd0\xd4 \xd2 \xe5\xde\xd4\xd5 \xde\xdf\xd5\xe0\xd0\xe6\xd8\xd8 ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/susu.ac.ru.xml-iso-8859-5] __

file_name = 'tests/iso-8859-5-russian/susu.ac.ru.xml', encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://susu.ac.ru/ru/news/rss\nExpect: ISO-8859...5\xdd\xd8\xef \xdf\xde\xd1\xd5\xd4\xd8\xe2\xd5\xdb\xd5\xd9 \xda\xde\xdd\xda\xe3\xe0\xe1\xd0 \xe1\xd0\xd9\xe2\xde\xd2 ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.6.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/forum.template-toolkit.ru.6.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_6.rs...6.rss">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/aif.ru.health.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/aif.ru.health.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://www.aif.ru/info/rss.php?magazine=health\...e0\xd0\xdb\xec\xdd\xeb\xe5 \xdf\xe0\xde\xd4\xe3\xda\xe2\xde\xd2.\t\t</description>\n\t</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.9.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/forum.template-toolkit.ru.9.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_9.rs...9.rss">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/kapranoff.ru.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/kapranoff.ru.xml', encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://kapranoff.ru/index.rdf\nExpect: ISO-8859...dc:subject/>\n<dc:creator>kappa</dc:creator>\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\n</item>\n\n\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/blog.mlmaster.com.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-russian/blog.mlmaster.com.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://blog.mlmaster.com/wp-rss2.php\nExpect: I...\t\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-russian/newsru.com.xml-iso-8859-5] __

file_name = 'tests/iso-8859-5-russian/newsru.com.xml', encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="ISO-8859-5"?>\n<!--\nSource: http://www.newsru.com/plain/rss/all.xml\nExpect...="http://www.newsru.com/pict/id/large/819577_20060103092327.gif" type="image/jpeg"/>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.analyse1.xml-tis-620] _

file_name = 'tests/TIS-620/pharmacy.kku.ac.th.analyse1.xml'
encoding = 'tis-620'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="tis-620"?>\n<!--\nSource: http://pharmacy.kku.ac.th/analyse1/wp-rss2.php\nEx...entRSS>http://pharmacy.kku.ac.th/analyse1/wp-commentsrss2.php?p=3</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.healthinfo-ne.xml-tis-620] _

file_name = 'tests/TIS-620/pharmacy.kku.ac.th.healthinfo-ne.xml'
encoding = 'tis-620'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="tis-620"?>\n<!--\nSource: http://pharmacy.kku.ac.th/healthinfo-ne/wp-rss2.ph...http://pharmacy.kku.ac.th/healthinfo-ne/wp-commentsrss2.php?p=386</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.centerlab.xml-tis-620] _

file_name = 'tests/TIS-620/pharmacy.kku.ac.th.centerlab.xml'
encoding = 'tis-620'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="tis-620"?>\n<!--\nSource: http://pharmacy.kku.ac.th/centerlab/wp-rss2.php\nE...ntRSS>http://pharmacy.kku.ac.th/centerlab/wp-commentsrss2.php?p=5</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/TIS-620/opentle.org.xml-tis-620] ________

file_name = 'tests/TIS-620/opentle.org.xml', encoding = 'tis-620'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="TIS-620"?>\n<!--\nSource: http://www.opentle.org/backend.php\nExpect: TIS-62...\xc3\xb9\xd3\xc1\xd2\xe3\xaa\xe9\xa7\xd2\xb9\xcd\xd5\xa1\xb4\xe9\xc7\xc2</description>\n</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/TIS-620/trickspot.boxchart.com.xml-tis-620] ___

file_name = 'tests/TIS-620/trickspot.boxchart.com.xml', encoding = 'tis-620'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="TIS-620"?>\n<!--\nSource: http://trickspot.boxchart.com/wp-rss2.php\nExpect:...commentRSS>http://trickspot.boxchart.com/wp-commentsrss2.php?p=52</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/TIS-620/_mozilla_bug488426_text.html-tis-620] __

file_name = 'tests/TIS-620/_mozilla_bug488426_text.html', encoding = 'tis-620'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html>\n<body>\n\xc3\xcb\xd1\xca\xca\xd3\xcb\xc3\xd1\xba\xcd\xd1\xa1\xa2\xc3\xd0\xe4\xb7\xc2\xb7\xd5\xe8\xe3\xaa\xe9\xa1\xd1\xba\xa4\xcd\xc1\xbe\xd4\xc7\xe0\xb5\xcd\xc3\xec\n</body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/utf-8/anitabee.blogspot.com.xml-utf-8] _____

file_name = 'tests/utf-8/anitabee.blogspot.com.xml', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/sty...e vagyok. </div>\n</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____________ test_encoding_detection[tests/utf-8/_ude_2.txt-utf-8] _____________

file_name = 'tests/utf-8/_ude_2.txt', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b"\xeb\xb6\x81\xec\xa1\xb0\xec\x84\xa0 \xec\x82\xac\xeb\x9e\x8c\xeb\x93\xa4\xec\x9d\x80 \xed\x9d\x94\xed\x9e...d\x98\xeb\xaf\xb8\xed\x95\x98\xeb\x8a\x94 North Korea\xeb\x9d\xbc\xea\xb3\xa0 \xeb\xb6\x80\xeb\xa5\xb8\xeb\x8b\xa4.\n")
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/utf-8/_chromium_UTF-8_with_no_encoding_specified.html-utf-8] _

file_name = 'tests/utf-8/_chromium_UTF-8_with_no_encoding_specified.html'
encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html><head>\n  <title> UTF-8 </title>\n </head><body>\n  \xe9\xba\xa6\xe8\x92\x82\xe7\x9a\x84\xe5\xa4\xa9...\xe5\xbf\x85\xe9\xa1\xbb\xe5\x8a\xaa\xe5\x8a\x9b\xe6\x89\x8d\xe8\xa1\x8c\xe3\x80\x82\xe2\x80\x9d\n \n\n</body></html>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____________ test_encoding_detection[tests/utf-8/_ude_3.txt-utf-8] _____________

file_name = 'tests/utf-8/_ude_3.txt', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\\\\\\\\\\\\\\{ssss } siaaaaaaaaa  ssss<ciao>i \xc3\xa0 \xc3\xa8 \xc3\xac\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/utf-8/weblabor.hu.2.xml-utf-8] _________

file_name = 'tests/utf-8/weblabor.hu.2.xml', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="utf-8"?>\n<!--\nSource: http://weblabor.hu/node/feed\nExpect: UTF-8\n-->\n<!...azis">Adatb\xc3\xa1zis</category>\n <pubDate>Mon, 19 Dec 2005 00:12:29 +0100</pubDate>\n</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/utf-8/balatonblog.typepad.com.xml-utf-8] ____

file_name = 'tests/utf-8/balatonblog.typepad.com.xml', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="utf-8"?>\n<!--\nSource: http://balatonblog.typepad.com/balatonblog/index.rdf...:subject>\n\n<dc:creator>ivcsek</dc:creator>\n<dc:date>2005-12-05T18:26:59+01:00</dc:date>\n</item>\n\n\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___________ test_encoding_detection[tests/utf-8/_ude_he3.txt-utf-8] ____________

file_name = 'tests/utf-8/_ude_he3.txt', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xd7\x90\xd7\x99\xd7\x9f \xd7\x9b\xd7\x9e\xd7\xa2\xd7\x98 \xd7\xa0\xd7\x99\xd7\x91\xd7\x99\xd7\x9d \xd7\x9...7\x94 \xd7\x90\xd7\x99\xd7\xa0\xd7\x95 \xd7\x92\xd7\x93\xd7\x95\xd7\x9c (\xd7\x99\xd7\x97\xd7\xa1\xd7\x99\xd7\xaa).\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____________ test_encoding_detection[tests/utf-8/_ude_5.txt-utf-8] _____________

file_name = 'tests/utf-8/_ude_5.txt', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xe4\xbb\x99\xe4\xba\xba\xe6\xb4\x9e\xe6\x96\x87\xe5\x8c\x96\xe4\xbf\x82\xe8\xa9\xb1\xe5\x88\xb0\xe8\x90\x...\xe5\x8d\x80\n\n1\xe9\x9a\xbb\xe5\x88\x86\xe9\xa1\x9e: \xe6\xb1\x9f\xe8\xa5\xbf\xe5\x97\xb0\xe6\xad\xb7\xe5\x8f\xb2\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/utf-8/_ude_greek.txt-utf-8] ___________

file_name = 'tests/utf-8/_ude_greek.txt', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xce\x97 \xce\xb5\xce\xbb\xce\xbb\xce\xb7\xce\xbd\xce\xb9\xce\xba\xce\xae \xce\xb1\xcf\x80\xce\xbf\xcf\x84...cf\x83\xcf\x84\xce\xb1 20 \xce\xb5\xce\xba\xce\xb1\xcf\x84\xce\xbf\xce\xbc\xce\xbc\xcf\x8d\xcf\x81\xce\xb9\xce\xb1.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___________ test_encoding_detection[tests/utf-8/_ude_he2.txt-utf-8] ____________

file_name = 'tests/utf-8/_ude_he2.txt', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xd7\x94\xd7\xa2\xd7\x91\xd7\xa8\xd7\x99\xd7\xaa \xd7\x94\xd7\x99\xd7\x90 \xd7\xa9\xd7\xa4\xd7\x94 \xd7\x9...xd7\x90 \xd7\x9e\xd7\xa9\xd7\xa4\xd7\x97\xd7\xaa \xd7\x90\xd7\x91\xd7\x9f \xd7\xaa\xd7\x99\xd7\x91\xd7\x95\xd7\x9f.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/utf-8/linuxbox.hu.xml-utf-8] __________

file_name = 'tests/utf-8/linuxbox.hu.xml', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="utf-8"?>\n<!--\nSource: http://linuxbox.hu/node/feed\nExpect: UTF-8\n-->\n<!...taxonomy/term/2">Linux</category>\n <pubDate>Fri, 09 Sep 2005 16:06:29 -0400</pubDate>\n</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/utf-8/_ude_russian.txt-utf-8] __________

file_name = 'tests/utf-8/_ude_russian.txt', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xd0\x92 \xd0\xb3\xd0\xb8\xd0\xbc\xd0\xbd\xd0\xb0\xd0\xb7\xd0\xb8\xd0\xb8 \xd0\xbe\xd0\xbd \xd0\xbd\xd0\xb...0\xd0\xb8\xd1\x82\xd1\x8c \xd0\xbf\xd0\xbe\xd1\x81\xd1\x82\xd1\x83\xd0\xbf\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___________ test_encoding_detection[tests/utf-8/pihgy.hu.xml-utf-8] ____________

file_name = 'tests/utf-8/pihgy.hu.xml', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="utf-8"?>\n<!--\nSource: http://pihgy.hu/node/feed\nExpect: UTF-8\n-->\n<!DOC... pedag\xc3\xb3gusoknak</category>\n <pubDate>Thu, 27 Oct 2005 17:30:09 +0200</pubDate>\n</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/utf-8/weblabor.hu.xml-utf-8] __________

file_name = 'tests/utf-8/weblabor.hu.xml', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="utf-8"?>\n<!--\nSource: http://weblabor.hu/rss\nExpect: UTF-8\n-->\n<!DOCTYP...hirek/rovatok/php">PHP</category>\n <pubDate>Wed, 04 Jan 2006 11:15:54 +0100</pubDate>\n</item>\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/utf-8/_mozilla_bug426271_text-utf-8.html-utf-8] _

file_name = 'tests/utf-8/_mozilla_bug426271_text-utf-8.html', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html lang="ja">\n<head>\n<title>\xe6\x97...\xad\xe3\x83\x9a\xe3\x83\x87\xe3\x82\xa3\xe3\x82\xa2\xef\xbc\x88Wikipedia\xef\xbc\x89\xe3\x80\x8f\n</body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/utf-8/boobooo.blogspot.com.xml-utf-8] ______

file_name = 'tests/utf-8/boobooo.blogspot.com.xml', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/sty...neket.\nT\xc3\xa9l</div>\n</summary>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____________ test_encoding_detection[tests/utf-8/_ude_1.txt-utf-8] _____________

file_name = 'tests/utf-8/_ude_1.txt', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xec\x97\xad\xec\x82\xac\xec\xa0\x81 \xec\x98\x88\xec\x88\x98 \xec\x97\xb0\xea\xb5\xac\xec\x9e\x90\xeb\x93...\xb1\xea\xb3\xbc\xeb\x93\xa4\xec\x9d\x84 \xec\x86\x8c\xea\xb0\x9c\xed\x95\x98\xea\xb3\xa0 \xec\x9e\x88\xeb\x8b\xa4.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/utf-8/_mozilla_bug306272_text.html-utf-8] ____

file_name = 'tests/utf-8/_mozilla_bug306272_text.html', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html><head>\n\n  <title>306272</title>\n...href="mailto:Antti.Nayha@somewhere.fi">Antti N\xc3\xa4yh\xc3\xa4 &lt;Antti.Nayha@somewhere.fi&gt;</a>\n</body></html>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___________ test_encoding_detection[tests/utf-8/_ude_he1.txt-utf-8] ____________

file_name = 'tests/utf-8/_ude_he1.txt', encoding = 'utf-8'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xd7\x94\xd7\xa9\xd7\x9d \xd7\xa2\xd7\x91\xd7\xa8 \xd7\x9e\xd7\x95\xd7\xa4\xd7\x99\xd7\xa2 \xd7\x91\xd7\xa...\xd7\x91\xd7\xa8 \xd7\x91\xd7\x90\xd7\x96\xd7\x95\xd7\xa8 \xd7\x99\xd7\xa8\xd7\x95\xd7\xa9\xd7\x9c\xd7\x99\xd7\x9d.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/UTF-32/bom-utf-32-be.srt-utf-32] ________

file_name = 'tests/UTF-32/bom-utf-32-be.srt', encoding = 'utf-32'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b"\x00\x00\xfe\xff\x00\x00\x001\x00\x00\x00\n\x00\x00\x000\x00\x00\x000\x00\x00\x00:\x00\x00\x000\x00\x00\x0...00\x00\x00e\x00\x00\x00s\x00\x00\x00s\x00\x00\x00 \x00\x00\x00d\x00\x00\x00a\x00\x00\x00y\x00\x00\x00\n\x00\x00\x00\n")
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/UTF-32/bom-utf-32-le.srt-utf-32] ________

file_name = 'tests/UTF-32/bom-utf-32-le.srt', encoding = 'utf-32'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b"\xff\xfe\x00\x001\x00\x00\x00\n\x00\x00\x000\x00\x00\x000\x00\x00\x00:\x00\x00\x000\x00\x00\x000\x00\x00\x...x00\x00\x00s\x00\x00\x00s\x00\x00\x00 \x00\x00\x00d\x00\x00\x00a\x00\x00\x00y\x00\x00\x00\n\x00\x00\x00\n\x00\x00\x00")
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/iso-8859-1/_ude_2.txt-iso-8859-1] ________

file_name = 'tests/iso-8859-1/_ude_2.txt', encoding = 'iso-8859-1'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'Le type de visa requis pour entrer en France d\xe9pend \xe0 la fois de la dur\xe9e et des motifs du s\xe9j...urn\xe9e, sportifs disputant un championnat, salari\xe9 d\xe9tach\xe9 dans le cadre d\'une\nprestation de service).\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/iso-8859-1/_ude_1.txt-iso-8859-1] ________

file_name = 'tests/iso-8859-1/_ude_1.txt', encoding = 'iso-8859-1'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b"Nas paginas que em seguida se leem acha-se t\xe3o bem determinada, com tanta eloquencia e t\xe3o profunda ...stra\xeddo que se affasta da sala do festim, e cuja voz se perde pouco a pouco no silencio da distancia e da noute.\n")
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/iso-8859-1/_ude_4.txt-iso-8859-1] ________

file_name = 'tests/iso-8859-1/_ude_4.txt', encoding = 'iso-8859-1'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b"Il padre. Ecco, sissignore! Ma un fatto \xe8 come un sacco: vuoto, non si regge. Perch\xe9 si regga, bisog...ntre quella poverina\ncredeva di sacrificarsi per me e per quei due, cucendo anche di notte la roba di Madama Pace!\n")
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/iso-8859-1/_ude_6.txt-iso-8859-1] ________

file_name = 'tests/iso-8859-1/_ude_6.txt', encoding = 'iso-8859-1'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'Viel\xe4 ehdit perehty\xe4 Sibeliuksen el\xe4m\xe4\xe4n Ateneumissa, aina 22. maaliskuuta asti.\nMoniaisti...in ja paahtimoihin.\nTapahtumassa kilpaillaan lis\xe4ksi Cup Tasting, Brewers Cup ja Vuoden Barista titteleist\xe4.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/iso-8859-1/_ude_5.txt-iso-8859-1] ________

file_name = 'tests/iso-8859-1/_ude_5.txt', encoding = 'iso-8859-1'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'Agentes de la Guardia Civil de la Comandancia de Madrid, integrantes del Equipo Mujer Menor, han detenido ...clases a Alumnos de Primaria,\nera tutor de ni\xf1os de 11 a\xf1os, pero daba clases a otros menores de 13 a\xf1os.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/iso-8859-1/_ude_3.txt-iso-8859-1] ________

file_name = 'tests/iso-8859-1/_ude_3.txt', encoding = 'iso-8859-1'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b"La commedia non ha atti n\xe9 scene. La rappresentazione sar\xe0 interrotta una prima volta, senza che il ... mettersi in ginocchio e\ninchiodarli. Alle martellate accorrer\xe0 dalla porta dei camerini il Direttore di scena.\n")
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/Johab/iyagi-readme.txt-johab] __________

file_name = 'tests/Johab/iyagi-readme.txt', encoding = 'johab'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'===============================================================================\n                         ...b6\x91\xa0i\xb7\xa1\x90a \xaca\xb6w \xac\xe9\xa1w\xac\xe1\x9fi \xc0q\x89\xa1\xd0a\xaf\xb3\xaf\xa1\xb5\xa1.\n-\x8f{-\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/Johab/hlpro-readme.txt-johab] __________

file_name = 'tests/Johab/hlpro-readme.txt', encoding = 'johab'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'      To read this document, use common combined Hangul code or KSSM code.\n\n                            ...9f\xa1\x9fi \xc4\xf1\xcca\xb7\xa9\x9c\xe1 \xb5\xb3\xade\xb5A \xac\xe9\xb8\xf7\xd0a\x8b\xa1 \xa4a\x9cs\x93\xa1\x94a.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___________ test_encoding_detection[tests/Johab/mdir-doc.txt-johab] ____________

file_name = 'tests/Johab/mdir-doc.txt', encoding = 'johab'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\n\n    \xd9\xc6\xd9\xc6\xd9\xc6                    \xd9\xc6\xd9\xc6\xd9\xc6       \xd9\xc6\xd9\xc6\xd9\xc...9\xc8\xd9\xc8\xd9\xc8\xd9\xc8\xd9\xc8\xd9\xc8\xd9\xc8\xd9\xc8\xd9\xc8\xd9\xc8\xd9\xc8\xd9\xc8\xd9\xc8\xd9\xc8\n\n\x1a')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.6.xml-ibm855] _

file_name = 'tests/IBM855/forum.template-toolkit.ru.6.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_6.rss\nE...6.rss">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___________ test_encoding_detection[tests/IBM855/_ude_1.txt-ibm855] ____________

file_name = 'tests/IBM855/_ude_1.txt', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xec \xac\xb7\xd2\xd4\xa0\xf3\xb7\xb7 \xd6\xd4 \xd4\xa8 \xa2\xf1\xd0 \xeb \xfb\xb7\xe3\xd0\xa8 \xd8\xa8\xe...xe5\xe5\xa8\xe3\xe5\xa0\xe5 \xb7 \xd8\xd6\xeb\xe5\xd6\xe1\xb7\xe5\xed \xd8\xd6\xe3\xe5\xe7\xd8\xd0\xa8\xd4\xb7\xa8.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/IBM855/blog.mlmaster.com.xml-ibm855] ______

file_name = 'tests/IBM855/blog.mlmaster.com.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://blog.mlmaster.com/wp-rss2.php\nExpect: IBM85...\t\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\n\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.1.xml-ibm855] _

file_name = 'tests/IBM855/forum.template-toolkit.ru.1.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_1.rss\nE...1.rss">http://forum.template-toolkit.ru/view_topic/topic_id-93.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.9.xml-ibm855] _

file_name = 'tests/IBM855/forum.template-toolkit.ru.9.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_9.rss\nE...9.rss">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.8.xml-ibm855] _

file_name = 'tests/IBM855/forum.template-toolkit.ru.8.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_8.rss\nE...8.rss">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.4.xml-ibm855] _

file_name = 'tests/IBM855/forum.template-toolkit.ru.4.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://forum.template-toolkit.ru/rss/forum_4.rss\nE...-4.rss">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\n\t\t</item>\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/IBM855/kapranoff.ru.xml-ibm855] _________

file_name = 'tests/IBM855/kapranoff.ru.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://kapranoff.ru/index.rdf\nExpect: IBM855\n-->\...dc:subject/>\n<dc:creator>kappa</dc:creator>\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\n</item>\n\n\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/IBM855/janulalife.blogspot.com.xml-ibm855] ___

file_name = 'tests/IBM855/janulalife.blogspot.com.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com/st...\xd6\xb7.\n<br/>\n</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/IBM855/aviaport.ru.xml-ibm855] _________

file_name = 'tests/IBM855/aviaport.ru.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://www.aviaport.ru/news/yandex_export.xml\nExpe...\xb7 \xeb\xe3\xa8\xb5 \xb7\xe3\xd8\xf1\xe5\xa0\xd4\xb7\xbd - \xb7 \xd2\xa0\xf5\xb7\xd4\xf1, \xb7 \xd0\x9c\xa6\xa8\xbd')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/IBM855/aif.ru.health.xml-ibm855] ________

file_name = 'tests/IBM855/aif.ru.health.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://www.aif.ru/info/rss.php?magazine=health\nExp...e1\xa0\xd0\xed\xd4\xf1\xb5 \xd8\xe1\xd6\xa6\xe7\xc6\xe5\xd6\xeb.\t\t</description>\n\t</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/IBM855/newsru.com.xml-ibm855] __________

file_name = 'tests/IBM855/newsru.com.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://www.newsru.com/plain/rss/all.xml\nExpect: IB...="http://www.newsru.com/pict/id/large/819577_20060103092327.gif" type="image/jpeg"/>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/IBM855/greek.ru.xml-ibm855] ___________

file_name = 'tests/IBM855/greek.ru.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://www.greek.ru/news/ya/yagreek\nExpect: IBM855...d6 \xb5\xd6\xe1\xd6\xf5\xd6 \xd8\xd6\xd2\xd4\xde\xe5 \xb7 \xd0\x9c\xa2\xde\xe5 \xeb \xa3\xd6\xd0\xed\xf5\xd6\xd2 \xe5')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/IBM855/music.peeps.ru.xml-ibm855] ________

file_name = 'tests/IBM855/music.peeps.ru.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://music.peeps.ru/news/action_rss.xml\nExpect: ...\xa6\xd4\xf1\xb5 \xd8\xa0\xd4\xc6-\xac\xe1\xe7\xd8\xd8 90-\xb5. </description>\n\t\t</item>\n\n\t</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/IBM855/aug32.hole.ru.xml-ibm855] ________

file_name = 'tests/IBM855/aug32.hole.ru.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://aug32.hole.ru/afisha/feed.php\nExpect: IBM85...&gt;</description>\n          <link>http://aug32.hole.ru/afisha.htm</link>\n        </item>\n    </channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/IBM855/intertat.ru.xml-ibm855] _________

file_name = 'tests/IBM855/intertat.ru.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://intertat.ru/myyandex.php\nExpect: IBM855\n--...\xb7\xa6\xa8\xe5\xa8\xd0\xed\xe3\xe5\xeb\xd6 \xd6 \xe1\xa8\xac\xb7\xe3\xe5\xe1\xa0\xa4\xb7\xb7 \xe4\xd3\xb8 \xf8\xd0 ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/IBM855/money.rin.ru.xml-ibm855] _________

file_name = 'tests/IBM855/money.rin.ru.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://money.rin.ru/news/rss/\nExpect: IBM855\n-->\...  (N 1080 \xd6\xe5 17 \xd4\xd6\xde\xa2\xe1\xde 2005 \xac\xd6\xa6\xa0).</description>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/IBM855/susu.ac.ru.xml-ibm855] __________

file_name = 'tests/IBM855/susu.ac.ru.xml', encoding = 'ibm855'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="IBM855"?>\n<!--\nSource: http://susu.ac.ru/ru/news/rss\nExpect: IBM855\n-->\...d4\xd4\xd6\xe3\xe5\xb7&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=""http://model.exponenta.ru/""&gt;Model.Exponenta.Ru ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/utf-8-sig/bom-utf-8.srt-utf-8-sig] _______

file_name = 'tests/utf-8-sig/bom-utf-8.srt', encoding = 'utf-8-sig'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b"\xef\xbb\xbf1\n00:00:06,500 --> 00:00:09,000\nAbout 2 months ago I found myself on\nthe comment section of...00:50,000\nSo what I thought I do is instead if answering on a YouTube comment is organize a global awareness day\n\n")
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/utf-8-sig/_ude_4.txt-utf-8-sig] _________

file_name = 'tests/utf-8-sig/_ude_4.txt', encoding = 'utf-8-sig'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\xef\xbb\xbf========================================================================\n    \xe3\x82\xb3\xe3...be\xe3\x81\x99\xe3\x80\x82\n\n/////////////////////////////////////////////////////////////////////////////\n\n\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/doncho.net.comments.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/doncho.net.comments.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://blog.doncho.net/wp-commentsrss2.php\nExp...\'wp-smiley\' /> </p>\n]]></content:encoded>\n\t\t\t\t</item>\n\t<item>\n \t\t<title>Comment on \xba\xe3\xdf\xde\xdd ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/debian.gabrovo.com.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://debian.gabrovo.com/backend/debianbg-arti...ebian.gabrovo.com/show.php?id=5&amp;tablica=articles&amp;sub=\xc2\xd5\xdc\xd0</link>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/iso-8859-5-bulgarian/ide.li.xml-iso-8859-5] ___

file_name = 'tests/iso-8859-5-bulgarian/ide.li.xml', encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://www.ide.li/backend.php\nExpect: ISO-8859...2\xe0\xd0\xd4\xd8\xe6\xd8\xde\xdd\xdd\xd8\xef \xe1\xd8 \xe1\xdf\xd8\xe1\xea\xda \xe1 \xda\xe3\xe0\xd8\xde\xd7\xdd\xd8')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.9.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/bpm.cult.bg.9.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://bpm.cult.bg/logs/rdf.php?id=9\nExpect: I...)</dc:subject>\n<dc:creator>Kaladan</dc:creator>\n<dc:date>2004-12-03T19:12:22+02:00</dc:date>\n</item>\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/bpm.cult.bg.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://bpm.cult.bg/services/rss/ezine.php\nExpe...e0\xd8\xe2\xd8\xd5, \xd8\xe1\xe2\xd8\xdd\xe1\xda\xd8 \xe1\xee\xe0\xdf\xe0\xd8\xd7 - \xdd\xd5 \xdc\xde\xd6\xd5\xe8\xd5')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/ecloga.cult.bg.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/ecloga.cult.bg.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://ecloga.cult.bg/log/wp-rss.php\nExpect: I...ption>\n            <link>http://ecloga.cult.bg/log/index.php?p=242</link>\n        </item>\n    </channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.news.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/debian.gabrovo.com.news.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://debian.gabrovo.com/backend/debianbg-news...//debian.gabrovo.com/show.php?id=56&amp;tablica=news&amp;sub=\xc2\xd5\xdc\xd0</link>\n</item>\n\n</channel>\n</rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/aero-bg.com.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/aero-bg.com.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.co...xde\xe0\xe2"</a>\n</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.4.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/bpm.cult.bg.4.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://bpm.cult.bg/logs/rdf.php?id=4\nExpect: I...ialogs, popup menus, strings) should be displayed on the chosen language, independently on the language of your OS (I')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/linux-bg.org.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/linux-bg.org.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://linux-bg.org/linux-bg-news.rdf\nExpect: ...=news&amp;key=378326293</link>\n</item>\n\n \n <skipHours>\n <hour>1</hour>\n </skipHours>\n \n </channel>\n </rss>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.medusa.4.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/bpm.cult.bg.medusa.4.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://bpm.cult.bg/medusa/logs/rdf.php?id=4\nEx...ialogs, popup menus, strings) should be displayed on the chosen language, independently on the language of your OS (I')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.2.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/bpm.cult.bg.2.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://bpm.cult.bg/logs/rdf.php?id=2\nExpect: I...og)</dc:subject>\n<dc:creator>snark</dc:creator>\n<dc:date>2005-12-12T18:12:01+02:00</dc:date>\n</item>\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/iso-8859-5-bulgarian/bbc.co.uk.popshow.xml-iso-8859-5] _

file_name = 'tests/iso-8859-5-bulgarian/bbc.co.uk.popshow.xml'
encoding = 'iso-8859-5'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="iso-8859-5"?>\n<!--\nSource: http://www.bbc.co.uk/bulgarian/popshow/index.rd...l</link>\n      <description xml:lang="bg">Rolling Stone, BBC, NME \xe1\xd0 \xd5\xd4\xd8\xdd\xde\xd4\xe3\xe8\xdd\xd8 ')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/ascii/_mozilla_bug638318_text.html-ascii] ____

file_name = 'tests/ascii/_mozilla_bug638318_text.html', encoding = 'ascii'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x...\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00<title>NOT UTF-16!</title>NOT UTF-16!')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/ascii/howto.diveintomark.org.xml-ascii] _____

file_name = 'tests/ascii/howto.diveintomark.org.xml', encoding = 'ascii'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">\n<title>how...DATA[Use Handbrake to convert your existing DVDs to play on the video iPod.]]></summary>\n        </entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/ascii/_chromium_iso-8859-1_with_no_encoding_specified.html-ascii] _

file_name = 'tests/ascii/_chromium_iso-8859-1_with_no_encoding_specified.html'
encoding = 'ascii'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.01 Transitional//EN" "http://www.w3c.o rg/TR/1999/REC-html401-19... src="/Icons/w3c_main" width=315></h1>\n<h2 id=slogan>Leading the Web to Its Full Potential...</h2>\n</body>\n</html>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/iso-2022-kr/_ude_iso1.txt-iso-2022-kr] _____

file_name = 'tests/iso-2022-kr/_ude_iso1.txt', encoding = 'iso-2022-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\x1b$)C\x0e?*;g@{\x0f \x0e?9<v\x0f \x0e?,18@Z5i@:\x0f \x0e:9@=<-3*\x0f \x0e;g555i@G\x0f \x0e<-=E<-\x0f \x0...FGGO?)\x0f, \x0e?*;g@{\x0f \x0e?9<v?!\x0f \x0e4kGQ\x0f \x0e?,18\x0f \x0e<:0z5i@;\x0f \x0e<R03GO0m\x0f \x0e@V4Y\x0f.\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/iso-2022-kr/_ude_iso2.txt-iso-2022-kr] _____

file_name = 'tests/iso-2022-kr/_ude_iso2.txt', encoding = 'iso-2022-kr'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b"\x1b$)C\x0e:OA6<1\x0f \x0e;g6w5i@:\x0f \x0eHgHw\x0f \x0e@Z19@;\x0f \x0eA6<1\x0f(\x0epH`X\x0f)\x0e@L3*\x0f ...'\x0eA6<19]55\x0f(\x0eGQ9]55\x0f) \x0e:OBJ\x0f\'\x0e@;\x0f \x0e@G9LGO4B\x0f North Korea\x0e6s0m\x0f \x0e:N8%4Y\x0f.\n")
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/UTF-32LE/nobom-utf32le.txt-utf-32le] ______

file_name = 'tests/UTF-32LE/nobom-utf32le.txt', encoding = 'utf-32le'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'D\x00\x00\x00a\x00\x00\x00t\x00\x00\x00e\x00\x00\x00T\x00\x00\x00i\x00\x00\x00m\x00\x00\x00e\x00\x00\x00,\...x00\x00\x00.\x00\x00\x000\x00\x00\x008\x00\x00\x003\x00\x00\x005\x00\x00\x003\x00\x00\x00\r\x00\x00\x00\n\x00\x00\x00')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/UTF-32LE/plane1-utf-32le.html-utf-32le] _____

file_name = 'tests/UTF-32LE/plane1-utf-32le.html', encoding = 'utf-32le'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<\x00\x00\x00!\x00\x00\x00D\x00\x00\x00O\x00\x00\x00C\x00\x00\x00T\x00\x00\x00Y\x00\x00\x00P\x00\x00\x00E\...x00\x00\x00/\x00\x00\x00h\x00\x00\x00t\x00\x00\x00m\x00\x00\x00l\x00\x00\x00>\x00\x00\x00\r\x00\x00\x00\n\x00\x00\x00')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/EUC-JP/overcube.com.xml-euc-jp] _________

file_name = 'tests/EUC-JP/overcube.com.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://www.overcube.com/blog/index.rdf\nExpect: EUC...y</dc:subject>\n<dc:creator>overQ</dc:creator>\n<dc:date>2005-12-28T23:25:11+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/EUC-JP/_mozilla_bug620106_text.html-euc-jp] ___

file_name = 'tests/EUC-JP/_mozilla_bug620106_text.html', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<!DOCTYPE html>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\...c\xa4\xac\xc0\xb5\xa4\xb7\xa4\xaf\xb8\xa1\xbd\xd0\xa4\xb5\xa4\xec\xa4\xc6\xa4\xa4\xa4\xde\xa4\xb9\xa4\xab\xa1\xa9\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/EUC-JP/rdf.ycf.nanet.co.jp.xml-euc-jp] _____

file_name = 'tests/EUC-JP/rdf.ycf.nanet.co.jp.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://www.ycf.nanet.co.jp/~dre/cgi-bin/diary/index...ad</dc:subject>\n<dc:creator>AND0</dc:creator>\n<dc:date>2005-10-28T02:46:13+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___________ test_encoding_detection[tests/EUC-JP/_ude_1.txt-euc-jp] ____________

file_name = 'tests/EUC-JP/_ude_1.txt', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'========================================================================\n    \xa5\xb3\xa5\xf3\xa5\xbd\xa1...b7\xa4\xde\xa4\xb9\xa1\xa3\n\n/////////////////////////////////////////////////////////////////////////////\n\n\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___________ test_encoding_detection[tests/EUC-JP/tls.org.xml-euc-jp] ___________

file_name = 'tests/EUC-JP/tls.org.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-jp" ?>\n<!--\nSource: http://www.tls.org/~moriya/diary/rss.cgi\nExpect: ...\xa4\xe8\xa4\xaf\xbf\xb2\xa4\xbf</description>\n\t<dc:date>2005-12-25T05:13:14+09:00</dc:date>\n</item>\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/EUC-JP/aivy.co.jp.xml-euc-jp] __________

file_name = 'tests/EUC-JP/aivy.co.jp.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://www.aivy.co.jp/BLOG_TEST/kobakoba/index.rdf\...de</dc:subject>\n<dc:creator>koba</dc:creator>\n<dc:date>2005-12-02T00:51:57+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-JP/yukiboh.moo.jp.xml-euc-jp] ________

file_name = 'tests/EUC-JP/yukiboh.moo.jp.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://yukiboh.moo.jp/weblog/index.rdf\nExpect: EUC...:creator>\xa4\xe6\xa4\xad\xcb\xb7</dc:creator>\n<dc:date>2004-12-08T09:00:40+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/EUC-JP/bphrs.net.xml-euc-jp] __________

file_name = 'tests/EUC-JP/bphrs.net.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://www.bphrs.net/mesi/index.rdf\nExpect: EUC-JP.../dc:subject>\n<dc:creator>bphrs</dc:creator>\n\n<dc:date>2005-04-02T18:49:14+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/EUC-JP/misuzilla.org.xml-euc-jp] ________

file_name = 'tests/EUC-JP/misuzilla.org.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<?xml-stylesheet href="rss2html.xsl" type="text/xsl" ?>\n<!--\nSo...xbc\xc2\xb9\xd4\xa4\xc7\xa4\xad\xa4\xde\xa4\xb9\xa1\xa3</p>\n</div>]]></content:encoded>\n  </item>\n\n\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.xml-euc-jp] ______

file_name = 'tests/EUC-JP/blog.kabu-navi.com.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://blog.kabu-navi.com/atom.xml\nExpect: EUC-JP\...xa2\xa1\xa2\xc6\xfc\xa1\xb9\xc0\xba\xbf\xca\xa4\xc7\xa4\xb9\xa4\xcd\xa1\xa3</p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/EUC-JP/aristrist.s57.xrea.com.xml-euc-jp] ____

file_name = 'tests/EUC-JP/aristrist.s57.xrea.com.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://aristrist.s57.xrea.com/mt/index.rdf\nExpect:.../dc:subject>\n<dc:creator>aristrist</dc:creator>\n<dc:date>2005-12-19T23:58:13+09:00</dc:date>\n</item>\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/EUC-JP/_mozilla_bug431054_text.html-euc-jp] ___

file_name = 'tests/EUC-JP/_mozilla_bug431054_text.html', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html>\n<body>\n\xa5\xed\xa5\xb0\xa5\xa4\xa5\xf3\n</body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/EUC-JP/_mozilla_bug426271_text-euc-jp.html-euc-jp] _

file_name = 'tests/EUC-JP/_mozilla_bug426271_text-euc-jp.html'
encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n<html lang="ja">\n<head>\n<title>\xc6\xfc...\xa1\xd8\xa5\xa6\xa5\xa3\xa5\xad\xa5\xda\xa5\xc7\xa5\xa3\xa5\xa2\xa1\xcaWikipedia\xa1\xcb\xa1\xd9\n</body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/EUC-JP/club.h14m.org.xml-euc-jp] ________

file_name = 'tests/EUC-JP/club.h14m.org.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-jp" ?>\n<!--\nSource: http://club.h14m.org/kenji/diary/rss.cgi\nExpect: ...\xa4\xb7\xa4\xde\xa4\xb9\xa1\xa3</description>\n\t<dc:date>2005-12-19T04:46:33+00:00</dc:date>\n</item>\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/EUC-JP/siesta.co.jp.aozora.xml-euc-jp] _____

file_name = 'tests/EUC-JP/siesta.co.jp.aozora.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://www.siesta.co.jp/aozora/index.rdf\nExpect: E...\n<dc:creator>PoorBook G3&apos;99</dc:creator>\n<dc:date>2005-10-29T08:05:59+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-JP/ch.kitaguni.tv.xml-euc-jp] ________

file_name = 'tests/EUC-JP/ch.kitaguni.tv.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="euc-jp"?>\n<!--\nSource: http://ch.kitaguni.tv/u/8280/index.rdf\nExpect: EUC...xb4\xa1\xbc\xa5\xeb\xa4\xa2\xa4\xea\xa4\xac\xa4\xc8\xa4\xa6\xa2\xf6</p>\n]]></content:encoded>\n</item>\n</rdf:RDF>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/EUC-JP/contents-factory.com.xml-euc-jp] _____

file_name = 'tests/EUC-JP/contents-factory.com.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://contents-factory.com/blog/index.rdf\nExpect:...dc:subject>\n<dc:creator>katayama</dc:creator>\n<dc:date>2005-11-15T23:27:43+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.atom.xml-euc-jp] ___

file_name = 'tests/EUC-JP/blog.kabu-navi.com.atom.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://www.kabu-navi.com/mt/atom.xml\nExpect: EUC-J...\xa4\xec\xa4\xca\xa4\xa4\xa1\xa3</p>\n\n<p><br />\n\xa4\xc7\xa4\xcf\xa1\xa3</p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/EUC-JP/atom.ycf.nanet.co.jp.xml-euc-jp] _____

file_name = 'tests/EUC-JP/atom.ycf.nanet.co.jp.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://www.ycf.nanet.co.jp/~dre/cgi-bin/diary/atom....xa4\xcf\xc5\xb1\xc2\xe0\xcd\xbd\xc4\xea\xa4\xc7\xa4\xb9\xa1\xa3</p>]]>\n      \n    </content>\n  </entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/EUC-JP/arclamp.jp.xml-euc-jp] __________

file_name = 'tests/EUC-JP/arclamp.jp.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://www.arclamp.jp/index.rdf\nExpect: EUC-JP\n--...</dc:subject>\n<dc:creator>yusuke</dc:creator>\n<dc:date>2005-12-07T01:52:31+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/EUC-JP/furusatonoeki.cutegirl.jp.xml-euc-jp] __

file_name = 'tests/EUC-JP/furusatonoeki.cutegirl.jp.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://furusatonoeki.cutegirl.jp/main/index.rdf\nEx...>\xa4\xd5\xa4\xeb\xc0\xb8\xa4\xad</dc:creator>\n<dc:date>2005-08-12T02:00:37+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/EUC-JP/pinkupa.com.xml-euc-jp] _________

file_name = 'tests/EUC-JP/pinkupa.com.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://www.pinkupa.com/index.rdf\nExpect: EUC-JP\n-.../dc:subject>\n<dc:creator>michiyo</dc:creator>\n<dc:date>2005-11-10T20:43:40+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-JP/artifact-jp.com.xml-euc-jp] _______

file_name = 'tests/EUC-JP/artifact-jp.com.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://artifact-jp.com/index.xml\nExpect: EUC-JP\n-...xa4\xb7\xa4\xc6\xa4\xb7\xa4\xde\xa4\xa4\xa4\xde\xa4\xb9\xa1\xa3...</description>\n    </item>\n\n  </channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/EUC-JP/azoz.org.xml-euc-jp] ___________

file_name = 'tests/EUC-JP/azoz.org.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://azoz.org/index.rdf\nExpect: EUC-JP\n-->\n<rd...SS</dc:subject>\n<dc:creator>eizo</dc:creator>\n<dc:date>2005-11-24T15:25:17+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-JP/akaname.main.jp.xml-euc-jp] _______

file_name = 'tests/EUC-JP/akaname.main.jp.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://akaname.main.jp/mt/index.rdf\nExpect: EUC-JP.../dc:subject>\n<dc:creator>akaname</dc:creator>\n<dc:date>2005-07-20T17:01:19+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________ test_encoding_detection[tests/EUC-JP/mimizun.com.xml-euc-jp] _________

file_name = 'tests/EUC-JP/mimizun.com.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://mimizun.com:81/blog/index.rdf\nExpect: EUC-J.../dc:subject>\n<dc:creator>mimizun</dc:creator>\n<dc:date>2005-12-13T11:20:59+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/EUC-JP/manana.moo.jp.xml-euc-jp] ________

file_name = 'tests/EUC-JP/manana.moo.jp.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://nanana.moo.jp/index.rdf\nExpect: EUC-JP\n-->...</dc:subject>\n<dc:creator>nanana</dc:creator>\n<dc:date>2005-03-06T11:43:59+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_______ test_encoding_detection[tests/EUC-JP/azito.under.jp.xml-euc-jp] ________

file_name = 'tests/EUC-JP/azito.under.jp.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://azito.under.jp/blog/azito/index.rdf\nExpect:...b</dc:subject>\n<dc:creator>azito</dc:creator>\n<dc:date>2005-12-12T18:19:15+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/EUC-JP/overcube.com.atom.xml-euc-jp] ______

file_name = 'tests/EUC-JP/overcube.com.atom.xml', encoding = 'euc-jp'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="EUC-JP"?>\n<!--\nSource: http://www.overcube.com/blog/atom.xml\nExpect: EUC-...\n\n<p>\xc2\xad\xa4\xac\xc4\xcb\xa4\xa4\xa4\xca\xa4\xa2\xa1\xa3\xa1\xa3</p>]]>\n    </content>\n  </entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/SHIFT_JIS/_ude_1.txt-shift_jis] _________

file_name = 'tests/SHIFT_JIS/_ude_1.txt', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'\rThe Project Gutenberg Etext of Rashomon by AKUTAGAWA Ryunosuke\r\r\r\r\r\rCopyright laws are changing al...s\x82\xcc\x92\xac\x82\xd6\x8b\xad\x93\x90\x82\xf0\x93\xad\x82\xab\x82\xc9\x8b}\x82\xa2\x82\xc5\x82\xa2\x82\xbd\x81B\r')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/SHIFT_JIS/accessories-brand.com.xml-shift_jis] _

file_name = 'tests/SHIFT_JIS/accessories-brand.com.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.accessories-brand.com/atom.xml\nExpec...tp://www.tasaki.co.jp/" target="_blank" >http://www.tasaki.co.jp/</a><br /></p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/SHIFT_JIS/setsuzei119.jp.xml-shift_jis] _____

file_name = 'tests/SHIFT_JIS/setsuzei119.jp.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://setsuzei119.jp/atom.xml\nExpect: SHIFT_JI...82\xcd\x81A\x83t\x83\x8a\x81[\x83_\x83C\x83\x84\x83\x8b\x81F\x81@0120-533-336</p>]]>\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/SHIFT_JIS/dogsinn.jp.xml-shift_jis] _______

file_name = 'tests/SHIFT_JIS/dogsinn.jp.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.dogsinn.jp/owner/atom.xml\nExpect: SH...\x81F</B></FONT></FONT><img src="photo/stars-3.gif" width="64" height="12"></p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/SHIFT_JIS/nextbeaut.com.xml-shift_jis] _____

file_name = 'tests/SHIFT_JIS/nextbeaut.com.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.nextbeaut.com/mt/atom.xml\nExpect: SH...81y\x96\xe2\x89\xae\x82\xb3\x82\xf1.net\x81z" width="100" height="100"></a></p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/SHIFT_JIS/ooganemochi.com.xml-shift_jis] ____

file_name = 'tests/SHIFT_JIS/ooganemochi.com.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.ooganemochi.com/atom.xml\nExpect: SHI...82\xaa\x82\xed\x82\xa9\x82\xe7\x82\xf1\x82\xa9\x82\xc1\x82\xbd\x82\x9f\x81B</p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/SHIFT_JIS/_ude_2.txt-shift_jis] _________

file_name = 'tests/SHIFT_JIS/_ude_2.txt', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'========================================================================\n    \x83R\x83\x93\x83\\\x81[\x83...2\xb5\x82\xdc\x82\xb7\x81B\n\n/////////////////////////////////////////////////////////////////////////////\n\n\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__ test_encoding_detection[tests/SHIFT_JIS/clickablewords.com.xml-shift_jis] ___

file_name = 'tests/SHIFT_JIS/clickablewords.com.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://clickablewords.com/atom.xml\nExpect: SHIF...82\xc6\x82\xb7\x82\xae\x82\xc9\x82\xa8\x95\xa0\x82\xf0\x89\xf3\x82\xb7\x81B</p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/SHIFT_JIS/bloglelife.com.xml-shift_jis] _____

file_name = 'tests/SHIFT_JIS/bloglelife.com.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.bloglelife.com/atom.xml\nExpect: SHIF...3g\x83v\x83\x8d\x83O\x83\x89\x83\x80</A><!-- /TG-Affiliate Banner Space --></p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/SHIFT_JIS/perth-on.net.xml-shift_jis] ______

file_name = 'tests/SHIFT_JIS/perth-on.net.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.perth-on.net/main/atom.xml\nExpect: S...c4\x82\xdd\x82\xc4\x82\xcd\x82\xa2\x82\xa9\x82\xaa\x82\xc5\x82\xb7\x82\xa9\x81B]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/SHIFT_JIS/andore.com.money.xml-shift_jis] ____

file_name = 'tests/SHIFT_JIS/andore.com.money.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://andore.com/money/index.rdf\nExpect: SHIFT...e</dc:subject>\n<dc:creator>money</dc:creator>\n<dc:date>2005-10-07T19:56:51+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/SHIFT_JIS/tamuyou.haun.org.xml-shift_jis] ____

file_name = 'tests/SHIFT_JIS/tamuyou.haun.org.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://tamuyou.haun.org/mt/index.rdf\nExpect: SH.../dc:subject>\n<dc:creator>tamuyou</dc:creator>\n<dc:date>2005-12-26T16:30:52+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/SHIFT_JIS/_ude_4.txt-shift_jis] _________

file_name = 'tests/SHIFT_JIS/_ude_4.txt', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'Project Gutenberg Etext of The Small Catechism of Martin Luther\nJapanese Translation by Hiroshi Yuki\n\nC...all Catechism of Martin Luther\nby  hyuki@hyuki.com\nhttp://www.hyuki.com/\nhttp://www.hyuki.com/trans/smallct.html\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/SHIFT_JIS/andore.com.xml-shift_jis] _______

file_name = 'tests/SHIFT_JIS/andore.com.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://andore.com/mt/index.rdf\nExpect: SHIFT_JI...t></dc:subject>\n<dc:creator>Hiro</dc:creator>\n<dc:date>2004-08-18T06:26:31+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/SHIFT_JIS/blog.inkase.net.xml-shift_jis] ____

file_name = 'tests/SHIFT_JIS/blog.inkase.net.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="shift_jis"?>\n<!--\nSource: http://blog.inkase.net/atom.xml\nExpect: SHIFT_J...no" marginwidth="0" marginheight="0" frameborder="0"></iframe>]]>\n        \n    </content>\n</entry>\n\n</feed> \n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/SHIFT_JIS/_chromium_Shift-JIS_with_no_encoding_specified.html-shift_jis] _

file_name = 'tests/SHIFT_JIS/_chromium_Shift-JIS_with_no_encoding_specified.html'
encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<html>\n <head>\n  <title> Shift_JIS </title>\n </head>\n\n <body>\n  \x8fO\x89@\x8bc\x89@\x89^\x89c\x88\x...96\xca\x8b\x91\x94\xdb\x82\xb7\x82\xe9\x81|\x82\xb1\x82\xc6\x82\xf0\x8c\x88\x82\xdf\x82\xbd\x81B\n </body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/SHIFT_JIS/sakusaka-silk.net.xml-shift_jis] ___

file_name = 'tests/SHIFT_JIS/sakusaka-silk.net.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="shift_jis"?>\n<!--\nSource: http://www.sakusaku-silk.net/index.rdf\nExpect: .../dc:subject>\n<dc:creator>silknet</dc:creator>\n<dc:date>2005-10-20T01:52:25+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/SHIFT_JIS/yasuhisa.com.xml-shift_jis] ______

file_name = 'tests/SHIFT_JIS/yasuhisa.com.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="shift_jis"?><?xml-stylesheet href="css/rss.css" type="text/css"?>\n<!--\nSou...c6\x8ev\x82\xa2\x82\xdc\x82\xb7\x81B</description>\n\t\t<dc:date>2005-12-21 10:37:07</dc:date>\n\t</item>\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/SHIFT_JIS/andore.com.inami.xml-shift_jis] ____

file_name = 'tests/SHIFT_JIS/andore.com.inami.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://andore.com/inami/index.rdf\nExpect: SHIFT...88</dc:subject>\n<dc:creator>Hiro</dc:creator>\n<dc:date>2005-11-24T11:00:00-08:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/SHIFT_JIS/_ude_3.txt-shift_jis] _________

file_name = 'tests/SHIFT_JIS/_ude_3.txt', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'========================================================================\n    \x83R\x83\x93\x83\\\x81[\x83...2\xb5\x82\xdc\x82\xb7\x81B\n\n/////////////////////////////////////////////////////////////////////////////\n\n\n\n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
______ test_encoding_detection[tests/SHIFT_JIS/amefoot.net.xml-shift_jis] ______

file_name = 'tests/SHIFT_JIS/amefoot.net.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.amefoot.net/atom.xml\nExpect: SHIFT_J...\xa9\x82\xaf\x82\xb5\x82\xdc\x82\xb5\x82\xbd\x81`\x81I\x81I\n</font></strong></p>]]>\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
________ test_encoding_detection[tests/SHIFT_JIS/10e.org.xml-shift_jis] ________

file_name = 'tests/SHIFT_JIS/10e.org.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://10e.org/index.rdf\nExpect: SHIFT_JIS\n-->...ws</dc:subject>\n<dc:creator>elel</dc:creator>\n<dc:date>2005-12-28T01:32:13+09:00</dc:date>\n</item>\n\n\n</rdf:RDF>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/SHIFT_JIS/grebeweb.net.xml-shift_jis] ______

file_name = 'tests/SHIFT_JIS/grebeweb.net.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.grebeweb.net/mt/atom.xml\nExpect: SHI...x96\xbe\x93\xfa\x88\xc8\x8d~\x82\xcc\x83G\x83\x93\x83g\x83\x8a\x82\xc5\x81B</p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/SHIFT_JIS/blog.paseri.ne.jp.xml-shift_jis] ___

file_name = 'tests/SHIFT_JIS/blog.paseri.ne.jp.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://blog.paseri.ne.jp/atom.xml\nExpect: SHIFT...ai\x81F \x81\x8f 2,926<br /> \x94\xad\x94\x84\x93\xfa\x81F 2004/02/21<br /></p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/SHIFT_JIS/1affliate.com.xml-shift_jis] _____

file_name = 'tests/SHIFT_JIS/1affliate.com.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.1affliate.com/atom.xml\nExpect: SHIFT...---------------------------------------------------------------------  \n</pre>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_ test_encoding_detection[tests/SHIFT_JIS/do.beginnersrack.com.xml-shift_jis] __

file_name = 'tests/SHIFT_JIS/do.beginnersrack.com.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="shift_jis"?>\n<!--\nSource: http://do.beginnersrack.com/atom.xml\nExpect: SH...b2\x97\x9d\x82\xaa\x89\xc2\x94\\\x82\xc8\x82\xcc\x82\xc5\x82\xb7\x81B\n\n\n\n    </content>\n</entry>\n\n</feed> \n\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/SHIFT_JIS/celeb.lalalu.com.xml-shift_jis] ____

file_name = 'tests/SHIFT_JIS/celeb.lalalu.com.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://celeb.lalalu.com/atom.xml\nExpect: SHIFT_...c\x82\xe6\x82\xa4\x82\xc8\x8bC\x82\xaa\x82\xb5\x82\xdc\x82\xb7\x82\xe6\x81B</p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/SHIFT_JIS/milliontimes.jp.xml-shift_jis] ____

file_name = 'tests/SHIFT_JIS/milliontimes.jp.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.milliontimes.jp/column/atom.xml\nExpe...c\x91O\x82\xaa\x82\xc2\x82\xa2\x82\xbd\x82\xe6\x82\xa4\x82\xc5\x82\xb7\x81B</p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/SHIFT_JIS/moon-light.ne.jp.xml-shift_jis] ____

file_name = 'tests/SHIFT_JIS/moon-light.ne.jp.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.moon-light.ne.jp/weblog/index.xml\nEx...category>DVD\x81|News</category>\n<pubDate>Mon, 19 Dec 2005 18:46:34 +0900</pubDate>\n</item>\n\n\n</channel>\n</rss>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_____ test_encoding_detection[tests/SHIFT_JIS/brag.zaka.to.xml-shift_jis] ______

file_name = 'tests/SHIFT_JIS/brag.zaka.to.xml', encoding = 'shift_jis'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS" standalone="yes"?>\n<?xml-stylesheet href="http://www.blogger.com...2\xa4\x82\xa9\x81B</div>\n</content>\n<draft xmlns="http://purl.org/atom-blog/ns#">false</draft>\n</entry>\n</feed>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
__________ test_encoding_detection[tests/CP932/y-moto.com.xml-cp932] ___________

file_name = 'tests/CP932/y-moto.com.xml', encoding = 'cp932'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<?xml version="1.0" encoding="Shift_JIS"?>\n<!--\nSource: http://www.y-moto.com/bd-1/atom.xml\nExpect: SHI...x8f\x91\x82\xa2\x82\xc4\x82\xc8\x82\xa2\x82\xaf\x82\xc7\x81E\x81E\x81E\x81B</p>]]>\n\n</content>\n</entry>\n\n</feed>')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
____ test_encoding_detection[tests/CP932/hardsoft.at.webry.info.xml-cp932] _____

file_name = 'tests/CP932/hardsoft.at.webry.info.xml', encoding = 'cp932'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-tra..._img/hardsoft.at.webry.info/200802/article_1.html" height="1" width="1" />\n<!-- beacon end -->\n\n</body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
___ test_encoding_detection[tests/CP932/www2.chuo-u.ac.jp-suishin.xml-cp932] ___

file_name = 'tests/CP932/www2.chuo-u.ac.jp-suishin.xml', encoding = 'cp932'

    @pytest.mark.parametrize("file_name, encoding", gen_test_params())
    def test_encoding_detection(file_name, encoding):
        with open(file_name, "rb") as f:
            input_bytes = f.read()
            result = chardet.detect(input_bytes)
            try:
                expected_unicode = input_bytes.decode(encoding)
            except LookupError:
                expected_unicode = ""
            try:
                detected_unicode = input_bytes.decode(result["encoding"])
            except (LookupError, UnicodeDecodeError, TypeError):
                detected_unicode = ""
        if result:
            encoding_match = (result["encoding"] or "").lower() == encoding
        else:
            encoding_match = False
        # Only care about mismatches that would actually result in different
        # behavior when decoding
        if not encoding_match and expected_unicode != detected_unicode:
            wrapped_expected = "\n".join(textwrap.wrap(expected_unicode, 100)) + "\n"
            wrapped_detected = "\n".join(textwrap.wrap(detected_unicode, 100)) + "\n"
            diff = "".join(
                list(
                    ndiff(
                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)
                    )
                )[:20]
            )
>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)

test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">\n<html>\n\n<head>\n<meta http-equiv="Content-Type"\ncontent...t;<a\n    href="mailto:kitaro@tamajs.chuo-u.ac.jp">kitaro@tamajs.chuo-u.ac.jp</a>&gt;\n</address>\n</body>\n</html>\n')
ignore_threshold = True

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError
_________________ test_detect_all_and_detect_one_should_agree __________________

txt = '0', enc = 'ascii', _ = HypothesisRandom(generated data)

    @given(
        st.text(min_size=1),
        st.sampled_from(
            [
                "ascii",
                "utf-8",
                "utf-16",
                "utf-32",
                "iso-8859-7",
                "iso-8859-8",
                "windows-1255",
            ]
        ),
        st.randoms(),
    )
    @settings(max_examples=200)
    def test_detect_all_and_detect_one_should_agree(txt, enc, _):
        try:
            data = txt.encode(enc)
        except UnicodeEncodeError:
            assume(False)
        try:
            result = chardet.detect(data)
>           results = chardet.detect_all(data)

test.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

byte_str = bytearray(b'0'), ignore_threshold = False

    def detect_all(byte_str, ignore_threshold=False):
        """
        Detect all the possible encodings of the given byte string.
    
        :param byte_str:          The byte sequence to examine.
        :type byte_str:           ``bytes`` or ``bytearray``
        :param ignore_threshold:  Include encodings that are below
                                  ``UniversalDetector.MINIMUM_THRESHOLD``
                                  in results.
        :type ignore_threshold:   ``bool``
        """
        if not isinstance(byte_str, bytearray):
            if not isinstance(byte_str, bytes):
                raise TypeError(
                    f"Expected object of type bytes or bytearray, got: {type(byte_str)}"
                )
            byte_str = bytearray(byte_str)
    
        detector = UniversalDetector()
        detector.feed(byte_str)
        detector.close()
    
>       if detector.input_state == InputState.HIGH_BYTE:
E       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?

chardet/__init__.py:65: AttributeError

During handling of the above exception, another exception occurred:

    @given(
>       st.text(min_size=1),
        st.sampled_from(
            [
                "ascii",
                "utf-8",
                "utf-16",
                "utf-32",
                "iso-8859-7",
                "iso-8859-8",
                "windows-1255",
            ]
        ),
        st.randoms(),
    )

test.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

txt = '0', enc = 'ascii', _ = HypothesisRandom(generated data)

    @given(
        st.text(min_size=1),
        st.sampled_from(
            [
                "ascii",
                "utf-8",
                "utf-16",
                "utf-32",
                "iso-8859-7",
                "iso-8859-8",
                "windows-1255",
            ]
        ),
        st.randoms(),
    )
    @settings(max_examples=200)
    def test_detect_all_and_detect_one_should_agree(txt, enc, _):
        try:
            data = txt.encode(enc)
        except UnicodeEncodeError:
            assume(False)
        try:
            result = chardet.detect(data)
            results = chardet.detect_all(data)
            assert result["encoding"] == results[0]["encoding"]
        except Exception as exc:
>           raise RuntimeError(f"{result} != {results}") from exc
E           UnboundLocalError: cannot access local variable 'results' where it is not associated with a value
E           Falsifying example: test_detect_all_and_detect_one_should_agree(
E               txt='0',
E               enc='ascii',  # or any other generated value
E               _=HypothesisRandom(generated data),
E           )

test.py:185: UnboundLocalError
--------------------------------- JSON report ----------------------------------
report saved to: report.json
=========================== short test summary info ============================
FAILED test.py::test_encoding_detection[tests/windows-1252/_ude_2.txt-windows-1252]
FAILED test.py::test_encoding_detection[tests/windows-1252/github_bug_9.txt-windows-1252]
FAILED test.py::test_encoding_detection[tests/windows-1252/_mozilla_bug421271_text.html-windows-1252]
FAILED test.py::test_encoding_detection[tests/windows-1252/_ude_1.txt-windows-1252]
FAILED test.py::test_encoding_detection[tests/UTF-32BE/plane1-utf-32be.html-utf-32be]
FAILED test.py::test_encoding_detection[tests/UTF-32BE/nobom-utf32be.txt-utf-32be]
FAILED test.py::test_encoding_detection[tests/UTF-16BE/plane1-utf-16be.html-utf-16be]
FAILED test.py::test_encoding_detection[tests/UTF-16BE/nobom-utf16be.txt-utf-16be]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.9.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/_chromium_windows-1251_with_no_encoding_specified.html-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/_ude_1.txt-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/aviaport.ru.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.8.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/money.rin.ru.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/anthropology.ru.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/music.peeps.ru.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/aif.ru.health.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.6.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/newsru.com.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/blog.mlmaster.com.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/aug32.hole.ru.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.4.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/janulalife.blogspot.com.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/intertat.ru.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/greek.ru.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.1.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-russian/kapranoff.ru.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/GB2312/softsea.net.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/chen56.blogcn.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/pda.blogsome.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/luciferwang.blogcn.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/bbs.blogsome.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/cindychen.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/_chromium_gb18030_with_no_encoding_specified.html.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/14.blog.westca.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/_mozilla_bug171813_text.html-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/xy15400.blogcn.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/lily.blogsome.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/w3cn.org.xml-gb2312] - A...
FAILED test.py::test_encoding_detection[tests/GB2312/jjgod.3322.org.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/coverer.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/godthink.blogsome.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/acnnewswire.net.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/eighthday.blogspot.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/cappuccinos.3322.org.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/2.blog.westca.com.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/GB2312/cnblog.org.xml-gb2312]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/music.peeps.ru.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.4.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/koi.kinder.ru.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/_ude_1.txt-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/aviaport.ru.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/intertat.ru.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/aug32.hole.ru.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.8.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/aif.ru.health.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/blog.mlmaster.com.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/money.rin.ru.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/newsru.com.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/greek.ru.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/susu.ac.ru.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/kapranoff.ru.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.6.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.9.xml-maccyrillic]
FAILED test.py::test_encoding_detection[tests/IBM866/greek.ru.xml-ibm866] - A...
FAILED test.py::test_encoding_detection[tests/IBM866/_ude_1.txt-ibm866] - Att...
FAILED test.py::test_encoding_detection[tests/IBM866/aviaport.ru.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/aug32.hole.ru.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/kapranoff.ru.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/music.peeps.ru.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.4.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.8.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/blog.mlmaster.com.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/money.rin.ru.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/janulalife.blogspot.com.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/intertat.ru.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.9.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/susu.ac.ru.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/newsru.com.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.6.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/aif.ru.health.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.1.xml-ibm866]
FAILED test.py::test_encoding_detection[tests/Big5/myblog.pchome.com.tw.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/blog.worren.net.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/marilynwu.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/coolloud.org.tw.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/ebao.us.xml-big5] - Attrib...
FAILED test.py::test_encoding_detection[tests/Big5/_ude_1.txt-big5] - Attribu...
FAILED test.py::test_encoding_detection[tests/Big5/upsaid.com.xml-big5] - Att...
FAILED test.py::test_encoding_detection[tests/Big5/leavesth.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/oui-design.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/kafkatseng.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/_chromium_Big5_with_no_encoding_specified.html-big5]
FAILED test.py::test_encoding_detection[tests/Big5/sinica.edu.tw.xml-big5] - ...
FAILED test.py::test_encoding_detection[tests/Big5/ke207.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/linyijen.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/tlkkuo.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/carbonxiv.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/0804.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/willythecop.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/sylvia1976.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/fudesign.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/digitalwall.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/catshadow.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/sanwenji.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/letterlego.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/unoriginalblog.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/Big5/ytc.blogspot.com.xml-big5]
FAILED test.py::test_encoding_detection[tests/UTF-16LE/nobom-utf16le.txt-utf-16le]
FAILED test.py::test_encoding_detection[tests/UTF-16LE/plane1-utf-16le.html-utf-16le]
FAILED test.py::test_encoding_detection[tests/iso-2022-jp/_ude_1.txt-iso-2022-jp]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.4.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/ecloga.cult.bg.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/linux-bg.org.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/rinennor.org.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/ide.li.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.news.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.2.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.3.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/informator.org.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.9.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.comments.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/bbc.co.uk.popshow.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.medusa.4.xml-windows-1251]
FAILED test.py::test_encoding_detection[tests/EUC-KR/willis.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/xenix.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/ittrend.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/zangsalang.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/_ude_euc1.txt-euc-kr] - ...
FAILED test.py::test_encoding_detection[tests/EUC-KR/lennon81.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/sparcs.kaist.ac.kr.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/poliplus.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/blog.rss.naver.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/blog.empas.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/birder.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/blog.bd-lab.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/_chromium_windows-949_with_no_encoding_specified.html-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/oroll.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/console.linuxstudy.pe.kr.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/alogblog.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/_mozilla_bug9357_text.html-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/epitaph.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/arts.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/acnnewswire.net.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/_ude_euc2.txt-euc-kr] - ...
FAILED test.py::test_encoding_detection[tests/EUC-KR/chisato.info.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/tori02.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/critique.or.kr.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/siwoo.org.xml-euc-kr] - ...
FAILED test.py::test_encoding_detection[tests/EUC-KR/jely.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/yunho.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/calmguy.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/jely.pe.kr.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/jowchung.oolim.net.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/kina.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/EUC-KR/scarletkh2.egloos.com.xml-euc-kr]
FAILED test.py::test_encoding_detection[tests/KOI8-R/susu.ac.ru.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/_ude_1.txt-koi8-r] - Att...
FAILED test.py::test_encoding_detection[tests/KOI8-R/kapranoff.ru.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/newsru.com.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/music.peeps.ru.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/aviaport.ru.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.6.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/janulalife.blogspot.com.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/_chromium_KOI8-R_with_no_encoding_specified.html-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/aif.ru.health.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/intertat.ru.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.9.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/aug32.hole.ru.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/blog.mlmaster.com.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/koi.kinder.ru.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/greek.ru.xml-koi8-r] - A...
FAILED test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.1.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.4.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/money.rin.ru.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.8.xml-koi8-r]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he3.txt-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/halemo.net.edoar.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.8.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/hydepark.hevre.co.il.7957.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/exego.net.2.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/maakav.org.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/neviim.net.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/infomed.co.il.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/_chromium_ISO-8859-8_with_no_encoding_specified.html-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/whatsup.org.il.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/hagada.org.il.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he2.txt-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/sharks.co.il.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.7.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/pcplus.co.il.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.50.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.6.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/hevra.org.il.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/law.co.il.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he1.txt-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/info.org.il.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/_chromium_windows-1255_with_no_encoding_specified.html-windows-1255]
FAILED test.py::test_encoding_detection[tests/windows-1255-hebrew/carshops.co.il.xml-windows-1255]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.wld.xml-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.fin.xml-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrt.xml-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.cmm.xml-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.bus.xml-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_2.txt-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.spo.xml-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/_chromium_ISO-8859-7_with_no_encoding_specified.html-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrk.xml-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_greek.txt-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_3.txt-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/hotstation.gr.xml-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_1.txt-iso-8859-7]
FAILED test.py::test_encoding_detection[tests/UTF-16/bom-utf-16-be.srt-utf-16]
FAILED test.py::test_encoding_detection[tests/UTF-16/bom-utf-16-le.srt-utf-16]
FAILED test.py::test_encoding_detection[tests/CP949/ricanet.com.xml-cp949] - ...
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/music.peeps.ru.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/intertat.ru.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/aviaport.ru.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.1.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.4.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/aug32.hole.ru.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/janulalife.blogspot.com.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/money.rin.ru.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/_chromium_ISO-8859-5_with_no_encoding_specified.html-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.8.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/greek.ru.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/susu.ac.ru.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.6.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/aif.ru.health.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.9.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/kapranoff.ru.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/blog.mlmaster.com.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-russian/newsru.com.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.analyse1.xml-tis-620]
FAILED test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.healthinfo-ne.xml-tis-620]
FAILED test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.centerlab.xml-tis-620]
FAILED test.py::test_encoding_detection[tests/TIS-620/opentle.org.xml-tis-620]
FAILED test.py::test_encoding_detection[tests/TIS-620/trickspot.boxchart.com.xml-tis-620]
FAILED test.py::test_encoding_detection[tests/TIS-620/_mozilla_bug488426_text.html-tis-620]
FAILED test.py::test_encoding_detection[tests/utf-8/anitabee.blogspot.com.xml-utf-8]
FAILED test.py::test_encoding_detection[tests/utf-8/_ude_2.txt-utf-8] - Attri...
FAILED test.py::test_encoding_detection[tests/utf-8/_chromium_UTF-8_with_no_encoding_specified.html-utf-8]
FAILED test.py::test_encoding_detection[tests/utf-8/_ude_3.txt-utf-8] - Attri...
FAILED test.py::test_encoding_detection[tests/utf-8/weblabor.hu.2.xml-utf-8]
FAILED test.py::test_encoding_detection[tests/utf-8/balatonblog.typepad.com.xml-utf-8]
FAILED test.py::test_encoding_detection[tests/utf-8/_ude_he3.txt-utf-8] - Att...
FAILED test.py::test_encoding_detection[tests/utf-8/_ude_5.txt-utf-8] - Attri...
FAILED test.py::test_encoding_detection[tests/utf-8/_ude_greek.txt-utf-8] - A...
FAILED test.py::test_encoding_detection[tests/utf-8/_ude_he2.txt-utf-8] - Att...
FAILED test.py::test_encoding_detection[tests/utf-8/linuxbox.hu.xml-utf-8] - ...
FAILED test.py::test_encoding_detection[tests/utf-8/_ude_russian.txt-utf-8]
FAILED test.py::test_encoding_detection[tests/utf-8/pihgy.hu.xml-utf-8] - Att...
FAILED test.py::test_encoding_detection[tests/utf-8/weblabor.hu.xml-utf-8] - ...
FAILED test.py::test_encoding_detection[tests/utf-8/_mozilla_bug426271_text-utf-8.html-utf-8]
FAILED test.py::test_encoding_detection[tests/utf-8/boobooo.blogspot.com.xml-utf-8]
FAILED test.py::test_encoding_detection[tests/utf-8/_ude_1.txt-utf-8] - Attri...
FAILED test.py::test_encoding_detection[tests/utf-8/_mozilla_bug306272_text.html-utf-8]
FAILED test.py::test_encoding_detection[tests/utf-8/_ude_he1.txt-utf-8] - Att...
FAILED test.py::test_encoding_detection[tests/UTF-32/bom-utf-32-be.srt-utf-32]
FAILED test.py::test_encoding_detection[tests/UTF-32/bom-utf-32-le.srt-utf-32]
FAILED test.py::test_encoding_detection[tests/iso-8859-1/_ude_2.txt-iso-8859-1]
FAILED test.py::test_encoding_detection[tests/iso-8859-1/_ude_1.txt-iso-8859-1]
FAILED test.py::test_encoding_detection[tests/iso-8859-1/_ude_4.txt-iso-8859-1]
FAILED test.py::test_encoding_detection[tests/iso-8859-1/_ude_6.txt-iso-8859-1]
FAILED test.py::test_encoding_detection[tests/iso-8859-1/_ude_5.txt-iso-8859-1]
FAILED test.py::test_encoding_detection[tests/iso-8859-1/_ude_3.txt-iso-8859-1]
FAILED test.py::test_encoding_detection[tests/Johab/iyagi-readme.txt-johab]
FAILED test.py::test_encoding_detection[tests/Johab/hlpro-readme.txt-johab]
FAILED test.py::test_encoding_detection[tests/Johab/mdir-doc.txt-johab] - Att...
FAILED test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.6.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/_ude_1.txt-ibm855] - Att...
FAILED test.py::test_encoding_detection[tests/IBM855/blog.mlmaster.com.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.1.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.9.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.8.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.4.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/kapranoff.ru.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/janulalife.blogspot.com.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/aviaport.ru.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/aif.ru.health.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/newsru.com.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/greek.ru.xml-ibm855] - A...
FAILED test.py::test_encoding_detection[tests/IBM855/music.peeps.ru.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/aug32.hole.ru.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/intertat.ru.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/money.rin.ru.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/IBM855/susu.ac.ru.xml-ibm855]
FAILED test.py::test_encoding_detection[tests/utf-8-sig/bom-utf-8.srt-utf-8-sig]
FAILED test.py::test_encoding_detection[tests/utf-8-sig/_ude_4.txt-utf-8-sig]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/doncho.net.comments.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/ide.li.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.9.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/ecloga.cult.bg.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.news.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/aero-bg.com.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.4.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/linux-bg.org.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.medusa.4.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.2.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bbc.co.uk.popshow.xml-iso-8859-5]
FAILED test.py::test_encoding_detection[tests/ascii/_mozilla_bug638318_text.html-ascii]
FAILED test.py::test_encoding_detection[tests/ascii/howto.diveintomark.org.xml-ascii]
FAILED test.py::test_encoding_detection[tests/ascii/_chromium_iso-8859-1_with_no_encoding_specified.html-ascii]
FAILED test.py::test_encoding_detection[tests/iso-2022-kr/_ude_iso1.txt-iso-2022-kr]
FAILED test.py::test_encoding_detection[tests/iso-2022-kr/_ude_iso2.txt-iso-2022-kr]
FAILED test.py::test_encoding_detection[tests/UTF-32LE/nobom-utf32le.txt-utf-32le]
FAILED test.py::test_encoding_detection[tests/UTF-32LE/plane1-utf-32le.html-utf-32le]
FAILED test.py::test_encoding_detection[tests/EUC-JP/overcube.com.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug620106_text.html-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/rdf.ycf.nanet.co.jp.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/_ude_1.txt-euc-jp] - Att...
FAILED test.py::test_encoding_detection[tests/EUC-JP/tls.org.xml-euc-jp] - At...
FAILED test.py::test_encoding_detection[tests/EUC-JP/aivy.co.jp.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/yukiboh.moo.jp.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/bphrs.net.xml-euc-jp] - ...
FAILED test.py::test_encoding_detection[tests/EUC-JP/misuzilla.org.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/aristrist.s57.xrea.com.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug431054_text.html-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug426271_text-euc-jp.html-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/club.h14m.org.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/siesta.co.jp.aozora.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/ch.kitaguni.tv.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/contents-factory.com.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.atom.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/atom.ycf.nanet.co.jp.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/arclamp.jp.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/furusatonoeki.cutegirl.jp.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/pinkupa.com.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/artifact-jp.com.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/azoz.org.xml-euc-jp] - A...
FAILED test.py::test_encoding_detection[tests/EUC-JP/akaname.main.jp.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/mimizun.com.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/manana.moo.jp.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/azito.under.jp.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/EUC-JP/overcube.com.atom.xml-euc-jp]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_1.txt-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/accessories-brand.com.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/setsuzei119.jp.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/dogsinn.jp.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/nextbeaut.com.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/ooganemochi.com.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_2.txt-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/clickablewords.com.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/bloglelife.com.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/perth-on.net.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.money.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/tamuyou.haun.org.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_4.txt-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/blog.inkase.net.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/_chromium_Shift-JIS_with_no_encoding_specified.html-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/sakusaka-silk.net.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/yasuhisa.com.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.inami.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_3.txt-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/amefoot.net.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/10e.org.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/grebeweb.net.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/blog.paseri.ne.jp.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/1affliate.com.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/do.beginnersrack.com.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/celeb.lalalu.com.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/milliontimes.jp.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/moon-light.ne.jp.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/SHIFT_JIS/brag.zaka.to.xml-shift_jis]
FAILED test.py::test_encoding_detection[tests/CP932/y-moto.com.xml-cp932] - A...
FAILED test.py::test_encoding_detection[tests/CP932/hardsoft.at.webry.info.xml-cp932]
FAILED test.py::test_encoding_detection[tests/CP932/www2.chuo-u.ac.jp-suishin.xml-cp932]
FAILED test.py::test_detect_all_and_detect_one_should_agree - UnboundLocalErr...
=================== 375 failed, 1 passed, 7 xfailed in 6.68s ===================
