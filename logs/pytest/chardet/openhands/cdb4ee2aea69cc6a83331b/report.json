{"created": 1732308243.810768, "duration": 6.50848650932312, "exitcode": 1, "root": "/testbed", "environment": {}, "summary": {"failed": 375, "xfailed": 7, "passed": 1, "total": 383, "collected": 383}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": ".", "type": "Dir"}]}, {"nodeid": "test.py", "outcome": "passed", "result": [{"nodeid": "test.py::test_encoding_detection[tests/windows-1252/_ude_2.txt-windows-1252]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1252/github_bug_9.txt-windows-1252]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1252/_mozilla_bug421271_text.html-windows-1252]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1252/_ude_1.txt-windows-1252]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32BE/plane1-utf-32be.html-utf-32be]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32BE/nobom-utf32be.txt-utf-32be]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16BE/plane1-utf-16be.html-utf-16be]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16BE/nobom-utf16be.txt-utf-16be]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.9.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/_chromium_windows-1251_with_no_encoding_specified.html-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/_ude_1.txt-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/aviaport.ru.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.8.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/money.rin.ru.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/anthropology.ru.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/music.peeps.ru.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/aif.ru.health.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.6.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/newsru.com.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/blog.mlmaster.com.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/aug32.hole.ru.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.4.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/janulalife.blogspot.com.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/intertat.ru.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/greek.ru.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.1.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/kapranoff.ru.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/softsea.net.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/chen56.blogcn.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/pda.blogsome.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/luciferwang.blogcn.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/bbs.blogsome.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/cindychen.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/_chromium_gb18030_with_no_encoding_specified.html.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/14.blog.westca.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/_mozilla_bug171813_text.html-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/xy15400.blogcn.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/lily.blogsome.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/w3cn.org.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/jjgod.3322.org.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/coverer.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/godthink.blogsome.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/acnnewswire.net.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/eighthday.blogspot.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/cappuccinos.3322.org.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/2.blog.westca.com.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/cnblog.org.xml-gb2312]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/music.peeps.ru.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.4.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/koi.kinder.ru.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/_ude_1.txt-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/aviaport.ru.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/intertat.ru.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/aug32.hole.ru.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.8.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/aif.ru.health.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/blog.mlmaster.com.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/money.rin.ru.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/newsru.com.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/greek.ru.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/susu.ac.ru.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/kapranoff.ru.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.6.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.9.xml-maccyrillic]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/greek.ru.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/_ude_1.txt-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/aviaport.ru.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/aug32.hole.ru.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/kapranoff.ru.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/music.peeps.ru.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.4.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.8.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/blog.mlmaster.com.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/money.rin.ru.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/janulalife.blogspot.com.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/intertat.ru.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.9.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/susu.ac.ru.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/newsru.com.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.6.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/aif.ru.health.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.1.xml-ibm866]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/myblog.pchome.com.tw.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/blog.worren.net.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/marilynwu.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/coolloud.org.tw.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/ebao.us.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/_ude_1.txt-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/upsaid.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/leavesth.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/oui-design.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/kafkatseng.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/_chromium_Big5_with_no_encoding_specified.html-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/sinica.edu.tw.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/ke207.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/linyijen.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/tlkkuo.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/carbonxiv.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/0804.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/willythecop.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/sylvia1976.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/fudesign.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/digitalwall.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/catshadow.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/sanwenji.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/letterlego.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/unoriginalblog.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/ytc.blogspot.com.xml-big5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16LE/nobom-utf16le.txt-utf-16le]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16LE/plane1-utf-16le.html-utf-16le]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-2022-jp/_ude_1.txt-iso-2022-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.4.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/ecloga.cult.bg.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/linux-bg.org.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/rinennor.org.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/ide.li.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.news.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.2.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.3.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/informator.org.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.9.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.comments.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bbc.co.uk.popshow.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.medusa.4.xml-windows-1251]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/willis.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/xenix.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/ittrend.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/zangsalang.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/_ude_euc1.txt-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/lennon81.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/sparcs.kaist.ac.kr.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/poliplus.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/blog.rss.naver.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/blog.empas.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/birder.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/blog.bd-lab.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/_chromium_windows-949_with_no_encoding_specified.html-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/oroll.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/console.linuxstudy.pe.kr.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/alogblog.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/_mozilla_bug9357_text.html-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/epitaph.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/arts.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/acnnewswire.net.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/_ude_euc2.txt-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/chisato.info.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/tori02.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/critique.or.kr.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/siwoo.org.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/jely.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/yunho.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/calmguy.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/jely.pe.kr.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/jowchung.oolim.net.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/kina.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/scarletkh2.egloos.com.xml-euc-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/susu.ac.ru.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/_ude_1.txt-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/kapranoff.ru.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/newsru.com.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/music.peeps.ru.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/aviaport.ru.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.6.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/janulalife.blogspot.com.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/_chromium_KOI8-R_with_no_encoding_specified.html-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/aif.ru.health.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/intertat.ru.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.9.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/aug32.hole.ru.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/blog.mlmaster.com.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/koi.kinder.ru.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/greek.ru.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.1.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.4.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/money.rin.ru.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.8.xml-koi8-r]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he3.txt-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/halemo.net.edoar.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.8.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/hydepark.hevre.co.il.7957.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/exego.net.2.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/maakav.org.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/neviim.net.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/infomed.co.il.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/_chromium_ISO-8859-8_with_no_encoding_specified.html-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/whatsup.org.il.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/hagada.org.il.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he2.txt-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/sharks.co.il.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.7.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/pcplus.co.il.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.50.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.6.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/hevra.org.il.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/law.co.il.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he1.txt-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/info.org.il.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/_chromium_windows-1255_with_no_encoding_specified.html-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/carshops.co.il.xml-windows-1255]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.wld.xml-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/disabled.gr.xml-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.fin.xml-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrt.xml-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.cmm.xml-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.bus.xml-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_2.txt-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.spo.xml-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/_chromium_ISO-8859-7_with_no_encoding_specified.html-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrk.xml-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_greek.txt-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_3.txt-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/hotstation.gr.xml-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_1.txt-iso-8859-7]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16/bom-utf-16-be.srt-utf-16]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16/bom-utf-16-le.srt-utf-16]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/CP949/ricanet.com.xml-cp949]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/music.peeps.ru.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/intertat.ru.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/aviaport.ru.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.1.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.4.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/aug32.hole.ru.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/janulalife.blogspot.com.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/money.rin.ru.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/_chromium_ISO-8859-5_with_no_encoding_specified.html-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.8.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/greek.ru.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/susu.ac.ru.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.6.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/aif.ru.health.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.9.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/kapranoff.ru.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/blog.mlmaster.com.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/newsru.com.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.analyse1.xml-tis-620]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.healthinfo-ne.xml-tis-620]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.centerlab.xml-tis-620]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/opentle.org.xml-tis-620]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/trickspot.boxchart.com.xml-tis-620]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/_mozilla_bug488426_text.html-tis-620]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-TW/_ude_euc-tw1.txt-euc-tw]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/anitabee.blogspot.com.xml-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_2.txt-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_chromium_UTF-8_with_no_encoding_specified.html-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_3.txt-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/weblabor.hu.2.xml-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/balatonblog.typepad.com.xml-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_he3.txt-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_5.txt-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_greek.txt-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_he2.txt-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/linuxbox.hu.xml-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_russian.txt-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/pihgy.hu.xml-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/weblabor.hu.xml-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_mozilla_bug426271_text-utf-8.html-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/boobooo.blogspot.com.xml-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_1.txt-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_mozilla_bug306272_text.html-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_he1.txt-utf-8]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32/bom-utf-32-be.srt-utf-32]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32/bom-utf-32-le.srt-utf-32]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_2.txt-iso-8859-1]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_1.txt-iso-8859-1]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_4.txt-iso-8859-1]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_6.txt-iso-8859-1]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_5.txt-iso-8859-1]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_3.txt-iso-8859-1]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Johab/iyagi-readme.txt-johab]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Johab/hlpro-readme.txt-johab]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/Johab/mdir-doc.txt-johab]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.6.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/_ude_1.txt-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/blog.mlmaster.com.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.1.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.9.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.8.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.4.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/kapranoff.ru.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/janulalife.blogspot.com.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/aviaport.ru.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/aif.ru.health.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/newsru.com.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/greek.ru.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/music.peeps.ru.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/aug32.hole.ru.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/intertat.ru.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/money.rin.ru.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/susu.ac.ru.xml-ibm855]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8-sig/bom-utf-8.srt-utf-8-sig]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8-sig/_ude_4.txt-utf-8-sig]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/doncho.net.comments.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/ide.li.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.9.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/ecloga.cult.bg.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.news.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/aero-bg.com.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.4.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/linux-bg.org.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.medusa.4.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.2.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bbc.co.uk.popshow.xml-iso-8859-5]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/ascii/_mozilla_bug638318_text.html-ascii]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/ascii/howto.diveintomark.org.xml-ascii]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/ascii/_chromium_iso-8859-1_with_no_encoding_specified.html-ascii]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-2022-kr/_ude_iso1.txt-iso-2022-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-2022-kr/_ude_iso2.txt-iso-2022-kr]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32LE/nobom-utf32le.txt-utf-32le]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32LE/plane1-utf-32le.html-utf-32le]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-9-turkish/wikitop_tr_ISO-8859-9.txt-iso-8859-9]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-9-turkish/_ude_1.txt-iso-8859-9]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-9-turkish/_ude_2.txt-iso-8859-9]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-9-turkish/subtitle.srt-iso-8859-9]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-9-turkish/divxplanet.com.xml-iso-8859-9]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/overcube.com.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug620106_text.html-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/rdf.ycf.nanet.co.jp.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/_ude_1.txt-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/tls.org.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/aivy.co.jp.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/yukiboh.moo.jp.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/bphrs.net.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/misuzilla.org.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/aristrist.s57.xrea.com.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug431054_text.html-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug426271_text-euc-jp.html-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/club.h14m.org.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/siesta.co.jp.aozora.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/ch.kitaguni.tv.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/contents-factory.com.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.atom.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/atom.ycf.nanet.co.jp.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/arclamp.jp.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/furusatonoeki.cutegirl.jp.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/pinkupa.com.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/artifact-jp.com.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/azoz.org.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/akaname.main.jp.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/mimizun.com.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/manana.moo.jp.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/azito.under.jp.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/overcube.com.atom.xml-euc-jp]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_1.txt-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/accessories-brand.com.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/setsuzei119.jp.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/dogsinn.jp.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/nextbeaut.com.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/ooganemochi.com.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_2.txt-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/clickablewords.com.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/bloglelife.com.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/perth-on.net.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.money.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/tamuyou.haun.org.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_4.txt-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/blog.inkase.net.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/_chromium_Shift-JIS_with_no_encoding_specified.html-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/sakusaka-silk.net.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/yasuhisa.com.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.inami.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_3.txt-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/amefoot.net.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/10e.org.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/grebeweb.net.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/blog.paseri.ne.jp.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/1affliate.com.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/do.beginnersrack.com.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/celeb.lalalu.com.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/milliontimes.jp.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/moon-light.ne.jp.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/brag.zaka.to.xml-shift_jis]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/CP932/y-moto.com.xml-cp932]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/CP932/hardsoft.at.webry.info.xml-cp932]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_encoding_detection[tests/CP932/www2.chuo-u.ac.jp-suishin.xml-cp932]", "type": "Function", "lineno": 75}, {"nodeid": "test.py::test_never_fails_to_detect_if_there_is_a_valid_encoding", "type": "Function", "lineno": 121}, {"nodeid": "test.py::test_detect_all_and_detect_one_should_agree", "type": "Function", "lineno": 158}]}, {"nodeid": "test_output.txt", "outcome": "passed", "result": []}, {"nodeid": ".", "outcome": "passed", "result": [{"nodeid": "test.py", "type": "Module"}, {"nodeid": "test_output.txt", "type": "DoctestTextfile"}]}], "tests": [{"nodeid": "test.py::test_encoding_detection[tests/windows-1252/_ude_2.txt-windows-1252]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1252/_ude_2.txt-windows-1252]", "parametrize", "pytestmark", "tests/windows-1252/_ude_2.txt-windows-1252", "test.py", "testbed", ""], "setup": {"duration": 0.00032832700000007264, "outcome": "passed"}, "call": {"duration": 0.00213324799999981, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1252/_ude_2.txt', encoding = 'windows-1252'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'Stipan Arkadiewitsch was tegenover zich zelf tamelijk oprecht. Hij kon niet liegen en zich zelf verzekeren...t: Leef zoo, dat gij elken dag zijn recht geeft, tracht u zelf te vergeten en te bedwelmen in den droom des levens.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0002089549999997331, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1252/github_bug_9.txt-windows-1252]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1252/github_bug_9.txt-windows-1252]", "parametrize", "pytestmark", "tests/windows-1252/github_bug_9.txt-windows-1252", "test.py", "testbed", ""], "setup": {"duration": 0.00021335200000027754, "outcome": "passed"}, "call": {"duration": 0.0004198499999996663, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1252/github_bug_9.txt', encoding = 'windows-1252'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'Then he said, \\x93The names Bod, James Bond.\\x94\\nto be \\x93me\\x94\\nSpam, beans, spam \\x96 served every day\\nbeans, spam, beans, \\x97 served every other day\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017691700000010968, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1252/_mozilla_bug421271_text.html-windows-1252]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1252/_mozilla_bug421271_text.html-windows-1252]", "parametrize", "pytestmark", "tests/windows-1252/_mozilla_bug421271_text.html-windows-1252", "test.py", "testbed", ""], "setup": {"duration": 0.00019194100000019532, "outcome": "passed"}, "call": {"duration": 0.000495872999999758, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1252/_mozilla_bug421271_text.html'\nencoding = 'windows-1252'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-tra...ways<br>Doncaster/Stranraer/Rushden &amp; Diamonds<br>and 50p on all nine results.<br>GET IN THERE.</p></body></html>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017903300000021716, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1252/_ude_1.txt-windows-1252]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1252/_ude_1.txt-windows-1252]", "parametrize", "pytestmark", "tests/windows-1252/_ude_1.txt-windows-1252", "test.py", "testbed", ""], "setup": {"duration": 0.00018978500000033094, "outcome": "passed"}, "call": {"duration": 0.0005444099999998286, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1252/_ude_1.txt', encoding = 'windows-1252'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'Die Deutsche Schule geh\\xf6rt zum Netzwerk der mehr als 140 Deutschen Auslandsschulen, die von der Zentral...entralstelle f\\xfcr Auslandsschulwesen gef\\xf6rdert.\\nKurz gefasst 10\\x80. Weltkarte Deutsche Schulen international\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016729899999967657, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32BE/plane1-utf-32be.html-utf-32be]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-32BE/plane1-utf-32be.html-utf-32be]", "parametrize", "pytestmark", "tests/UTF-32BE/plane1-utf-32be.html-utf-32be", "test.py", "testbed", ""], "setup": {"duration": 0.00019772100000015058, "outcome": "passed"}, "call": {"duration": 0.0026999720000002725, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-32BE/plane1-utf-32be.html', encoding = 'utf-32be'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\x00\\x00\\x00<\\x00\\x00\\x00!\\x00\\x00\\x00D\\x00\\x00\\x00O\\x00\\x00\\x00C\\x00\\x00\\x00T\\x00\\x00\\x00Y\\x00\\x00\\x00P\\x...00\\x00\\x00<\\x00\\x00\\x00/\\x00\\x00\\x00h\\x00\\x00\\x00t\\x00\\x00\\x00m\\x00\\x00\\x00l\\x00\\x00\\x00>\\x00\\x00\\x00\\r\\x00\\x00\\x00\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001673380000002389, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32BE/nobom-utf32be.txt-utf-32be]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-32BE/nobom-utf32be.txt-utf-32be]", "parametrize", "pytestmark", "tests/UTF-32BE/nobom-utf32be.txt-utf-32be", "test.py", "testbed", ""], "setup": {"duration": 0.00019762400000011837, "outcome": "passed"}, "call": {"duration": 0.00041329799999978434, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-32BE/nobom-utf32be.txt', encoding = 'utf-32be'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\x00\\x00\\x00D\\x00\\x00\\x00a\\x00\\x00\\x00t\\x00\\x00\\x00e\\x00\\x00\\x00T\\x00\\x00\\x00i\\x00\\x00\\x00m\\x00\\x00\\x00e\\x...00\\x00\\x001\\x00\\x00\\x00.\\x00\\x00\\x000\\x00\\x00\\x008\\x00\\x00\\x003\\x00\\x00\\x005\\x00\\x00\\x003\\x00\\x00\\x00\\r\\x00\\x00\\x00\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001691569999997533, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16BE/plane1-utf-16be.html-utf-16be]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-16BE/plane1-utf-16be.html-utf-16be]", "parametrize", "pytestmark", "tests/UTF-16BE/plane1-utf-16be.html-utf-16be", "test.py", "testbed", ""], "setup": {"duration": 0.00018584999999982088, "outcome": "passed"}, "call": {"duration": 0.002700150999999984, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-16BE/plane1-utf-16be.html', encoding = 'utf-16be'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\x00<\\x00!\\x00D\\x00O\\x00C\\x00T\\x00Y\\x00P\\x00E\\x00 \\x00H\\x00T\\x00M\\x00L\\x00 \\x00P\\x00U\\x00B\\x00L\\x00I\\x00C\\...0\\x002\\x00-\\x002\\x004\\x00.\\x00\\r\\x00\\n\\x00<\\x00/\\x00p\\x00>\\x00\\r\\x00\\n\\x00<\\x00/\\x00h\\x00t\\x00m\\x00l\\x00>\\x00\\r\\x00\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017238999999991123, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16BE/nobom-utf16be.txt-utf-16be]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-16BE/nobom-utf16be.txt-utf-16be]", "parametrize", "pytestmark", "tests/UTF-16BE/nobom-utf16be.txt-utf-16be", "test.py", "testbed", ""], "setup": {"duration": 0.00019480199999977188, "outcome": "passed"}, "call": {"duration": 0.000435872999999809, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-16BE/nobom-utf16be.txt', encoding = 'utf-16be'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\x00D\\x00a\\x00t\\x00e\\x00T\\x00i\\x00m\\x00e\\x00,\\x00B\\x00i\\x00d\\x00,\\x00A\\x00s\\x00k\\x00\\r\\x00\\n\\x000\\x007\\x00...\\x000\\x00.\\x003\\x001\\x009\\x00,\\x001\\x00.\\x000\\x008\\x003\\x000\\x007\\x00,\\x001\\x00.\\x000\\x008\\x003\\x005\\x003\\x00\\r\\x00\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017053399999999996, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.9.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.9.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/forum.template-toolkit.ru.9.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018427999999959255, "outcome": "passed"}, "call": {"duration": 0.0022486060000002084, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/forum.template-toolkit.ru.9.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_9....9.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018509600000005122, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/_chromium_windows-1251_with_no_encoding_specified.html-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/_chromium_windows-1251_with_no_encoding_specified.html-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/_chromium_windows-1251_with_no_encoding_specified.html-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019079100000007898, "outcome": "passed"}, "call": {"duration": 0.0004912739999998195, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/_chromium_windows-1251_with_no_encoding_specified.html'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html>\\n <head>\\n  <title> windows-1251 </title>\\n </head>\\n\\n <body>\\n  \\xcc\\xce\\xd1\\xca\\xc2\\xc0, 9 \\xff\\...\\xee \\xef\\xf0\\xe5\\xf0\\xe2\\xe0\\xed\\xed\\xfb\\xe5 \\xe4\\xe2\\xe0 \\xe4\\xed\\xff \\xed\\xe0\\xe7\\xe0\\xe4 ...\\n </body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016870199999985402, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/_ude_1.txt-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/_ude_1.txt-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/_ude_1.txt-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.0001885690000000828, "outcome": "passed"}, "call": {"duration": 0.0006451369999997958, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/_ude_1.txt', encoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xc2 \\xe3\\xe8\\xec\\xed\\xe0\\xe7\\xe8\\xe8 \\xee\\xed \\xed\\xe5 \\xe1\\xfb\\xeb \\xe2 \\xf7\\xe8\\xf1\\xeb\\xe5 \\xef\\xe5\\xf...xf2\\xf2\\xe5\\xf1\\xf2\\xe0\\xf2 \\xe8 \\xef\\xee\\xe2\\xf2\\xee\\xf0\\xe8\\xf2\\xfc \\xef\\xee\\xf1\\xf2\\xf3\\xef\\xeb\\xe5\\xed\\xe8\\xe5.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016794099999994927, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/aviaport.ru.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/aviaport.ru.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/aviaport.ru.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019136899999994128, "outcome": "passed"}, "call": {"duration": 0.01569095900000006, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/aviaport.ru.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://www.aviaport.ru/news/yandex_export.xml...d\\xed\\xee\\xe9 \\xf1\\xf2\\xf0\\xe0\\xf5\\xee\\xe2\\xea\\xe8.\\n\\t\\t\\t</yandex:full-text>\\n\\t\\t</item>\\n\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016837800000013559, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.8.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.8.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/forum.template-toolkit.ru.8.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019947799999986415, "outcome": "passed"}, "call": {"duration": 0.004672081999999911, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/forum.template-toolkit.ru.8.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_8....8.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016664699999990873, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/money.rin.ru.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/money.rin.ru.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/money.rin.ru.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019665999999984862, "outcome": "passed"}, "call": {"duration": 0.002185684999999715, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/money.rin.ru.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://money.rin.ru/news/rss/\\nExpect: window...  (N 1080 \\xee\\xf2 17 \\xed\\xee\\xff\\xe1\\xf0\\xff 2005 \\xe3\\xee\\xe4\\xe0).</description>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001809049999996759, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/anthropology.ru.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/anthropology.ru.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/anthropology.ru.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018878699999991255, "outcome": "passed"}, "call": {"duration": 0.002740715999999921, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/anthropology.ru.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Windows-1251\"?>\\n<!--\\nSource: http://anthropology.ru/ru/rss20.xml\\nExpect: ...4\\xe8\\xe8 \\xea\\xf3\\xeb\\xfc\\xf2\\xf3\\xf0\\xfb\\xbb</a></strong>]]></description>\\n\\t\\t</item>\\n\\n\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017846900000018096, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/music.peeps.ru.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/music.peeps.ru.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/music.peeps.ru.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018397299999994843, "outcome": "passed"}, "call": {"duration": 0.002254572999999649, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/music.peeps.ru.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://music.peeps.ru/news/action_rss.xml\\nEx...\\xe4\\xed\\xfb\\xf5 \\xef\\xe0\\xed\\xea-\\xe3\\xf0\\xf3\\xef\\xef 90-\\xf5. </description>\\n\\t\\t</item>\\n\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017178200000023125, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/aif.ru.health.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/aif.ru.health.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/aif.ru.health.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018426900000001467, "outcome": "passed"}, "call": {"duration": 0.0023300090000000218, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/aif.ru.health.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://www.aif.ru/info/rss.php?magazine=healt...f0\\xe0\\xeb\\xfc\\xed\\xfb\\xf5 \\xef\\xf0\\xee\\xe4\\xf3\\xea\\xf2\\xee\\xe2.\\t\\t</description>\\n\\t</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018119900000002076, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.6.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.6.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/forum.template-toolkit.ru.6.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.000188969999999955, "outcome": "passed"}, "call": {"duration": 0.007887812999999966, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/forum.template-toolkit.ru.6.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_6....6.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017128100000007862, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/newsru.com.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/newsru.com.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/newsru.com.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018897499999992462, "outcome": "passed"}, "call": {"duration": 0.0058674600000001575, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/newsru.com.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://www.newsru.com/plain/rss/all.xml\\nExpe...=\"http://www.newsru.com/pict/id/large/819577_20060103092327.gif\" type=\"image/jpeg\"/>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017804400000009935, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/blog.mlmaster.com.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/blog.mlmaster.com.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/blog.mlmaster.com.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.0001943050000003943, "outcome": "passed"}, "call": {"duration": 0.0018851010000000556, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/blog.mlmaster.com.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://blog.mlmaster.com/wp-rss2.php\\nExpect:...\\t\\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018542899999962614, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/aug32.hole.ru.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/aug32.hole.ru.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/aug32.hole.ru.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019155999999975748, "outcome": "passed"}, "call": {"duration": 0.000576509999999697, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/aug32.hole.ru.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://aug32.hole.ru/afisha/feed.php\\nExpect:...&gt;</description>\\n          <link>http://aug32.hole.ru/afisha.htm</link>\\n        </item>\\n    </channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016985099999988762, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.4.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.4.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/forum.template-toolkit.ru.4.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018662599999963447, "outcome": "passed"}, "call": {"duration": 0.002855803000000101, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/forum.template-toolkit.ru.4.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_4....-4.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001680150000002989, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/janulalife.blogspot.com.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/janulalife.blogspot.com.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/janulalife.blogspot.com.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018572700000030196, "outcome": "passed"}, "call": {"duration": 0.0048071130000000295, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/janulalife.blogspot.com.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger....\\xee\\xe8.\\n<br/>\\n</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017550000000010613, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/intertat.ru.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/intertat.ru.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/intertat.ru.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018146300000010385, "outcome": "passed"}, "call": {"duration": 0.00047778699999989627, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/intertat.ru.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://intertat.ru/myyandex.php\\nExpect: wind...\\xe8\\xe4\\xe5\\xf2\\xe5\\xeb\\xfc\\xf1\\xf2\\xe2\\xee \\xee \\xf0\\xe5\\xe3\\xe8\\xf1\\xf2\\xf0\\xe0\\xf6\\xe8\\xe8 \\xd1\\xcc\\xc8 \\xdd\\xeb ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016505000000011094, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/greek.ru.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/greek.ru.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/greek.ru.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.0001928749999997592, "outcome": "passed"}, "call": {"duration": 0.0007853600000000682, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/greek.ru.xml', encoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://www.greek.ru/news/ya/yagreek\\nExpect: ...e8. \\xd0\\xee\\xe2\\xed\\xee 29 \\xeb\\xe5\\xf2 \\xed\\xe0\\xe7\\xe0\\xe4 \\xe2 \\xf5\\xee\\xe4\\xe5 \\xee\\xef\\xe5\\xf0\\xe0\\xf6\\xe8\\xe8 ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016796699999988007, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.1.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/forum.template-toolkit.ru.1.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/forum.template-toolkit.ru.1.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019187399999998078, "outcome": "passed"}, "call": {"duration": 0.006194360999999926, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/forum.template-toolkit.ru.1.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_1....1.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-93.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017726799999984166, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-russian/kapranoff.ru.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-russian/kapranoff.ru.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-russian/kapranoff.ru.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018187299999983253, "outcome": "passed"}, "call": {"duration": 0.002005972000000078, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-russian/kapranoff.ru.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://kapranoff.ru/index.rdf\\nExpect: window...dc:subject/>\\n<dc:creator>kappa</dc:creator>\\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001676590000001532, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/softsea.net.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/softsea.net.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/softsea.net.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00019334800000025965, "outcome": "passed"}, "call": {"duration": 0.019122668999999703, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/softsea.net.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\"?>\\n<!--\\nSource: http://www.softsea.net/rss/3.xml > softsea.net.xml\\...w.softsea.net/soft/108440.htm</guid>\\n<pubDate>Mon, 19 Dec 2005 16:00:00 GMT</pubDate>\\n</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016827799999985515, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/chen56.blogcn.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/chen56.blogcn.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/chen56.blogcn.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.0001827549999999789, "outcome": "passed"}, "call": {"duration": 0.003065279999999948, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/chen56.blogcn.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\"  encoding=\"gb2312\" ?>\\n<!--\\nSource: http://www.blogcn.com/rss.asp?uid=chen56\\nExpect:...ckback.asp?mydiary=285759 target=_blank>\\xd2\\xfd\\xd3\\xc3\\xb4\\xcb\\xce\\xc4</a>)]]>    </description>  </item></rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017230600000006646, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/pda.blogsome.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/pda.blogsome.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/pda.blogsome.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00018376299999989243, "outcome": "passed"}, "call": {"duration": 0.001168469999999644, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/pda.blogsome.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\"?><!-- generator=\"wordpress/1.5.1-alpha\" -->\\n<!--\\nSource: http://pd...description>\\n\\t\\t<link>http://pda.blogsome.com/2004/12/29/e-tencdhaieoum500/</link>\\n\\t</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017922400000003336, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/luciferwang.blogcn.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/luciferwang.blogcn.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/luciferwang.blogcn.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00018472600000007944, "outcome": "passed"}, "call": {"duration": 0.0038266679999998665, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/luciferwang.blogcn.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\"  encoding=\"gb2312\" ?>\\n<!--\\nSource: http://www.blogcn.com/rss.asp?uid=luciferwang\\nEx...back.asp?mydiary=25452215 target=_blank>\\xd2\\xfd\\xd3\\xc3\\xb4\\xcb\\xce\\xc4</a>)]]>    </description>  </item></rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017666299999996582, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/bbs.blogsome.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/bbs.blogsome.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/bbs.blogsome.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00019370000000007437, "outcome": "passed"}, "call": {"duration": 0.0026143100000002306, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/bbs.blogsome.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\"?><!-- generator=\"wordpress/1.5.1-alpha\" -->\\n<!--\\nSource: http://bb...c0\\xb4\\n\\n </description>\\n\\t\\t<link>http://bbs.blogsome.com/2004/12/26/aoae/</link>\\n\\t</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.000180105000000097, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/cindychen.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/cindychen.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/cindychen.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00018531200000015957, "outcome": "passed"}, "call": {"duration": 0.0029449589999996917, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/cindychen.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"GB2312\"?>\\n<!--\\nSource: http://www.cindychen.com/dynamic/wp-rss2.php\\nExpec...mentRSS>http://www.cindychen.com/dynamic/wp-commentsrss2.php?p=32</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016662899999975167, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/_chromium_gb18030_with_no_encoding_specified.html.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/_chromium_gb18030_with_no_encoding_specified.html.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/_chromium_gb18030_with_no_encoding_specified.html.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00018584900000018223, "outcome": "passed"}, "call": {"duration": 0.0004854769999997899, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/_chromium_gb18030_with_no_encoding_specified.html.xml'\nencoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<!DOCTYPE html PUBLIC \"-//W3C//DTD Xhtml 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-tra...3\\xb0\\xbf\\xaa\\xca\\xbc\\xbd\\xf8\\xc8\\xeb\\xb3\\xc9\\xca\\xec\\xb5\\xc4\\xb4\\xf3\\xc6\\xac\\xca\\xb1\\xb4\\xfa\\xa3\\xbb\\n</body></html>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001666630000003444, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/14.blog.westca.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/14.blog.westca.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/14.blog.westca.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00018410500000021202, "outcome": "passed"}, "call": {"duration": 0.00247809099999996, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/14.blog.westca.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\" ?><!-- generator=\"b2evolution/0.8.6.2\" -->\\n<!--\\nSource: http://blo...c\\xb7\\xa3\\xac\\xd5\\xe2\\xc3\\xce\\xb2\\xbb\\xd7\\xf7\\xd2\\xb2\\xb0\\xd5\\xa1\\xa3</p>]]></content:encoded>\\n</item>\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016702000000012873, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/_mozilla_bug171813_text.html-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/_mozilla_bug171813_text.html-gb2312]", "parametrize", "pytestmark", "tests/GB2312/_mozilla_bug171813_text.html-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.0001932519999998661, "outcome": "passed"}, "call": {"duration": 0.0005572650000003065, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/_mozilla_bug171813_text.html', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<body leftmargin=\"0\" topmargin=\"0\" bgcolor=\"#fffeeb\">\\n<table border=0 cellpadding=0 cellspacing=0 height=...ec\\xcc\\xec\\xd7\\xee\\xb5\\xcd6\\xc3\\xab/\\xd0\\xa1\\xca\\xb1</a></div>\\n    </td>\\n  </tr>\\n  <tbody> </tbody> \\n</table>\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016896899999974124, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/xy15400.blogcn.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/xy15400.blogcn.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/xy15400.blogcn.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.0001870280000000335, "outcome": "passed"}, "call": {"duration": 0.0037093620000003824, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/xy15400.blogcn.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\"  encoding=\"gb2312\" ?>\\n<!--\\nSource: http://www.blogcn.com/rss.asp?uid=xyl5400\\nExpect...kback.asp?mydiary=5368356 target=_blank>\\xd2\\xfd\\xd3\\xc3\\xb4\\xcb\\xce\\xc4</a>)]]>    </description>  </item></rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016841000000011874, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/lily.blogsome.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/lily.blogsome.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/lily.blogsome.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.0001841279999998946, "outcome": "passed"}, "call": {"duration": 0.006435018000000348, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/lily.blogsome.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\"?>\\n<!--\\nSource: http://lily.blogsome.com/feed/rss2/\\nExpect: GB1803...:commentRSS>http://lily.blogsome.com/2004/12/15/hello_world/feed/</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017649200000002807, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/w3cn.org.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/w3cn.org.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/w3cn.org.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00017962399999982281, "outcome": "passed"}, "call": {"duration": 0.0015380040000003703, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/w3cn.org.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\" ?>\\n<!--\\nSource: http://www.w3cn.org/article/rss.xml\\nExpect: GB180...:54</pubDate>\\n\\t<guid>http://www.w3cn.org/article/translate/2004/89.html</guid>\\n  </item>\\n\\n  </channel>\\n  </rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016782500000012135, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/jjgod.3322.org.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/jjgod.3322.org.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/jjgod.3322.org.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00018751100000002907, "outcome": "passed"}, "call": {"duration": 0.0023743400000002524, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/jjgod.3322.org.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\"?>\\n<!--\\nSource: http://jjgod.3322.org/feed/rss2/\\nExpect: GB18030\\n...\\t\\t<wfw:commentRSS>http://jjgod.3322.org/2005/11/09/dojo/feed/</wfw:commentRSS>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016473200000000077, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/coverer.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/coverer.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/coverer.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00018028300000016984, "outcome": "passed"}, "call": {"duration": 0.0023385170000000954, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/coverer.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\"?>\\n<!--\\nSource: http://www.coverer.com/index.xml\\nExpect: GB18030\\n...a\\xb6\\xe0php\\xb0\\xae\\xba\\xc3\\xd5\\xdf\\xb5\\xc4\\xb9\\xd8\\xd7\\xa2......</description>\\n    </item>\\n\\n  </channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017844300000025015, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/godthink.blogsome.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/godthink.blogsome.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/godthink.blogsome.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00018294699999987785, "outcome": "passed"}, "call": {"duration": 0.0008760919999999395, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/godthink.blogsome.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\"?><!-- generator=\"wordpress/1.5.1-alpha\" -->\\n<!--\\nSource: http://go...n </description>\\n\\t\\t<link>http://godthink.blogsome.com/2004/12/27/uuodhdha/</link>\\n\\t</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018407299999978477, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/acnnewswire.net.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/acnnewswire.net.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/acnnewswire.net.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00019419300000000916, "outcome": "passed"}, "call": {"duration": 0.002203336, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/acnnewswire.net.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\" ?>\\n<!--\\nSource: http://www.acnnewswire.net/rss2/press_rss_20c.asp\\...t/Article.Asp?lang=_c&amp;Art_ID=29689</guid><pubDate>Tue, 22 Nov 2005 14:59:44+0900</pubDate></item></channel></rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018602700000025507, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/eighthday.blogspot.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/eighthday.blogspot.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/eighthday.blogspot.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00019105199999991385, "outcome": "passed"}, "call": {"duration": 0.0042230010000001705, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/eighthday.blogspot.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"GB2312\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/st...c8\\xb8\\xd4\\xbe~~~~</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.000173220000000196, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/cappuccinos.3322.org.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/cappuccinos.3322.org.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/cappuccinos.3322.org.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00019423800000017977, "outcome": "passed"}, "call": {"duration": 0.0018328940000000848, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/cappuccinos.3322.org.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"GB2312\"?>\\n<!--\\nSource: http://cappuccinos.3322.org/wp-rss2.php\\nExpect: GB...:commentRSS>http://cappuccinos.3322.org/wp-commentsrss2.php?p=126</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016948199999999858, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/2.blog.westca.com.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/2.blog.westca.com.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/2.blog.westca.com.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00018858799999987852, "outcome": "passed"}, "call": {"duration": 0.0032762640000001397, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/2.blog.westca.com.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\" ?><!-- generator=\"b2evolution/0.8.6.2\" -->\\n<!--\\nSource: http://blo...2\\xda\\xc3\\xc0\\xd4\\xaa\\xa1\\xa3(\\xd7\\xf7\\xd5\\xdf\\xa3\\xba \\xd1\\xcf\\xd9\\xb2 )]]></content:encoded>\\n</item>\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001673679999996125, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/GB2312/cnblog.org.xml-gb2312]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/GB2312/cnblog.org.xml-gb2312]", "parametrize", "pytestmark", "tests/GB2312/cnblog.org.xml-gb2312", "test.py", "testbed", ""], "setup": {"duration": 0.00018165399999992005, "outcome": "passed"}, "call": {"duration": 0.0045958950000000165, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/GB2312/cnblog.org.xml', encoding = 'gb2312'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"gb2312\"?>\\n<!--\\nSource: http://www.cnblog.org/blog/cache/cnblog.xml\\nExpect...xbc\\xbc\\xca\\xf5\\xb7\\xc7\\xd3\\xaa\\xc0\\xfb\\xd0\\xd4\\xd7\\xe9\\xd6\\xaf]]></description>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016659599999968577, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/music.peeps.ru.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/music.peeps.ru.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/music.peeps.ru.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.00018134799999991458, "outcome": "passed"}, "call": {"duration": 0.0039860780000000595, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/music.peeps.ru.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://music.peeps.ru/news/action_rss.xml\\nExp...\\xe4\\xed\\xfb\\xf5 \\xef\\xe0\\xed\\xea-\\xe3\\xf0\\xf3\\xef\\xef 90-\\xf5. </description>\\n\\t\\t</item>\\n\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016930000000003886, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.4.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.4.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/forum.template-toolkit.ru.4.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.00019479500000008088, "outcome": "passed"}, "call": {"duration": 0.0028846519999996545, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/forum.template-toolkit.ru.4.xml'\nencoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_4.r...-4.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016678899999966745, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/koi.kinder.ru.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/koi.kinder.ru.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/koi.kinder.ru.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.00019155700000039744, "outcome": "passed"}, "call": {"duration": 0.0012060140000000885, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/koi.kinder.ru.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://koi.kinder.ru/rss/kinder_news_koi8.xml\\...>\\n\\n<item>\\n<title>\\x83\\xe0\\xe7\\xe5\\xf2\\xe0-\\xe0\\xeb\\xfc\\xec\\xe0\\xed\\xe0\\xf5 (\\xf1\\xe0\\xe9\\xf2 \\xf8\\xea\\xee\\xeb\\xfb ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016856399999998217, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/_ude_1.txt-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/_ude_1.txt-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/_ude_1.txt-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.00018743800000020627, "outcome": "passed"}, "call": {"duration": 0.0006610970000000549, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/_ude_1.txt', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\x82 \\xe3\\xe8\\xec\\xed\\xe0\\xe7\\xe8\\xe8 \\xee\\xed \\xed\\xe5 \\xe1\\xfb\\xeb \\xe2 \\xf7\\xe8\\xf1\\xeb\\xe5 \\xef\\xe5\\xf...xf2\\xf2\\xe5\\xf1\\xf2\\xe0\\xf2 \\xe8 \\xef\\xee\\xe2\\xf2\\xee\\xf0\\xe8\\xf2\\xfc \\xef\\xee\\xf1\\xf2\\xf3\\xef\\xeb\\xe5\\xed\\xe8\\xe5.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017590399999978246, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/aviaport.ru.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/aviaport.ru.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/aviaport.ru.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.00018455199999989347, "outcome": "passed"}, "call": {"duration": 0.01576337799999994, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/aviaport.ru.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://www.aviaport.ru/news/yandex_export.xml\\...d\\xed\\xee\\xe9 \\xf1\\xf2\\xf0\\xe0\\xf5\\xee\\xe2\\xea\\xe8.\\n\\t\\t\\t</yandex:full-text>\\n\\t\\t</item>\\n\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001754709999999271, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/intertat.ru.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/intertat.ru.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/intertat.ru.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.0001880660000002088, "outcome": "passed"}, "call": {"duration": 0.0004978600000002942, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/intertat.ru.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://intertat.ru/myyandex.php\\nExpect: MacCy...\\xe8\\xe4\\xe5\\xf2\\xe5\\xeb\\xfc\\xf1\\xf2\\xe2\\xee \\xee \\xf0\\xe5\\xe3\\xe8\\xf1\\xf2\\xf0\\xe0\\xf6\\xe8\\xe8 \\x91\\x8c\\x88 \\x9d\\xeb ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00020063799999991971, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/aug32.hole.ru.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/aug32.hole.ru.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/aug32.hole.ru.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.0002142919999998938, "outcome": "passed"}, "call": {"duration": 0.0005235770000000528, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/aug32.hole.ru.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://aug32.hole.ru/afisha/feed.php\\nExpect: ...&gt;</description>\\n          <link>http://aug32.hole.ru/afisha.htm</link>\\n        </item>\\n    </channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019651599999992442, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.8.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.8.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/forum.template-toolkit.ru.8.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.0001929669999998218, "outcome": "passed"}, "call": {"duration": 0.004777185000000017, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/forum.template-toolkit.ru.8.xml'\nencoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_8.r...8.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019371399999990047, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/aif.ru.health.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/aif.ru.health.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/aif.ru.health.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.0002000080000001958, "outcome": "passed"}, "call": {"duration": 0.0023829909999997234, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/aif.ru.health.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://www.aif.ru/info/rss.php?magazine=health...f0\\xe0\\xeb\\xfc\\xed\\xfb\\xf5 \\xef\\xf0\\xee\\xe4\\xf3\\xea\\xf2\\xee\\xe2.\\t\\t</description>\\n\\t</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001730900000000979, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/blog.mlmaster.com.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/blog.mlmaster.com.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/blog.mlmaster.com.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.00019304600000014105, "outcome": "passed"}, "call": {"duration": 0.0018908459999997795, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/blog.mlmaster.com.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://blog.mlmaster.com/wp-rss2.php\\nExpect: ...\\t\\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016868999999974932, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/money.rin.ru.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/money.rin.ru.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/money.rin.ru.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.0002026200000000422, "outcome": "passed"}, "call": {"duration": 0.0022432769999998214, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/money.rin.ru.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://money.rin.ru/news/rss/\\nExpect: MacCyri...  (N 1080 \\xee\\xf2 17 \\xed\\xee\\xdf\\xe1\\xf0\\xdf 2005 \\xe3\\xee\\xe4\\xe0).</description>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001707539999999952, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/newsru.com.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/newsru.com.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/newsru.com.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.00018395300000006998, "outcome": "passed"}, "call": {"duration": 0.00591732899999986, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/newsru.com.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://www.newsru.com/plain/rss/all.xml\\nExpec...=\"http://www.newsru.com/pict/id/large/819577_20060103092327.gif\" type=\"image/jpeg\"/>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017958200000034452, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/greek.ru.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/greek.ru.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/greek.ru.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.00020640100000024475, "outcome": "passed"}, "call": {"duration": 0.0008228980000000163, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/greek.ru.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://www.greek.ru/news/ya/yagreek\\nExpect: M...e8. \\x90\\xee\\xe2\\xed\\xee 29 \\xeb\\xe5\\xf2 \\xed\\xe0\\xe7\\xe0\\xe4 \\xe2 \\xf5\\xee\\xe4\\xe5 \\xee\\xef\\xe5\\xf0\\xe0\\xf6\\xe8\\xe8 ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001671160000000782, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/susu.ac.ru.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/susu.ac.ru.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/susu.ac.ru.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.00019126599999985672, "outcome": "passed"}, "call": {"duration": 0.0006251480000001308, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/susu.ac.ru.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://susu.ac.ru/ru/news/rss\\nExpect: MacCyri...5\\xed\\xe8\\xdf \\xef\\xee\\xe1\\xe5\\xe4\\xe8\\xf2\\xe5\\xeb\\xe5\\xe9 \\xea\\xee\\xed\\xea\\xf3\\xf0\\xf1\\xe0 \\xf1\\xe0\\xe9\\xf2\\xee\\xe2 ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017180400000027518, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/kapranoff.ru.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/kapranoff.ru.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/kapranoff.ru.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.00020029899999984835, "outcome": "passed"}, "call": {"duration": 0.0020427050000000335, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/kapranoff.ru.xml', encoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://kapranoff.ru/index.rdf\\nExpect: MacCyri...dc:subject/>\\n<dc:creator>kappa</dc:creator>\\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001792560000000165, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.6.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.6.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/forum.template-toolkit.ru.6.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.00018829399999997776, "outcome": "passed"}, "call": {"duration": 0.007969840999999978, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/forum.template-toolkit.ru.6.xml'\nencoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_6.r...6.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001688099999999082, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.9.xml-maccyrillic]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/MacCyrillic/forum.template-toolkit.ru.9.xml-maccyrillic]", "parametrize", "pytestmark", "tests/MacCyrillic/forum.template-toolkit.ru.9.xml-maccyrillic", "test.py", "testbed", ""], "setup": {"duration": 0.0001824550000000258, "outcome": "passed"}, "call": {"duration": 0.0010459339999999706, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/MacCyrillic/forum.template-toolkit.ru.9.xml'\nencoding = 'maccyrillic'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"MacCyrillic\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_9.r...9.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016644800000031879, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/greek.ru.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/greek.ru.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/greek.ru.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.00018310500000007224, "outcome": "passed"}, "call": {"duration": 0.004385962999999826, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/greek.ru.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://www.greek.ru/news/ya/yagreek\\nExpect: IBM866...e1 \\xae\\xe1\\xe2\\xe0\\xae\\xa2\\xa0 \\x91\\xaf\\xa5\\xe6\\xa5\\xe1... \\n</description>\\n    </item>                \\n\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017083799999983995, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/_ude_1.txt-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/_ude_1.txt-ibm866]", "parametrize", "pytestmark", "tests/IBM866/_ude_1.txt-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.0001844909999997313, "outcome": "passed"}, "call": {"duration": 0.0006609609999999044, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/_ude_1.txt', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\x82 \\xa3\\xa8\\xac\\xad\\xa0\\xa7\\xa8\\xa8 \\xae\\xad \\xad\\xa5 \\xa1\\xeb\\xab \\xa2 \\xe7\\xa8\\xe1\\xab\\xa5 \\xaf\\xa5\\xe...xe2\\xe2\\xa5\\xe1\\xe2\\xa0\\xe2 \\xa8 \\xaf\\xae\\xa2\\xe2\\xae\\xe0\\xa8\\xe2\\xec \\xaf\\xae\\xe1\\xe2\\xe3\\xaf\\xab\\xa5\\xad\\xa8\\xa5.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017607199999991607, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/aviaport.ru.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/aviaport.ru.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/aviaport.ru.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.00018759099999998696, "outcome": "passed"}, "call": {"duration": 0.007194330999999998, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/aviaport.ru.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://www.aviaport.ru/news/yandex_export.xml\\nExpe...d\\xa8\\xa8 \\xa0\\xed\\xe0\\xae\\xaf\\xae\\xe0\\xe2\\xa0, \\xe1\\xae\\xae\\xa1\\xe9\\xa0\\xa5\\xe2 \\x93\\xaa\\xe0\\xa0\\xf5\\xad\\xe1\\xec\\xaa')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019985499999997103, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/aug32.hole.ru.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/aug32.hole.ru.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/aug32.hole.ru.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.0001908600000000149, "outcome": "passed"}, "call": {"duration": 0.0004782620000001181, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/aug32.hole.ru.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://aug32.hole.ru/afisha/feed.php\\nExpect: IBM86...&gt;</description>\\n          <link>http://aug32.hole.ru/afisha.htm</link>\\n        </item>\\n    </channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016646999999991863, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/kapranoff.ru.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/kapranoff.ru.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/kapranoff.ru.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.00018890299999974047, "outcome": "passed"}, "call": {"duration": 0.0020251700000000206, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/kapranoff.ru.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://kapranoff.ru/index.rdf\\nExpect: IBM866\\n-->\\...dc:subject/>\\n<dc:creator>kappa</dc:creator>\\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017759800000005654, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/music.peeps.ru.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/music.peeps.ru.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/music.peeps.ru.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.00018585699999995597, "outcome": "passed"}, "call": {"duration": 0.0022557540000001097, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/music.peeps.ru.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://music.peeps.ru/news/action_rss.xml\\nExpect: ...\\xa4\\xad\\xeb\\xe5 \\xaf\\xa0\\xad\\xaa-\\xa3\\xe0\\xe3\\xaf\\xaf 90-\\xe5. </description>\\n\\t\\t</item>\\n\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016799999999994597, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.4.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.4.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/forum.template-toolkit.ru.4.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.0001862940000001423, "outcome": "passed"}, "call": {"duration": 0.002853949999999994, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/forum.template-toolkit.ru.4.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_4.rss\\nE...-4.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016868000000025418, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.8.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.8.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/forum.template-toolkit.ru.8.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.00019199599999986106, "outcome": "passed"}, "call": {"duration": 0.0046838190000002555, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/forum.template-toolkit.ru.8.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_8.rss\\nE...8.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001690250000003779, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/blog.mlmaster.com.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/blog.mlmaster.com.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/blog.mlmaster.com.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.0001837080000002267, "outcome": "passed"}, "call": {"duration": 0.0018516249999995793, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/blog.mlmaster.com.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://blog.mlmaster.com/wp-rss2.php\\nExpect: IBM86...\\t\\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001684750000001678, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/money.rin.ru.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/money.rin.ru.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/money.rin.ru.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.00019560100000015623, "outcome": "passed"}, "call": {"duration": 0.0021863330000000403, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/money.rin.ru.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://money.rin.ru/news/rss/\\nExpect: IBM866\\n-->\\...  (N 1080 \\xae\\xe2 17 \\xad\\xae\\xef\\xa1\\xe0\\xef 2005 \\xa3\\xae\\xa4\\xa0).</description>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017438499999977708, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/janulalife.blogspot.com.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/janulalife.blogspot.com.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/janulalife.blogspot.com.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.00018093399999985493, "outcome": "passed"}, "call": {"duration": 0.004843538999999897, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/janulalife.blogspot.com.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/st...\\xae\\xa8.\\n<br/>\\n</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001666700000000354, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/intertat.ru.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/intertat.ru.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/intertat.ru.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.0001791849999999151, "outcome": "passed"}, "call": {"duration": 0.00047301300000013313, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/intertat.ru.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://intertat.ru/myyandex.php\\nExpect: IBM866\\n--...\\xa8\\xa4\\xa5\\xe2\\xa5\\xab\\xec\\xe1\\xe2\\xa2\\xae \\xae \\xe0\\xa5\\xa3\\xa8\\xe1\\xe2\\xe0\\xa0\\xe6\\xa8\\xa8 \\x91\\x8c\\x88 \\x9d\\xab ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016717600000015764, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.9.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.9.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/forum.template-toolkit.ru.9.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.0001866340000002964, "outcome": "passed"}, "call": {"duration": 0.0010431610000001257, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/forum.template-toolkit.ru.9.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_9.rss\\nE...9.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017002899999996046, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/susu.ac.ru.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/susu.ac.ru.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/susu.ac.ru.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.00018794700000013265, "outcome": "passed"}, "call": {"duration": 0.0008290800000003706, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/susu.ac.ru.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://susu.ac.ru/ru/news/rss\\nExpect: IBM866\\n-->\\...ad\\xad\\xae\\xe1\\xe2\\xa8&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"http://model.exponenta.ru/\"\"&gt;Model.Exponenta.Ru ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016865100000007516, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/newsru.com.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/newsru.com.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/newsru.com.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.0001808859999998802, "outcome": "passed"}, "call": {"duration": 0.005832543000000356, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/newsru.com.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://www.newsru.com/plain/rss/all.xml\\nExpect: IB...=\"http://www.newsru.com/pict/id/large/819577_20060103092327.gif\" type=\"image/jpeg\"/>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017138500000024592, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.6.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.6.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/forum.template-toolkit.ru.6.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.00020244800000002172, "outcome": "passed"}, "call": {"duration": 0.007878428999999798, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/forum.template-toolkit.ru.6.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_6.rss\\nE...6.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016950000000015564, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/aif.ru.health.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/aif.ru.health.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/aif.ru.health.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.00018724699999994598, "outcome": "passed"}, "call": {"duration": 0.002325676000000332, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/aif.ru.health.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://www.aif.ru/info/rss.php?magazine=health\\nExp...e0\\xa0\\xab\\xec\\xad\\xeb\\xe5 \\xaf\\xe0\\xae\\xa4\\xe3\\xaa\\xe2\\xae\\xa2.\\t\\t</description>\\n\\t</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016755099999965495, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.1.xml-ibm866]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM866/forum.template-toolkit.ru.1.xml-ibm866]", "parametrize", "pytestmark", "tests/IBM866/forum.template-toolkit.ru.1.xml-ibm866", "test.py", "testbed", ""], "setup": {"duration": 0.00018102599999991753, "outcome": "passed"}, "call": {"duration": 0.006257331999999671, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM866/forum.template-toolkit.ru.1.xml', encoding = 'ibm866'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM866\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_1.rss\\nE...1.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-93.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017759299999964284, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/myblog.pchome.com.tw.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/myblog.pchome.com.tw.xml-big5]", "parametrize", "pytestmark", "tests/Big5/myblog.pchome.com.tw.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00018484600000023832, "outcome": "passed"}, "call": {"duration": 0.0019149329999996745, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/myblog.pchome.com.tw.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Big5\"?>\\n<!--\\nSource: http://myblog.pchome.com.tw/_/myblog/rss.php?blog_id=...=07&amp;an=163&amp;acn=140\\n</link>\\n<pubDate>Wed, 06 Jul 2005 06:13:20 GMT</pubDate> \\n</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017891300000005828, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/blog.worren.net.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/blog.worren.net.xml-big5]", "parametrize", "pytestmark", "tests/Big5/blog.worren.net.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00018501000000004098, "outcome": "passed"}, "call": {"duration": 0.0023914970000000757, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/blog.worren.net.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Big5\"?>\\n<!--\\nSource: http://blog.worren.net/wp-atom.php\\nExpect: Big5\\n-->...acO\\xa7A\\xaa\\xba\\xa4F! \\xc1\\xd9\\xacO\\xa7\\xd6\\xb7Q\\xb7Q\\xa7O\\xaa\\xba\\xa8\\xc6\\xa7a !  </summary>\\n\\t</entry>\\n\\t</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016662200000006067, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/marilynwu.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/marilynwu.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/marilynwu.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.0001922799999998226, "outcome": "passed"}, "call": {"duration": 0.0017177109999999551, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/marilynwu.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...83/1600/IMG_23481.JPG\"&gt;</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016656199999998123, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/coolloud.org.tw.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/coolloud.org.tw.xml-big5]", "parametrize", "pytestmark", "tests/Big5/coolloud.org.tw.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00019256400000022822, "outcome": "passed"}, "call": {"duration": 0.003378777999999638, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/coolloud.org.tw.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"big5\"?>\\n<!--\\nSource: http://www.coolloud.org.tw/index.xml\\nExpect: Big5\\n-...tor>\\n  <dc:date>2005-12-29T12:42:34+08:00</dc:date>\\n  <category>\\xa9\\xca\\xa7O</category>\\n  </item>\\n</rdf:RDF>\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016723799999995848, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/ebao.us.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/ebao.us.xml-big5]", "parametrize", "pytestmark", "tests/Big5/ebao.us.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00018057100000001824, "outcome": "passed"}, "call": {"duration": 0.0013221990000000794, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/ebao.us.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\"?>\\n<!--\\nSource: http://www.ebao.us/xml/rssgen/rssgen_LatestNews.asp\\n...4\\xa2\\xaf\\xa2H </description> \\n  <pubDate>Fri, 16 Dec 2005 14:19:19 GMT</pubDate>\\n  </item>\\n  </channel>\\n  </rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016632599999999442, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/_ude_1.txt-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/_ude_1.txt-big5]", "parametrize", "pytestmark", "tests/Big5/_ude_1.txt-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00018368800000034824, "outcome": "passed"}, "call": {"duration": 0.0004221549999998686, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/_ude_1.txt', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xba\\xfb\\xb0\\xf2\\xa4j\\xa8\\xe5\\xa1]Wikipedia\\xa1^\\xaa\\xcc\\xa1A\\xba\\xf4\\xb8\\xf4\\xac\\xb0\\xc2\\xa6\\xa1F\\xb6\\xb0...c1n\\xb6H\\xacM\\xc5T\\xa1A\\xa8\\xe3\\xbf\\xfd\\xa9\\xf3\\xba\\xfb\\xb0\\xf2\\xa6@\\xa8\\xc9\\xa1J\\xba\\xfb\\xb0\\xf2\\xa4j\\xa8\\xe5\\xa1C\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001665259999996671, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/upsaid.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/upsaid.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/upsaid.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00018302799999991848, "outcome": "passed"}, "call": {"duration": 0.012693062999999949, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/upsaid.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"big5\" ?>\\n<!--\\nSource: http://www.upsaid.com/isis/index.rdf\\nExpect: Big5\\n...\\t<dc:date>2005-09-29T01:03:27+07:00</dc:date>\\n\\t\\t\\t<slash:comments>0</slash:comments>\\n\\t\\t</item>\\n\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018876399999978588, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/leavesth.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/leavesth.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/leavesth.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.0001969260000000972, "outcome": "passed"}, "call": {"duration": 0.004283452999999771, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/leavesth.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...G | Jedi.org</a>\\n</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017566400000035287, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/oui-design.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/oui-design.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/oui-design.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00020086600000013277, "outcome": "passed"}, "call": {"duration": 0.0008430169999997794, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/oui-design.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"big5\" ?>\\n<!--\\nSource: http://www.oui-design.com/fpcode/rss.php\\nExpect: Bi... 2:27 pm</date>\\n<link>http://www.oui-design.com/fpcode/news.php?story_id=259</link>\\n</item>\\n\\t\\t\\n\\n</rdf:RDF>\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016991800000010215, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/kafkatseng.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/kafkatseng.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/kafkatseng.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00018633499999998193, "outcome": "passed"}, "call": {"duration": 0.0027436680000003655, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/kafkatseng.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...F&lt;br /&gt;\\xc6g\\xb0\\xd5</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016813100000012682, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/_chromium_Big5_with_no_encoding_specified.html-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/_chromium_Big5_with_no_encoding_specified.html-big5]", "parametrize", "pytestmark", "tests/Big5/_chromium_Big5_with_no_encoding_specified.html-big5", "test.py", "testbed", ""], "setup": {"duration": 0.0001807349999998209, "outcome": "passed"}, "call": {"duration": 0.00042453500000005917, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/_chromium_Big5_with_no_encoding_specified.html'\nencoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html>\\n <head>\\n  <title> Big5 </title>\\n </head>\\n\\n <body>\\n  \\xa5x\\xa5_\\xac\\xdd\\xa6u\\xa9\\xd2\\xacQ\\xa4\\...a1u\\xa8I\\xc0q\\xa7\\xdc\\xc4\\xb3\\xa1v\\xa1A\\xaa\\xfc\\xab\\xf3\\xaa\\xed\\xa5\\xdc\\xb7|\\xa6\\xd2\\xbc{\\xa1C\\n </body>\\n</html>\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016984300000011388, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/sinica.edu.tw.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/sinica.edu.tw.xml-big5]", "parametrize", "pytestmark", "tests/Big5/sinica.edu.tw.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00018634999999989077, "outcome": "passed"}, "call": {"duration": 0.0026858359999999415, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/sinica.edu.tw.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl.../>\\n<br/> \\n<br/> </div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016983499999989604, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/ke207.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/ke207.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/ke207.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00018657900000018657, "outcome": "passed"}, "call": {"duration": 0.003183672999999665, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/ke207.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...,\\xa1\\xcf,\\xa1\\xcf</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001693529999999832, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/linyijen.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/linyijen.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/linyijen.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00018354200000025855, "outcome": "passed"}, "call": {"duration": 0.0026334660000002508, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/linyijen.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...\\xa6n\\xaa\\xba\\xa1C</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016845000000031973, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/tlkkuo.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/tlkkuo.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/tlkkuo.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.0001813719999996799, "outcome": "passed"}, "call": {"duration": 0.0018929700000001048, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/tlkkuo.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl.../&gt;\\xc1\\xc2\\xc1\\xc2\\xa7A</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017025600000009078, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/carbonxiv.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/carbonxiv.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/carbonxiv.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00018533099999995528, "outcome": "passed"}, "call": {"duration": 0.004300623999999864, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/carbonxiv.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...\\xd2\\xb7R</span>\\n</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001681730000000492, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/0804.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/0804.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/0804.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.000325378999999959, "outcome": "passed"}, "call": {"duration": 0.004944051999999921, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/0804.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...xa4\\xb7N!</span>\\n</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019645999999973185, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/willythecop.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/willythecop.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/willythecop.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00019286699999998547, "outcome": "passed"}, "call": {"duration": 0.0032292169999998954, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/willythecop.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...I</a>\\n</strong>\\n</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018239100000005948, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/sylvia1976.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/sylvia1976.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/sylvia1976.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00020604299999993358, "outcome": "passed"}, "call": {"duration": 0.00365899599999997, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/sylvia1976.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...n\\xa6\\xd1\\xc1\\xf3\\xaeQ\\xb7\\xc7\\xb3\\xc6\\xaa\\xba\\xa4\\xe9\\xa6\\xa1\\xb1\\xdf\\xc0\\\\\\xc5o\\xa1I</content>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.000186639000000266, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/fudesign.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/fudesign.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/fudesign.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00020221300000011766, "outcome": "passed"}, "call": {"duration": 0.00583196500000005, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/fudesign.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...fullpost\"&gt;&lt;/span&gt;</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019521400000011013, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/digitalwall.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/digitalwall.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/digitalwall.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00020728400000002978, "outcome": "passed"}, "call": {"duration": 0.0006680820000002363, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/digitalwall.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"big5\" ?>\\r\\n<!--\\nSource: http://www.digitalwall.com/rss20/rss_cht.xml\\nExpe...pts/display.asp?UID=321</guid>\\r\\n<pubDate>Sat, 17 Dec 2005 15:21:36 GMT</pubDate>\\r\\n</item>\\r\\n</channel>\\r\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018469600000026176, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/catshadow.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/catshadow.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/catshadow.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00020027500000008303, "outcome": "passed"}, "call": {"duration": 0.0042165969999996555, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/catshadow.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...\\xae\\xc8\\xb5{\\xa1K</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018321000000032228, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/sanwenji.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/sanwenji.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/sanwenji.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.0001871079999999914, "outcome": "passed"}, "call": {"duration": 0.01339692399999981, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/sanwenji.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...a\\xa1\\xaa\\xba\\xa1C</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017316699999980756, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/letterlego.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/letterlego.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/letterlego.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00019399000000008826, "outcome": "passed"}, "call": {"duration": 0.013437829999999984, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/letterlego.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...;&lt;br /&gt;&lt;/span&gt;</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001778920000004014, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/unoriginalblog.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/unoriginalblog.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/unoriginalblog.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.000195895000000057, "outcome": "passed"}, "call": {"duration": 0.0041522790000003695, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/unoriginalblog.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Big5\"?>\\n<!--\\nSource: http://unoriginalblog.com/feed/\\nExpect: Big5\\n-->\\n<...fw:commentRSS>http://unoriginalblog.com/2005/11/another-day/feed/</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017318200000016049, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Big5/ytc.blogspot.com.xml-big5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Big5/ytc.blogspot.com.xml-big5]", "parametrize", "pytestmark", "tests/Big5/ytc.blogspot.com.xml-big5", "test.py", "testbed", ""], "setup": {"duration": 0.00018747000000018943, "outcome": "passed"}, "call": {"duration": 0.010934140999999897, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Big5/ytc.blogspot.com.xml', encoding = 'big5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"BIG5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/styl...7\\xda\\xbb\\xa1\\xa1C</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001769079999998091, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16LE/nobom-utf16le.txt-utf-16le]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-16LE/nobom-utf16le.txt-utf-16le]", "parametrize", "pytestmark", "tests/UTF-16LE/nobom-utf16le.txt-utf-16le", "test.py", "testbed", ""], "setup": {"duration": 0.0002036320000002867, "outcome": "passed"}, "call": {"duration": 0.001676983999999937, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-16LE/nobom-utf16le.txt', encoding = 'utf-16le'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'D\\x00a\\x00t\\x00e\\x00T\\x00i\\x00m\\x00e\\x00,\\x00B\\x00i\\x00d\\x00,\\x00A\\x00s\\x00k\\x00\\r\\x00\\n\\x000\\x007\\x00/\\x0...0\\x00.\\x003\\x001\\x009\\x00,\\x001\\x00.\\x000\\x008\\x003\\x000\\x007\\x00,\\x001\\x00.\\x000\\x008\\x003\\x005\\x003\\x00\\r\\x00\\n\\x00')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017547599999989671, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16LE/plane1-utf-16le.html-utf-16le]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-16LE/plane1-utf-16le.html-utf-16le]", "parametrize", "pytestmark", "tests/UTF-16LE/plane1-utf-16le.html-utf-16le", "test.py", "testbed", ""], "setup": {"duration": 0.00020333099999980675, "outcome": "passed"}, "call": {"duration": 0.0017772390000003746, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-16LE/plane1-utf-16le.html', encoding = 'utf-16le'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<\\x00!\\x00D\\x00O\\x00C\\x00T\\x00Y\\x00P\\x00E\\x00 \\x00H\\x00T\\x00M\\x00L\\x00 \\x00P\\x00U\\x00B\\x00L\\x00I\\x00C\\x00 ...02\\x00-\\x002\\x004\\x00.\\x00\\r\\x00\\n\\x00<\\x00/\\x00p\\x00>\\x00\\r\\x00\\n\\x00<\\x00/\\x00h\\x00t\\x00m\\x00l\\x00>\\x00\\r\\x00\\n\\x00')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017519599999982205, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-2022-jp/_ude_1.txt-iso-2022-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-2022-jp/_ude_1.txt-iso-2022-jp]", "parametrize", "pytestmark", "tests/iso-2022-jp/_ude_1.txt-iso-2022-jp", "test.py", "testbed", ""], "setup": {"duration": 0.000192887000000308, "outcome": "passed"}, "call": {"duration": 0.00198955199999995, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-2022-jp/_ude_1.txt', encoding = 'iso-2022-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'========================================================================\\n    \\x1b$B%3%s%=!<%k\\x1b(J \\x1b$...!<%9ItJ,$r<($7$^$9!#\\x1b(J\\n\\n/////////////////////////////////////////////////////////////////////////////\\n\\n\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017765300000016637, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.4.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.4.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/bpm.cult.bg.4.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019399500000005787, "outcome": "passed"}, "call": {"duration": 0.003172393999999912, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.4.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://bpm.cult.bg/logs/rdf.php?id=4\\nExpect:....log)</dc:subject>\\n<dc:creator>dubka</dc:creator>\\n<dc:date>2005-10-09T11:10:26+02:00</dc:date>\\n</item>\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017254599999994014, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/ecloga.cult.bg.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/ecloga.cult.bg.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/ecloga.cult.bg.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00020006999999999664, "outcome": "passed"}, "call": {"duration": 0.0037657349999999923, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/ecloga.cult.bg.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://ecloga.cult.bg/log/wp-rss.php\\nExpect:...ption>\\n            <link>http://ecloga.cult.bg/log/index.php?p=242</link>\\n        </item>\\n    </channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001726109999999892, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/bpm.cult.bg.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019614599999995264, "outcome": "passed"}, "call": {"duration": 0.001886486000000076, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://bpm.cult.bg/services/rss/ezine.php\\nEx...subject>*bpm . ezine / social</dc:subject>\\n<dc:creator>oleole</dc:creator>\\n<dc:date></dc:date>\\n</item>\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001714029999999589, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/linux-bg.org.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/linux-bg.org.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/linux-bg.org.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.0001887859999998298, "outcome": "passed"}, "call": {"duration": 0.0010470019999999636, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/linux-bg.org.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://linux-bg.org/linux-bg-news.rdf\\nExpect...=news&amp;key=378326293</link>\\n</item>\\n\\n \\n <skipHours>\\n <hour>1</hour>\\n </skipHours>\\n \\n </channel>\\n </rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001736989999998606, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/rinennor.org.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/rinennor.org.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/rinennor.org.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00020085899999999768, "outcome": "passed"}, "call": {"duration": 0.001720994999999892, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/rinennor.org.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Windows-1251\"?>\\n<!--\\nSource: http://www.rinennor.org/backend_full.php\\nExp...ing session.bug_compat_42 or session.bug_compat_warn to off, respectively. in <b>Unknown</b> on line <b>0</b><br />\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001727879999999793, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/ide.li.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/ide.li.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/ide.li.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019615300000008773, "outcome": "passed"}, "call": {"duration": 0.0013391330000001034, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/ide.li.xml', encoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://www.ide.li/backend.php\\nExpect: window...b\\xe3\\xe0\\xf0\\xe8\\xed \\xc8\\xe2\\xe0\\xed \\xcf\\xee\\xeb\\xee\\xe2\\xed\\xfe\\xea.</description>\\n</item>\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001719929999999259, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/doncho.net.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.0001882669999999642, "outcome": "passed"}, "call": {"duration": 0.002618369999999981, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/doncho.net.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://doncho.net/blog/wp-rss2.php\\nExpect: w...\\n\\t\\t<wfw:commentRSS>http://blog.doncho.net/?feed=rss2&amp;p=384</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017368399999995177, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.news.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.news.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/debian.gabrovo.com.news.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018525700000004974, "outcome": "passed"}, "call": {"duration": 0.0008427260000001269, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/debian.gabrovo.com.news.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://debian.gabrovo.com/backend/debianbg-ne...p://debian.gabrovo.com/show.php?id=56&amp;tablica=news&amp;sub=\\xd2\\xe5\\xec\\xe0</link>\\n</item>\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017179600000005735, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.2.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.2.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/bpm.cult.bg.2.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.0001853460000003082, "outcome": "passed"}, "call": {"duration": 0.003260531000000011, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.2.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://bpm.cult.bg/logs/rdf.php?id=2\\nExpect:....log)</dc:subject>\\n<dc:creator>snark</dc:creator>\\n<dc:date>2005-12-12T18:12:01+02:00</dc:date>\\n</item>\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017274399999989143, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.3.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.3.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/bpm.cult.bg.3.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018941499999991507, "outcome": "passed"}, "call": {"duration": 0.0028696660000000485, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.3.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://bpm.cult.bg/logs/rdf.php?id=3\\nExpect:...log)</dc:subject>\\n<dc:creator>Lucash</dc:creator>\\n<dc:date>2005-06-14T18:06:01+02:00</dc:date>\\n</item>\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017565200000024817, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/informator.org.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/informator.org.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/informator.org.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00018672499999983216, "outcome": "passed"}, "call": {"duration": 0.0008061960000000923, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/informator.org.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://www.informator.org/html/backend.php\\nE...tp://www.informator.org/html/modules.php?name=News&amp;file=article&amp;sid=173</link>\\n</item>\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017503400000018488, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/debian.gabrovo.com.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/debian.gabrovo.com.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019170300000004303, "outcome": "passed"}, "call": {"duration": 0.0006338229999998113, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/debian.gabrovo.com.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://debian.gabrovo.com/backend/debianbg-ar.../debian.gabrovo.com/show.php?id=5&amp;tablica=articles&amp;sub=\\xd2\\xe5\\xec\\xe0</link>\\n</item>\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017581200000016395, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.9.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.9.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/bpm.cult.bg.9.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.0001911500000000288, "outcome": "passed"}, "call": {"duration": 0.0033886910000000547, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.9.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://bpm.cult.bg/logs/rdf.php?id=9\\nExpect:...og)</dc:subject>\\n<dc:creator>Kaladan</dc:creator>\\n<dc:date>2004-12-03T19:12:22+02:00</dc:date>\\n</item>\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018993799999966754, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.comments.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/doncho.net.comments.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/doncho.net.comments.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019531200000022508, "outcome": "passed"}, "call": {"duration": 0.0028696150000002696, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/doncho.net.comments.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://blog.doncho.net/wp-commentsrss2.php\\nE...ort of my favourite password manager! Thanks a lot!</p>\\n]]></content:encoded>\\n\\t\\t\\t\\t</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017392700000007366, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bbc.co.uk.popshow.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/bbc.co.uk.popshow.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/bbc.co.uk.popshow.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.00019629200000004232, "outcome": "passed"}, "call": {"duration": 0.006273877000000372, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/bbc.co.uk.popshow.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://www.bbc.co.uk/bulgarian/popshow/index....r>worldservice.com/bulgarian</dc:publisher>\\n      <dc:type>External Link, Pop Show</dc:type>\\n   </item>\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018246600000004776, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.medusa.4.xml-windows-1251]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1251-bulgarian/bpm.cult.bg.medusa.4.xml-windows-1251]", "parametrize", "pytestmark", "tests/windows-1251-bulgarian/bpm.cult.bg.medusa.4.xml-windows-1251", "test.py", "testbed", ""], "setup": {"duration": 0.0001915630000000057, "outcome": "passed"}, "call": {"duration": 0.003129067000000152, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1251-bulgarian/bpm.cult.bg.medusa.4.xml'\nencoding = 'windows-1251'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1251\"?>\\n<!--\\nSource: http://bpm.cult.bg/medusa/logs/rdf.php?id=4\\n....log)</dc:subject>\\n<dc:creator>dubka</dc:creator>\\n<dc:date>2005-10-09T11:10:26+02:00</dc:date>\\n</item>\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018517700000009185, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/willis.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/willis.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/willis.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019135500000011518, "outcome": "passed"}, "call": {"duration": 0.006747854999999969, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/willis.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://willis.egloos.com/index.xml\\nExpect: EUC-KR...t<category>- Work</category>\\n\\t\\t<pubDate>Mon, 28 Nov 2005 01:29:49 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019816299999986242, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/xenix.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/xenix.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/xenix.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019820400000014615, "outcome": "passed"}, "call": {"duration": 0.009753942999999765, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/xenix.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://xenix.egloos.com/index.xml\\nExpect: EUC-KR\\...\\xb0\\xed \\xa2\\xc6</category>\\n\\t\\t<pubDate>Sun, 18 Dec 2005 10:53:17 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001803650000002932, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/ittrend.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/ittrend.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/ittrend.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019734299999996097, "outcome": "passed"}, "call": {"duration": 0.005762865999999978, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/ittrend.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://ittrend.egloos.com/index.xml\\nExpect: EUC-K...5\\xb5\\xbf\\xc7\\xe2</category>\\n\\t\\t<pubDate>Sat, 26 Nov 2005 07:21:50 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00021906999999998789, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/zangsalang.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/zangsalang.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/zangsalang.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00020774600000006416, "outcome": "passed"}, "call": {"duration": 0.0033252019999996385, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/zangsalang.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://zangsalang.egloos.com/index.xml\\nExpect: EU...xc3\\xa2\\xb0\\xed**</category>\\n\\t\\t<pubDate>Thu, 24 Jun 2004 12:04:11 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001974240000000016, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/_ude_euc1.txt-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/_ude_euc1.txt-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/_ude_euc1.txt-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00021462200000010867, "outcome": "passed"}, "call": {"duration": 0.0004527200000001841, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/_ude_euc1.txt', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xbf\\xaa\\xbb\\xe7\\xc0\\xfb \\xbf\\xb9\\xbc\\xf6 \\xbf\\xac\\xb1\\xb8\\xc0\\xda\\xb5\\xe9\\xc0\\xba \\xba\\xb9\\xc0\\xbd\\xbc\\xa...b4\\xeb\\xc7\\xd1 \\xbf\\xac\\xb1\\xb8 \\xbc\\xba\\xb0\\xfa\\xb5\\xe9\\xc0\\xbb \\xbc\\xd2\\xb0\\xb3\\xc7\\xcf\\xb0\\xed \\xc0\\xd6\\xb4\\xd9.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018788399999980498, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/lennon81.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/lennon81.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/lennon81.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019400000000002748, "outcome": "passed"}, "call": {"duration": 0.001711100999999715, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/lennon81.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://lennon81.egloos.com/index.xml\\nExpect: EUC-...c\\xbe\\xdf\\xb1\\xe2</category>\\n\\t\\t<pubDate>Fri, 20 May 2005 10:49:24 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017360100000018974, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/sparcs.kaist.ac.kr.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/sparcs.kaist.ac.kr.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/sparcs.kaist.ac.kr.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00018770699999981488, "outcome": "passed"}, "call": {"duration": 0.001808621999999982, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/sparcs.kaist.ac.kr.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\"  encoding=\"EUC-KR\" ?>\\n<!--\\nSource: http://sparcs.kaist.ac.kr/~ari/article.rss.xml\\nE...12:17:44 +0900</pubDate>\\n<category>article</category>\\n<author>ari</author>\\n</item>\\n\\n\\n\\n</channel>\\n</rss>\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017375699999977456, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/poliplus.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/poliplus.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/poliplus.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00018638900000000902, "outcome": "passed"}, "call": {"duration": 0.0018291670000003535, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/poliplus.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://poliplus.egloos.com/index.xml\\nExpect: EUC-...cc\\xba\\xd0\\xb7\\xf9</category>\\n\\t\\t<pubDate>Thu, 8 Dec 2005 15:51:56 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001739469999999521, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/blog.rss.naver.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/blog.rss.naver.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/blog.rss.naver.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00018987199999997983, "outcome": "passed"}, "call": {"duration": 0.0013034810000003283, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/blog.rss.naver.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-KR\" ?>\\n<!--\\nSource: http://blog.rss.naver.com/alphathinker.xml\\nExpect...<pubDate>Mon, 05 Apr 2004 16:05:52 +0900</pubDate>\\n\\t\\t\\t\\t</item>\\n\\n\\t\\t\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018271099999989104, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/blog.empas.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/blog.empas.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/blog.empas.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019007599999998348, "outcome": "passed"}, "call": {"duration": 0.0007537529999996906, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/blog.empas.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\"?>\\n<!--\\nSource: http://blog.empas.com/limpidly/rss.xml\\nExpect: EUC...xb4\\xd9. \\xbe\\xc8\\xb3\\xe7\\xc8\\xf7 \\xb0\\xe8\\xbd\\xca\\xbd\\xc3\\xbf\\xc0. </description>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018023400000011236, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/birder.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/birder.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/birder.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00018512900000011712, "outcome": "passed"}, "call": {"duration": 0.0027413069999999706, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/birder.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://birder.egloos.com/index.xml\\nExpect: EUC-KR... \\xc8\\xb2\\xc8\\xa6</category>\\n\\t\\t<pubDate>Wed, 29 Jun 2005 13:38:22 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001744610000002922, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/blog.bd-lab.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/blog.bd-lab.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/blog.bd-lab.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00018615999999971322, "outcome": "passed"}, "call": {"duration": 0.002190628000000139, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/blog.bd-lab.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-KR\"?>\\n<!--\\nSource: http://blog.bd-lab.com/blog/index.xml\\nExpect: EUC-...e\\xb1\\xd7\\xb7\\xa1\\xb9\\xd6</dc:subject>\\n<dc:date>2005-04-18T18:09:24+09:00</dc:date>\\n</item>\\n\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017238800000018983, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/_chromium_windows-949_with_no_encoding_specified.html-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/_chromium_windows-949_with_no_encoding_specified.html-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/_chromium_windows-949_with_no_encoding_specified.html-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019595700000030192, "outcome": "passed"}, "call": {"duration": 0.0004798810000004039, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/_chromium_windows-949_with_no_encoding_specified.html'\nencoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html>\\n <head>\\n  <title> windows-949 </title>\\n </head>\\n\\n <body>\\n  \\xc7\\xd1\\xb3\\xaa\\xb6\\xf3\\xb4\\xe7\\x...\\xcf\\xb6\\xf3\\xb4\\xc2 \\xb0\\xf8\\xb9\\xae\\xc0\\xbb \\xb0\\xa2\\xb0\\xa2 \\xb9\\xdf\\xbc\\xdb\\xc7\\xdf\\xb4\\xd9.\\n </body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017324199999979584, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/oroll.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/oroll.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/oroll.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00018926400000029986, "outcome": "passed"}, "call": {"duration": 0.0016769530000000366, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/oroll.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\r\\n<!--\\nSource: http://oroll.egloos.com/index.xml\\nExpect: EUC-K...xa2\\xbe</category>\\r\\n\\t\\t<pubDate>Sat, 30 Apr 2005 02:43:14 GMT</pubDate>\\r\\n\\t</item>\\r\\n\\t</channel>\\r\\n</rss>\\r\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018483299999960678, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/console.linuxstudy.pe.kr.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/console.linuxstudy.pe.kr.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/console.linuxstudy.pe.kr.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.0001908620000001804, "outcome": "passed"}, "call": {"duration": 0.00250976199999986, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/console.linuxstudy.pe.kr.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://console.linuxstudy.pe.kr/blog/index.xml\\nEx...xb0\\xed \\xbd\\xcd\\xc0\\xba \\xbf\\xb5\\xc8\\xad. \\xc4\\xe7. \\xc4\\xe7. \\xc4\\xe7.</description>\\n</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017175400000013497, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/alogblog.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/alogblog.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/alogblog.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019396600000032294, "outcome": "passed"}, "call": {"duration": 0.002431838999999769, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/alogblog.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-KR\"?>\\n<!--\\nSource: http://alogblog.com/blog/index.xml\\nExpect: EUC-KR\\...\\xb1 \\xc0\\xfa\\xb7\\xb1</category>\\n<pubDate>Sat, 23 Oct 2004 14:16:00 +0900</pubDate>\\n</item>\\n\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001740029999997006, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/_mozilla_bug9357_text.html-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/_mozilla_bug9357_text.html-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/_mozilla_bug9357_text.html-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.0001910509999998311, "outcome": "passed"}, "call": {"duration": 0.00040259300000000664, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/_mozilla_bug9357_text.html', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<!DOCTYPE html>\\n<html>\\n<head>\\n <title>EUC-KR test</title>\\n</head>\\n<body>\\n <p>\\xbf\\xe4\\xc3\\xbb\\xc7\\xc...b8\\xa6 \\xc0\\xcc\\xbf\\xeb\\xc7\\xcf\\xbd\\xc3\\xb1\\xe2 \\xb9\\xd9\\xb6\\xf8\\xb4\\xcf\\xb4\\xd9 </p>\\n</body>\\n</html>\\n\\n\\n\\n\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018374699999990085, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/epitaph.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/epitaph.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/epitaph.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019295699999988258, "outcome": "passed"}, "call": {"duration": 0.0021876849999999948, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/epitaph.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://epitaph.egloos.com/index.xml\\nExpect: EUC-K...c\\xbe\\xdf\\xb1\\xe2</category>\\n\\t\\t<pubDate>Wed, 24 Aug 2005 23:40:18 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017800899999986797, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/arts.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/arts.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/arts.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00020067399999978974, "outcome": "passed"}, "call": {"duration": 0.003789978999999999, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/arts.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://arts.egloos.com/index.xml\\nExpect: EUC-KR\\n...c\\xba\\xd0\\xb7\\xf9</category>\\n\\t\\t<pubDate>Sat, 19 Feb 2005 12:08:16 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001711509999999805, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/acnnewswire.net.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/acnnewswire.net.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/acnnewswire.net.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00018968799999985464, "outcome": "passed"}, "call": {"duration": 0.0025412070000001563, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/acnnewswire.net.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://www.acnnewswire.net/rss2/press_rss_20k.asp\\.../Article.Asp?lang=_k&amp;Art_ID=29771</guid><pubDate>Thu, 21 July 2005 14:00:00+0900</pubDate></item></channel></rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001737059999999957, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/_ude_euc2.txt-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/_ude_euc2.txt-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/_ude_euc2.txt-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019870600000038152, "outcome": "passed"}, "call": {"duration": 0.0005565880000002466, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/_ude_euc2.txt', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"\\xba\\xcf\\xc1\\xb6\\xbc\\xb1 \\xbb\\xe7\\xb6\\xf7\\xb5\\xe9\\xc0\\xba \\xc8\\xe7\\xc8\\xf7 \\xc0\\xda\\xb1\\xb9\\xc0\\xbb \\xc1\\x...) \\xba\\xcf\\xc2\\xca\\'\\xc0\\xbb \\xc0\\xc7\\xb9\\xcc\\xc7\\xcf\\xb4\\xc2 North Korea\\xb6\\xf3\\xb0\\xed \\xba\\xce\\xb8\\xa5\\xb4\\xd9.\\n\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001770709999999731, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/chisato.info.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/chisato.info.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/chisato.info.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00020335199999976794, "outcome": "passed"}, "call": {"duration": 0.01484661900000006, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/chisato.info.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://chisato.info/blog/index.xml\\nExpect: EUC-KR...or>\\xc7\\xcf\\xb3\\xeb\\xbe\\xc6</author>\\n<pubDate>Thu,  1 Sep 2005 22:35:29 +0900</pubDate>\\n</item>\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.000171906000000277, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/tori02.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/tori02.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/tori02.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.0001940309999999279, "outcome": "passed"}, "call": {"duration": 0.004308972000000022, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/tori02.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://tori02.egloos.com/index.xml\\nExpect: EUC-KR...9\\xc0\\xcc\\xbc\\xc7</category>\\n\\t\\t<pubDate>Sat, 19 Mar 2005 01:47:31 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017391199999972073, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/critique.or.kr.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/critique.or.kr.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/critique.or.kr.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019014800000016763, "outcome": "passed"}, "call": {"duration": 0.0015899049999998915, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/critique.or.kr.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://www.critique.or.kr/tt/index.xml\\nExpect: EU...category>\\n<author>slowhand</author>\\n<pubDate>Fri, 09 Dec 2005 20:06:41 +0900</pubDate>\\n</item>\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001726889999997816, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/siwoo.org.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/siwoo.org.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/siwoo.org.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00018717100000031905, "outcome": "passed"}, "call": {"duration": 0.003003934000000097, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/siwoo.org.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://siwoo.org/tt/index.xml\\nExpect: EUC-KR\\n-->...n</category>\\n<author>siwoo</author>\\n<pubDate>Wed, 15 Jun 2005 10:18:21 +0900</pubDate>\\n</item>\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001749470000000919, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/jely.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/jely.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/jely.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019214199999995074, "outcome": "passed"}, "call": {"duration": 0.004909569999999697, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/jely.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://jely.egloos.com/index.xml\\nExpect: EUC-KR\\n...category>planning</category>\\n\\t\\t<pubDate>Thu, 15 Dec 2005 00:48:44 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017314099999987675, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/yunho.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/yunho.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/yunho.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019182899999981018, "outcome": "passed"}, "call": {"duration": 0.005064544999999754, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/yunho.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://yunho.egloos.com/index.xml\\nExpect: EUC-KR\\...7\\xb7\\xa1\\xb9\\xd6</category>\\n\\t\\t<pubDate>Sun, 23 Oct 2005 13:20:39 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017692300000016203, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/calmguy.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/calmguy.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/calmguy.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019071000000003835, "outcome": "passed"}, "call": {"duration": 0.006051047000000143, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/calmguy.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://calmguy.egloos.com/index.xml\\nExpect: EUC-K...c\\xba\\xd0\\xb7\\xf9</category>\\n\\t\\t<pubDate>Tue, 14 Jun 2005 04:24:28 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017863099999981813, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/jely.pe.kr.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/jely.pe.kr.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/jely.pe.kr.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00019524199999976233, "outcome": "passed"}, "call": {"duration": 0.00450322099999978, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/jely.pe.kr.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-KR\"?>\\n<!--\\nSource: http://jely.pe.kr/index.xml\\nExpect: EUC-KR\\n-->\\n<...d>\\n<dc:subject>monologue</dc:subject>\\n<dc:date>2004-10-19T08:53:44+09:00</dc:date>\\n</item>\\n\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017505199999989784, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/jowchung.oolim.net.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/jowchung.oolim.net.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/jowchung.oolim.net.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.0001935070000000927, "outcome": "passed"}, "call": {"duration": 0.008993615000000066, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/jowchung.oolim.net.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\r\\n<!--\\nSource: http://jowchung.oolim.net/index.xml\\nExpect: EUC...ory>\\r\\n<author>JWC</author>\\r\\n<pubDate>Fri, 23 Sep 2005 02:43:10 +0900</pubDate>\\r\\n</item>\\r\\n</channel>\\r\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017231999999989256, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/kina.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/kina.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/kina.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00020013600000012843, "outcome": "passed"}, "call": {"duration": 0.002201616999999878, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/kina.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://kina.egloos.com/index.xml\\nExpect: EUC-KR\\n...c\\xba\\xd0\\xb7\\xf9</category>\\n\\t\\t<pubDate>Sun, 16 May 2004 08:59:23 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017453500000019773, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-KR/scarletkh2.egloos.com.xml-euc-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-KR/scarletkh2.egloos.com.xml-euc-kr]", "parametrize", "pytestmark", "tests/EUC-KR/scarletkh2.egloos.com.xml-euc-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00018493899999993957, "outcome": "passed"}, "call": {"duration": 0.002462948999999881, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-KR/scarletkh2.egloos.com.xml', encoding = 'euc-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<!--\\nSource: http://scarletkh2.egloos.com/index.xml\\nExpect: EU...c\\xba\\xd0\\xb7\\xf9</category>\\n\\t\\t<pubDate>Fri, 22 Jul 2005 04:46:07 GMT</pubDate>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018598599999997134, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/susu.ac.ru.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/susu.ac.ru.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/susu.ac.ru.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00019117200000007273, "outcome": "passed"}, "call": {"duration": 0.005483977000000362, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/susu.ac.ru.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\"?>\\n<!--\\nSource: http://susu.ac.ru/ru/news/rss\\nExpect: KOI8-R\\n-->\\...de\\xc1\\xcc\\xcf \\xd7 13.00.</yandex:full-text>\\n<guid>http://susu.ac.ru/ru/news/1321</guid>\\n</item>\\n</channel></rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017309400000087294, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/_ude_1.txt-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/_ude_1.txt-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/_ude_1.txt-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00018816600000004513, "outcome": "passed"}, "call": {"duration": 0.0006883030000004453, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/_ude_1.txt', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xf7 \\xc7\\xc9\\xcd\\xce\\xc1\\xda\\xc9\\xc9 \\xcf\\xce \\xce\\xc5 \\xc2\\xd9\\xcc \\xd7 \\xde\\xc9\\xd3\\xcc\\xc5 \\xd0\\xc5\\xd...xd4\\xd4\\xc5\\xd3\\xd4\\xc1\\xd4 \\xc9 \\xd0\\xcf\\xd7\\xd4\\xcf\\xd2\\xc9\\xd4\\xd8 \\xd0\\xcf\\xd3\\xd4\\xd5\\xd0\\xcc\\xc5\\xce\\xc9\\xc5.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001717030000003561, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/kapranoff.ru.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/kapranoff.ru.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/kapranoff.ru.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00019827499999980347, "outcome": "passed"}, "call": {"duration": 0.002081454999999899, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/kapranoff.ru.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\"?>\\n<!--\\nSource: http://kapranoff.ru/index.rdf\\nExpect: KOI8-R\\n-->\\.../dc:subject>\\n<dc:creator>kappa</dc:creator>\\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018401999999984042, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/newsru.com.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/newsru.com.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/newsru.com.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00018500199999937905, "outcome": "passed"}, "call": {"duration": 0.006046262999999996, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/newsru.com.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\"?>\\n<!--\\nSource: http://www.newsru.com/plain/rss/all.xml\\nExpect: KO...\"http://www.newsru.com/pict/id/large/819577_20060103092327.gif\" type=\"image/jpeg\" />\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017029999999973455, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/music.peeps.ru.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/music.peeps.ru.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/music.peeps.ru.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.000185092999999803, "outcome": "passed"}, "call": {"duration": 0.0023020609999999664, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/music.peeps.ru.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\"?>\\n<!--\\nSource: http://music.peeps.ru/news/action_rss.xml\\nExpect: ...\\xc4\\xce\\xd9\\xc8 \\xd0\\xc1\\xce\\xcb-\\xc7\\xd2\\xd5\\xd0\\xd0 90-\\xc8. </description>\\n\\t\\t</item>\\n\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001734159999999818, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/aviaport.ru.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/aviaport.ru.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/aviaport.ru.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.0001895479999998173, "outcome": "passed"}, "call": {"duration": 0.016985070999999685, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/aviaport.ru.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\"?>\\n<!--\\nSource: http://www.aviaport.ru/news/yandex_export.xml\\nExpe...xcf\\xca \\xd3\\xd4\\xd2\\xc1\\xc8\\xcf\\xd7\\xcb\\xc9.\\n\\t\\t\\t</yandex:full-text>\\n\\t\\t</item>\\n\\n\\t</channel>\\n</rss>\\n\\t\\t\\t')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00023655400000066606, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.6.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.6.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/forum.template-toolkit.ru.6.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.0002333919999992773, "outcome": "passed"}, "call": {"duration": 0.008313442000000393, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/forum.template-toolkit.ru.6.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\" ?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_6.rss\\n...6.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00022280200000057704, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/janulalife.blogspot.com.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/janulalife.blogspot.com.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/janulalife.blogspot.com.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.0002223239999992188, "outcome": "passed"}, "call": {"duration": 0.005076544999999655, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/janulalife.blogspot.com.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"KOI8-R\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/st...\\xcf\\xc9.\\n<br/>\\n</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001809900000004916, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/_chromium_KOI8-R_with_no_encoding_specified.html-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/_chromium_KOI8-R_with_no_encoding_specified.html-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/_chromium_KOI8-R_with_no_encoding_specified.html-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00020200099999989618, "outcome": "passed"}, "call": {"duration": 0.0005131170000005625, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/_chromium_KOI8-R_with_no_encoding_specified.html'\nencoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html>\\n <head>\\n  <title> KOI8-R </title>\\n </head>\\n\\n <body>\\n  \\xed\\xef\\xf3\\xeb\\xf7\\xe1, 9 \\xd1\\xce\\xd...\\xcf \\xd0\\xd2\\xc5\\xd2\\xd7\\xc1\\xce\\xce\\xd9\\xc5 \\xc4\\xd7\\xc1 \\xc4\\xce\\xd1 \\xce\\xc1\\xda\\xc1\\xc4 ...\\n </body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017016099999977996, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/aif.ru.health.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/aif.ru.health.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/aif.ru.health.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.0001866580000005058, "outcome": "passed"}, "call": {"duration": 0.0024090900000004467, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/aif.ru.health.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\"?>\\n<!--\\nSource: http://www.aif.ru/info/rss.php?magazine=health\\nExp...d2\\xc1\\xcc\\xd8\\xce\\xd9\\xc8 \\xd0\\xd2\\xcf\\xc4\\xd5\\xcb\\xd4\\xcf\\xd7.\\t\\t</description>\\n\\t</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017360399999954979, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/intertat.ru.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/intertat.ru.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/intertat.ru.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00018746499999977573, "outcome": "passed"}, "call": {"duration": 0.017324443999999772, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/intertat.ru.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\"?>\\n<!--\\nSource: http://intertat.ru/myyandex.php\\nExpect: KOI8-R\\n--...\\xca \\xc9\\xce\\xc6\\xcf\\xd2\\xcd\\xc1\\xc3\\xc9\\xc9.                           </yandex:full-text></item></channel></rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019355799999942747, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.9.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.9.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/forum.template-toolkit.ru.9.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00020363999999961635, "outcome": "passed"}, "call": {"duration": 0.0010977519999997298, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/forum.template-toolkit.ru.9.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\" ?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_9.rss\\n...9.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018218000000036483, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/aug32.hole.ru.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/aug32.hole.ru.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/aug32.hole.ru.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00020019499999968104, "outcome": "passed"}, "call": {"duration": 0.000511890999999487, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/aug32.hole.ru.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"KOI8-R\" ?>\\n<!--\\nSource: http://aug32.hole.ru/afisha/feed.php\\nExpect: KOI8...</description>\\n          <link>http://aug32.hole.ru/afisha.htm</link>\\n        </item>\\n    </channel>\\n</rss>\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017604299999973705, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/blog.mlmaster.com.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/blog.mlmaster.com.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/blog.mlmaster.com.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00020289400000006452, "outcome": "passed"}, "call": {"duration": 0.0019116629999995638, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/blog.mlmaster.com.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\"?>\\n<!--\\nSource: http://blog.mlmaster.com/wp-rss2.php\\nExpect: KOI8-...\\t\\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019146500000033484, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/koi.kinder.ru.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/koi.kinder.ru.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/koi.kinder.ru.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00020221100000039627, "outcome": "passed"}, "call": {"duration": 0.006461271000000046, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/koi.kinder.ru.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"KOI8-R\"?>\\n<!--\\nSource: http://koi.kinder.ru/rss/kinder_news_koi8.xml\\nExpe...ubDate>Mon, 04 Oct 2004 16:28:31 +0300</pubDate>\\n<author>otter@kinder.ru</author>\\n</item>\\n\\n</channel>\\n</rss>\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00022033900000018036, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/greek.ru.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/greek.ru.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/greek.ru.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00022100899999966117, "outcome": "passed"}, "call": {"duration": 0.001408284999999232, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/greek.ru.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\"?>\\n<!--\\nSource: http://www.greek.ru/news/ya/yagreek\\nExpect: KOI8-R...d3 \\xcf\\xd3\\xd4\\xd2\\xcf\\xd7\\xc1 \\xf3\\xd0\\xc5\\xc3\\xc5\\xd3... \\n</description>\\n    </item>                \\n\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018647699999974066, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.1.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.1.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/forum.template-toolkit.ru.1.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00020460300000024745, "outcome": "passed"}, "call": {"duration": 0.006472207999999924, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/forum.template-toolkit.ru.1.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\" ?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_1.rss\\n...1.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-93.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001812889999994738, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.4.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.4.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/forum.template-toolkit.ru.4.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.000214645999999874, "outcome": "passed"}, "call": {"duration": 0.0030069870000000165, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/forum.template-toolkit.ru.4.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\" ?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_4.rss\\n...-4.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018111300000001052, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/money.rin.ru.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/money.rin.ru.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/money.rin.ru.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.00019848300000013808, "outcome": "passed"}, "call": {"duration": 0.002249482999999941, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/money.rin.ru.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"KOI8-R\"?>\\n<!--\\nSource: http://money.rin.ru/news/rss/\\nExpect: KOI8-R\\n-->\\...\"   (N 1080 \\xcf\\xd4 17 \\xce\\xcf\\xd1\\xc2\\xd2\\xd1 2005 \\xc7\\xcf\\xc4\\xc1).</description>\\n</item>\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017719299999985338, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.8.xml-koi8-r]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/KOI8-R/forum.template-toolkit.ru.8.xml-koi8-r]", "parametrize", "pytestmark", "tests/KOI8-R/forum.template-toolkit.ru.8.xml-koi8-r", "test.py", "testbed", ""], "setup": {"duration": 0.000191760999999957, "outcome": "passed"}, "call": {"duration": 0.004867010999999977, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/KOI8-R/forum.template-toolkit.ru.8.xml', encoding = 'koi8-r'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"koi8-r\" ?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_8.rss\\n...8.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017778199999973765, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he3.txt-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/_ude_he3.txt-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/_ude_he3.txt-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00018947800000024273, "outcome": "passed"}, "call": {"duration": 0.002199263999999701, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/_ude_he3.txt', encoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xe0\\xe9\\xef \\xeb\\xee\\xf2\\xe8 \\xf0\\xe9\\xe1\\xe9\\xed \\xe0\\xe6\\xe5\\xf8\\xe9\\xe9\\xed \\xf2\\xe1\\xf8\\xe9\\xe9\\xed. ...\\xe8\\xe9\\xed), \\xe0\\xe5\\xec\\xed \\xf9\\xe5\\xf0\\xe9 \\xe6\\xe4 \\xe0\\xe9\\xf0\\xe5 \\xe2\\xe3\\xe5\\xec (\\xe9\\xe7\\xf1\\xe9\\xfa).\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017522599999963973, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/halemo.net.edoar.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/halemo.net.edoar.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/halemo.net.edoar.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.0001998450000000318, "outcome": "passed"}, "call": {"duration": 0.0042296620000001894, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/halemo.net.edoar.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://halemo.net/edoar/rss.xml\\nExpect: wind...xf0\\xe5\\xfa \\xe7\\xe1\\xf8\\xfa \\xee\\xe9\\xf7\\xf8\\xe5\\xf1\\xe5\\xf4\\xe8.\\n</description>\\n</item>\\n\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017263199999995038, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.8.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.8.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/notes.co.il.8.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.0001880799999991467, "outcome": "passed"}, "call": {"duration": 0.002927101000000043, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/notes.co.il.8.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.notes.co.il/rss.asp?b=8\\nExpect: w...\\xe5? \\xe0\\xe5 \\xf9...&lt;/div&gt;</description><pubDate>2005-10-20T12:47:00+02:00</pubDate></item></channel></rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017424700000034932, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/hydepark.hevre.co.il.7957.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/hydepark.hevre.co.il.7957.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/hydepark.hevre.co.il.7957.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00018864300000043244, "outcome": "passed"}, "call": {"duration": 0.021542569000000178, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/hydepark.hevre.co.il.7957.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://hydepark.hevre.co.il/hydepark/rss1.asp.../><br/>\\xfa\\xe5\\xf7\\xef \\xf2\\xec \\xe9\\xe3\\xe9 - babyfish - 01/01/2006 5:47:57]]></description></item></channel></rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001997980000005839, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/exego.net.2.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/exego.net.2.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/exego.net.2.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00020859999999967016, "outcome": "passed"}, "call": {"duration": 0.003235967000000173, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/exego.net.2.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.exego.net/forums/forumRSS.asp?f=2\\...\\xe9\\xed \\xec\\xe4\\xed?&lt;/div&gt;</description><pubDate>2005-12-28T21:54:00+02:00</pubDate></item></channel></rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017897400000066455, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/maakav.org.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/maakav.org.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/maakav.org.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00020856700000049244, "outcome": "passed"}, "call": {"duration": 0.0007880040000003419, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/maakav.org.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.maakav.org/edunuke/html/backend.ph...9\\xee\\xe4</title>\\n<link>http://www.maakav.org/edunuke/html/article.php?sid=448</link>\\n</item>\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017474699999997512, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/neviim.net.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/neviim.net.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/neviim.net.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00020288199999995982, "outcome": "passed"}, "call": {"duration": 0.0021374569999998982, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/neviim.net.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.neviim.net/wp-rss2.php\\nExpect: wi...t\\t<wfw:commentRSS>http://www.neviim.net/wp-commentsrss2.php?p=74</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001805269999994863, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/infomed.co.il.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/infomed.co.il.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/infomed.co.il.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00018629100000033816, "outcome": "passed"}, "call": {"duration": 0.0021790089999997875, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/infomed.co.il.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\" ?> \\n<!--\\nSource: http://infomed.co.il/rss/rss.xml\\nExpect: w...ion>\\n   <category>\\xf9\\xe0\\xec\\xe5\\xfa \\xe5\\xfa\\xf9\\xe5\\xe1\\xe5\\xfa</category>\\n</item>\\n</channel>\\n</rss>\\n\\n\\n \\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001880120000006258, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/_chromium_ISO-8859-8_with_no_encoding_specified.html-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/_chromium_ISO-8859-8_with_no_encoding_specified.html-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/_chromium_ISO-8859-8_with_no_encoding_specified.html-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00022261600000028636, "outcome": "passed"}, "call": {"duration": 0.0005304160000001445, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/_chromium_ISO-8859-8_with_no_encoding_specified.html'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html>\\n <head>\\n  <title> ISO-8859-8 </title>\\n </head>\\n\\n <body dir=\"rtl\">\\n  \\xe1\\xee\\xf7\\xe1\\xe9\\xec ...xed \\xe2\\xe5\\xf8\\xed \\xe7\\xe9\\xf6\\xe5\\xf0\\xe9 \\xe9\\xf7\\xe1\\xf2 \\xe0\\xfa \\xe6\\xeb\\xe5\\xfa\\xe4 ...\\n </body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001758929999997605, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/whatsup.org.il.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/whatsup.org.il.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/whatsup.org.il.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00019047400000005155, "outcome": "passed"}, "call": {"duration": 0.0025833200000002776, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/whatsup.org.il.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.whatsup.org.il/backend.php\\nExpect...0\\xe6\\xe5\\xf8\\xe9\\xed \\xe0\\xe7\\xf8\\xe9\\xed \\xe1\\xf2\\xe5\\xec\\xed...&quot;</description>\\n</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017183200000037147, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/hagada.org.il.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/hagada.org.il.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/hagada.org.il.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00019839199999971413, "outcome": "passed"}, "call": {"duration": 0.0011852770000002621, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/hagada.org.il.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.hagada.org.il/hagada/html/backend....p;file=article&amp;sid=4177</link>\\n<description><span dir=\"rtl\"></span></description>\\n</item>\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017338799999944143, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he2.txt-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/_ude_he2.txt-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/_ude_he2.txt-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00019013000000001057, "outcome": "passed"}, "call": {"duration": 0.0008056850000004445, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/_ude_he2.txt', encoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xe4\\xf2\\xe1\\xf8\\xe9\\xfa \\xe4\\xe9\\xe0 \\xf9\\xf4\\xe4 \\xe4\\xee\\xf9\\xfa\\xe9\\xe9\\xeb\\xfa \\xec\\xf7\\xe1\\xe5\\xf6\\x... \\xe1\\xe9\\xee\\xe9 \\xe4\\xe1\\xe9\\xf0\\xe9\\xe9\\xed \\xe4\\xe9\\xe0 \\xee\\xf9\\xf4\\xe7\\xfa \\xe0\\xe1\\xef \\xfa\\xe9\\xe1\\xe5\\xef.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017434700000062975, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/sharks.co.il.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/sharks.co.il.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/sharks.co.il.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00019249400000020955, "outcome": "passed"}, "call": {"duration": 0.0015924060000003237, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/sharks.co.il.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.sharks.co.il/backend2.php\\nExpect:...8\\xe5 - \\xe6\\xe5\\xe4\\xe9 \\xe4\\xf7\\xec\\xe9\\xee\\xe0\\xef 50KCC.&lt;/div&gt;</description>\\n</item>\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017392400000026953, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.7.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.7.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/notes.co.il.7.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00018652500000015948, "outcome": "passed"}, "call": {"duration": 0.002767882999999749, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/notes.co.il.7.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.notes.co.il/rss.asp?b=7\\nExpect: w...c\\xe4\\xe9\\xf2\\xec\\xe1?&lt;/div&gt;</description><pubDate>2004-11-11T00:42:00+02:00</pubDate></item></channel></rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001746049999997723, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/pcplus.co.il.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/pcplus.co.il.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/pcplus.co.il.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00018627000000037697, "outcome": "passed"}, "call": {"duration": 0.0007425909999998481, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/pcplus.co.il.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.pcplus.co.il/rss.php\\nExpect: wind...e5\\xf4\\xe8</title>\\n\\n<link>http://www.pcplus.co.il/opinions.php?id=139</link>\\n\\n</item>\\n\\n\\n</channel>\\n\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001735360000001407, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.50.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.50.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/notes.co.il.50.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00019010599999980116, "outcome": "passed"}, "call": {"duration": 0.0030076470000004463, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/notes.co.il.50.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.notes.co.il/rss.asp?b=50\\nExpect: ...f=\"http://www.notes...&lt;/div&gt;</description><pubDate>2005-12-03T08:00:00+02:00</pubDate></item></channel></rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00016971999999970677, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.6.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/notes.co.il.6.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/notes.co.il.6.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.0001856569999993951, "outcome": "passed"}, "call": {"duration": 0.0028666800000003434, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/notes.co.il.6.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.notes.co.il/rss.asp?b=6\\nExpect: w...d \\xe0\\xfa \\xe4\\xee...&lt;/div&gt;</description><pubDate>2005-07-14T08:14:00+02:00</pubDate></item></channel></rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017720199999970987, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/hevra.org.il.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/hevra.org.il.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/hevra.org.il.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00020262500000001182, "outcome": "passed"}, "call": {"duration": 0.0008506569999999769, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/hevra.org.il.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://hevra.org.il/backend.php\\nExpect: wind...link>http://www.hevra.org.il/modules.php?name=News&amp;file=article&amp;sid=830</link>\\n</item>\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017246499999945542, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/law.co.il.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/law.co.il.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/law.co.il.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.0001930450000005024, "outcome": "passed"}, "call": {"duration": 0.0017334729999998189, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/law.co.il.xml', encoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.law.co.il/rss.php\\nExpect: windows..., \\xf2\\xe5&amp;quot;\\xe3 \\xe9\\xe4\\xe5\\xe3\\xe4 \\xe8\\xe5\\xf0\\xe9\\xf7.\\n</description>\\n   </item>\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017737200000045306, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/_ude_he1.txt-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/_ude_he1.txt-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/_ude_he1.txt-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00019308300000009382, "outcome": "passed"}, "call": {"duration": 0.0005433890000006159, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/_ude_he1.txt', encoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xe4\\xf9\\xed \\xf2\\xe1\\xf8 \\xee\\xe5\\xf4\\xe9\\xf2 \\xe1\\xfa\\xf0\"\\xea \\xeb\\xf9\\xee\\xe5 \\xf9\\xec \\xf1\\xe1\\xe5 \\x...\\xfa \\xf9\\xee\\xe5 \\xf9\\xec \\xe4\\xf0\\xe9\\xe1 \\xf9\\xe3\\xe5\\xe1\\xf8 \\xe1\\xe0\\xe6\\xe5\\xf8 \\xe9\\xf8\\xe5\\xf9\\xec\\xe9\\xed.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017623000000011046, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/info.org.il.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/info.org.il.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/info.org.il.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00019897499999999013, "outcome": "passed"}, "call": {"duration": 0.0022920449999999093, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/info.org.il.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"WINDOWS-1255\"?>\\n<!--\\nSource: http://www.info.org.il/rss/rss.php\\nExpect: w...Indows-1255.</description>\\n<link>http://www.info.org.il/rss/index.php#90165987</link>\\n</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017364800000052583, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/_chromium_windows-1255_with_no_encoding_specified.html-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/_chromium_windows-1255_with_no_encoding_specified.html-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/_chromium_windows-1255_with_no_encoding_specified.html-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00019114200000025505, "outcome": "passed"}, "call": {"duration": 0.0005119049999997571, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/_chromium_windows-1255_with_no_encoding_specified.html'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html>\\n <head>\\n  <title> windows-1255 </title>\\n </head>\\n\\n <body dir=\"rtl\">\\n  \\xe1\\xee\\xf7\\xe1\\xe9\\xe...xed \\xe2\\xe5\\xf8\\xed \\xe7\\xe9\\xf6\\xe5\\xf0\\xe9 \\xe9\\xf7\\xe1\\xf2 \\xe0\\xfa \\xe6\\xeb\\xe5\\xfa\\xe4 ...\\n </body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017535399999957235, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/windows-1255-hebrew/carshops.co.il.xml-windows-1255]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/windows-1255-hebrew/carshops.co.il.xml-windows-1255]", "parametrize", "pytestmark", "tests/windows-1255-hebrew/carshops.co.il.xml-windows-1255", "test.py", "testbed", ""], "setup": {"duration": 0.00019790899999971856, "outcome": "passed"}, "call": {"duration": 0.032573902999999405, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/windows-1255-hebrew/carshops.co.il.xml'\nencoding = 'windows-1255'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"windows-1255\"?>\\n<!--\\nSource: http://www.carshops.co.il/rss2.php\\nExpect: w...]></description>\\n    <pubDate><![CDATA[Fri, 27 Aug 2004 00:00:00 +0300]]></pubDate>\\n  </item>\\n  </channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017374699999983534, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.wld.xml-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.wld.xml-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/naftemporiki.gr.wld.xml-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.00019629200000004232, "outcome": "passed"}, "call": {"duration": 0.002898800999999729, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.wld.xml'\nencoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-7\"?>\\n<!--\\nSource: http://www.naftemporiki.gr/news/static/rss/news....gr (\\xc7 \\xcd\\xc1\\xd5\\xd4\\xc5\\xcc\\xd0\\xcf\\xd1\\xc9\\xca\\xc7 ON LINE)</author>\\n</item>\\n\\n\\n\\n</channel>\\n</rss>\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017756499999954656, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/disabled.gr.xml-iso-8859-7]", "lineno": 75, "outcome": "xfailed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/disabled.gr.xml-iso-8859-7]", "parametrize", "xfail", "pytestmark", "tests/iso-8859-7-greek/disabled.gr.xml-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.00021189200000026887, "outcome": "passed"}, "call": {"duration": 0.0027665600000004176, "outcome": "skipped", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/disabled.gr.xml', encoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-7\"?>\\n<!--\\nSource: http://www.disabled.gr/at/wp-rss2.php\\nExpect: ...\\t<wfw:commentRSS>http://www.disabled.gr/at/?feed=rss2&amp;p=2553</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017585699999944637, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.fin.xml-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.fin.xml-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/naftemporiki.gr.fin.xml-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.0001879639999993188, "outcome": "passed"}, "call": {"duration": 0.0013773609999994108, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.fin.xml'\nencoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-7\"?>\\n<!--\\nSource: http://www.naftemporiki.gr/news/static/rss/news...\\n<description></description>\\n<author>editor@ana.gr (\\xc1\\xd0\\xc5)</author>\\n</item>\\n\\n\\n\\n</channel>\\n</rss>\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001755800000005081, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrt.xml-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrt.xml-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/naftemporiki.gr.mrt.xml-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.00019373700000002714, "outcome": "passed"}, "call": {"duration": 0.001376679999999908, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.mrt.xml'\nencoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-7\"?>\\n<!--\\nSource: http://www.naftemporiki.gr/news/static/rss/news...emporiki.gr (\\xc7 \\xcd\\xc1\\xd5\\xd4\\xc5\\xcc\\xd0\\xcf\\xd1\\xc9\\xca\\xc7)</author>\\n</item>\\n\\n\\n\\n</channel>\\n</rss>\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001792110000007341, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.cmm.xml-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.cmm.xml-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/naftemporiki.gr.cmm.xml-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.00020526799999931455, "outcome": "passed"}, "call": {"duration": 0.001259651999999889, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.cmm.xml'\nencoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-7\"?>\\n<!--\\nSource: http://www.naftemporiki.gr/news/static/rss/news...emporiki.gr (\\xc7 \\xcd\\xc1\\xd5\\xd4\\xc5\\xcc\\xd0\\xcf\\xd1\\xc9\\xca\\xc7)</author>\\n</item>\\n\\n\\n\\n</channel>\\n</rss>\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001833520000005251, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.bus.xml-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.bus.xml-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/naftemporiki.gr.bus.xml-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.0001959590000000233, "outcome": "passed"}, "call": {"duration": 0.0013734789999997332, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.bus.xml'\nencoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-7\"?>\\n<!--\\nSource: http://www.naftemporiki.gr/news/static/rss/news...emporiki.gr (\\xc7 \\xcd\\xc1\\xd5\\xd4\\xc5\\xcc\\xd0\\xcf\\xd1\\xc9\\xca\\xc7)</author>\\n</item>\\n\\n\\n\\n</channel>\\n</rss>\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017718199999983142, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_2.txt-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/_ude_2.txt-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/_ude_2.txt-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.00019597199999932258, "outcome": "passed"}, "call": {"duration": 0.0007049820000002427, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/_ude_2.txt', encoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xc4\\xf9\\xf1\\xe5\\xdc\\xed \\xf3\\xf4\\xef \\xcf\\xe9 \\xb6\\xed\\xe5\\xec\\xef\\xe9, \\xf4\\xef \\xcc\\xde\\xed\\xf5\\xec\\xe1...1\\xe3\\xfc\\xed\\xe9\\xe1 \\xe1\\xeb\\xeb\\xdc \\xe4\\xe5 \\xf6\\xe1\\xdf\\xed\\xe5\\xf4\\xe1\\xe9 \\xed\\xe1 \\xec\\xf0\\xef\\xf1\\xe5\\xdf.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018397499999966982, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.spo.xml-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.spo.xml-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/naftemporiki.gr.spo.xml-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.00019366699999956438, "outcome": "passed"}, "call": {"duration": 0.0013163920000005547, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.spo.xml'\nencoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-7\"?>\\n<!--\\nSource: http://www.naftemporiki.gr/news/static/rss/news...\\n<description></description>\\n<author>editor@ana.gr (\\xc1\\xd0\\xc5)</author>\\n</item>\\n\\n\\n\\n</channel>\\n</rss>\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017368600000011725, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/_chromium_ISO-8859-7_with_no_encoding_specified.html-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/_chromium_ISO-8859-7_with_no_encoding_specified.html-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/_chromium_ISO-8859-7_with_no_encoding_specified.html-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.0001902840000003181, "outcome": "passed"}, "call": {"duration": 0.00045968900000037394, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/_chromium_ISO-8859-7_with_no_encoding_specified.html'\nencoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html>\\n <head>\\n  <title> ISO-8859-7 </title>\\n </head>\\n\\n <body>\\n  \\xcc\\xe5 \\xef\\xec\\xe9\\xeb\\xdf\\xe1 \\...e5\\xe9\\xf2 \\xf4\\xef\\xf5 \\xca\\xca\\xc5 \\xe3\\xe9\\xe1 \\xf4\\xef \\xe1\\xe3\\xf1\\xef\\xf4\\xe9\\xea\\xfc, ...\\n </body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017208399999990576, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrk.xml-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/naftemporiki.gr.mrk.xml-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/naftemporiki.gr.mrk.xml-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.0001844230000003222, "outcome": "passed"}, "call": {"duration": 0.0013095650000005676, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/naftemporiki.gr.mrk.xml'\nencoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-7\"?>\\n<!--\\nSource: http://www.naftemporiki.gr/news/static/rss/news...emporiki.gr (\\xc7 \\xcd\\xc1\\xd5\\xd4\\xc5\\xcc\\xd0\\xcf\\xd1\\xc9\\xca\\xc7)</author>\\n</item>\\n\\n\\n\\n</channel>\\n</rss>\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017335099999993275, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_greek.txt-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/_ude_greek.txt-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/_ude_greek.txt-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.00018690900000084554, "outcome": "passed"}, "call": {"duration": 0.0005144779999994853, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/_ude_greek.txt', encoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xc7 \\xe5\\xeb\\xeb\\xe7\\xed\\xe9\\xea\\xde \\xe1\\xf0\\xef\\xf4\\xe5\\xeb\\xe5\\xdf \\xf4\\xe7 \\xec\\xe7\\xf4\\xf1\\xe9\\xea\\x...xfe\\xf3\\xf3\\xe1 \\xe5\\xdf\\xed\\xe1\\xe9 \\xe3\\xfd\\xf1\\xf9 \\xf3\\xf4\\xe1 20 \\xe5\\xea\\xe1\\xf4\\xef\\xec\\xec\\xfd\\xf1\\xe9\\xe1.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001788100000004178, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_3.txt-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/_ude_3.txt-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/_ude_3.txt-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.00018991699999926226, "outcome": "passed"}, "call": {"duration": 0.0005016750000006454, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/_ude_3.txt', encoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xc7 \\xe5\\xeb\\xeb\\xe7\\xed\\xe9\\xea\\xde \\xe1\\xf0\\xef\\xf4\\xe5\\xeb\\xe5\\xdf \\xf4\\xe7 \\xec\\xe7\\xf4\\xf1\\xe9\\xea\\x...xfe\\xf3\\xf3\\xe1 \\xe5\\xdf\\xed\\xe1\\xe9 \\xe3\\xfd\\xf1\\xf9 \\xf3\\xf4\\xe1 20 \\xe5\\xea\\xe1\\xf4\\xef\\xec\\xec\\xfd\\xf1\\xe9\\xe1.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018194200000021254, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/hotstation.gr.xml-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/hotstation.gr.xml-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/hotstation.gr.xml-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.00018634300000019977, "outcome": "passed"}, "call": {"duration": 0.0008290730000002355, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/hotstation.gr.xml', encoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-7\"?>\\n<!--\\nSource: http://www.hotstation.gr/backend.php\\nExpect: I...ink>http://www.HotStation.gr/modules.php?name=News&amp;file=article&amp;sid=855</link>\\n</item>\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.000182131999999946, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-7-greek/_ude_1.txt-iso-8859-7]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-7-greek/_ude_1.txt-iso-8859-7]", "parametrize", "pytestmark", "tests/iso-8859-7-greek/_ude_1.txt-iso-8859-7", "test.py", "testbed", ""], "setup": {"duration": 0.0001856740000008017, "outcome": "passed"}, "call": {"duration": 0.0007958019999998456, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-7-greek/_ude_1.txt', encoding = 'iso-8859-7'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xb8\\xed\\xe1\\xf2 \\xe4\\xe9\\xe1\\xe4\\xe9\\xea\\xf4\\xf5\\xe1\\xea\\xfc\\xf2 \\xec\\xe1\\xf2 \\xf6\\xdf\\xeb\\xef\\xf2, \\xf4\\...xea\\xdc \\xe1\\xe9\\xf3\\xe8\\xde\\xec\\xe1\\xf4\\xe1 \\xf0\\xf1\\xef\\xf2 \\xf4\\xef\\xed \\xe1\\xf0\\xef\\xe8\\xe1\\xed\\xfc\\xed\\xf4\\xe1. ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017441699999931615, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16/bom-utf-16-be.srt-utf-16]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-16/bom-utf-16-be.srt-utf-16]", "parametrize", "pytestmark", "tests/UTF-16/bom-utf-16-be.srt-utf-16", "test.py", "testbed", ""], "setup": {"duration": 0.0002006000000003283, "outcome": "passed"}, "call": {"duration": 0.0004734790000000544, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-16/bom-utf-16-be.srt', encoding = 'utf-16'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"\\xfe\\xff\\x001\\x00\\n\\x000\\x000\\x00:\\x000\\x000\\x00:\\x000\\x006\\x00,\\x005\\x000\\x000\\x00 \\x00-\\x00-\\x00>\\x00 \\x...\\x00 \\x00g\\x00l\\x00o\\x00b\\x00a\\x00l\\x00 \\x00a\\x00w\\x00a\\x00r\\x00e\\x00n\\x00e\\x00s\\x00s\\x00 \\x00d\\x00a\\x00y\\x00\\n\\x00\\n\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001735219999998705, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-16/bom-utf-16-le.srt-utf-16]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-16/bom-utf-16-le.srt-utf-16]", "parametrize", "pytestmark", "tests/UTF-16/bom-utf-16-le.srt-utf-16", "test.py", "testbed", ""], "setup": {"duration": 0.00018881100000012196, "outcome": "passed"}, "call": {"duration": 0.0004963560000001976, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-16/bom-utf-16-le.srt', encoding = 'utf-16'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"\\xff\\xfe1\\x00\\n\\x000\\x000\\x00:\\x000\\x000\\x00:\\x000\\x006\\x00,\\x005\\x000\\x000\\x00 \\x00-\\x00-\\x00>\\x00 \\x000\\... \\x00g\\x00l\\x00o\\x00b\\x00a\\x00l\\x00 \\x00a\\x00w\\x00a\\x00r\\x00e\\x00n\\x00e\\x00s\\x00s\\x00 \\x00d\\x00a\\x00y\\x00\\n\\x00\\n\\x00\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017136199999967516, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/CP949/ricanet.com.xml-cp949]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/CP949/ricanet.com.xml-cp949]", "parametrize", "pytestmark", "tests/CP949/ricanet.com.xml-cp949", "test.py", "testbed", ""], "setup": {"duration": 0.00019711900000007887, "outcome": "passed"}, "call": {"duration": 0.00873756200000031, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/CP949/ricanet.com.xml', encoding = 'cp949'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-kr\" ?>\\n<rss version=\\'0.92\\'>\\n<channel>\\n<docs></docs>\\n<title>\\xb8\\xa...--end-->]]></description>\\n<link>http://ricanet.com/new/view.php?id=blog/100206</link>\\n</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017759300000008693, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/music.peeps.ru.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/music.peeps.ru.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/music.peeps.ru.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00019706600000013452, "outcome": "passed"}, "call": {"duration": 0.00370849099999937, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/music.peeps.ru.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://music.peeps.ru/news/action_rss.xml\\nExpe...\\xd4\\xdd\\xeb\\xe5 \\xdf\\xd0\\xdd\\xda-\\xd3\\xe0\\xe3\\xdf\\xdf 90-\\xe5. </description>\\n\\t\\t</item>\\n\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017957100000032256, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/intertat.ru.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/intertat.ru.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/intertat.ru.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.0001953380000001559, "outcome": "passed"}, "call": {"duration": 0.0004930569999999079, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/intertat.ru.xml', encoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://intertat.ru/myyandex.php\\nExpect: ISO-88...\\xd8\\xd4\\xd5\\xe2\\xd5\\xdb\\xec\\xe1\\xe2\\xd2\\xde \\xde \\xe0\\xd5\\xd3\\xd8\\xe1\\xe2\\xe0\\xd0\\xe6\\xd8\\xd8 \\xc1\\xbc\\xb8 \\xcd\\xdb ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017289999999992034, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/aviaport.ru.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/aviaport.ru.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/aviaport.ru.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00020380600000002858, "outcome": "passed"}, "call": {"duration": 0.011908878999999928, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/aviaport.ru.xml', encoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://www.aviaport.ru/news/yandex_export.xml\\n...\\xd8 \\xd2\\xe1\\xd5\\xe5 \\xd8\\xe1\\xdf\\xeb\\xe2\\xd0\\xdd\\xd8\\xd9 - \\xd8 \\xdc\\xd0\\xe8\\xd8\\xdd\\xeb, \\xd8 \\xdb\\xee\\xd4\\xd5\\xd9')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018146999999935076, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.1.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.1.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/forum.template-toolkit.ru.1.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.0001976929999996102, "outcome": "passed"}, "call": {"duration": 0.00632559099999952, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/forum.template-toolkit.ru.1.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_1.rs...1.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-93.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017415099999951167, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.4.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.4.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/forum.template-toolkit.ru.4.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00020072700000017818, "outcome": "passed"}, "call": {"duration": 0.0028858789999999246, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/forum.template-toolkit.ru.4.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_4.rs...-4.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00030723999999970886, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/aug32.hole.ru.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/aug32.hole.ru.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/aug32.hole.ru.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00024582799999972593, "outcome": "passed"}, "call": {"duration": 0.0006362690000001336, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/aug32.hole.ru.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://aug32.hole.ru/afisha/feed.php\\nExpect: I...&gt;</description>\\n          <link>http://aug32.hole.ru/afisha.htm</link>\\n        </item>\\n    </channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018447899999962658, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/janulalife.blogspot.com.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/janulalife.blogspot.com.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/janulalife.blogspot.com.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.0001980420000000649, "outcome": "passed"}, "call": {"duration": 0.004963043000000056, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/janulalife.blogspot.com.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.co...\\xde\\xd8.\\n<br/>\\n</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017809800000012643, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/money.rin.ru.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/money.rin.ru.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/money.rin.ru.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00019251500000017074, "outcome": "passed"}, "call": {"duration": 0.0022355709999999362, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/money.rin.ru.xml', encoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://money.rin.ru/news/rss/\\nExpect: ISO-8859...  (N 1080 \\xde\\xe2 17 \\xdd\\xde\\xef\\xd1\\xe0\\xef 2005 \\xd3\\xde\\xd4\\xd0).</description>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017283500000075946, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/_chromium_ISO-8859-5_with_no_encoding_specified.html-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/_chromium_ISO-8859-5_with_no_encoding_specified.html-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/_chromium_ISO-8859-5_with_no_encoding_specified.html-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00019894500000017246, "outcome": "passed"}, "call": {"duration": 0.0005297490000000238, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/_chromium_ISO-8859-5_with_no_encoding_specified.html'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html>\\n <head>\\n  <title> ISO-8859-5 </title>\\n </head>\\n\\n <body>\\n  \\xbc\\xbe\\xc1\\xba\\xb2\\xb0, 9 \\xef\\xd...\\xde \\xdf\\xe0\\xd5\\xe0\\xd2\\xd0\\xdd\\xdd\\xeb\\xd5 \\xd4\\xd2\\xd0 \\xd4\\xdd\\xef \\xdd\\xd0\\xd7\\xd0\\xd4 ...\\n </body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017622500000058494, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.8.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.8.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/forum.template-toolkit.ru.8.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00018633299999937236, "outcome": "passed"}, "call": {"duration": 0.004715842999999609, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/forum.template-toolkit.ru.8.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_8.rs...8.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001761999999994046, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/greek.ru.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/greek.ru.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/greek.ru.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00020158500000011514, "outcome": "passed"}, "call": {"duration": 0.0008173349999998081, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/greek.ru.xml', encoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://www.greek.ru/news/ya/yagreek\\nExpect: IS...d8. \\xc0\\xde\\xd2\\xdd\\xde 29 \\xdb\\xd5\\xe2 \\xdd\\xd0\\xd7\\xd0\\xd4 \\xd2 \\xe5\\xde\\xd4\\xd5 \\xde\\xdf\\xd5\\xe0\\xd0\\xe6\\xd8\\xd8 ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017489099999945523, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/susu.ac.ru.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/susu.ac.ru.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/susu.ac.ru.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.000218040999999225, "outcome": "passed"}, "call": {"duration": 0.0006256200000001044, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/susu.ac.ru.xml', encoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://susu.ac.ru/ru/news/rss\\nExpect: ISO-8859...5\\xdd\\xd8\\xef \\xdf\\xde\\xd1\\xd5\\xd4\\xd8\\xe2\\xd5\\xdb\\xd5\\xd9 \\xda\\xde\\xdd\\xda\\xe3\\xe0\\xe1\\xd0 \\xe1\\xd0\\xd9\\xe2\\xde\\xd2 ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001783729999997874, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.6.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.6.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/forum.template-toolkit.ru.6.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00020541100000048829, "outcome": "passed"}, "call": {"duration": 0.00795178499999949, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/forum.template-toolkit.ru.6.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_6.rs...6.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00020793400000052031, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/aif.ru.health.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/aif.ru.health.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/aif.ru.health.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00020800799999953767, "outcome": "passed"}, "call": {"duration": 0.0024293410000000293, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/aif.ru.health.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://www.aif.ru/info/rss.php?magazine=health\\...e0\\xd0\\xdb\\xec\\xdd\\xeb\\xe5 \\xdf\\xe0\\xde\\xd4\\xe3\\xda\\xe2\\xde\\xd2.\\t\\t</description>\\n\\t</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.000190907000000351, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.9.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/forum.template-toolkit.ru.9.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/forum.template-toolkit.ru.9.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00020534100000002553, "outcome": "passed"}, "call": {"duration": 0.0011108430000001945, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/forum.template-toolkit.ru.9.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_9.rs...9.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001818319999999929, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/kapranoff.ru.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/kapranoff.ru.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/kapranoff.ru.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00021032300000012327, "outcome": "passed"}, "call": {"duration": 0.002078792999999912, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/kapranoff.ru.xml', encoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://kapranoff.ru/index.rdf\\nExpect: ISO-8859...dc:subject/>\\n<dc:creator>kappa</dc:creator>\\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018650600000036377, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/blog.mlmaster.com.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/blog.mlmaster.com.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/blog.mlmaster.com.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00019096800000006908, "outcome": "passed"}, "call": {"duration": 0.0018860170000003507, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/blog.mlmaster.com.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://blog.mlmaster.com/wp-rss2.php\\nExpect: I...\\t\\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017607400000052564, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-russian/newsru.com.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-russian/newsru.com.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-russian/newsru.com.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.000195311999999781, "outcome": "passed"}, "call": {"duration": 0.005942999000000171, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-russian/newsru.com.xml', encoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"ISO-8859-5\"?>\\n<!--\\nSource: http://www.newsru.com/plain/rss/all.xml\\nExpect...=\"http://www.newsru.com/pict/id/large/819577_20060103092327.gif\" type=\"image/jpeg\"/>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018499300000041075, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.analyse1.xml-tis-620]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.analyse1.xml-tis-620]", "parametrize", "pytestmark", "tests/TIS-620/pharmacy.kku.ac.th.analyse1.xml-tis-620", "test.py", "testbed", ""], "setup": {"duration": 0.000187890999999496, "outcome": "passed"}, "call": {"duration": 0.004828878999999731, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/TIS-620/pharmacy.kku.ac.th.analyse1.xml'\nencoding = 'tis-620'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"tis-620\"?>\\n<!--\\nSource: http://pharmacy.kku.ac.th/analyse1/wp-rss2.php\\nEx...entRSS>http://pharmacy.kku.ac.th/analyse1/wp-commentsrss2.php?p=3</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017498100000068462, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.healthinfo-ne.xml-tis-620]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.healthinfo-ne.xml-tis-620]", "parametrize", "pytestmark", "tests/TIS-620/pharmacy.kku.ac.th.healthinfo-ne.xml-tis-620", "test.py", "testbed", ""], "setup": {"duration": 0.0001869779999994492, "outcome": "passed"}, "call": {"duration": 0.004718289000000375, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/TIS-620/pharmacy.kku.ac.th.healthinfo-ne.xml'\nencoding = 'tis-620'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"tis-620\"?>\\n<!--\\nSource: http://pharmacy.kku.ac.th/healthinfo-ne/wp-rss2.ph...http://pharmacy.kku.ac.th/healthinfo-ne/wp-commentsrss2.php?p=386</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017496300000008347, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.centerlab.xml-tis-620]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/TIS-620/pharmacy.kku.ac.th.centerlab.xml-tis-620]", "parametrize", "pytestmark", "tests/TIS-620/pharmacy.kku.ac.th.centerlab.xml-tis-620", "test.py", "testbed", ""], "setup": {"duration": 0.00018641499999993982, "outcome": "passed"}, "call": {"duration": 0.002500961999999163, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/TIS-620/pharmacy.kku.ac.th.centerlab.xml'\nencoding = 'tis-620'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"tis-620\"?>\\n<!--\\nSource: http://pharmacy.kku.ac.th/centerlab/wp-rss2.php\\nE...ntRSS>http://pharmacy.kku.ac.th/centerlab/wp-commentsrss2.php?p=5</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019919000000001574, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/opentle.org.xml-tis-620]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/TIS-620/opentle.org.xml-tis-620]", "parametrize", "pytestmark", "tests/TIS-620/opentle.org.xml-tis-620", "test.py", "testbed", ""], "setup": {"duration": 0.0001877049999992053, "outcome": "passed"}, "call": {"duration": 0.003611702000000605, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/TIS-620/opentle.org.xml', encoding = 'tis-620'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"TIS-620\"?>\\n<!--\\nSource: http://www.opentle.org/backend.php\\nExpect: TIS-62...\\xc3\\xb9\\xd3\\xc1\\xd2\\xe3\\xaa\\xe9\\xa7\\xd2\\xb9\\xcd\\xd5\\xa1\\xb4\\xe9\\xc7\\xc2</description>\\n</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018039400000002814, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/trickspot.boxchart.com.xml-tis-620]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/TIS-620/trickspot.boxchart.com.xml-tis-620]", "parametrize", "pytestmark", "tests/TIS-620/trickspot.boxchart.com.xml-tis-620", "test.py", "testbed", ""], "setup": {"duration": 0.00018739500000020115, "outcome": "passed"}, "call": {"duration": 0.003344654000000169, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/TIS-620/trickspot.boxchart.com.xml', encoding = 'tis-620'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"TIS-620\"?>\\n<!--\\nSource: http://trickspot.boxchart.com/wp-rss2.php\\nExpect:...commentRSS>http://trickspot.boxchart.com/wp-commentsrss2.php?p=52</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019682799999998224, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/TIS-620/_mozilla_bug488426_text.html-tis-620]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/TIS-620/_mozilla_bug488426_text.html-tis-620]", "parametrize", "pytestmark", "tests/TIS-620/_mozilla_bug488426_text.html-tis-620", "test.py", "testbed", ""], "setup": {"duration": 0.00019921200000005967, "outcome": "passed"}, "call": {"duration": 0.00035303900000016597, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/TIS-620/_mozilla_bug488426_text.html', encoding = 'tis-620'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html>\\n<body>\\n\\xc3\\xcb\\xd1\\xca\\xca\\xd3\\xcb\\xc3\\xd1\\xba\\xcd\\xd1\\xa1\\xa2\\xc3\\xd0\\xe4\\xb7\\xc2\\xb7\\xd5\\xe8\\xe3\\xaa\\xe9\\xa1\\xd1\\xba\\xa4\\xcd\\xc1\\xbe\\xd4\\xc7\\xe0\\xb5\\xcd\\xc3\\xec\\n</body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017668000000004014, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-TW/_ude_euc-tw1.txt-euc-tw]", "lineno": 75, "outcome": "passed", "keywords": ["test_encoding_detection[tests/EUC-TW/_ude_euc-tw1.txt-euc-tw]", "parametrize", "pytestmark", "tests/EUC-TW/_ude_euc-tw1.txt-euc-tw", "test.py", "testbed", ""], "setup": {"duration": 0.00019245200000028717, "outcome": "passed"}, "call": {"duration": 0.00040671100000011506, "outcome": "passed"}, "teardown": {"duration": 0.00015279499999998336, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/anitabee.blogspot.com.xml-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/anitabee.blogspot.com.xml-utf-8]", "parametrize", "pytestmark", "tests/utf-8/anitabee.blogspot.com.xml-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.00018107399999944818, "outcome": "passed"}, "call": {"duration": 0.009560785999999766, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/anitabee.blogspot.com.xml', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/sty...e vagyok. </div>\\n</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.000214388999999926, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_2.txt-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_ude_2.txt-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_ude_2.txt-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.0002080019999999294, "outcome": "passed"}, "call": {"duration": 0.0005999740000000031, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_ude_2.txt', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"\\xeb\\xb6\\x81\\xec\\xa1\\xb0\\xec\\x84\\xa0 \\xec\\x82\\xac\\xeb\\x9e\\x8c\\xeb\\x93\\xa4\\xec\\x9d\\x80 \\xed\\x9d\\x94\\xed\\x9e...d\\x98\\xeb\\xaf\\xb8\\xed\\x95\\x98\\xeb\\x8a\\x94 North Korea\\xeb\\x9d\\xbc\\xea\\xb3\\xa0 \\xeb\\xb6\\x80\\xeb\\xa5\\xb8\\xeb\\x8b\\xa4.\\n\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001766979999997531, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_chromium_UTF-8_with_no_encoding_specified.html-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_chromium_UTF-8_with_no_encoding_specified.html-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_chromium_UTF-8_with_no_encoding_specified.html-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.00018977499999994762, "outcome": "passed"}, "call": {"duration": 0.00043264399999998204, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_chromium_UTF-8_with_no_encoding_specified.html'\nencoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html><head>\\n  <title> UTF-8 </title>\\n </head><body>\\n  \\xe9\\xba\\xa6\\xe8\\x92\\x82\\xe7\\x9a\\x84\\xe5\\xa4\\xa9...\\xe5\\xbf\\x85\\xe9\\xa1\\xbb\\xe5\\x8a\\xaa\\xe5\\x8a\\x9b\\xe6\\x89\\x8d\\xe8\\xa1\\x8c\\xe3\\x80\\x82\\xe2\\x80\\x9d\\n \\n\\n</body></html>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018235200000038532, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_3.txt-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_ude_3.txt-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_ude_3.txt-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.00018640800000024882, "outcome": "passed"}, "call": {"duration": 0.00033336200000011473, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_ude_3.txt', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\\\\\\\\\\\\\\\\\\\\\\\\\\\{ssss } siaaaaaaaaa  ssss<ciao>i \\xc3\\xa0 \\xc3\\xa8 \\xc3\\xac\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001734249999998383, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/weblabor.hu.2.xml-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/weblabor.hu.2.xml-utf-8]", "parametrize", "pytestmark", "tests/utf-8/weblabor.hu.2.xml-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.00019685599999963443, "outcome": "passed"}, "call": {"duration": 0.0031779600000003683, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/weblabor.hu.2.xml', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<!--\\nSource: http://weblabor.hu/node/feed\\nExpect: UTF-8\\n-->\\n<!...azis\">Adatb\\xc3\\xa1zis</category>\\n <pubDate>Mon, 19 Dec 2005 00:12:29 +0100</pubDate>\\n</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017437500000028194, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/balatonblog.typepad.com.xml-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/balatonblog.typepad.com.xml-utf-8]", "parametrize", "pytestmark", "tests/utf-8/balatonblog.typepad.com.xml-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.0002005409999998875, "outcome": "passed"}, "call": {"duration": 0.009916963000000223, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/balatonblog.typepad.com.xml', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<!--\\nSource: http://balatonblog.typepad.com/balatonblog/index.rdf...:subject>\\n\\n<dc:creator>ivcsek</dc:creator>\\n<dc:date>2005-12-05T18:26:59+01:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001864209999995481, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_he3.txt-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_ude_he3.txt-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_ude_he3.txt-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.0001876630000001711, "outcome": "passed"}, "call": {"duration": 0.00042809899999962653, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_ude_he3.txt', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xd7\\x90\\xd7\\x99\\xd7\\x9f \\xd7\\x9b\\xd7\\x9e\\xd7\\xa2\\xd7\\x98 \\xd7\\xa0\\xd7\\x99\\xd7\\x91\\xd7\\x99\\xd7\\x9d \\xd7\\x9...7\\x94 \\xd7\\x90\\xd7\\x99\\xd7\\xa0\\xd7\\x95 \\xd7\\x92\\xd7\\x93\\xd7\\x95\\xd7\\x9c (\\xd7\\x99\\xd7\\x97\\xd7\\xa1\\xd7\\x99\\xd7\\xaa).\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001746329999994245, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_5.txt-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_ude_5.txt-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_ude_5.txt-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.0002009489999998948, "outcome": "passed"}, "call": {"duration": 0.00035930299999975546, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_ude_5.txt', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xe4\\xbb\\x99\\xe4\\xba\\xba\\xe6\\xb4\\x9e\\xe6\\x96\\x87\\xe5\\x8c\\x96\\xe4\\xbf\\x82\\xe8\\xa9\\xb1\\xe5\\x88\\xb0\\xe8\\x90\\x...\\xe5\\x8d\\x80\\n\\n1\\xe9\\x9a\\xbb\\xe5\\x88\\x86\\xe9\\xa1\\x9e: \\xe6\\xb1\\x9f\\xe8\\xa5\\xbf\\xe5\\x97\\xb0\\xe6\\xad\\xb7\\xe5\\x8f\\xb2\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017183000000020598, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_greek.txt-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_ude_greek.txt-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_ude_greek.txt-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.0001823109999996575, "outcome": "passed"}, "call": {"duration": 0.0004963819999996844, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_ude_greek.txt', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xce\\x97 \\xce\\xb5\\xce\\xbb\\xce\\xbb\\xce\\xb7\\xce\\xbd\\xce\\xb9\\xce\\xba\\xce\\xae \\xce\\xb1\\xcf\\x80\\xce\\xbf\\xcf\\x84...cf\\x83\\xcf\\x84\\xce\\xb1 20 \\xce\\xb5\\xce\\xba\\xce\\xb1\\xcf\\x84\\xce\\xbf\\xce\\xbc\\xce\\xbc\\xcf\\x8d\\xcf\\x81\\xce\\xb9\\xce\\xb1.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018522399999998385, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_he2.txt-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_ude_he2.txt-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_ude_he2.txt-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.0001922209999998259, "outcome": "passed"}, "call": {"duration": 0.0008011589999998847, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_ude_he2.txt', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xd7\\x94\\xd7\\xa2\\xd7\\x91\\xd7\\xa8\\xd7\\x99\\xd7\\xaa \\xd7\\x94\\xd7\\x99\\xd7\\x90 \\xd7\\xa9\\xd7\\xa4\\xd7\\x94 \\xd7\\x9...xd7\\x90 \\xd7\\x9e\\xd7\\xa9\\xd7\\xa4\\xd7\\x97\\xd7\\xaa \\xd7\\x90\\xd7\\x91\\xd7\\x9f \\xd7\\xaa\\xd7\\x99\\xd7\\x91\\xd7\\x95\\xd7\\x9f.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017467700000040054, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/linuxbox.hu.xml-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/linuxbox.hu.xml-utf-8]", "parametrize", "pytestmark", "tests/utf-8/linuxbox.hu.xml-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.0001865890000001258, "outcome": "passed"}, "call": {"duration": 0.003542696000000234, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/linuxbox.hu.xml', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<!--\\nSource: http://linuxbox.hu/node/feed\\nExpect: UTF-8\\n-->\\n<!...taxonomy/term/2\">Linux</category>\\n <pubDate>Fri, 09 Sep 2005 16:06:29 -0400</pubDate>\\n</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018363700000012528, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_russian.txt-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_ude_russian.txt-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_ude_russian.txt-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.00018850400000047784, "outcome": "passed"}, "call": {"duration": 0.0006799160000001692, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_ude_russian.txt', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xd0\\x92 \\xd0\\xb3\\xd0\\xb8\\xd0\\xbc\\xd0\\xbd\\xd0\\xb0\\xd0\\xb7\\xd0\\xb8\\xd0\\xb8 \\xd0\\xbe\\xd0\\xbd \\xd0\\xbd\\xd0\\xb...0\\xd0\\xb8\\xd1\\x82\\xd1\\x8c \\xd0\\xbf\\xd0\\xbe\\xd1\\x81\\xd1\\x82\\xd1\\x83\\xd0\\xbf\\xd0\\xbb\\xd0\\xb5\\xd0\\xbd\\xd0\\xb8\\xd0\\xb5.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019307500000032007, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/pihgy.hu.xml-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/pihgy.hu.xml-utf-8]", "parametrize", "pytestmark", "tests/utf-8/pihgy.hu.xml-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.00019590100000055344, "outcome": "passed"}, "call": {"duration": 0.004110063999999802, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/pihgy.hu.xml', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<!--\\nSource: http://pihgy.hu/node/feed\\nExpect: UTF-8\\n-->\\n<!DOC... pedag\\xc3\\xb3gusoknak</category>\\n <pubDate>Thu, 27 Oct 2005 17:30:09 +0200</pubDate>\\n</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018691899999989658, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/weblabor.hu.xml-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/weblabor.hu.xml-utf-8]", "parametrize", "pytestmark", "tests/utf-8/weblabor.hu.xml-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.00021264400000031713, "outcome": "passed"}, "call": {"duration": 0.002729484000000504, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/weblabor.hu.xml', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<!--\\nSource: http://weblabor.hu/rss\\nExpect: UTF-8\\n-->\\n<!DOCTYP...hirek/rovatok/php\">PHP</category>\\n <pubDate>Wed, 04 Jan 2006 11:15:54 +0100</pubDate>\\n</item>\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017803500000024286, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_mozilla_bug426271_text-utf-8.html-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_mozilla_bug426271_text-utf-8.html-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_mozilla_bug426271_text-utf-8.html-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.00020882799999988322, "outcome": "passed"}, "call": {"duration": 0.0004622890000005597, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_mozilla_bug426271_text-utf-8.html', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\\n<html lang=\"ja\">\\n<head>\\n<title>\\xe6\\x97...\\xad\\xe3\\x83\\x9a\\xe3\\x83\\x87\\xe3\\x82\\xa3\\xe3\\x82\\xa2\\xef\\xbc\\x88Wikipedia\\xef\\xbc\\x89\\xe3\\x80\\x8f\\n</body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001732580000002315, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/boobooo.blogspot.com.xml-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/boobooo.blogspot.com.xml-utf-8]", "parametrize", "pytestmark", "tests/utf-8/boobooo.blogspot.com.xml-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.0001864950000003418, "outcome": "passed"}, "call": {"duration": 0.003312059999999839, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/boobooo.blogspot.com.xml', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/sty...neket.\\nT\\xc3\\xa9l</div>\\n</summary>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001833449999999459, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_1.txt-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_ude_1.txt-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_ude_1.txt-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.00018505600000029432, "outcome": "passed"}, "call": {"duration": 0.0003949360000001789, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_ude_1.txt', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xec\\x97\\xad\\xec\\x82\\xac\\xec\\xa0\\x81 \\xec\\x98\\x88\\xec\\x88\\x98 \\xec\\x97\\xb0\\xea\\xb5\\xac\\xec\\x9e\\x90\\xeb\\x93...\\xb1\\xea\\xb3\\xbc\\xeb\\x93\\xa4\\xec\\x9d\\x84 \\xec\\x86\\x8c\\xea\\xb0\\x9c\\xed\\x95\\x98\\xea\\xb3\\xa0 \\xec\\x9e\\x88\\xeb\\x8b\\xa4.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017493699999970858, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_mozilla_bug306272_text.html-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_mozilla_bug306272_text.html-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_mozilla_bug306272_text.html-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.00019249999999981782, "outcome": "passed"}, "call": {"duration": 0.0003871349999995388, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_mozilla_bug306272_text.html', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\\n<html><head>\\n\\n  <title>306272</title>\\n...href=\"mailto:Antti.Nayha@somewhere.fi\">Antti N\\xc3\\xa4yh\\xc3\\xa4 &lt;Antti.Nayha@somewhere.fi&gt;</a>\\n</body></html>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00020153599999961358, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8/_ude_he1.txt-utf-8]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8/_ude_he1.txt-utf-8]", "parametrize", "pytestmark", "tests/utf-8/_ude_he1.txt-utf-8", "test.py", "testbed", ""], "setup": {"duration": 0.00019107399999995778, "outcome": "passed"}, "call": {"duration": 0.0005586339999998913, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8/_ude_he1.txt', encoding = 'utf-8'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xd7\\x94\\xd7\\xa9\\xd7\\x9d \\xd7\\xa2\\xd7\\x91\\xd7\\xa8 \\xd7\\x9e\\xd7\\x95\\xd7\\xa4\\xd7\\x99\\xd7\\xa2 \\xd7\\x91\\xd7\\xa...\\xd7\\x91\\xd7\\xa8 \\xd7\\x91\\xd7\\x90\\xd7\\x96\\xd7\\x95\\xd7\\xa8 \\xd7\\x99\\xd7\\xa8\\xd7\\x95\\xd7\\xa9\\xd7\\x9c\\xd7\\x99\\xd7\\x9d.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001733310000000543, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32/bom-utf-32-be.srt-utf-32]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-32/bom-utf-32-be.srt-utf-32]", "parametrize", "pytestmark", "tests/UTF-32/bom-utf-32-be.srt-utf-32", "test.py", "testbed", ""], "setup": {"duration": 0.00019408799999975912, "outcome": "passed"}, "call": {"duration": 0.000479942000000122, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-32/bom-utf-32-be.srt', encoding = 'utf-32'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"\\x00\\x00\\xfe\\xff\\x00\\x00\\x001\\x00\\x00\\x00\\n\\x00\\x00\\x000\\x00\\x00\\x000\\x00\\x00\\x00:\\x00\\x00\\x000\\x00\\x00\\x0...00\\x00\\x00e\\x00\\x00\\x00s\\x00\\x00\\x00s\\x00\\x00\\x00 \\x00\\x00\\x00d\\x00\\x00\\x00a\\x00\\x00\\x00y\\x00\\x00\\x00\\n\\x00\\x00\\x00\\n\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017373799999997885, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32/bom-utf-32-le.srt-utf-32]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-32/bom-utf-32-le.srt-utf-32]", "parametrize", "pytestmark", "tests/UTF-32/bom-utf-32-le.srt-utf-32", "test.py", "testbed", ""], "setup": {"duration": 0.00019970399999991173, "outcome": "passed"}, "call": {"duration": 0.0004828629999993339, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-32/bom-utf-32-le.srt', encoding = 'utf-32'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"\\xff\\xfe\\x00\\x001\\x00\\x00\\x00\\n\\x00\\x00\\x000\\x00\\x00\\x000\\x00\\x00\\x00:\\x00\\x00\\x000\\x00\\x00\\x000\\x00\\x00\\x...x00\\x00\\x00s\\x00\\x00\\x00s\\x00\\x00\\x00 \\x00\\x00\\x00d\\x00\\x00\\x00a\\x00\\x00\\x00y\\x00\\x00\\x00\\n\\x00\\x00\\x00\\n\\x00\\x00\\x00\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001740479999998712, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_2.txt-iso-8859-1]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-1/_ude_2.txt-iso-8859-1]", "parametrize", "pytestmark", "tests/iso-8859-1/_ude_2.txt-iso-8859-1", "test.py", "testbed", ""], "setup": {"duration": 0.000186943000000106, "outcome": "passed"}, "call": {"duration": 0.000828856999999239, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-1/_ude_2.txt', encoding = 'iso-8859-1'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'Le type de visa requis pour entrer en France d\\xe9pend \\xe0 la fois de la dur\\xe9e et des motifs du s\\xe9j...urn\\xe9e, sportifs disputant un championnat, salari\\xe9 d\\xe9tach\\xe9 dans le cadre d\\'une\\nprestation de service).\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001743290000000286, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_1.txt-iso-8859-1]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-1/_ude_1.txt-iso-8859-1]", "parametrize", "pytestmark", "tests/iso-8859-1/_ude_1.txt-iso-8859-1", "test.py", "testbed", ""], "setup": {"duration": 0.0001890049999992982, "outcome": "passed"}, "call": {"duration": 0.0007360480000002667, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-1/_ude_1.txt', encoding = 'iso-8859-1'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"Nas paginas que em seguida se leem acha-se t\\xe3o bem determinada, com tanta eloquencia e t\\xe3o profunda ...stra\\xeddo que se affasta da sala do festim, e cuja voz se perde pouco a pouco no silencio da distancia e da noute.\\n\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017278900000050612, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_4.txt-iso-8859-1]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-1/_ude_4.txt-iso-8859-1]", "parametrize", "pytestmark", "tests/iso-8859-1/_ude_4.txt-iso-8859-1", "test.py", "testbed", ""], "setup": {"duration": 0.00018685399999984753, "outcome": "passed"}, "call": {"duration": 0.0006420060000005279, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-1/_ude_4.txt', encoding = 'iso-8859-1'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"Il padre. Ecco, sissignore! Ma un fatto \\xe8 come un sacco: vuoto, non si regge. Perch\\xe9 si regga, bisog...ntre quella poverina\\ncredeva di sacrificarsi per me e per quei due, cucendo anche di notte la roba di Madama Pace!\\n\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018393599999999566, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_6.txt-iso-8859-1]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-1/_ude_6.txt-iso-8859-1]", "parametrize", "pytestmark", "tests/iso-8859-1/_ude_6.txt-iso-8859-1", "test.py", "testbed", ""], "setup": {"duration": 0.00019434200000034707, "outcome": "passed"}, "call": {"duration": 0.000850377999999985, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-1/_ude_6.txt', encoding = 'iso-8859-1'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'Viel\\xe4 ehdit perehty\\xe4 Sibeliuksen el\\xe4m\\xe4\\xe4n Ateneumissa, aina 22. maaliskuuta asti.\\nMoniaisti...in ja paahtimoihin.\\nTapahtumassa kilpaillaan lis\\xe4ksi Cup Tasting, Brewers Cup ja Vuoden Barista titteleist\\xe4.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017987000000019293, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_5.txt-iso-8859-1]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-1/_ude_5.txt-iso-8859-1]", "parametrize", "pytestmark", "tests/iso-8859-1/_ude_5.txt-iso-8859-1", "test.py", "testbed", ""], "setup": {"duration": 0.00020024999999979087, "outcome": "passed"}, "call": {"duration": 0.0007776020000003214, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-1/_ude_5.txt', encoding = 'iso-8859-1'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'Agentes de la Guardia Civil de la Comandancia de Madrid, integrantes del Equipo Mujer Menor, han detenido ...clases a Alumnos de Primaria,\\nera tutor de ni\\xf1os de 11 a\\xf1os, pero daba clases a otros menores de 13 a\\xf1os.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017803800000049108, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-1/_ude_3.txt-iso-8859-1]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-1/_ude_3.txt-iso-8859-1]", "parametrize", "pytestmark", "tests/iso-8859-1/_ude_3.txt-iso-8859-1", "test.py", "testbed", ""], "setup": {"duration": 0.00019597200000021076, "outcome": "passed"}, "call": {"duration": 0.0007228689999996263, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-1/_ude_3.txt', encoding = 'iso-8859-1'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"La commedia non ha atti n\\xe9 scene. La rappresentazione sar\\xe0 interrotta una prima volta, senza che il ... mettersi in ginocchio e\\ninchiodarli. Alle martellate accorrer\\xe0 dalla porta dei camerini il Direttore di scena.\\n\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017689899999950853, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Johab/iyagi-readme.txt-johab]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Johab/iyagi-readme.txt-johab]", "parametrize", "pytestmark", "tests/Johab/iyagi-readme.txt-johab", "test.py", "testbed", ""], "setup": {"duration": 0.00019573299999997573, "outcome": "passed"}, "call": {"duration": 0.005002583000000449, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Johab/iyagi-readme.txt', encoding = 'johab'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'===============================================================================\\n                         ...b6\\x91\\xa0i\\xb7\\xa1\\x90a \\xaca\\xb6w \\xac\\xe9\\xa1w\\xac\\xe1\\x9fi \\xc0q\\x89\\xa1\\xd0a\\xaf\\xb3\\xaf\\xa1\\xb5\\xa1.\\n-\\x8f{-\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017670100000000133, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Johab/hlpro-readme.txt-johab]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Johab/hlpro-readme.txt-johab]", "parametrize", "pytestmark", "tests/Johab/hlpro-readme.txt-johab", "test.py", "testbed", ""], "setup": {"duration": 0.0001895169999999169, "outcome": "passed"}, "call": {"duration": 0.0006573079999991904, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Johab/hlpro-readme.txt', encoding = 'johab'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'      To read this document, use common combined Hangul code or KSSM code.\\n\\n                            ...9f\\xa1\\x9fi \\xc4\\xf1\\xcca\\xb7\\xa9\\x9c\\xe1 \\xb5\\xb3\\xade\\xb5A \\xac\\xe9\\xb8\\xf7\\xd0a\\x8b\\xa1 \\xa4a\\x9cs\\x93\\xa1\\x94a.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001746830000000088, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/Johab/mdir-doc.txt-johab]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/Johab/mdir-doc.txt-johab]", "parametrize", "pytestmark", "tests/Johab/mdir-doc.txt-johab", "test.py", "testbed", ""], "setup": {"duration": 0.0001910719999997923, "outcome": "passed"}, "call": {"duration": 0.011640078999999304, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/Johab/mdir-doc.txt', encoding = 'johab'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\n\\n    \\xd9\\xc6\\xd9\\xc6\\xd9\\xc6                    \\xd9\\xc6\\xd9\\xc6\\xd9\\xc6       \\xd9\\xc6\\xd9\\xc6\\xd9\\xc...9\\xc8\\xd9\\xc8\\xd9\\xc8\\xd9\\xc8\\xd9\\xc8\\xd9\\xc8\\xd9\\xc8\\xd9\\xc8\\xd9\\xc8\\xd9\\xc8\\xd9\\xc8\\xd9\\xc8\\xd9\\xc8\\xd9\\xc8\\n\\n\\x1a')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001821980000000778, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.6.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.6.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/forum.template-toolkit.ru.6.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00019102900000067535, "outcome": "passed"}, "call": {"duration": 0.010860874000000464, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/forum.template-toolkit.ru.6.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_6.rss\\nE...6.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-62.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017661900000032205, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/_ude_1.txt-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/_ude_1.txt-ibm855]", "parametrize", "pytestmark", "tests/IBM855/_ude_1.txt-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00019000900000065712, "outcome": "passed"}, "call": {"duration": 0.0006868599999991787, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/_ude_1.txt', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xec \\xac\\xb7\\xd2\\xd4\\xa0\\xf3\\xb7\\xb7 \\xd6\\xd4 \\xd4\\xa8 \\xa2\\xf1\\xd0 \\xeb \\xfb\\xb7\\xe3\\xd0\\xa8 \\xd8\\xa8\\xe...xe5\\xe5\\xa8\\xe3\\xe5\\xa0\\xe5 \\xb7 \\xd8\\xd6\\xeb\\xe5\\xd6\\xe1\\xb7\\xe5\\xed \\xd8\\xd6\\xe3\\xe5\\xe7\\xd8\\xd0\\xa8\\xd4\\xb7\\xa8.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017327800000010996, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/blog.mlmaster.com.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/blog.mlmaster.com.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/blog.mlmaster.com.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.0002003290000001101, "outcome": "passed"}, "call": {"duration": 0.0018939989999999796, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/blog.mlmaster.com.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://blog.mlmaster.com/wp-rss2.php\\nExpect: IBM85...\\t\\t<wfw:commentRSS>http://blog.mlmaster.com/?feed=rss2&amp;p=286</wfw:commentRSS>\\n\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001718019999996656, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.1.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.1.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/forum.template-toolkit.ru.1.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00018356100000005426, "outcome": "passed"}, "call": {"duration": 0.006342322000000067, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/forum.template-toolkit.ru.1.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_1.rss\\nE...1.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-93.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018508100000058647, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.9.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.9.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/forum.template-toolkit.ru.9.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00018495499999993115, "outcome": "passed"}, "call": {"duration": 0.0010509850000000043, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/forum.template-toolkit.ru.9.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_9.rss\\nE...9.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-56.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018308900000008066, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.8.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.8.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/forum.template-toolkit.ru.8.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00020091600000071708, "outcome": "passed"}, "call": {"duration": 0.005108191000000595, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/forum.template-toolkit.ru.8.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_8.rss\\nE...8.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-53.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019494699999977882, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.4.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/forum.template-toolkit.ru.4.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/forum.template-toolkit.ru.4.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00020768599999954063, "outcome": "passed"}, "call": {"duration": 0.0031819439999996035, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/forum.template-toolkit.ru.4.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://forum.template-toolkit.ru/rss/forum_4.rss\\nE...-4.rss\">http://forum.template-toolkit.ru/view_topic/topic_id-1.html?rss</source>\\n\\t\\t</item>\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018384999999998541, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/kapranoff.ru.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/kapranoff.ru.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/kapranoff.ru.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00020782300000021792, "outcome": "passed"}, "call": {"duration": 0.00206915700000021, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/kapranoff.ru.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://kapranoff.ru/index.rdf\\nExpect: IBM855\\n-->\\...dc:subject/>\\n<dc:creator>kappa</dc:creator>\\n<dc:date>2003-12-03T11:37:49+03:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018259500000006312, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/janulalife.blogspot.com.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/janulalife.blogspot.com.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/janulalife.blogspot.com.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00018951599999983415, "outcome": "passed"}, "call": {"duration": 0.004944185999999462, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/janulalife.blogspot.com.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com/st...\\xd6\\xb7.\\n<br/>\\n</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017333400000030252, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/aviaport.ru.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/aviaport.ru.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/aviaport.ru.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.000185099999999494, "outcome": "passed"}, "call": {"duration": 0.011913736000000341, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/aviaport.ru.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://www.aviaport.ru/news/yandex_export.xml\\nExpe...\\xb7 \\xeb\\xe3\\xa8\\xb5 \\xb7\\xe3\\xd8\\xf1\\xe5\\xa0\\xd4\\xb7\\xbd - \\xb7 \\xd2\\xa0\\xf5\\xb7\\xd4\\xf1, \\xb7 \\xd0\\x9c\\xa6\\xa8\\xbd')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001707590000004089, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/aif.ru.health.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/aif.ru.health.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/aif.ru.health.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00019356299999984117, "outcome": "passed"}, "call": {"duration": 0.002362620000000426, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/aif.ru.health.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://www.aif.ru/info/rss.php?magazine=health\\nExp...e1\\xa0\\xd0\\xed\\xd4\\xf1\\xb5 \\xd8\\xe1\\xd6\\xa6\\xe7\\xc6\\xe5\\xd6\\xeb.\\t\\t</description>\\n\\t</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017100600000041766, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/newsru.com.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/newsru.com.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/newsru.com.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00018323300000044895, "outcome": "passed"}, "call": {"duration": 0.005881296000000091, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/newsru.com.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://www.newsru.com/plain/rss/all.xml\\nExpect: IB...=\"http://www.newsru.com/pict/id/large/819577_20060103092327.gif\" type=\"image/jpeg\"/>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017411500000008573, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/greek.ru.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/greek.ru.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/greek.ru.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.0001957699999994844, "outcome": "passed"}, "call": {"duration": 0.0010480109999999598, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/greek.ru.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://www.greek.ru/news/ya/yagreek\\nExpect: IBM855...d6 \\xb5\\xd6\\xe1\\xd6\\xf5\\xd6 \\xd8\\xd6\\xd2\\xd4\\xde\\xe5 \\xb7 \\xd0\\x9c\\xa2\\xde\\xe5 \\xeb \\xa3\\xd6\\xd0\\xed\\xf5\\xd6\\xd2 \\xe5')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017194399999986842, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/music.peeps.ru.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/music.peeps.ru.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/music.peeps.ru.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00018778599999969003, "outcome": "passed"}, "call": {"duration": 0.002283401999999768, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/music.peeps.ru.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://music.peeps.ru/news/action_rss.xml\\nExpect: ...\\xa6\\xd4\\xf1\\xb5 \\xd8\\xa0\\xd4\\xc6-\\xac\\xe1\\xe7\\xd8\\xd8 90-\\xb5. </description>\\n\\t\\t</item>\\n\\n\\t</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017161000000065485, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/aug32.hole.ru.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/aug32.hole.ru.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/aug32.hole.ru.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00018863200000041047, "outcome": "passed"}, "call": {"duration": 0.0004738410000006965, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/aug32.hole.ru.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://aug32.hole.ru/afisha/feed.php\\nExpect: IBM85...&gt;</description>\\n          <link>http://aug32.hole.ru/afisha.htm</link>\\n        </item>\\n    </channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017164299999983257, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/intertat.ru.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/intertat.ru.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/intertat.ru.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00018832199999962995, "outcome": "passed"}, "call": {"duration": 0.00047807199999994054, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/intertat.ru.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://intertat.ru/myyandex.php\\nExpect: IBM855\\n--...\\xb7\\xa6\\xa8\\xe5\\xa8\\xd0\\xed\\xe3\\xe5\\xeb\\xd6 \\xd6 \\xe1\\xa8\\xac\\xb7\\xe3\\xe5\\xe1\\xa0\\xa4\\xb7\\xb7 \\xe4\\xd3\\xb8 \\xf8\\xd0 ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017741799999981822, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/money.rin.ru.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/money.rin.ru.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/money.rin.ru.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.00018560599999961624, "outcome": "passed"}, "call": {"duration": 0.002239057999999794, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/money.rin.ru.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://money.rin.ru/news/rss/\\nExpect: IBM855\\n-->\\...  (N 1080 \\xd6\\xe5 17 \\xd4\\xd6\\xde\\xa2\\xe1\\xde 2005 \\xac\\xd6\\xa6\\xa0).</description>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017656200000004674, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/IBM855/susu.ac.ru.xml-ibm855]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/IBM855/susu.ac.ru.xml-ibm855]", "parametrize", "pytestmark", "tests/IBM855/susu.ac.ru.xml-ibm855", "test.py", "testbed", ""], "setup": {"duration": 0.000194038000000063, "outcome": "passed"}, "call": {"duration": 0.0008727930000000939, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/IBM855/susu.ac.ru.xml', encoding = 'ibm855'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"IBM855\"?>\\n<!--\\nSource: http://susu.ac.ru/ru/news/rss\\nExpect: IBM855\\n-->\\...d4\\xd4\\xd6\\xe3\\xe5\\xb7&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"http://model.exponenta.ru/\"\"&gt;Model.Exponenta.Ru ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001866269999997172, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8-sig/bom-utf-8.srt-utf-8-sig]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8-sig/bom-utf-8.srt-utf-8-sig]", "parametrize", "pytestmark", "tests/utf-8-sig/bom-utf-8.srt-utf-8-sig", "test.py", "testbed", ""], "setup": {"duration": 0.00019760200000007444, "outcome": "passed"}, "call": {"duration": 0.0004885940000001199, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8-sig/bom-utf-8.srt', encoding = 'utf-8-sig'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"\\xef\\xbb\\xbf1\\n00:00:06,500 --> 00:00:09,000\\nAbout 2 months ago I found myself on\\nthe comment section of...00:50,000\\nSo what I thought I do is instead if answering on a YouTube comment is organize a global awareness day\\n\\n\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017664800000005698, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/utf-8-sig/_ude_4.txt-utf-8-sig]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/utf-8-sig/_ude_4.txt-utf-8-sig]", "parametrize", "pytestmark", "tests/utf-8-sig/_ude_4.txt-utf-8-sig", "test.py", "testbed", ""], "setup": {"duration": 0.000191177999999681, "outcome": "passed"}, "call": {"duration": 0.0005822630000000828, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/utf-8-sig/_ude_4.txt', encoding = 'utf-8-sig'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xef\\xbb\\xbf========================================================================\\n    \\xe3\\x82\\xb3\\xe3...be\\xe3\\x81\\x99\\xe3\\x80\\x82\\n\\n/////////////////////////////////////////////////////////////////////////////\\n\\n\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017285299999958426, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/doncho.net.comments.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/doncho.net.comments.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/doncho.net.comments.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00020584700000014777, "outcome": "passed"}, "call": {"duration": 0.001412825000000062, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/doncho.net.comments.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://blog.doncho.net/wp-commentsrss2.php\\nExp...\\'wp-smiley\\' /> </p>\\n]]></content:encoded>\\n\\t\\t\\t\\t</item>\\n\\t<item>\\n \\t\\t<title>Comment on \\xba\\xe3\\xdf\\xde\\xdd ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017253000000039265, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/debian.gabrovo.com.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.0001873129999996337, "outcome": "passed"}, "call": {"duration": 0.0006279270000000281, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/debian.gabrovo.com.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://debian.gabrovo.com/backend/debianbg-arti...ebian.gabrovo.com/show.php?id=5&amp;tablica=articles&amp;sub=\\xc2\\xd5\\xdc\\xd0</link>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.000171579999999949, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/ide.li.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/ide.li.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/ide.li.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00018369499999959515, "outcome": "passed"}, "call": {"duration": 0.0010574540000005683, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/ide.li.xml', encoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://www.ide.li/backend.php\\nExpect: ISO-8859...2\\xe0\\xd0\\xd4\\xd8\\xe6\\xd8\\xde\\xdd\\xdd\\xd8\\xef \\xe1\\xd8 \\xe1\\xdf\\xd8\\xe1\\xea\\xda \\xe1 \\xda\\xe3\\xe0\\xd8\\xde\\xd7\\xdd\\xd8')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017262799999961942, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.9.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.9.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/bpm.cult.bg.9.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.0001940030000007198, "outcome": "passed"}, "call": {"duration": 0.0033172750000005635, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/bpm.cult.bg.9.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://bpm.cult.bg/logs/rdf.php?id=9\\nExpect: I...)</dc:subject>\\n<dc:creator>Kaladan</dc:creator>\\n<dc:date>2004-12-03T19:12:22+02:00</dc:date>\\n</item>\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017405799999981042, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/bpm.cult.bg.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00020258400000017218, "outcome": "passed"}, "call": {"duration": 0.0010411780000003645, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/bpm.cult.bg.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://bpm.cult.bg/services/rss/ezine.php\\nExpe...e0\\xd8\\xe2\\xd8\\xd5, \\xd8\\xe1\\xe2\\xd8\\xdd\\xe1\\xda\\xd8 \\xe1\\xee\\xe0\\xdf\\xe0\\xd8\\xd7 - \\xdd\\xd5 \\xdc\\xde\\xd6\\xd5\\xe8\\xd5')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018180299999936977, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/ecloga.cult.bg.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/ecloga.cult.bg.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/ecloga.cult.bg.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00018645599999977946, "outcome": "passed"}, "call": {"duration": 0.0037911699999995108, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/ecloga.cult.bg.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://ecloga.cult.bg/log/wp-rss.php\\nExpect: I...ption>\\n            <link>http://ecloga.cult.bg/log/index.php?p=242</link>\\n        </item>\\n    </channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017304400000028863, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.news.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/debian.gabrovo.com.news.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/debian.gabrovo.com.news.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00018504899999971514, "outcome": "passed"}, "call": {"duration": 0.0008363730000002789, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/debian.gabrovo.com.news.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://debian.gabrovo.com/backend/debianbg-news...//debian.gabrovo.com/show.php?id=56&amp;tablica=news&amp;sub=\\xc2\\xd5\\xdc\\xd0</link>\\n</item>\\n\\n</channel>\\n</rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017814500000046252, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/aero-bg.com.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/aero-bg.com.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/aero-bg.com.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00018711500000012649, "outcome": "passed"}, "call": {"duration": 0.0029009769999994717, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/aero-bg.com.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.co...xde\\xe0\\xe2\"</a>\\n</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017384600000003303, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.4.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.4.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/bpm.cult.bg.4.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.0001897929999996606, "outcome": "passed"}, "call": {"duration": 0.001666504000000124, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/bpm.cult.bg.4.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://bpm.cult.bg/logs/rdf.php?id=4\\nExpect: I...ialogs, popup menus, strings) should be displayed on the chosen language, independently on the language of your OS (I')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017204799999959164, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/linux-bg.org.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/linux-bg.org.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/linux-bg.org.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00018663600000046188, "outcome": "passed"}, "call": {"duration": 0.0010430379999997186, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/linux-bg.org.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://linux-bg.org/linux-bg-news.rdf\\nExpect: ...=news&amp;key=378326293</link>\\n</item>\\n\\n \\n <skipHours>\\n <hour>1</hour>\\n </skipHours>\\n \\n </channel>\\n </rss>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017081900000004424, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.medusa.4.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.medusa.4.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/bpm.cult.bg.medusa.4.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.00019501399999999336, "outcome": "passed"}, "call": {"duration": 0.0016562199999992089, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/bpm.cult.bg.medusa.4.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://bpm.cult.bg/medusa/logs/rdf.php?id=4\\nEx...ialogs, popup menus, strings) should be displayed on the chosen language, independently on the language of your OS (I')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018018000000008527, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.2.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/bpm.cult.bg.2.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/bpm.cult.bg.2.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.0002376109999993048, "outcome": "passed"}, "call": {"duration": 0.0032340490000004607, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/bpm.cult.bg.2.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://bpm.cult.bg/logs/rdf.php?id=2\\nExpect: I...og)</dc:subject>\\n<dc:creator>snark</dc:creator>\\n<dc:date>2005-12-12T18:12:01+02:00</dc:date>\\n</item>\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018109200000004932, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-5-bulgarian/bbc.co.uk.popshow.xml-iso-8859-5]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-8859-5-bulgarian/bbc.co.uk.popshow.xml-iso-8859-5]", "parametrize", "pytestmark", "tests/iso-8859-5-bulgarian/bbc.co.uk.popshow.xml-iso-8859-5", "test.py", "testbed", ""], "setup": {"duration": 0.0001937569999999056, "outcome": "passed"}, "call": {"duration": 0.003578164000000328, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-5-bulgarian/bbc.co.uk.popshow.xml'\nencoding = 'iso-8859-5'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-5\"?>\\n<!--\\nSource: http://www.bbc.co.uk/bulgarian/popshow/index.rd...l</link>\\n      <description xml:lang=\"bg\">Rolling Stone, BBC, NME \\xe1\\xd0 \\xd5\\xd4\\xd8\\xdd\\xde\\xd4\\xe3\\xe8\\xdd\\xd8 ')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017794900000023262, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/ascii/_mozilla_bug638318_text.html-ascii]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/ascii/_mozilla_bug638318_text.html-ascii]", "parametrize", "pytestmark", "tests/ascii/_mozilla_bug638318_text.html-ascii", "test.py", "testbed", ""], "setup": {"duration": 0.00019478500000058574, "outcome": "passed"}, "call": {"duration": 0.0004308069999998665, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/ascii/_mozilla_bug638318_text.html', encoding = 'ascii'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00<title>NOT UTF-16!</title>NOT UTF-16!')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017302400000041018, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/ascii/howto.diveintomark.org.xml-ascii]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/ascii/howto.diveintomark.org.xml-ascii]", "parametrize", "pytestmark", "tests/ascii/howto.diveintomark.org.xml-ascii", "test.py", "testbed", ""], "setup": {"duration": 0.0001888830000007502, "outcome": "passed"}, "call": {"duration": 0.0008015529999996218, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/ascii/howto.diveintomark.org.xml', encoding = 'ascii'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"UTF-8\"?><feed xmlns=\"http://www.w3.org/2005/Atom\" xml:lang=\"en\">\\n<title>how...DATA[Use Handbrake to convert your existing DVDs to play on the video iPod.]]></summary>\\n        </entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001701379999996533, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/ascii/_chromium_iso-8859-1_with_no_encoding_specified.html-ascii]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/ascii/_chromium_iso-8859-1_with_no_encoding_specified.html-ascii]", "parametrize", "pytestmark", "tests/ascii/_chromium_iso-8859-1_with_no_encoding_specified.html-ascii", "test.py", "testbed", ""], "setup": {"duration": 0.00018391700000019995, "outcome": "passed"}, "call": {"duration": 0.0004050540000006819, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/ascii/_chromium_iso-8859-1_with_no_encoding_specified.html'\nencoding = 'ascii'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<!DOCTYPE html PUBLIC \"-//W3C//DTD html 4.01 Transitional//EN\" \"http://www.w3c.o rg/TR/1999/REC-html401-19... src=\"/Icons/w3c_main\" width=315></h1>\\n<h2 id=slogan>Leading the Web to Its Full Potential...</h2>\\n</body>\\n</html>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017616099999973045, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-2022-kr/_ude_iso1.txt-iso-2022-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-2022-kr/_ude_iso1.txt-iso-2022-kr]", "parametrize", "pytestmark", "tests/iso-2022-kr/_ude_iso1.txt-iso-2022-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00020252899999917418, "outcome": "passed"}, "call": {"duration": 0.0018913750000004725, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-2022-kr/_ude_iso1.txt', encoding = 'iso-2022-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\x1b$)C\\x0e?*;g@{\\x0f \\x0e?9<v\\x0f \\x0e?,18@Z5i@:\\x0f \\x0e:9@=<-3*\\x0f \\x0e;g555i@G\\x0f \\x0e<-=E<-\\x0f \\x0...FGGO?)\\x0f, \\x0e?*;g@{\\x0f \\x0e?9<v?!\\x0f \\x0e4kGQ\\x0f \\x0e?,18\\x0f \\x0e<:0z5i@;\\x0f \\x0e<R03GO0m\\x0f \\x0e@V4Y\\x0f.\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018466200000055721, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-2022-kr/_ude_iso2.txt-iso-2022-kr]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/iso-2022-kr/_ude_iso2.txt-iso-2022-kr]", "parametrize", "pytestmark", "tests/iso-2022-kr/_ude_iso2.txt-iso-2022-kr", "test.py", "testbed", ""], "setup": {"duration": 0.00018972099999992054, "outcome": "passed"}, "call": {"duration": 0.000560156000000589, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-2022-kr/_ude_iso2.txt', encoding = 'iso-2022-kr'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"\\x1b$)C\\x0e:OA6<1\\x0f \\x0e;g6w5i@:\\x0f \\x0eHgHw\\x0f \\x0e@Z19@;\\x0f \\x0eA6<1\\x0f(\\x0epH`X\\x0f)\\x0e@L3*\\x0f ...'\\x0eA6<19]55\\x0f(\\x0eGQ9]55\\x0f) \\x0e:OBJ\\x0f\\'\\x0e@;\\x0f \\x0e@G9LGO4B\\x0f North Korea\\x0e6s0m\\x0f \\x0e:N8%4Y\\x0f.\\n\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001723470000003502, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32LE/nobom-utf32le.txt-utf-32le]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-32LE/nobom-utf32le.txt-utf-32le]", "parametrize", "pytestmark", "tests/UTF-32LE/nobom-utf32le.txt-utf-32le", "test.py", "testbed", ""], "setup": {"duration": 0.0001891319999991481, "outcome": "passed"}, "call": {"duration": 0.001450554999999909, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-32LE/nobom-utf32le.txt', encoding = 'utf-32le'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'D\\x00\\x00\\x00a\\x00\\x00\\x00t\\x00\\x00\\x00e\\x00\\x00\\x00T\\x00\\x00\\x00i\\x00\\x00\\x00m\\x00\\x00\\x00e\\x00\\x00\\x00,\\...x00\\x00\\x00.\\x00\\x00\\x000\\x00\\x00\\x008\\x00\\x00\\x003\\x00\\x00\\x005\\x00\\x00\\x003\\x00\\x00\\x00\\r\\x00\\x00\\x00\\n\\x00\\x00\\x00')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017252299999981346, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/UTF-32LE/plane1-utf-32le.html-utf-32le]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/UTF-32LE/plane1-utf-32le.html-utf-32le]", "parametrize", "pytestmark", "tests/UTF-32LE/plane1-utf-32le.html-utf-32le", "test.py", "testbed", ""], "setup": {"duration": 0.00019620999999947486, "outcome": "passed"}, "call": {"duration": 0.0017922399999994454, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/UTF-32LE/plane1-utf-32le.html', encoding = 'utf-32le'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<\\x00\\x00\\x00!\\x00\\x00\\x00D\\x00\\x00\\x00O\\x00\\x00\\x00C\\x00\\x00\\x00T\\x00\\x00\\x00Y\\x00\\x00\\x00P\\x00\\x00\\x00E\\...x00\\x00\\x00/\\x00\\x00\\x00h\\x00\\x00\\x00t\\x00\\x00\\x00m\\x00\\x00\\x00l\\x00\\x00\\x00>\\x00\\x00\\x00\\r\\x00\\x00\\x00\\n\\x00\\x00\\x00')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017260400000029819, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-9-turkish/wikitop_tr_ISO-8859-9.txt-iso-8859-9]", "lineno": 75, "outcome": "xfailed", "keywords": ["test_encoding_detection[tests/iso-8859-9-turkish/wikitop_tr_ISO-8859-9.txt-iso-8859-9]", "parametrize", "xfail", "pytestmark", "tests/iso-8859-9-turkish/wikitop_tr_ISO-8859-9.txt-iso-8859-9", "test.py", "testbed", ""], "setup": {"duration": 0.00020562899999987394, "outcome": "passed"}, "call": {"duration": 0.002139456000000095, "outcome": "skipped", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-9-turkish/wikitop_tr_ISO-8859-9.txt'\nencoding = 'iso-8859-9'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\xddstanbul, T\\xfcrkiye\\'nin en kalabal\\xfdk, iktisadi ve k\\xfclt\\xfcrel a\\xe7\\xfddan en \\xf6nemli\\n\\xfeeh...-Saltanat-\\xfd Kostantiniyyet\\xfc\\'l-Mahrus\\xe2t\\xfc\\'l-Mahmiyye\" gibi ba\\xfel\\xfdklar\\nkullan\\xfdl\\xfdrd\\xfd.[17] \\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017457999999948015, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-9-turkish/_ude_1.txt-iso-8859-9]", "lineno": 75, "outcome": "xfailed", "keywords": ["test_encoding_detection[tests/iso-8859-9-turkish/_ude_1.txt-iso-8859-9]", "parametrize", "xfail", "pytestmark", "tests/iso-8859-9-turkish/_ude_1.txt-iso-8859-9", "test.py", "testbed", ""], "setup": {"duration": 0.00019785700000074513, "outcome": "passed"}, "call": {"duration": 0.0006950210000002954, "outcome": "skipped", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-9-turkish/_ude_1.txt', encoding = 'iso-8859-9'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'Politik ama\\xe7l\\xfd \"hack\" eylemi ger\\xe7ekle\\xfetiren Anonymous, ter\\xf6r \\xf6rg\\xfct\\xfc I\\xde\\xddD\\'e ...r ve Facebook\\'ta sald\\xfdr\\xfdya u\\xf0rayan hesaplar\\xfdn\\xfdn listesi de, Anonymous taraf\\xfdndan yay\\xfdnland\\xfd.')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017387499999976797, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-9-turkish/_ude_2.txt-iso-8859-9]", "lineno": 75, "outcome": "xfailed", "keywords": ["test_encoding_detection[tests/iso-8859-9-turkish/_ude_2.txt-iso-8859-9]", "parametrize", "xfail", "pytestmark", "tests/iso-8859-9-turkish/_ude_2.txt-iso-8859-9", "test.py", "testbed", ""], "setup": {"duration": 0.00019322099999996567, "outcome": "passed"}, "call": {"duration": 0.000985690000000261, "outcome": "skipped", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-9-turkish/_ude_2.txt', encoding = 'iso-8859-9'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'Ta\\xfeta kan vard\\xfd. Bah\\xe7ede \\xfcrk\\xfct\\xfcc\\xfc bir serinlik. Cinayetin tek tan\\xfd\\xf0\\xfd dolunay...clkenin \\xe7ok da yabanc\\xfds\\xfd de\\xf0ildim. Evet, art\\xfdk kendimi i\\xfeime vermeliydim. Bak\\xfd\\xfelar\\xfdm\\xfd\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001731959999995425, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-9-turkish/subtitle.srt-iso-8859-9]", "lineno": 75, "outcome": "xfailed", "keywords": ["test_encoding_detection[tests/iso-8859-9-turkish/subtitle.srt-iso-8859-9]", "parametrize", "xfail", "pytestmark", "tests/iso-8859-9-turkish/subtitle.srt-iso-8859-9", "test.py", "testbed", ""], "setup": {"duration": 0.0002017869999999533, "outcome": "passed"}, "call": {"duration": 0.0007102129999996265, "outcome": "skipped", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-9-turkish/subtitle.srt', encoding = 'iso-8859-9'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b\"1\\n00:00:03,273 --> 00:00:04,416\\nBenim ad\\xfdm Abaddon.\\n\\n2\\n00:00:04,417 --> 00:00:06,051\\nCehennemin S...8,373\\nNe olursa olsun\\nyerlerinizi koruyun!\\n\\n22\\n00:01:18,375 --> 00:01:19,825\\nSava\\xfe\\xe7\\xfd korunmal\\xfd.\\n\\n\")\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001715710000000925, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/iso-8859-9-turkish/divxplanet.com.xml-iso-8859-9]", "lineno": 75, "outcome": "xfailed", "keywords": ["test_encoding_detection[tests/iso-8859-9-turkish/divxplanet.com.xml-iso-8859-9]", "parametrize", "xfail", "pytestmark", "tests/iso-8859-9-turkish/divxplanet.com.xml-iso-8859-9", "test.py", "testbed", ""], "setup": {"duration": 0.0002056900000004802, "outcome": "passed"}, "call": {"duration": 0.0016598830000003062, "outcome": "skipped", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/iso-8859-9-turkish/divxplanet.com.xml'\nencoding = 'iso-8859-9'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"iso-8859-9\"?>\\n<rss version=\"0.91\">\\n<channel>\\n<title>DiVXPlanet - Paylasim...om/sub/s/307316/Filth.html</link><description>Filth English 1 CD altyaz\\xfds\\xfd</description></item></channel></rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018880300000034822, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/overcube.com.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/overcube.com.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/overcube.com.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.0001995049999994336, "outcome": "passed"}, "call": {"duration": 0.0031092409999997628, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/overcube.com.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://www.overcube.com/blog/index.rdf\\nExpect: EUC...y</dc:subject>\\n<dc:creator>overQ</dc:creator>\\n<dc:date>2005-12-28T23:25:11+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019705400000002982, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug620106_text.html-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/_mozilla_bug620106_text.html-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/_mozilla_bug620106_text.html-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00019842499999978003, "outcome": "passed"}, "call": {"duration": 0.000414241000000537, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/_mozilla_bug620106_text.html', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<!DOCTYPE html>\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\...c\\xa4\\xac\\xc0\\xb5\\xa4\\xb7\\xa4\\xaf\\xb8\\xa1\\xbd\\xd0\\xa4\\xb5\\xa4\\xec\\xa4\\xc6\\xa4\\xa4\\xa4\\xde\\xa4\\xb9\\xa4\\xab\\xa1\\xa9\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019373200000050161, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/rdf.ycf.nanet.co.jp.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/rdf.ycf.nanet.co.jp.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/rdf.ycf.nanet.co.jp.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00019902699999985174, "outcome": "passed"}, "call": {"duration": 0.0023472409999998334, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/rdf.ycf.nanet.co.jp.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://www.ycf.nanet.co.jp/~dre/cgi-bin/diary/index...ad</dc:subject>\\n<dc:creator>AND0</dc:creator>\\n<dc:date>2005-10-28T02:46:13+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018149299999947743, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/_ude_1.txt-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/_ude_1.txt-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/_ude_1.txt-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00019519099999953937, "outcome": "passed"}, "call": {"duration": 0.000602693000000265, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/_ude_1.txt', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'========================================================================\\n    \\xa5\\xb3\\xa5\\xf3\\xa5\\xbd\\xa1...b7\\xa4\\xde\\xa4\\xb9\\xa1\\xa3\\n\\n/////////////////////////////////////////////////////////////////////////////\\n\\n\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017572700000023644, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/tls.org.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/tls.org.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/tls.org.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00018732200000037835, "outcome": "passed"}, "call": {"duration": 0.003305079999999627, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/tls.org.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-jp\" ?>\\n<!--\\nSource: http://www.tls.org/~moriya/diary/rss.cgi\\nExpect: ...\\xa4\\xe8\\xa4\\xaf\\xbf\\xb2\\xa4\\xbf</description>\\n\\t<dc:date>2005-12-25T05:13:14+09:00</dc:date>\\n</item>\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001713439999999622, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/aivy.co.jp.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/aivy.co.jp.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/aivy.co.jp.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.0001872330000001199, "outcome": "passed"}, "call": {"duration": 0.002824009999999433, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/aivy.co.jp.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://www.aivy.co.jp/BLOG_TEST/kobakoba/index.rdf\\...de</dc:subject>\\n<dc:creator>koba</dc:creator>\\n<dc:date>2005-12-02T00:51:57+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018135400000041102, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/yukiboh.moo.jp.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/yukiboh.moo.jp.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/yukiboh.moo.jp.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00018659499999973406, "outcome": "passed"}, "call": {"duration": 0.0023852419999998986, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/yukiboh.moo.jp.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://yukiboh.moo.jp/weblog/index.rdf\\nExpect: EUC...:creator>\\xa4\\xe6\\xa4\\xad\\xcb\\xb7</dc:creator>\\n<dc:date>2004-12-08T09:00:40+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017141899999995047, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/bphrs.net.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/bphrs.net.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/bphrs.net.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.0001944370000002138, "outcome": "passed"}, "call": {"duration": 0.0019376150000001147, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/bphrs.net.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://www.bphrs.net/mesi/index.rdf\\nExpect: EUC-JP.../dc:subject>\\n<dc:creator>bphrs</dc:creator>\\n\\n<dc:date>2005-04-02T18:49:14+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001722879999999094, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/misuzilla.org.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/misuzilla.org.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/misuzilla.org.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00018638899999956493, "outcome": "passed"}, "call": {"duration": 0.003880844999999411, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/misuzilla.org.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<?xml-stylesheet href=\"rss2html.xsl\" type=\"text/xsl\" ?>\\n<!--\\nSo...xbc\\xc2\\xb9\\xd4\\xa4\\xc7\\xa4\\xad\\xa4\\xde\\xa4\\xb9\\xa1\\xa3</p>\\n</div>]]></content:encoded>\\n  </item>\\n\\n\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017066799999998494, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/blog.kabu-navi.com.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00018414200000016478, "outcome": "passed"}, "call": {"duration": 0.003584441000000105, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/blog.kabu-navi.com.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://blog.kabu-navi.com/atom.xml\\nExpect: EUC-JP\\...xa2\\xa1\\xa2\\xc6\\xfc\\xa1\\xb9\\xc0\\xba\\xbf\\xca\\xa4\\xc7\\xa4\\xb9\\xa4\\xcd\\xa1\\xa3</p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018150599999966488, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/aristrist.s57.xrea.com.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/aristrist.s57.xrea.com.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/aristrist.s57.xrea.com.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00018516500000043123, "outcome": "passed"}, "call": {"duration": 0.0053503890000001775, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/aristrist.s57.xrea.com.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://aristrist.s57.xrea.com/mt/index.rdf\\nExpect:.../dc:subject>\\n<dc:creator>aristrist</dc:creator>\\n<dc:date>2005-12-19T23:58:13+09:00</dc:date>\\n</item>\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017249900000049223, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug431054_text.html-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/_mozilla_bug431054_text.html-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/_mozilla_bug431054_text.html-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00019731700000047425, "outcome": "passed"}, "call": {"duration": 0.0003373939999997688, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/_mozilla_bug431054_text.html', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html>\\n<body>\\n\\xa5\\xed\\xa5\\xb0\\xa5\\xa4\\xa5\\xf3\\n</body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017324900000037502, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/_mozilla_bug426271_text-euc-jp.html-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/_mozilla_bug426271_text-euc-jp.html-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/_mozilla_bug426271_text-euc-jp.html-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00018886500000014905, "outcome": "passed"}, "call": {"duration": 0.0004538899999992907, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/_mozilla_bug426271_text-euc-jp.html'\nencoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\\n<html lang=\"ja\">\\n<head>\\n<title>\\xc6\\xfc...\\xa1\\xd8\\xa5\\xa6\\xa5\\xa3\\xa5\\xad\\xa5\\xda\\xa5\\xc7\\xa5\\xa3\\xa5\\xa2\\xa1\\xcaWikipedia\\xa1\\xcb\\xa1\\xd9\\n</body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017336600000028568, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/club.h14m.org.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/club.h14m.org.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/club.h14m.org.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00018646100000019317, "outcome": "passed"}, "call": {"duration": 0.0020217829999999992, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/club.h14m.org.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-jp\" ?>\\n<!--\\nSource: http://club.h14m.org/kenji/diary/rss.cgi\\nExpect: ...\\xa4\\xb7\\xa4\\xde\\xa4\\xb9\\xa1\\xa3</description>\\n\\t<dc:date>2005-12-19T04:46:33+00:00</dc:date>\\n</item>\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018653900000042967, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/siesta.co.jp.aozora.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/siesta.co.jp.aozora.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/siesta.co.jp.aozora.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.0002058449999999823, "outcome": "passed"}, "call": {"duration": 0.020459159000000504, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/siesta.co.jp.aozora.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://www.siesta.co.jp/aozora/index.rdf\\nExpect: E...\\n<dc:creator>PoorBook G3&apos;99</dc:creator>\\n<dc:date>2005-10-29T08:05:59+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0002065289999997333, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/ch.kitaguni.tv.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/ch.kitaguni.tv.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/ch.kitaguni.tv.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.0002303059999997359, "outcome": "passed"}, "call": {"duration": 0.004055402000000541, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/ch.kitaguni.tv.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"euc-jp\"?>\\n<!--\\nSource: http://ch.kitaguni.tv/u/8280/index.rdf\\nExpect: EUC...xb4\\xa1\\xbc\\xa5\\xeb\\xa4\\xa2\\xa4\\xea\\xa4\\xac\\xa4\\xc8\\xa4\\xa6\\xa2\\xf6</p>\\n]]></content:encoded>\\n</item>\\n</rdf:RDF>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017719700000018435, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/contents-factory.com.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/contents-factory.com.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/contents-factory.com.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.0001908359999998055, "outcome": "passed"}, "call": {"duration": 0.0024407619999999852, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/contents-factory.com.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://contents-factory.com/blog/index.rdf\\nExpect:...dc:subject>\\n<dc:creator>katayama</dc:creator>\\n<dc:date>2005-11-15T23:27:43+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018235500000063354, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.atom.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/blog.kabu-navi.com.atom.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/blog.kabu-navi.com.atom.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00018939499999959253, "outcome": "passed"}, "call": {"duration": 0.00415694199999983, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/blog.kabu-navi.com.atom.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://www.kabu-navi.com/mt/atom.xml\\nExpect: EUC-J...\\xa4\\xec\\xa4\\xca\\xa4\\xa4\\xa1\\xa3</p>\\n\\n<p><br />\\n\\xa4\\xc7\\xa4\\xcf\\xa1\\xa3</p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017194700000011665, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/atom.ycf.nanet.co.jp.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/atom.ycf.nanet.co.jp.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/atom.ycf.nanet.co.jp.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.0001850130000002892, "outcome": "passed"}, "call": {"duration": 0.0037388130000000075, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/atom.ycf.nanet.co.jp.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://www.ycf.nanet.co.jp/~dre/cgi-bin/diary/atom....xa4\\xcf\\xc5\\xb1\\xc2\\xe0\\xcd\\xbd\\xc4\\xea\\xa4\\xc7\\xa4\\xb9\\xa1\\xa3</p>]]>\\n      \\n    </content>\\n  </entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017225199999959528, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/arclamp.jp.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/arclamp.jp.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/arclamp.jp.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00018462999999968588, "outcome": "passed"}, "call": {"duration": 0.01230854500000067, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/arclamp.jp.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://www.arclamp.jp/index.rdf\\nExpect: EUC-JP\\n--...</dc:subject>\\n<dc:creator>yusuke</dc:creator>\\n<dc:date>2005-12-07T01:52:31+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001876909999998233, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/furusatonoeki.cutegirl.jp.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/furusatonoeki.cutegirl.jp.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/furusatonoeki.cutegirl.jp.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.0001962780000006603, "outcome": "passed"}, "call": {"duration": 0.0027699729999994815, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/furusatonoeki.cutegirl.jp.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://furusatonoeki.cutegirl.jp/main/index.rdf\\nEx...>\\xa4\\xd5\\xa4\\xeb\\xc0\\xb8\\xa4\\xad</dc:creator>\\n<dc:date>2005-08-12T02:00:37+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001728430000005332, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/pinkupa.com.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/pinkupa.com.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/pinkupa.com.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00018739699999947845, "outcome": "passed"}, "call": {"duration": 0.0033669829999993794, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/pinkupa.com.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://www.pinkupa.com/index.rdf\\nExpect: EUC-JP\\n-.../dc:subject>\\n<dc:creator>michiyo</dc:creator>\\n<dc:date>2005-11-10T20:43:40+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018419999999963466, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/artifact-jp.com.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/artifact-jp.com.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/artifact-jp.com.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00019739399999973983, "outcome": "passed"}, "call": {"duration": 0.0017017180000005183, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/artifact-jp.com.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://artifact-jp.com/index.xml\\nExpect: EUC-JP\\n-...xa4\\xb7\\xa4\\xc6\\xa4\\xb7\\xa4\\xde\\xa4\\xa4\\xa4\\xde\\xa4\\xb9\\xa1\\xa3...</description>\\n    </item>\\n\\n  </channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017722100000039376, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/azoz.org.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/azoz.org.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/azoz.org.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00019404000000022847, "outcome": "passed"}, "call": {"duration": 0.0029334810000003486, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/azoz.org.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://azoz.org/index.rdf\\nExpect: EUC-JP\\n-->\\n<rd...SS</dc:subject>\\n<dc:creator>eizo</dc:creator>\\n<dc:date>2005-11-24T15:25:17+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017784200000026118, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/akaname.main.jp.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/akaname.main.jp.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/akaname.main.jp.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00019530400000000725, "outcome": "passed"}, "call": {"duration": 0.005304681999999339, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/akaname.main.jp.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://akaname.main.jp/mt/index.rdf\\nExpect: EUC-JP.../dc:subject>\\n<dc:creator>akaname</dc:creator>\\n<dc:date>2005-07-20T17:01:19+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001724980000004095, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/mimizun.com.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/mimizun.com.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/mimizun.com.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00018833900000014836, "outcome": "passed"}, "call": {"duration": 0.002456944000000405, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/mimizun.com.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://mimizun.com:81/blog/index.rdf\\nExpect: EUC-J.../dc:subject>\\n<dc:creator>mimizun</dc:creator>\\n<dc:date>2005-12-13T11:20:59+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017244999999999067, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/manana.moo.jp.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/manana.moo.jp.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/manana.moo.jp.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.0001846939999996522, "outcome": "passed"}, "call": {"duration": 0.0018514730000003254, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/manana.moo.jp.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://nanana.moo.jp/index.rdf\\nExpect: EUC-JP\\n-->...</dc:subject>\\n<dc:creator>nanana</dc:creator>\\n<dc:date>2005-03-06T11:43:59+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017237200000064234, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/azito.under.jp.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/azito.under.jp.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/azito.under.jp.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.0001895169999999169, "outcome": "passed"}, "call": {"duration": 0.0019380829999997573, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/azito.under.jp.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://azito.under.jp/blog/azito/index.rdf\\nExpect:...b</dc:subject>\\n<dc:creator>azito</dc:creator>\\n<dc:date>2005-12-12T18:19:15+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018350800000010992, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/EUC-JP/overcube.com.atom.xml-euc-jp]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/EUC-JP/overcube.com.atom.xml-euc-jp]", "parametrize", "pytestmark", "tests/EUC-JP/overcube.com.atom.xml-euc-jp", "test.py", "testbed", ""], "setup": {"duration": 0.00019191099999993355, "outcome": "passed"}, "call": {"duration": 0.015217743000000006, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/EUC-JP/overcube.com.atom.xml', encoding = 'euc-jp'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"EUC-JP\"?>\\n<!--\\nSource: http://www.overcube.com/blog/atom.xml\\nExpect: EUC-...\\n\\n<p>\\xc2\\xad\\xa4\\xac\\xc4\\xcb\\xa4\\xa4\\xa4\\xca\\xa4\\xa2\\xa1\\xa3\\xa1\\xa3</p>]]>\\n    </content>\\n  </entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017065599999988024, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_1.txt-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/_ude_1.txt-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/_ude_1.txt-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00020399099999934833, "outcome": "passed"}, "call": {"duration": 0.006145076000000138, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/_ude_1.txt', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'\\rThe Project Gutenberg Etext of Rashomon by AKUTAGAWA Ryunosuke\\r\\r\\r\\r\\r\\rCopyright laws are changing al...s\\x82\\xcc\\x92\\xac\\x82\\xd6\\x8b\\xad\\x93\\x90\\x82\\xf0\\x93\\xad\\x82\\xab\\x82\\xc9\\x8b}\\x82\\xa2\\x82\\xc5\\x82\\xa2\\x82\\xbd\\x81B\\r')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017568300000014858, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/accessories-brand.com.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/accessories-brand.com.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/accessories-brand.com.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018992600000000692, "outcome": "passed"}, "call": {"duration": 0.003144213000000562, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/accessories-brand.com.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.accessories-brand.com/atom.xml\\nExpec...tp://www.tasaki.co.jp/\" target=\"_blank\" >http://www.tasaki.co.jp/</a><br /></p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018447100000074101, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/setsuzei119.jp.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/setsuzei119.jp.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/setsuzei119.jp.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00019706500000005178, "outcome": "passed"}, "call": {"duration": 0.0076644620000001495, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/setsuzei119.jp.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://setsuzei119.jp/atom.xml\\nExpect: SHIFT_JI...82\\xcd\\x81A\\x83t\\x83\\x8a\\x81[\\x83_\\x83C\\x83\\x84\\x83\\x8b\\x81F\\x81@0120-533-336</p>]]>\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0002085349999996211, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/dogsinn.jp.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/dogsinn.jp.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/dogsinn.jp.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.0002031929999999349, "outcome": "passed"}, "call": {"duration": 0.0036415679999999284, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/dogsinn.jp.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.dogsinn.jp/owner/atom.xml\\nExpect: SH...\\x81F</B></FONT></FONT><img src=\"photo/stars-3.gif\" width=\"64\" height=\"12\"></p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001866580000005058, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/nextbeaut.com.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/nextbeaut.com.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/nextbeaut.com.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00020446100000004463, "outcome": "passed"}, "call": {"duration": 0.004452462000000601, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/nextbeaut.com.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.nextbeaut.com/mt/atom.xml\\nExpect: SH...81y\\x96\\xe2\\x89\\xae\\x82\\xb3\\x82\\xf1.net\\x81z\" width=\"100\" height=\"100\"></a></p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018908900000003115, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/ooganemochi.com.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/ooganemochi.com.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/ooganemochi.com.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.0001963009999998988, "outcome": "passed"}, "call": {"duration": 0.0008139499999995081, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/ooganemochi.com.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.ooganemochi.com/atom.xml\\nExpect: SHI...82\\xaa\\x82\\xed\\x82\\xa9\\x82\\xe7\\x82\\xf1\\x82\\xa9\\x82\\xc1\\x82\\xbd\\x82\\x9f\\x81B</p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001755420000000285, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_2.txt-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/_ude_2.txt-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/_ude_2.txt-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018944800000042505, "outcome": "passed"}, "call": {"duration": 0.0005823380000000711, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/_ude_2.txt', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'========================================================================\\n    \\x83R\\x83\\x93\\x83\\\\\\x81[\\x83...2\\xb5\\x82\\xdc\\x82\\xb7\\x81B\\n\\n/////////////////////////////////////////////////////////////////////////////\\n\\n\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018207799999991892, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/clickablewords.com.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/clickablewords.com.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/clickablewords.com.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018556600000074752, "outcome": "passed"}, "call": {"duration": 0.0037077359999999615, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/clickablewords.com.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://clickablewords.com/atom.xml\\nExpect: SHIF...82\\xc6\\x82\\xb7\\x82\\xae\\x82\\xc9\\x82\\xa8\\x95\\xa0\\x82\\xf0\\x89\\xf3\\x82\\xb7\\x81B</p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017379500000025416, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/bloglelife.com.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/bloglelife.com.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/bloglelife.com.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.0001842650000005719, "outcome": "passed"}, "call": {"duration": 0.0054566179999993025, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/bloglelife.com.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.bloglelife.com/atom.xml\\nExpect: SHIF...3g\\x83v\\x83\\x8d\\x83O\\x83\\x89\\x83\\x80</A><!-- /TG-Affiliate Banner Space --></p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017083799999983995, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/perth-on.net.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/perth-on.net.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/perth-on.net.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018684299999982557, "outcome": "passed"}, "call": {"duration": 0.0009730020000002781, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/perth-on.net.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.perth-on.net/main/atom.xml\\nExpect: S...c4\\x82\\xdd\\x82\\xc4\\x82\\xcd\\x82\\xa2\\x82\\xa9\\x82\\xaa\\x82\\xc5\\x82\\xb7\\x82\\xa9\\x81B]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017328200000044092, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.money.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/andore.com.money.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/andore.com.money.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018748000000012865, "outcome": "passed"}, "call": {"duration": 0.0030373150000002624, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/andore.com.money.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://andore.com/money/index.rdf\\nExpect: SHIFT...e</dc:subject>\\n<dc:creator>money</dc:creator>\\n<dc:date>2005-10-07T19:56:51+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018439200000042177, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/tamuyou.haun.org.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/tamuyou.haun.org.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/tamuyou.haun.org.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018831299999977347, "outcome": "passed"}, "call": {"duration": 0.004860714999999516, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/tamuyou.haun.org.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://tamuyou.haun.org/mt/index.rdf\\nExpect: SH.../dc:subject>\\n<dc:creator>tamuyou</dc:creator>\\n<dc:date>2005-12-26T16:30:52+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001738969999998119, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_4.txt-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/_ude_4.txt-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/_ude_4.txt-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018993399999978067, "outcome": "passed"}, "call": {"duration": 0.006250947999999923, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/_ude_4.txt', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'Project Gutenberg Etext of The Small Catechism of Martin Luther\\nJapanese Translation by Hiroshi Yuki\\n\\nC...all Catechism of Martin Luther\\nby  hyuki@hyuki.com\\nhttp://www.hyuki.com/\\nhttp://www.hyuki.com/trans/smallct.html\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018296200000023077, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/andore.com.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/andore.com.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018398500000049722, "outcome": "passed"}, "call": {"duration": 0.0020030269999997685, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/andore.com.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://andore.com/mt/index.rdf\\nExpect: SHIFT_JI...t></dc:subject>\\n<dc:creator>Hiro</dc:creator>\\n<dc:date>2004-08-18T06:26:31+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017225700000000899, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/blog.inkase.net.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/blog.inkase.net.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/blog.inkase.net.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018446899999968736, "outcome": "passed"}, "call": {"duration": 0.005770994999999779, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/blog.inkase.net.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"shift_jis\"?>\\n<!--\\nSource: http://blog.inkase.net/atom.xml\\nExpect: SHIFT_J...no\" marginwidth=\"0\" marginheight=\"0\" frameborder=\"0\"></iframe>]]>\\n        \\n    </content>\\n</entry>\\n\\n</feed> \\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019592000000034915, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/_chromium_Shift-JIS_with_no_encoding_specified.html-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/_chromium_Shift-JIS_with_no_encoding_specified.html-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/_chromium_Shift-JIS_with_no_encoding_specified.html-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00020578200000009872, "outcome": "passed"}, "call": {"duration": 0.0004954939999999297, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/_chromium_Shift-JIS_with_no_encoding_specified.html'\nencoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<html>\\n <head>\\n  <title> Shift_JIS </title>\\n </head>\\n\\n <body>\\n  \\x8fO\\x89@\\x8bc\\x89@\\x89^\\x89c\\x88\\x...96\\xca\\x8b\\x91\\x94\\xdb\\x82\\xb7\\x82\\xe9\\x81|\\x82\\xb1\\x82\\xc6\\x82\\xf0\\x8c\\x88\\x82\\xdf\\x82\\xbd\\x81B\\n </body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018689199999943895, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/sakusaka-silk.net.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/sakusaka-silk.net.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/sakusaka-silk.net.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00020877900000026983, "outcome": "passed"}, "call": {"duration": 0.010137870999999521, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/sakusaka-silk.net.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"shift_jis\"?>\\n<!--\\nSource: http://www.sakusaku-silk.net/index.rdf\\nExpect: .../dc:subject>\\n<dc:creator>silknet</dc:creator>\\n<dc:date>2005-10-20T01:52:25+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017680199999947632, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/yasuhisa.com.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/yasuhisa.com.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/yasuhisa.com.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00019733400000010448, "outcome": "passed"}, "call": {"duration": 0.0014285820000008442, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/yasuhisa.com.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"shift_jis\"?><?xml-stylesheet href=\"css/rss.css\" type=\"text/css\"?>\\n<!--\\nSou...c6\\x8ev\\x82\\xa2\\x82\\xdc\\x82\\xb7\\x81B</description>\\n\\t\\t<dc:date>2005-12-21 10:37:07</dc:date>\\n\\t</item>\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001750979999997071, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/andore.com.inami.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/andore.com.inami.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/andore.com.inami.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00019101300000023969, "outcome": "passed"}, "call": {"duration": 0.002815787999999486, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/andore.com.inami.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://andore.com/inami/index.rdf\\nExpect: SHIFT...88</dc:subject>\\n<dc:creator>Hiro</dc:creator>\\n<dc:date>2005-11-24T11:00:00-08:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017362999999992468, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/_ude_3.txt-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/_ude_3.txt-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/_ude_3.txt-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00019289299999947218, "outcome": "passed"}, "call": {"duration": 0.0005673729999999821, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/_ude_3.txt', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'========================================================================\\n    \\x83R\\x83\\x93\\x83\\\\\\x81[\\x83...2\\xb5\\x82\\xdc\\x82\\xb7\\x81B\\n\\n/////////////////////////////////////////////////////////////////////////////\\n\\n\\n\\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.000171066000000053, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/amefoot.net.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/amefoot.net.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/amefoot.net.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018661500000050069, "outcome": "passed"}, "call": {"duration": 0.010640837000000403, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/amefoot.net.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.amefoot.net/atom.xml\\nExpect: SHIFT_J...\\xa9\\x82\\xaf\\x82\\xb5\\x82\\xdc\\x82\\xb5\\x82\\xbd\\x81`\\x81I\\x81I\\n</font></strong></p>]]>\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017399700000009233, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/10e.org.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/10e.org.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/10e.org.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018942799999965843, "outcome": "passed"}, "call": {"duration": 0.008549174999999742, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/10e.org.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://10e.org/index.rdf\\nExpect: SHIFT_JIS\\n-->...ws</dc:subject>\\n<dc:creator>elel</dc:creator>\\n<dc:date>2005-12-28T01:32:13+09:00</dc:date>\\n</item>\\n\\n\\n</rdf:RDF>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017441000000051332, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/grebeweb.net.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/grebeweb.net.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/grebeweb.net.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00020147199999964727, "outcome": "passed"}, "call": {"duration": 0.0034994929999996316, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/grebeweb.net.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.grebeweb.net/mt/atom.xml\\nExpect: SHI...x96\\xbe\\x93\\xfa\\x88\\xc8\\x8d~\\x82\\xcc\\x83G\\x83\\x93\\x83g\\x83\\x8a\\x82\\xc5\\x81B</p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001729370000003172, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/blog.paseri.ne.jp.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/blog.paseri.ne.jp.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/blog.paseri.ne.jp.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.0001979169999994923, "outcome": "passed"}, "call": {"duration": 0.0050828600000007995, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/blog.paseri.ne.jp.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://blog.paseri.ne.jp/atom.xml\\nExpect: SHIFT...ai\\x81F \\x81\\x8f 2,926<br /> \\x94\\xad\\x94\\x84\\x93\\xfa\\x81F 2004/02/21<br /></p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00019196799999932068, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/1affliate.com.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/1affliate.com.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/1affliate.com.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00020013199999979747, "outcome": "passed"}, "call": {"duration": 0.008311171999999978, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/1affliate.com.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.1affliate.com/atom.xml\\nExpect: SHIFT...---------------------------------------------------------------------  \\n</pre>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018684700000015653, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/do.beginnersrack.com.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/do.beginnersrack.com.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/do.beginnersrack.com.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00021006999999961806, "outcome": "passed"}, "call": {"duration": 0.005255871000000134, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/do.beginnersrack.com.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"shift_jis\"?>\\n<!--\\nSource: http://do.beginnersrack.com/atom.xml\\nExpect: SH...b2\\x97\\x9d\\x82\\xaa\\x89\\xc2\\x94\\\\\\x82\\xc8\\x82\\xcc\\x82\\xc5\\x82\\xb7\\x81B\\n\\n\\n\\n    </content>\\n</entry>\\n\\n</feed> \\n\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018328999999983608, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/celeb.lalalu.com.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/celeb.lalalu.com.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/celeb.lalalu.com.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00019333299999946263, "outcome": "passed"}, "call": {"duration": 0.00904767200000034, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/celeb.lalalu.com.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://celeb.lalalu.com/atom.xml\\nExpect: SHIFT_...c\\x82\\xe6\\x82\\xa4\\x82\\xc8\\x8bC\\x82\\xaa\\x82\\xb5\\x82\\xdc\\x82\\xb7\\x82\\xe6\\x81B</p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017435399999943257, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/milliontimes.jp.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/milliontimes.jp.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/milliontimes.jp.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018844900000036802, "outcome": "passed"}, "call": {"duration": 0.0063443940000000865, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/milliontimes.jp.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.milliontimes.jp/column/atom.xml\\nExpe...c\\x91O\\x82\\xaa\\x82\\xc2\\x82\\xa2\\x82\\xbd\\x82\\xe6\\x82\\xa4\\x82\\xc5\\x82\\xb7\\x81B</p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017352600000020146, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/moon-light.ne.jp.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/moon-light.ne.jp.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/moon-light.ne.jp.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00018999200000013872, "outcome": "passed"}, "call": {"duration": 0.0018373359999994676, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/moon-light.ne.jp.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.moon-light.ne.jp/weblog/index.xml\\nEx...category>DVD\\x81|News</category>\\n<pubDate>Mon, 19 Dec 2005 18:46:34 +0900</pubDate>\\n</item>\\n\\n\\n</channel>\\n</rss>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017101399999930322, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/SHIFT_JIS/brag.zaka.to.xml-shift_jis]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/SHIFT_JIS/brag.zaka.to.xml-shift_jis]", "parametrize", "pytestmark", "tests/SHIFT_JIS/brag.zaka.to.xml-shift_jis", "test.py", "testbed", ""], "setup": {"duration": 0.00019899799999922863, "outcome": "passed"}, "call": {"duration": 0.0034766410000006687, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/SHIFT_JIS/brag.zaka.to.xml', encoding = 'shift_jis'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\" standalone=\"yes\"?>\\n<?xml-stylesheet href=\"http://www.blogger.com...2\\xa4\\x82\\xa9\\x81B</div>\\n</content>\\n<draft xmlns=\"http://purl.org/atom-blog/ns#\">false</draft>\\n</entry>\\n</feed>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017013099999996228, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/CP932/y-moto.com.xml-cp932]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/CP932/y-moto.com.xml-cp932]", "parametrize", "pytestmark", "tests/CP932/y-moto.com.xml-cp932", "test.py", "testbed", ""], "setup": {"duration": 0.0001844070000007747, "outcome": "passed"}, "call": {"duration": 0.008415760000000105, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/CP932/y-moto.com.xml', encoding = 'cp932'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<?xml version=\"1.0\" encoding=\"Shift_JIS\"?>\\n<!--\\nSource: http://www.y-moto.com/bd-1/atom.xml\\nExpect: SHI...x8f\\x91\\x82\\xa2\\x82\\xc4\\x82\\xc8\\x82\\xa2\\x82\\xaf\\x82\\xc7\\x81E\\x81E\\x81E\\x81B</p>]]>\\n\\n</content>\\n</entry>\\n\\n</feed>')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.0001721889999997117, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/CP932/hardsoft.at.webry.info.xml-cp932]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/CP932/hardsoft.at.webry.info.xml-cp932]", "parametrize", "pytestmark", "tests/CP932/hardsoft.at.webry.info.xml-cp932", "test.py", "testbed", ""], "setup": {"duration": 0.00018868500000035482, "outcome": "passed"}, "call": {"duration": 0.010215247000000538, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/CP932/hardsoft.at.webry.info.xml', encoding = 'cp932'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-tra..._img/hardsoft.at.webry.info/200802/article_1.html\" height=\"1\" width=\"1\" />\\n<!-- beacon end -->\\n\\n</body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00018415300000018675, "outcome": "passed"}}, {"nodeid": "test.py::test_encoding_detection[tests/CP932/www2.chuo-u.ac.jp-suishin.xml-cp932]", "lineno": 75, "outcome": "failed", "keywords": ["test_encoding_detection[tests/CP932/www2.chuo-u.ac.jp-suishin.xml-cp932]", "parametrize", "pytestmark", "tests/CP932/www2.chuo-u.ac.jp-suishin.xml-cp932", "test.py", "testbed", ""], "setup": {"duration": 0.00019855999999940366, "outcome": "passed"}, "call": {"duration": 0.0013616409999999135, "outcome": "failed", "crash": {"path": "/testbed/chardet/__init__.py", "lineno": 65, "message": "AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?"}, "traceback": [{"path": "test.py", "lineno": 105, "message": ""}, {"path": "chardet/__init__.py", "lineno": 65, "message": "AttributeError"}], "longrepr": "file_name = 'tests/CP932/www2.chuo-u.ac.jp-suishin.xml', encoding = 'cp932'\n\n    @pytest.mark.parametrize(\"file_name, encoding\", gen_test_params())\n    def test_encoding_detection(file_name, encoding):\n        with open(file_name, \"rb\") as f:\n            input_bytes = f.read()\n            result = chardet.detect(input_bytes)\n            try:\n                expected_unicode = input_bytes.decode(encoding)\n            except LookupError:\n                expected_unicode = \"\"\n            try:\n                detected_unicode = input_bytes.decode(result[\"encoding\"])\n            except (LookupError, UnicodeDecodeError, TypeError):\n                detected_unicode = \"\"\n        if result:\n            encoding_match = (result[\"encoding\"] or \"\").lower() == encoding\n        else:\n            encoding_match = False\n        # Only care about mismatches that would actually result in different\n        # behavior when decoding\n        if not encoding_match and expected_unicode != detected_unicode:\n            wrapped_expected = \"\\n\".join(textwrap.wrap(expected_unicode, 100)) + \"\\n\"\n            wrapped_detected = \"\\n\".join(textwrap.wrap(detected_unicode, 100)) + \"\\n\"\n            diff = \"\".join(\n                list(\n                    ndiff(\n                        wrapped_expected.splitlines(True), wrapped_detected.splitlines(True)\n                    )\n                )[:20]\n            )\n>           all_encodings = chardet.detect_all(input_bytes, ignore_threshold=True)\n\ntest.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\\n<html>\\n\\n<head>\\n<meta http-equiv=\"Content-Type\"\\ncontent...t;<a\\n    href=\"mailto:kitaro@tamajs.chuo-u.ac.jp\">kitaro@tamajs.chuo-u.ac.jp</a>&gt;\\n</address>\\n</body>\\n</html>\\n')\nignore_threshold = True\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError"}, "teardown": {"duration": 0.00017572099999974, "outcome": "passed"}}, {"nodeid": "test.py::test_never_fails_to_detect_if_there_is_a_valid_encoding", "lineno": 121, "outcome": "xfailed", "keywords": ["test_never_fails_to_detect_if_there_is_a_valid_encoding", "xfail", "is_hypothesis_test", "_hypothesis_internal_settings_applied", "_hypothesis_internal_use_seed", "_hypothesis_internal_use_settings", "_hypothesis_internal_use_reproduce_failure", "hypothesis", "pytestmark", "test.py", "testbed", ""], "setup": {"duration": 0.000151805000000671, "outcome": "passed"}, "call": {"duration": 1.6466455710000005, "outcome": "skipped", "crash": {"path": "/testbed/test.py", "lineno": 144, "message": "TypeError: 'NoneType' object is not subscriptable\nFalsifying example: test_never_fails_to_detect_if_there_is_a_valid_encoding(\n    txt='0',\n    enc='ascii',  # or any other generated value\n    rnd=HypothesisRandom(generated data),\n)"}, "traceback": [{"path": "test.py", "lineno": 123, "message": ""}, {"path": "test.py", "lineno": 144, "message": "TypeError"}], "longrepr": "@pytest.mark.xfail\n>   @given(\n        st.text(min_size=1),\n        st.sampled_from(\n            [\n                \"ascii\",\n                \"utf-8\",\n                \"utf-16\",\n                \"utf-32\",\n                \"iso-8859-7\",\n                \"iso-8859-8\",\n                \"windows-1255\",\n            ]\n        ),\n        st.randoms(),\n    )\n\ntest.py:123: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntxt = '0', enc = 'ascii', rnd = HypothesisRandom(generated data)\n\n    @pytest.mark.xfail\n    @given(\n        st.text(min_size=1),\n        st.sampled_from(\n            [\n                \"ascii\",\n                \"utf-8\",\n                \"utf-16\",\n                \"utf-32\",\n                \"iso-8859-7\",\n                \"iso-8859-8\",\n                \"windows-1255\",\n            ]\n        ),\n        st.randoms(),\n    )\n    @settings(max_examples=200)\n    def test_never_fails_to_detect_if_there_is_a_valid_encoding(txt, enc, rnd):\n        try:\n            data = txt.encode(enc)\n        except UnicodeEncodeError:\n            assume(False)\n>       detected = chardet.detect(data)[\"encoding\"]\nE       TypeError: 'NoneType' object is not subscriptable\nE       Falsifying example: test_never_fails_to_detect_if_there_is_a_valid_encoding(\nE           txt='0',\nE           enc='ascii',  # or any other generated value\nE           rnd=HypothesisRandom(generated data),\nE       )\n\ntest.py:144: TypeError"}, "teardown": {"duration": 0.0003004830000001846, "outcome": "passed"}}, {"nodeid": "test.py::test_detect_all_and_detect_one_should_agree", "lineno": 158, "outcome": "failed", "keywords": ["test_detect_all_and_detect_one_should_agree", "is_hypothesis_test", "_hypothesis_internal_settings_applied", "_hypothesis_internal_use_seed", "_hypothesis_internal_use_settings", "_hypothesis_internal_use_reproduce_failure", "hypothesis", "test.py", "testbed", ""], "setup": {"duration": 0.00023796199999992496, "outcome": "passed"}, "call": {"duration": 0.5213852659999993, "outcome": "failed", "crash": {"path": "/testbed/test.py", "lineno": 185, "message": "UnboundLocalError: cannot access local variable 'results' where it is not associated with a value\nFalsifying example: test_detect_all_and_detect_one_should_agree(\n    txt='0',\n    enc='ascii',  # or any other generated value\n    _=HypothesisRandom(generated data),\n)"}, "traceback": [{"path": "test.py", "lineno": 160, "message": ""}, {"path": "test.py", "lineno": 185, "message": "UnboundLocalError"}], "longrepr": "txt = '0', enc = 'ascii', _ = HypothesisRandom(generated data)\n\n    @given(\n        st.text(min_size=1),\n        st.sampled_from(\n            [\n                \"ascii\",\n                \"utf-8\",\n                \"utf-16\",\n                \"utf-32\",\n                \"iso-8859-7\",\n                \"iso-8859-8\",\n                \"windows-1255\",\n            ]\n        ),\n        st.randoms(),\n    )\n    @settings(max_examples=200)\n    def test_detect_all_and_detect_one_should_agree(txt, enc, _):\n        try:\n            data = txt.encode(enc)\n        except UnicodeEncodeError:\n            assume(False)\n        try:\n            result = chardet.detect(data)\n>           results = chardet.detect_all(data)\n\ntest.py:182: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nbyte_str = bytearray(b'0'), ignore_threshold = False\n\n    def detect_all(byte_str, ignore_threshold=False):\n        \"\"\"\n        Detect all the possible encodings of the given byte string.\n    \n        :param byte_str:          The byte sequence to examine.\n        :type byte_str:           ``bytes`` or ``bytearray``\n        :param ignore_threshold:  Include encodings that are below\n                                  ``UniversalDetector.MINIMUM_THRESHOLD``\n                                  in results.\n        :type ignore_threshold:   ``bool``\n        \"\"\"\n        if not isinstance(byte_str, bytearray):\n            if not isinstance(byte_str, bytes):\n                raise TypeError(\n                    f\"Expected object of type bytes or bytearray, got: {type(byte_str)}\"\n                )\n            byte_str = bytearray(byte_str)\n    \n        detector = UniversalDetector()\n        detector.feed(byte_str)\n        detector.close()\n    \n>       if detector.input_state == InputState.HIGH_BYTE:\nE       AttributeError: 'UniversalDetector' object has no attribute 'input_state'. Did you mean: '_input_state'?\n\nchardet/__init__.py:65: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\n    @given(\n>       st.text(min_size=1),\n        st.sampled_from(\n            [\n                \"ascii\",\n                \"utf-8\",\n                \"utf-16\",\n                \"utf-32\",\n                \"iso-8859-7\",\n                \"iso-8859-8\",\n                \"windows-1255\",\n            ]\n        ),\n        st.randoms(),\n    )\n\ntest.py:160: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntxt = '0', enc = 'ascii', _ = HypothesisRandom(generated data)\n\n    @given(\n        st.text(min_size=1),\n        st.sampled_from(\n            [\n                \"ascii\",\n                \"utf-8\",\n                \"utf-16\",\n                \"utf-32\",\n                \"iso-8859-7\",\n                \"iso-8859-8\",\n                \"windows-1255\",\n            ]\n        ),\n        st.randoms(),\n    )\n    @settings(max_examples=200)\n    def test_detect_all_and_detect_one_should_agree(txt, enc, _):\n        try:\n            data = txt.encode(enc)\n        except UnicodeEncodeError:\n            assume(False)\n        try:\n            result = chardet.detect(data)\n            results = chardet.detect_all(data)\n            assert result[\"encoding\"] == results[0][\"encoding\"]\n        except Exception as exc:\n>           raise RuntimeError(f\"{result} != {results}\") from exc\nE           UnboundLocalError: cannot access local variable 'results' where it is not associated with a value\nE           Falsifying example: test_detect_all_and_detect_one_should_agree(\nE               txt='0',\nE               enc='ascii',  # or any other generated value\nE               _=HypothesisRandom(generated data),\nE           )\n\ntest.py:185: UnboundLocalError"}, "teardown": {"duration": 0.0003120709999997473, "outcome": "passed"}}]}