
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands paramiko - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-paramiko" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands paramiko
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_initsets_attributes_and_parses_blob" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::init::sets_attributes_and_parses_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_initcomment_optional" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::init::comment_optional
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_initsets_inner_key_when_known_typersa" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::init::sets_inner_key_when_known_type[rsa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_fieldsdefers_to_inner_key_when_presentrsa" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::fields::defers_to_inner_key_when_present[rsa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_get_bitsdefers_to_inner_key_when_presentrsa" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[rsa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_asbytesdefers_to_inner_key_when_presentrsa" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[rsa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_type_stringloads_from_type_and_bytesrsa" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[rsa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathloads_from_pathrsa" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::loads_from_Path[rsa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_fingerprintrsa" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::fingerprint[rsa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_algorithm_namersa" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::algorithm_name[rsa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingsame_key_is_equal_to_itselfrsa" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[rsa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingsame_key_same_hashrsa" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::same_key_same_hash[rsa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingkeys_are_not_equal_to_other_typesrsa" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[rsa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_initsets_inner_key_when_known_typedss" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::init::sets_inner_key_when_known_type[dss]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_fieldsdefers_to_inner_key_when_presentdss" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::fields::defers_to_inner_key_when_present[dss]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_get_bitsdefers_to_inner_key_when_presentdss" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[dss]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_asbytesdefers_to_inner_key_when_presentdss" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[dss]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_type_stringloads_from_type_and_bytesdss" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[dss]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathloads_from_pathdss" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::loads_from_Path[dss]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_fingerprintdss" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::fingerprint[dss]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_algorithm_namedss" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::algorithm_name[dss]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingsame_key_is_equal_to_itselfdss" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[dss]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingsame_key_same_hashdss" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::same_key_same_hash[dss]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingkeys_are_not_equal_to_other_typesdss" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[dss]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_initsets_inner_key_when_known_typeed25519" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::init::sets_inner_key_when_known_type[ed25519]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_fieldsdefers_to_inner_key_when_presented25519" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::fields::defers_to_inner_key_when_present[ed25519]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_get_bitsdefers_to_inner_key_when_presented25519" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[ed25519]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_asbytesdefers_to_inner_key_when_presented25519" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[ed25519]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_type_stringloads_from_type_and_bytesed25519" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[ed25519]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathloads_from_pathed25519" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::loads_from_Path[ed25519]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_fingerprinted25519" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::fingerprint[ed25519]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_algorithm_nameed25519" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::algorithm_name[ed25519]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingsame_key_is_equal_to_itselfed25519" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[ed25519]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingsame_key_same_hashed25519" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::same_key_same_hash[ed25519]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingkeys_are_not_equal_to_other_typesed25519" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[ed25519]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_initsets_inner_key_when_known_typeecdsa-256" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::init::sets_inner_key_when_known_type[ecdsa-256]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_fieldsdefers_to_inner_key_when_presentecdsa-256" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::fields::defers_to_inner_key_when_present[ecdsa-256]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_get_bitsdefers_to_inner_key_when_presentecdsa-256" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[ecdsa-256]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_asbytesdefers_to_inner_key_when_presentecdsa-256" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[ecdsa-256]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_type_stringloads_from_type_and_bytesecdsa-256" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[ecdsa-256]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathloads_from_pathecdsa-256" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::loads_from_Path[ecdsa-256]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_fingerprintecdsa-256" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::fingerprint[ecdsa-256]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_algorithm_nameecdsa-256" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::algorithm_name[ecdsa-256]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingsame_key_is_equal_to_itselfecdsa-256" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[ecdsa-256]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingsame_key_same_hashecdsa-256" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::same_key_same_hash[ecdsa-256]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_equality_and_hashingkeys_are_not_equal_to_other_typesecdsa-256" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[ecdsa-256]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_fieldsdefaults_to_get_name_and_blob" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::fields::defaults_to_get_name_and_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_get_bitsdefaults_to_superclass_implementation" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::get_bits::defaults_to_superclass_implementation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_asbytesdefaults_to_owned_blob" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::asbytes::defaults_to_owned_blob
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_signing_datasign_kwargs0-0" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::signing_data[sign_kwargs0-0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_signing_datasign_kwargs1-2" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::signing_data[sign_kwargs1-2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_signing_datasign_kwargs2-4" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::signing_data[sign_kwargs2-4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_signing_datasign_kwargs3-2" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::signing_data[sign_kwargs3-2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agentpyagentkey_signing_datasign_kwargs4-4" class="md-nav__link">
    <span class="md-ellipsis">
      agent.py::AgentKey_::signing_data[sign_kwargs4-4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthhandler_bad_auth_type" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthHandler_::bad_auth_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthhandler_bad_password" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthHandler_::bad_password
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthhandler_multipart_auth" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthHandler_::multipart_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthhandler_interactive_auth" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthHandler_::interactive_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthhandler_interactive_fallback" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthHandler_::interactive_fallback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthhandler_utf8" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthHandler_::utf8
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthhandler_non_utf8" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthHandler_::non_utf8
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthhandler_auth_exception_when_disconnected" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthHandler_::auth_exception_when_disconnected
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthhandler_non_responsive_triggers_auth_exception" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthHandler_::non_responsive_triggers_auth_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthonlyhandler_fallback_pubkey_algorithmkey_type_algo_selected_when_no_server_sig_algs" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthOnlyHandler_::fallback_pubkey_algorithm::key_type_algo_selected_when_no_server_sig_algs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthonlyhandler_fallback_pubkey_algorithmkey_type_algo_selection_is_cert_suffix_aware" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthOnlyHandler_::fallback_pubkey_algorithm::key_type_algo_selection_is_cert_suffix_aware
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthonlyhandler_fallback_pubkey_algorithmuses_first_preferred_algo_if_key_type_not_in_list" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthOnlyHandler_::fallback_pubkey_algorithm::uses_first_preferred_algo_if_key_type_not_in_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpysha2signaturepubkeyspubkey_auth_honors_disabled_algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::SHA2SignaturePubkeys::pubkey_auth_honors_disabled_algorithms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpysha2signaturepubkeysclient_sha2_disabled_server_sha1_disabled_no_match" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::SHA2SignaturePubkeys::client_sha2_disabled_server_sha1_disabled_no_match
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpysha2signaturepubkeysclient_sha1_disabled_server_sha2_disabled_no_match" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::SHA2SignaturePubkeys::client_sha1_disabled_server_sha2_disabled_no_match
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpysha2signaturepubkeysssh_rsa_still_used_when_sha2_disabled" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::SHA2SignaturePubkeys::ssh_rsa_still_used_when_sha2_disabled
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpysha2signaturepubkeysfirst_client_preferred_algo_used_when_no_server_sig_algs" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::SHA2SignaturePubkeys::first_client_preferred_algo_used_when_no_server_sig_algs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpysha2signaturepubkeyssha2_512" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::SHA2SignaturePubkeys::sha2_512
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpysha2signaturepubkeyssha2_256" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::SHA2SignaturePubkeys::sha2_256
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpysha2signaturepubkeyssha2_256_when_client_only_enables_256" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::SHA2SignaturePubkeys::sha2_256_when_client_only_enables_256
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthsource_base_classrepr_helper_prints_basic_kv_pairs" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthSource_::base_class::repr_helper_prints_basic_kv_pairs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthsource_base_classauthenticate_takes_transport_and_is_abstract" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthSource_::base_class::authenticate_takes_transport_and_is_abstract
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthsource_noneauth_authenticate_auths_none" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthSource_::NoneAuth_::authenticate_auths_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthsource_noneauth_repr_shows_class" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthSource_::NoneAuth_::repr_shows_class
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthsource_password_repr_adds_username" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthSource_::Password_::repr_adds_username
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthsource_password_authenticate_gets_and_supplies_password" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthSource_::Password_::authenticate_gets_and_supplies_password
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthsource_privatekey_authenticate_calls_publickey_with_pkey" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthSource_::PrivateKey_::authenticate_calls_publickey_with_pkey
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthsource_inmemoryprivatekey_repr_shows_pkey_repr" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthSource_::InMemoryPrivateKey_::repr_shows_pkey_repr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthsource_inmemoryprivatekey_repr_appends_agent_flag_when_agentkey" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthSource_::InMemoryPrivateKey_::repr_appends_agent_flag_when_AgentKey
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthsource_ondiskprivatekey_repr_reflects_source_path_and_pkey" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthSource_::OnDiskPrivateKey_::repr_reflects_source_path_and_pkey
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthresult_dunder_strshows_str_not_repr_of_auth_source_and_result" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthResult_::dunder_str::shows_str_not_repr_of_auth_source_and_result
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthresult_dunder_strempty_list_result_values_show_success_string" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthResult_::dunder_str::empty_list_result_values_show_success_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthfailure_str_is_newline_plus_result_str" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthFailure_::str_is_newline_plus_result_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthstrategy_get_sources_is_abstract" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthStrategy_::get_sources_is_abstract
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthstrategy_authenticaterequires_and_uses_transport_with_methods_returning_result" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthStrategy_::authenticate::requires_and_uses_transport_with_methods_returning_result
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthstrategy_authenticatelogs_sources_attempted" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthStrategy_::authenticate::logs_sources_attempted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthstrategy_authenticateraises_authfailure_if_no_successes" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthStrategy_::authenticate::raises_AuthFailure_if_no_successes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#authpyauthstrategy_authenticateshort_circuits_on_successful_auth" class="md-nav__link">
    <span class="md-ellipsis">
      auth.py::AuthStrategy_::authenticate::short_circuits_on_successful_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathloads_from_str" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::loads_from_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathexpands_user" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::expands_user
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathraises_unknownkeytype_for_unknown_types" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::raises_UnknownKeyType_for_unknown_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathleaves_cryptography_exceptions_untouched" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::leaves_cryptography_exceptions_untouched
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathautomatically_loads_certificatesexisting_cert_loaded_when_given_key_path" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::automatically_loads_certificates::existing_cert_loaded_when_given_key_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathautomatically_loads_certificatescan_be_given_cert_path_instead" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::automatically_loads_certificates::can_be_given_cert_path_instead
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathautomatically_loads_certificatesno_cert_load_if_no_cert" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::automatically_loads_certificates::no_cert_load_if_no_cert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_from_pathautomatically_loads_certificatesexcepts_usefully_if_no_key_only_cert" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::from_path::automatically_loads_certificates::excepts_usefully_if_no_key_only_cert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_load_certificatersa_public_cert_blobs" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::load_certificate::rsa_public_cert_blobs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_load_certificateloading_cert_of_different_type_from_key_raises_valueerror" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::load_certificate::loading_cert_of_different_type_from_key_raises_ValueError
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_identifiers_classmethodsdefault_is_class_name_attribute" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::identifiers_classmethods::default_is_class_name_attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_identifiers_classmethodsrsa_is_all_combos_of_cert_and_sha_type" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::identifiers_classmethods::rsa_is_all_combos_of_cert_and_sha_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_identifiers_classmethodsdss_is_protocol_name" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::identifiers_classmethods::dss_is_protocol_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_identifiers_classmethodsed25519_is_protocol_name" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::identifiers_classmethods::ed25519_is_protocol_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pkeypypkey_identifiers_classmethodsecdsa_is_all_curve_names" class="md-nav__link">
    <span class="md-ellipsis">
      pkey.py::PKey_::identifiers_classmethods::ecdsa_is_all_curve_names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_buffered_pipepybufferedpipetesttest_buffered_pipe" class="md-nav__link">
    <span class="md-ellipsis">
      test_buffered_pipe.py::BufferedPipeTest::test_buffered_pipe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_buffered_pipepybufferedpipetesttest_close_while_reading" class="md-nav__link">
    <span class="md-ellipsis">
      test_buffered_pipe.py::BufferedPipeTest::test_close_while_reading
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_buffered_pipepybufferedpipetesttest_delay" class="md-nav__link">
    <span class="md-ellipsis">
      test_buffered_pipe.py::BufferedPipeTest::test_delay
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_buffered_pipepybufferedpipetesttest_or_pipe" class="md-nav__link">
    <span class="md-ellipsis">
      test_buffered_pipe.py::BufferedPipeTest::test_or_pipe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_channelfilepytestchannelfiletest_read_recvs_from_channel" class="md-nav__link">
    <span class="md-ellipsis">
      test_channelfile.py::TestChannelFile::test_read_recvs_from_channel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_channelfilepytestchannelfiletest_write_calls_channel_sendall" class="md-nav__link">
    <span class="md-ellipsis">
      test_channelfile.py::TestChannelFile::test_write_calls_channel_sendall
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_channelfilepytestchannelstderrfiletest_read_calls_channel_recv_stderr" class="md-nav__link">
    <span class="md-ellipsis">
      test_channelfile.py::TestChannelStderrFile::test_read_calls_channel_recv_stderr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_channelfilepytestchannelstderrfiletest_write_calls_channel_sendall" class="md-nav__link">
    <span class="md-ellipsis">
      test_channelfile.py::TestChannelStderrFile::test_write_calls_channel_sendall
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_channelfilepytestchannelstdinfiletest_read_recvs_from_channel" class="md-nav__link">
    <span class="md-ellipsis">
      test_channelfile.py::TestChannelStdinFile::test_read_recvs_from_channel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_channelfilepytestchannelstdinfiletest_write_calls_channel_sendall" class="md-nav__link">
    <span class="md-ellipsis">
      test_channelfile.py::TestChannelStdinFile::test_write_calls_channel_sendall
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_channelfilepytestchannelstdinfiletest_close_calls_channel_shutdown_write" class="md-nav__link">
    <span class="md-ellipsis">
      test_channelfile.py::TestChannelStdinFile::test_close_calls_channel_shutdown_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_auth_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_auth_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_auth_trickledown" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_auth_trickledown
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_auth_trickledown_gssauth" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_auth_trickledown_gssauth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_auth_trickledown_gsskex" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_auth_trickledown_gsskex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_auto_add_policy" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_auto_add_policy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_banner_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_banner_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_certs_allowed_as_key_filename_values" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_certs_allowed_as_key_filename_values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_certs_implicitly_loaded_alongside_key_filename_keys" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_certs_implicitly_loaded_alongside_key_filename_keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_channel_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_channel_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_cleanup" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_cleanup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_client_can_be_used_as_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_client_can_be_used_as_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_client_dsa" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_client_dsa
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_client_ecdsa" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_client_ecdsa
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_client_ed25519" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_client_ed25519
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_client_rsa" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_client_rsa
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_closes_socket_on_socket_errors" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_closes_socket_on_socket_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_disabled_algorithms_defaults_to_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_disabled_algorithms_defaults_to_None
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_disabled_algorithms_passed_directly_if_given" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_disabled_algorithms_passed_directly_if_given
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_host_key_negotiation_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_host_key_negotiation_1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_host_key_negotiation_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_host_key_negotiation_2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_host_key_negotiation_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_host_key_negotiation_3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_host_key_negotiation_4" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_host_key_negotiation_4
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_missing_key_policy_accepts_classes_or_instances" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_missing_key_policy_accepts_classes_or_instances
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_multiple_key_files" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_multiple_key_files
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_multiple_key_files_failure" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_multiple_key_files_failure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_newer_openssh_uses_rsa_sha2_for_certs_not_ssh_rsa" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_newer_openssh_uses_rsa_sha2_for_certs_not_ssh_rsa
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_old_openssh_needs_ssh_rsa_for_certs_not_rsa_sha2" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_old_openssh_needs_ssh_rsa_for_certs_not_rsa_sha2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_reject_policy" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_reject_policy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_reject_policy_gsskex" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_reject_policy_gsskex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_save_host_keys" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_save_host_keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_transport_factory_defaults_to_transport" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_transport_factory_defaults_to_Transport
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_transport_factory_may_be_specified" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_transport_factory_may_be_specified
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpysshclienttesttest_update_environment" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::SSHClientTest::test_update_environment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpypasswordpassphraseteststest_passphrase_kwarg_not_used_for_password_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::PasswordPassphraseTests::test_passphrase_kwarg_not_used_for_password_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpypasswordpassphraseteststest_passphrase_kwarg_used_for_key_passphrase" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::PasswordPassphraseTests::test_passphrase_kwarg_used_for_key_passphrase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpypasswordpassphraseteststest_password_kwarg_not_used_for_passphrase_when_passphrase_kwarg_given" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::PasswordPassphraseTests::test_password_kwarg_not_used_for_passphrase_when_passphrase_kwarg_given
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpypasswordpassphraseteststest_password_kwarg_used_for_passphrase_when_no_passphrase_kwarg_given" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::PasswordPassphraseTests::test_password_kwarg_used_for_passphrase_when_no_passphrase_kwarg_given
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clientpypasswordpassphraseteststest_password_kwarg_works_for_password_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_client.py::PasswordPassphraseTests::test_password_kwarg_works_for_password_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_from_text" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_from_text
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_from_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_from_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_from_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_from_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_parse_config" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_parse_config
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_host_configircdangercom-values0" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_host_config[irc.danger.com-values0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_host_configircexamplecom-values1" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_host_config[irc.example.com-values1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_host_configspooexamplecom-values2" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_host_config[spoo.example.com-values2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_fabric_issue_33" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_fabric_issue_33
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_proxycommand_config_equals_parsing" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_proxycommand_config_equals_parsing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_proxycommand_interpolation" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_proxycommand_interpolation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_proxycommand_tilde_expansion" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_proxycommand_tilde_expansion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_proxyjump_token_expansion" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_proxyjump_token_expansion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_controlpath_token_expansion" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_controlpath_token_expansion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_negation" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_negation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_proxycommand" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_proxycommand
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_identityfile" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_identityfile
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_config_addressfamily_and_lazy_fqdn" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_config_addressfamily_and_lazy_fqdn
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_config_dos_crlf_succeeds" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_config_dos_crlf_succeeds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_get_hostnames" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_get_hostnames
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_quoted_host_names" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_quoted_host_names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_quoted_params_in_config" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_quoted_params_in_config
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_quoted_host_in_config" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_quoted_host_in_config
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_invalid_line_format_excepts" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_invalid_line_format_excepts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_proxycommand_none_issue_415" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_proxycommand_none_issue_415
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_proxycommand_none_masking" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_proxycommand_none_masking
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigtest_hostname_tokenization" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfig::test_hostname_tokenization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_bool_true_ishyes" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[yes]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_bool_true_ishyes_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[YES]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_bool_true_ishyes_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[Yes]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_bool_true_ishtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_boolno" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[no]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_boolno_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[NO]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_boolno_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[No]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_boolfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_int42_0" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int[42_0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_int42_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int[42_1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_int_failuresnot-an-int" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int_failures[not an int]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_int_failuresnone" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int_failures[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfigdict_as_int_failuresnon_int2" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int_failures[non_int2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfig_host_dicts_are_sshconfigdict_instances" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfig_host_dicts_are_SSHConfigDict_instances
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestsshconfigdicttest_sshconfig_wildcard_host_dicts_are_sshconfigdict_instances" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestSSHConfigDict::test_SSHConfig_wildcard_host_dicts_are_SSHConfigDict_instances
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_off_by_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_off_by_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_explicit_no_same_as_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_explicit_no_same_as_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_canonicalization_base_casescanon" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_canonicalization_base_casescanon-always" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon-always]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_canonicalization_base_casescanon-local" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon-local]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_canonicalization_base_casescanon-local-always" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon-local-always]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_uses_getaddrinfo_when_addressfamily_given" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_uses_getaddrinfo_when_AddressFamily_given
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_canonicaldomains_may_be_set_to_space_separated_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_CanonicalDomains_may_be_set_to_space_separated_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_canonicalization_applies_to_single_dot_by_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_canonicalization_applies_to_single_dot_by_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_canonicalization_not_applied_to_two_dots_by_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_canonicalization_not_applied_to_two_dots_by_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_hostname_depth_controllable_with_max_dots_directive" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_hostname_depth_controllable_with_max_dots_directive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_max_dots_may_be_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_max_dots_may_be_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_fallback_yes_does_not_canonicalize_or_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_fallback_yes_does_not_canonicalize_or_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_fallback_no_causes_errors_for_unresolvable_names" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_fallback_no_causes_errors_for_unresolvable_names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytesthostnamecanonicalizationtest_identityfile_continues_being_appended_to" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestHostnameCanonicalization::test_identityfile_continues_being_appended_to
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchalltest_always_matches" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchAll::test_always_matches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchalltest_may_not_mix_with_non_canonical_keywords" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchAll::test_may_not_mix_with_non_canonical_keywords
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchalltest_may_come_after_canonical" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchAll::test_may_come_after_canonical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchalltest_may_not_come_before_canonical" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchAll::test_may_not_come_before_canonical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchalltest_after_canonical_not_loaded_when_non_canonicalized" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchAll::test_after_canonical_not_loaded_when_non_canonicalized
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchexectest_raises_invoke_importerrors_at_runtime" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchExec::test_raises_invoke_ImportErrors_at_runtime
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchexectest_accepts_single_possibly_quoted_argumentunquoted-rando" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchExec::test_accepts_single_possibly_quoted_argument[unquoted-rando]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchexectest_accepts_single_possibly_quoted_argumentquoted-benjamin" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchExec::test_accepts_single_possibly_quoted_argument[quoted-benjamin]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchexectest_accepts_single_possibly_quoted_argumentquoted-spaced-neil" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchExec::test_accepts_single_possibly_quoted_argument[quoted spaced-neil]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchexectest_does_not_match_nonzero_exit_codes" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchExec::test_does_not_match_nonzero_exit_codes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchexectest_tokenizes_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchExec::test_tokenizes_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchexectest_works_with_canonical" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchExec::test_works_with_canonical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchexectest_may_be_negated" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchExec::test_may_be_negated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchexectest_requires_an_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchExec::test_requires_an_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchexectest_works_with_tokenized_hostname" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchExec::test_works_with_tokenized_hostname
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchhosttest_matches_target_name_when_no_hostname" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchHost::test_matches_target_name_when_no_hostname
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchhosttest_matches_hostname_from_global_setting" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchHost::test_matches_hostname_from_global_setting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchhosttest_matches_hostname_from_earlier_match" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchHost::test_matches_hostname_from_earlier_match
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchhosttest_may_be_globbed" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchHost::test_may_be_globbed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchhosttest_may_be_comma_separated_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchHost::test_may_be_comma_separated_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchhosttest_comma_separated_list_may_have_internal_negation" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchHost::test_comma_separated_list_may_have_internal_negation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchhosttest_matches_canonicalized_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchHost::test_matches_canonicalized_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchhosttest_works_with_canonical_keyword" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchHost::test_works_with_canonical_keyword
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchhosttest_may_be_negated" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchHost::test_may_be_negated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchhosttest_requires_an_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchHost::test_requires_an_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchoriginalhosttest_matches_target_host_not_hostname" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchOriginalHost::test_matches_target_host_not_hostname
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchoriginalhosttest_matches_target_host_not_canonicalized_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchOriginalHost::test_matches_target_host_not_canonicalized_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchoriginalhosttest_may_be_globbed" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchOriginalHost::test_may_be_globbed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchoriginalhosttest_may_be_comma_separated_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchOriginalHost::test_may_be_comma_separated_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchoriginalhosttest_comma_separated_list_may_have_internal_negation" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchOriginalHost::test_comma_separated_list_may_have_internal_negation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchoriginalhosttest_may_be_negated" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchOriginalHost::test_may_be_negated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchoriginalhosttest_requires_an_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchOriginalHost::test_requires_an_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchusertest_matches_configured_username" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchUser::test_matches_configured_username
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchusertest_matches_local_username_by_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchUser::test_matches_local_username_by_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchusertest_may_be_globbed" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchUser::test_may_be_globbed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchusertest_may_be_comma_separated_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchUser::test_may_be_comma_separated_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchusertest_comma_separated_list_may_have_internal_negation" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchUser::test_comma_separated_list_may_have_internal_negation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchusertest_may_be_negated" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchUser::test_may_be_negated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchusertest_requires_an_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchUser::test_requires_an_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchlocalusertest_matches_local_username" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchLocalUser::test_matches_local_username
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchlocalusertest_may_be_globbed" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchLocalUser::test_may_be_globbed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchlocalusertest_may_be_comma_separated_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchLocalUser::test_may_be_comma_separated_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchlocalusertest_comma_separated_list_may_have_internal_negation" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchLocalUser::test_comma_separated_list_may_have_internal_negation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchlocalusertest_may_be_negated" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchLocalUser::test_may_be_negated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestmatchlocalusertest_requires_an_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestMatchLocalUser::test_requires_an_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestcomplexmatchingtest_originalhost_host" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestComplexMatching::test_originalhost_host
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestcomplexmatchingtest_originalhost_localuser" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestComplexMatching::test_originalhost_localuser
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestcomplexmatchingtest_everything_but_all" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestComplexMatching::test_everything_but_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestcomplexmatchingtest_everything_but_all_with_some_negated" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestComplexMatching::test_everything_but_all_with_some_negated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestcomplexmatchingtest_negated_canonical" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestComplexMatching::test_negated_canonical
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestfinalmatchingtest_finally" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestFinalMatching::test_finally
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestfinalmatchingtest_default_port" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestFinalMatching::test_default_port
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configpytestfinalmatchingtest_negated" class="md-nav__link">
    <span class="md-ellipsis">
      test_config.py::TestFinalMatching::test_negated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_buffering_flushes" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_buffering_flushes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_flush" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_flush
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_lf" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_lf
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_read_all" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_read_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_readable" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_readable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_readinto" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_readinto
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_readline" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_readline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_writable" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_writable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_write" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_write_bad_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_write_bad_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_write_bytearray" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_write_bytearray
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_write_memoryview" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_write_memoryview
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filepybufferedfiletesttest_write_unicode_as_binary" class="md-nav__link">
    <span class="md-ellipsis">
      test_file.py::BufferedFileTest::test_write_unicode_as_binary
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystesttest_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTest::test_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystesttest_delitem" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTest::test_delitem
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystesttest_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTest::test_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystesttest_dict_set" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTest::test_dict_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystesttest_entry_delitem" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTest::test_entry_delitem
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystesttest_load" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTest::test_load
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystabstesttest_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTabsTest::test_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystabstesttest_delitem" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTabsTest::test_delitem
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystabstesttest_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTabsTest::test_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystabstesttest_dict_set" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTabsTest::test_dict_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystabstesttest_entry_delitem" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTabsTest::test_entry_delitem
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_hostkeyspyhostkeystabstesttest_load" class="md-nav__link">
    <span class="md-ellipsis">
      test_hostkeys.py::HostKeysTabsTest::test_load
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_gex_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_gex_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_gex_old_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_gex_old_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_gex_server" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_gex_server
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_gex_server_with_old_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_gex_server_with_old_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_gex_sha256_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_gex_sha256_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_gex_sha256_old_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_gex_sha256_old_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_gex_sha256_server" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_gex_sha256_server
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_gex_sha256_server_with_old_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_gex_sha256_server_with_old_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_group1_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_group1_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_group1_server" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_group1_server
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_kex_c25519_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_kex_c25519_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_kex_c25519_server" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_kex_c25519_server
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_kex_group14_sha256_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_kex_group14_sha256_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_kex_group14_sha256_server" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_kex_group14_sha256_server
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_kex_group16_sha512_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_kex_group16_sha512_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_kex_group16_sha512_server" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_kex_group16_sha512_server
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_kex_nistp256_client" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_kex_nistp256_client
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_kexpykextesttest_kex_nistp256_server" class="md-nav__link">
    <span class="md-ellipsis">
      test_kex.py::KexTest::test_kex_nistp256_server
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_messagepymessagetesttest_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_message.py::MessageTest::test_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_messagepymessagetesttest_bytes_str_and_repr" class="md-nav__link">
    <span class="md-ellipsis">
      test_message.py::MessageTest::test_bytes_str_and_repr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_messagepymessagetesttest_decode" class="md-nav__link">
    <span class="md-ellipsis">
      test_message.py::MessageTest::test_decode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_messagepymessagetesttest_encode" class="md-nav__link">
    <span class="md-ellipsis">
      test_message.py::MessageTest::test_encode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_messagepymessagetesttest_misc" class="md-nav__link">
    <span class="md-ellipsis">
      test_message.py::MessageTest::test_misc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packetizerpypacketizertesttest_closed" class="md-nav__link">
    <span class="md-ellipsis">
      test_packetizer.py::PacketizerTest::test_closed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packetizerpypacketizertesttest_read" class="md-nav__link">
    <span class="md-ellipsis">
      test_packetizer.py::PacketizerTest::test_read
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_packetizerpypacketizertesttest_write" class="md-nav__link">
    <span class="md-ellipsis">
      test_packetizer.py::PacketizerTest::test_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_compare_dss" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_compare_dss
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_compare_ecdsa_256" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_compare_ecdsa_256
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_compare_ecdsa_384" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_compare_ecdsa_384
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_compare_ecdsa_521" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_compare_ecdsa_521
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_compare_rsa" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_compare_rsa
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_ed25519" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_ed25519
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_ed25519_compare" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_ed25519_compare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_ed25519_load_from_file_obj" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_ed25519_load_from_file_obj
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_existing_keyfiles_still_work_ok" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_existing_keyfiles_still_work_ok
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_generate_dss" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_generate_dss
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_generate_ecdsa" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_generate_ecdsa
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_generate_key_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_generate_key_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_generate_rsa" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_generate_rsa
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_keyfile_is_actually_encrypted" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_keyfile_is_actually_encrypted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_dss" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_dss
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_dss_password" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_dss_password
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_ecdsa_256" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_ecdsa_256
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_ecdsa_384" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_ecdsa_384
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_ecdsa_521" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_ecdsa_521
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_ecdsa_password_256" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_ecdsa_password_256
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_ecdsa_password_384" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_ecdsa_password_384
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_ecdsa_password_521" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_ecdsa_password_521
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_ecdsa_transmutes_crypto_exceptions" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_ecdsa_transmutes_crypto_exceptions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_openssh_format_dss_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_openssh_format_DSS_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_openssh_format_ec_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_openssh_format_EC_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_openssh_format_rsa_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_openssh_format_RSA_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_rsa" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_rsa
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_rsa_password" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_rsa_password
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_load_rsa_transmutes_crypto_exceptions" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_load_rsa_transmutes_crypto_exceptions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_loading_empty_keys_errors_usefully" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_loading_empty_keys_errors_usefully
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_loading_openssh_rsa_keys_uses_correct_p_q" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_loading_openssh_RSA_keys_uses_correct_p_q
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_new_keyfiles_avoid_descriptor_race_integration" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_new_keyfiles_avoid_descriptor_race_integration
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_new_keyfiles_avoid_file_descriptor_race_on_chmod" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_new_keyfiles_avoid_file_descriptor_race_on_chmod
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_salt_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_salt_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_sign_and_verify_rsa_sha2_256" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_sign_and_verify_rsa_sha2_256
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_sign_and_verify_rsa_sha2_512" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_sign_and_verify_rsa_sha2_512
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_sign_and_verify_ssh_rsa" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_sign_and_verify_ssh_rsa
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_sign_dss" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_sign_dss
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_sign_ecdsa_256" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_sign_ecdsa_256
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_sign_ecdsa_384" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_sign_ecdsa_384
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_sign_ecdsa_521" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_sign_ecdsa_521
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkeypykeytesttest_stringification" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkey.py::KeyTest::test_stringification
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_proxypytestproxycommandtest_send_writes_to_process_stdin_returning_length" class="md-nav__link">
    <span class="md-ellipsis">
      test_proxy.py::TestProxyCommand::test_send_writes_to_process_stdin_returning_length
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_proxypytestproxycommandtest_send_raises_proxycommandfailure_on_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_proxy.py::TestProxyCommand::test_send_raises_ProxyCommandFailure_on_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_proxypytestproxycommandtest_recv_reads_from_process_stdout_returning_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      test_proxy.py::TestProxyCommand::test_recv_reads_from_process_stdout_returning_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_proxypytestproxycommandtest_recv_returns_buffer_on_timeout_if_any_read" class="md-nav__link">
    <span class="md-ellipsis">
      test_proxy.py::TestProxyCommand::test_recv_returns_buffer_on_timeout_if_any_read
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_proxypytestproxycommandtest_recv_raises_timeout_if_nothing_read" class="md-nav__link">
    <span class="md-ellipsis">
      test_proxy.py::TestProxyCommand::test_recv_raises_timeout_if_nothing_read
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_proxypytestproxycommandtest_recv_raises_proxycommandfailure_on_non_timeout_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_proxy.py::TestProxyCommand::test_recv_raises_ProxyCommandFailure_on_non_timeout_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_proxypytestproxycommandtest_close_kills_subprocess" class="md-nav__link">
    <span class="md-ellipsis">
      test_proxy.py::TestProxyCommand::test_close_kills_subprocess
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_proxypytestproxycommandtest_closed_exposes_whether_subprocess_has_exited" class="md-nav__link">
    <span class="md-ellipsis">
      test_proxy.py::TestProxyCommand::test_closed_exposes_whether_subprocess_has_exited
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_proxypytestproxycommandtest_timeout_affects_whether_timeout_is_raised" class="md-nav__link">
    <span class="md-ellipsis">
      test_proxy.py::TestProxyCommand::test_timeout_affects_whether_timeout_is_raised
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_close" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_sftp_can_be_used_as_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_sftp_can_be_used_as_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_write" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_sftp_file_can_be_used_as_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_sftp_file_can_be_used_as_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_append" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_append
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_rename" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_rename
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptesta_posix_rename" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::testa_posix_rename
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_folder" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_folder
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_listdir" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_listdir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_listdir_iter" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_listdir_iter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_listdir_in_locale" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_listdir_in_locale
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_setstat" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_setstat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_fsetstat" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_fsetstat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_readline_seek" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_readline_seek
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_write_seek" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_write_seek
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_symlink" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_symlink
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_flush_seek" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_flush_seek
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_realpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_realpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_mkdir" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_mkdir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_chdir" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_chdir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_get_put" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_get_put
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_get_without_prefetch" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_get_without_prefetch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_check" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_check
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_x_flag" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_x_flag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_utf8" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_utf8
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_utf8_chdir" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_utf8_chdir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_bad_readv" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_bad_readv
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_put_without_confirm" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_put_without_confirm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_getcwd" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_getcwd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_seek_append" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_seek_append
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_putfo_empty_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_putfo_empty_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_non_utf8_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_non_utf8_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_sftp_attributes_locale_time" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_sftp_attributes_locale_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_sftp_attributes_empty_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_sftp_attributes_empty_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftppytestsftptest_write_memoryview" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp.py::TestSFTP::test_write_memoryview
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftp_bigpytestbigsftptest_lots_of_files" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp_big.py::TestBigSFTP::test_lots_of_files
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftp_bigpytestbigsftptest_big_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp_big.py::TestBigSFTP::test_big_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftp_bigpytestbigsftptest_big_file_pipelined" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp_big.py::TestBigSFTP::test_big_file_pipelined
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftp_bigpytestbigsftptest_prefetch_seek" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp_big.py::TestBigSFTP::test_prefetch_seek
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftp_bigpytestbigsftptest_readv_seek" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp_big.py::TestBigSFTP::test_readv_seek
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftp_bigpytestbigsftptest_lots_of_prefetching" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp_big.py::TestBigSFTP::test_lots_of_prefetching
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftp_bigpytestbigsftptest_prefetch_readv" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp_big.py::TestBigSFTP::test_prefetch_readv
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftp_bigpytestbigsftptest_large_readv" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp_big.py::TestBigSFTP::test_large_readv
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftp_bigpytestbigsftptest_big_file_big_buffer" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp_big.py::TestBigSFTP::test_big_file_big_buffer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftp_bigpytestbigsftptest_big_file_renegotiate" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp_big.py::TestBigSFTP::test_big_file_renegotiate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_sftp_bigpytestbigsftptest_prefetch_limit" class="md-nav__link">
    <span class="md-ellipsis">
      test_sftp_big.py::TestBigSFTP::test_prefetch_limit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ssh_exceptionpyexceptionstringdisplaytesttest_badhostkeyexception" class="md-nav__link">
    <span class="md-ellipsis">
      test_ssh_exception.py::ExceptionStringDisplayTest::test_BadHostKeyException
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_can_override_packetizer_used" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_can_override_packetizer_used
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_channel_can_be_used_as_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_channel_can_be_used_as_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_channel_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_channel_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_channel_send_memoryview" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_channel_send_memoryview
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_channel_send_misc" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_channel_send_misc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_client_does_not_respond_to_msg_unimplemented" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_client_does_not_respond_to_MSG_UNIMPLEMENTED
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_compression" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_compression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_compute_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_compute_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_exec_command" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_exec_command
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_exit_status" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_exit_status
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_handshake_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_handshake_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_invoke_shell" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_invoke_shell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_keepalive" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_keepalive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_long_banner" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_long_banner
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_port_forwarding" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_port_forwarding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_rekey_deadlock" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_rekey_deadlock
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_renegotiate" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_renegotiate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_reverse_port_forwarding" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_reverse_port_forwarding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_sanitze_packet_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_sanitze_packet_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_sanitze_window_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_sanitze_window_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_security_options" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_security_options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_select" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_select
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_select_after_close" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_select_after_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_send_ready" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_send_ready
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_server_does_not_respond_to_msg_unimplemented" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_server_does_not_respond_to_MSG_UNIMPLEMENTED
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_server_rejects_arbitrary_global_request_without_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_server_rejects_arbitrary_global_request_without_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_server_rejects_client_msg_userauth_success" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_server_rejects_client_MSG_USERAUTH_SUCCESS
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_server_rejects_open_channel_without_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_server_rejects_open_channel_without_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_server_rejects_port_forward_without_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_server_rejects_port_forward_without_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_server_transports_reject_client_message_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_server_transports_reject_client_message_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_special" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_special
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_stderr_select" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_stderr_select
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttest_x11" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::test_x11
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytransporttesttestb_security_options_reset" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TransportTest::testb_security_options_reset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_can_override_packetizer_used" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_can_override_packetizer_used
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_channel_can_be_used_as_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_channel_can_be_used_as_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_channel_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_channel_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_channel_send_memoryview" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_channel_send_memoryview
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_channel_send_misc" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_channel_send_misc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_client_does_not_respond_to_msg_unimplemented" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_client_does_not_respond_to_MSG_UNIMPLEMENTED
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_compression" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_compression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_compute_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_compute_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_exec_command" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_exec_command
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_exit_status" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_exit_status
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_handshake_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_handshake_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_invoke_shell" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_invoke_shell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_keepalive" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_keepalive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_long_banner" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_long_banner
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_port_forwarding" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_port_forwarding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_rekey_deadlock" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_rekey_deadlock
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_renegotiate" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_renegotiate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_reverse_port_forwarding" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_reverse_port_forwarding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_sanitze_packet_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_sanitze_packet_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_sanitze_window_size" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_sanitze_window_size
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_security_options" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_security_options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_select" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_select
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_select_after_close" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_select_after_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_send_ready" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_send_ready
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_server_does_not_respond_to_msg_unimplemented" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_server_does_not_respond_to_MSG_UNIMPLEMENTED
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_server_rejects_arbitrary_global_request_without_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_server_rejects_arbitrary_global_request_without_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_server_rejects_client_msg_userauth_success" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_server_rejects_client_MSG_USERAUTH_SUCCESS
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_server_rejects_open_channel_without_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_server_rejects_open_channel_without_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_server_rejects_port_forward_without_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_server_rejects_port_forward_without_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_server_transports_reject_client_message_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_server_transports_reject_client_message_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_special" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_special
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_stderr_select" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_stderr_select
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttest_x11" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::test_x11
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyservicerequestingtransporttesttestb_security_options_reset" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::ServiceRequestingTransportTest::testb_security_options_reset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyalgorithmdisablingteststest_implementation_refers_to_public_algo_lists" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::AlgorithmDisablingTests::test_implementation_refers_to_public_algo_lists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyalgorithmdisablingteststest_preferred_lists_default_to_private_attribute_contents" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::AlgorithmDisablingTests::test_preferred_lists_default_to_private_attribute_contents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyalgorithmdisablingteststest_preferred_lists_filter_disabled_algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::AlgorithmDisablingTests::test_preferred_lists_filter_disabled_algorithms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytestsha2signaturekeyexchangetest_base_case_ssh_rsa_still_used_as_fallback" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestSHA2SignatureKeyExchange::test_base_case_ssh_rsa_still_used_as_fallback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytestsha2signaturekeyexchangetest_client_sha1_disabled_server_sha2_disabled_no_match" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestSHA2SignatureKeyExchange::test_client_sha1_disabled_server_sha2_disabled_no_match
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytestsha2signaturekeyexchangetest_client_sha2_disabled_server_sha1_disabled_no_match" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestSHA2SignatureKeyExchange::test_client_sha2_disabled_server_sha1_disabled_no_match
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytestsha2signaturekeyexchangetest_explicit_client_hostkey_not_limited" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestSHA2SignatureKeyExchange::test_explicit_client_hostkey_not_limited
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytestsha2signaturekeyexchangetest_kex_with_sha2_256" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestSHA2SignatureKeyExchange::test_kex_with_sha2_256
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytestsha2signaturekeyexchangetest_kex_with_sha2_512" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestSHA2SignatureKeyExchange::test_kex_with_sha2_512
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytestextinfotest_client_uses_server_sig_algs_for_pubkey_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestExtInfo::test_client_uses_server_sig_algs_for_pubkey_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpytestextinfotest_ext_info_handshake_exposed_in_client_kexinit" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestExtInfo::test_ext_info_handshake_exposed_in_client_kexinit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_kex_algos_includes_kex_strict_c" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_kex_algos_includes_kex_strict_c
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_mode_agreementtrue-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_mode_agreement[True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_mode_agreementtrue-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_mode_agreement[True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_mode_agreementfalse-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_mode_agreement[False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_mode_agreementfalse-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_mode_agreement[False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_mode_advertised_by_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_mode_advertised_by_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_messageordererror_non_kex_messages_in_initial_kex90" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[90]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_messageordererror_non_kex_messages_in_initial_kex2" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_messageordererror_non_kex_messages_in_initial_kex4" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_messageordererror_non_kex_messages_in_initial_kex3" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_messageordererror_non_kex_messages_in_initial_kex253" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[253]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_sshexception_raised_on_out_of_order_messages_when_not_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_SSHException_raised_on_out_of_order_messages_when_not_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_error_not_raised_when_kexinit_not_seq_0_but_unstrict" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_error_not_raised_when_kexinit_not_seq_0_but_unstrict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_messageordererror_raised_when_kexinit_not_seq_0_and_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_MessageOrderError_raised_when_kexinit_not_seq_0_and_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_sequence_numbers_reset_on_newkeys_when_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_sequence_numbers_reset_on_newkeys_when_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_sequence_numbers_not_reset_on_newkeys_when_not_strict" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_sequence_numbers_not_reset_on_newkeys_when_not_strict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_transportpyteststrictkextest_sequence_number_rollover_detected" class="md-nav__link">
    <span class="md-ellipsis">
      test_transport.py::TestStrictKex::test_sequence_number_rollover_detected
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpyutiltesttest_generate_key_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::UtilTest::test_generate_key_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilpyutiltesttest_host_keys" class="md-nav__link">
    <span class="md-ellipsis">
      test_util.py::UtilTest::test_host_keys
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-paramiko"><strong>OpenHands</strong>: paramiko</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">41</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">425</td>
</tr>
<tr>
<td style="text-align: left;">error</td>
<td style="text-align: center;">91</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">21</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">578</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">578</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="agentpyagentkey_initsets_attributes_and_parses_blob">agent.py::AgentKey_::init::sets_attributes_and_parses_blob</h3>
<details><summary> <pre>agent.py::AgentKey_::init::sets_attributes_and_parses_blob</pre></summary><pre>
self = <tests.agent.AgentKey_.init object at 0x7eb2fba92e00>

    def sets_attributes_and_parses_blob(self):
        agent = Mock()
        blob = Message()
        blob.add_string("bad-type")
>       key = AgentKey(agent=agent, blob=bytes(blob))
E       TypeError: __bytes__ returned non-bytes (type NoneType)

tests/agent.py:43: TypeError
</pre>
</details>
<h3 id="agentpyagentkey_initcomment_optional">agent.py::AgentKey_::init::comment_optional</h3>
<details><summary> <pre>agent.py::AgentKey_::init::comment_optional</pre></summary><pre>
self = <tests.agent.AgentKey_.init object at 0x7eb2fba922f0>

    def comment_optional(self):
        blob = Message()
        blob.add_string("bad-type")
>       key = AgentKey(agent=Mock(), blob=bytes(blob), comment="hi!")
E       TypeError: __bytes__ returned non-bytes (type NoneType)

tests/agent.py:54: TypeError
</pre>
</details>
<h3 id="agentpyagentkey_initsets_inner_key_when_known_typersa">agent.py::AgentKey_::init::sets_inner_key_when_known_type[rsa]</h3>
<details><summary> <pre>agent.py::AgentKey_::init::sets_inner_key_when_known_type[rsa]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[rsa]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_fieldsdefers_to_inner_key_when_presentrsa">agent.py::AgentKey_::fields::defers_to_inner_key_when_present[rsa]</h3>
<details><summary> <pre>agent.py::AgentKey_::fields::defers_to_inner_key_when_present[rsa]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[rsa]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_get_bitsdefers_to_inner_key_when_presentrsa">agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[rsa]</h3>
<details><summary> <pre>agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[rsa]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[rsa]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_asbytesdefers_to_inner_key_when_presentrsa">agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[rsa]</h3>
<details><summary> <pre>agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[rsa]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[rsa]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_from_type_stringloads_from_type_and_bytesrsa">pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[rsa]</h3>
<details><summary> <pre>pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[rsa]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[rsa]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_from_pathloads_from_pathrsa">pkey.py::PKey_::from_path::loads_from_Path[rsa]</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::loads_from_Path[rsa]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[rsa]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_fingerprintrsa">pkey.py::PKey_::fingerprint[rsa]</h3>
<details><summary> <pre>pkey.py::PKey_::fingerprint[rsa]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[rsa]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_algorithm_namersa">pkey.py::PKey_::algorithm_name[rsa]</h3>
<details><summary> <pre>pkey.py::PKey_::algorithm_name[rsa]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[rsa]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingsame_key_is_equal_to_itselfrsa">pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[rsa]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[rsa]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[rsa]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingsame_key_same_hashrsa">pkey.py::PKey_::equality_and_hashing::same_key_same_hash[rsa]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::same_key_same_hash[rsa]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[rsa]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingkeys_are_not_equal_to_other_typesrsa">pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[rsa]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[rsa]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[rsa]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_initsets_inner_key_when_known_typedss">agent.py::AgentKey_::init::sets_inner_key_when_known_type[dss]</h3>
<details><summary> <pre>agent.py::AgentKey_::init::sets_inner_key_when_known_type[dss]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[dss]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_fieldsdefers_to_inner_key_when_presentdss">agent.py::AgentKey_::fields::defers_to_inner_key_when_present[dss]</h3>
<details><summary> <pre>agent.py::AgentKey_::fields::defers_to_inner_key_when_present[dss]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[dss]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_get_bitsdefers_to_inner_key_when_presentdss">agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[dss]</h3>
<details><summary> <pre>agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[dss]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[dss]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_asbytesdefers_to_inner_key_when_presentdss">agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[dss]</h3>
<details><summary> <pre>agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[dss]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[dss]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_from_type_stringloads_from_type_and_bytesdss">pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[dss]</h3>
<details><summary> <pre>pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[dss]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[dss]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_from_pathloads_from_pathdss">pkey.py::PKey_::from_path::loads_from_Path[dss]</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::loads_from_Path[dss]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[dss]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_fingerprintdss">pkey.py::PKey_::fingerprint[dss]</h3>
<details><summary> <pre>pkey.py::PKey_::fingerprint[dss]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[dss]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_algorithm_namedss">pkey.py::PKey_::algorithm_name[dss]</h3>
<details><summary> <pre>pkey.py::PKey_::algorithm_name[dss]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[dss]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingsame_key_is_equal_to_itselfdss">pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[dss]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[dss]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[dss]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingsame_key_same_hashdss">pkey.py::PKey_::equality_and_hashing::same_key_same_hash[dss]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::same_key_same_hash[dss]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[dss]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingkeys_are_not_equal_to_other_typesdss">pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[dss]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[dss]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[dss]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_initsets_inner_key_when_known_typeed25519">agent.py::AgentKey_::init::sets_inner_key_when_known_type[ed25519]</h3>
<details><summary> <pre>agent.py::AgentKey_::init::sets_inner_key_when_known_type[ed25519]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ed25519]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_fieldsdefers_to_inner_key_when_presented25519">agent.py::AgentKey_::fields::defers_to_inner_key_when_present[ed25519]</h3>
<details><summary> <pre>agent.py::AgentKey_::fields::defers_to_inner_key_when_present[ed25519]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ed25519]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_get_bitsdefers_to_inner_key_when_presented25519">agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[ed25519]</h3>
<details><summary> <pre>agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[ed25519]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ed25519]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_asbytesdefers_to_inner_key_when_presented25519">agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[ed25519]</h3>
<details><summary> <pre>agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[ed25519]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ed25519]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_from_type_stringloads_from_type_and_bytesed25519">pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[ed25519]</h3>
<details><summary> <pre>pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[ed25519]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ed25519]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_from_pathloads_from_pathed25519">pkey.py::PKey_::from_path::loads_from_Path[ed25519]</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::loads_from_Path[ed25519]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ed25519]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_fingerprinted25519">pkey.py::PKey_::fingerprint[ed25519]</h3>
<details><summary> <pre>pkey.py::PKey_::fingerprint[ed25519]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ed25519]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_algorithm_nameed25519">pkey.py::PKey_::algorithm_name[ed25519]</h3>
<details><summary> <pre>pkey.py::PKey_::algorithm_name[ed25519]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ed25519]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingsame_key_is_equal_to_itselfed25519">pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[ed25519]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[ed25519]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ed25519]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingsame_key_same_hashed25519">pkey.py::PKey_::equality_and_hashing::same_key_same_hash[ed25519]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::same_key_same_hash[ed25519]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ed25519]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingkeys_are_not_equal_to_other_typesed25519">pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[ed25519]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[ed25519]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ed25519]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_initsets_inner_key_when_known_typeecdsa-256">agent.py::AgentKey_::init::sets_inner_key_when_known_type[ecdsa-256]</h3>
<details><summary> <pre>agent.py::AgentKey_::init::sets_inner_key_when_known_type[ecdsa-256]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ecdsa-256]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_fieldsdefers_to_inner_key_when_presentecdsa-256">agent.py::AgentKey_::fields::defers_to_inner_key_when_present[ecdsa-256]</h3>
<details><summary> <pre>agent.py::AgentKey_::fields::defers_to_inner_key_when_present[ecdsa-256]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ecdsa-256]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_get_bitsdefers_to_inner_key_when_presentecdsa-256">agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[ecdsa-256]</h3>
<details><summary> <pre>agent.py::AgentKey_::get_bits::defers_to_inner_key_when_present[ecdsa-256]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ecdsa-256]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_asbytesdefers_to_inner_key_when_presentecdsa-256">agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[ecdsa-256]</h3>
<details><summary> <pre>agent.py::AgentKey_::asbytes::defers_to_inner_key_when_present[ecdsa-256]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ecdsa-256]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_from_type_stringloads_from_type_and_bytesecdsa-256">pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[ecdsa-256]</h3>
<details><summary> <pre>pkey.py::PKey_::from_type_string::loads_from_type_and_bytes[ecdsa-256]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ecdsa-256]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_from_pathloads_from_pathecdsa-256">pkey.py::PKey_::from_path::loads_from_Path[ecdsa-256]</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::loads_from_Path[ecdsa-256]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ecdsa-256]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_fingerprintecdsa-256">pkey.py::PKey_::fingerprint[ecdsa-256]</h3>
<details><summary> <pre>pkey.py::PKey_::fingerprint[ecdsa-256]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ecdsa-256]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_algorithm_nameecdsa-256">pkey.py::PKey_::algorithm_name[ecdsa-256]</h3>
<details><summary> <pre>pkey.py::PKey_::algorithm_name[ecdsa-256]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ecdsa-256]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingsame_key_is_equal_to_itselfecdsa-256">pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[ecdsa-256]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::same_key_is_equal_to_itself[ecdsa-256]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ecdsa-256]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingsame_key_same_hashecdsa-256">pkey.py::PKey_::equality_and_hashing::same_key_same_hash[ecdsa-256]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::same_key_same_hash[ecdsa-256]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ecdsa-256]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_equality_and_hashingkeys_are_not_equal_to_other_typesecdsa-256">pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[ecdsa-256]</h3>
<details><summary> <pre>pkey.py::PKey_::equality_and_hashing::keys_are_not_equal_to_other_types[ecdsa-256]</pre></summary><pre>
request = <SubRequest 'keys' for <Function sets_inner_key_when_known_type[ecdsa-256]>>

    @pytest.fixture(scope="session", params=key_data, ids=lambda x: x[0])
    def keys(request):
        """
        Yield an object for each known type of key, with attributes:

        - ``short_type``: short identifier, eg ``rsa`` or ``ecdsa-256``
        - ``full_type``: the "message style" key identifier, eg ``ssh-rsa``, or
          ``ecdsa-sha2-nistp256``.
        - ``path``: a pathlib Path object to the fixture key file
        - ``pkey``: PKey object, which may or may not also have a cert loaded
        - ``expected_fp``: the expected fingerprint of said key
        """
        short_type, key_type, key_class, fingerprint = request.param
        bag = Lexicon()
        bag.short_type = short_type
        bag.full_type = key_type
        bag.path = Path(_support(f"{short_type}.key"))
        with bag.path.open() as fd:
            bag.pkey = key_class.from_private_key(fd)
        # Second copy for things like equality-but-not-identity testing
        with bag.path.open() as fd:
            bag.pkey2 = key_class.from_private_key(fd)
        bag.expected_fp = fingerprint
        # Also tack on the cert-bearing variant for some tests
        cert = bag.path.with_suffix(".key-cert.pub")
        bag.pkey_with_cert = PKey.from_path(cert) if cert.exists() else None
        # Safety checks
>       assert bag.pkey.fingerprint == fingerprint
E       AttributeError: 'NoneType' object has no attribute 'fingerprint'

tests/conftest.py:169: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_fieldsdefaults_to_get_name_and_blob">agent.py::AgentKey_::fields::defaults_to_get_name_and_blob</h3>
<details><summary> <pre>agent.py::AgentKey_::fields::defaults_to_get_name_and_blob</pre></summary><pre>
self = <tests.agent.AgentKey_.fields object at 0x7eb2fb91fdc0>

    def defaults_to_get_name_and_blob(self):
        key = _BareAgentKey(name="lol", blob=b"lmao")
>       assert key._fields == ["lol", b"lmao"]

tests/agent.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PKey(alg=None, bits=None, fp=None), name = '_fields'

    def __getattr__(self, name):
        """
        Proxy any un-implemented methods/properties to the inner_key.
        """
        if self.inner_key is None:
>           raise AttributeError(name)
E           AttributeError: _fields

paramiko/agent.py:271: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_get_bitsdefaults_to_superclass_implementation">agent.py::AgentKey_::get_bits::defaults_to_superclass_implementation</h3>
<details><summary> <pre>agent.py::AgentKey_::get_bits::defaults_to_superclass_implementation</pre></summary><pre>
self = <tests.agent.AgentKey_.get_bits object at 0x7eb2fb91c6a0>

    def defaults_to_superclass_implementation(self):
        # TODO 4.0: assert raises NotImplementedError like changed parent?
>       assert _BareAgentKey(None, None).get_bits() == 0
E       assert None == 0
E        +  where None = get_bits()
E        +    where get_bits = PKey(alg=None, bits=None, fp=None).get_bits
E        +      where PKey(alg=None, bits=None, fp=None) = _BareAgentKey(None, None)

tests/agent.py:75: AssertionError
</pre>
</details>
<h3 id="agentpyagentkey_asbytesdefaults_to_owned_blob">agent.py::AgentKey_::asbytes::defaults_to_owned_blob</h3>
<details><summary> <pre>agent.py::AgentKey_::asbytes::defaults_to_owned_blob</pre></summary><pre>
self = <tests.agent.AgentKey_.asbytes object at 0x7eb2fb91c8b0>

    def defaults_to_owned_blob(self):
        blob = Mock()
>       assert _BareAgentKey(name=None, blob=blob).asbytes() is blob
E       AssertionError: assert None is <Mock id='139307151162672'>
E        +  where None = asbytes()
E        +    where asbytes = PKey(alg=None, bits=None, fp=None).asbytes
E        +      where PKey(alg=None, bits=None, fp=None) = _BareAgentKey(name=None, blob=<Mock id='139307151162672'>)

tests/agent.py:84: AssertionError
</pre>
</details>
<h3 id="agentpyagentkey_signing_datasign_kwargs0-0">agent.py::AgentKey_::signing_data[sign_kwargs0-0]</h3>
<details><summary> <pre>agent.py::AgentKey_::signing_data[sign_kwargs0-0]</pre></summary><pre>
self = <tests.agent.AgentKey_ object at 0x7eb2fb086830>, sign_kwargs = {}
expected_flag = 0

    @mark.parametrize(
        "sign_kwargs,expected_flag",
        [
            # No algorithm kwarg: no flags (bitfield -> 0 int)
            (dict(), 0),
            (dict(algorithm="rsa-sha2-256"), SSH_AGENT_RSA_SHA2_256),
            (dict(algorithm="rsa-sha2-512"), SSH_AGENT_RSA_SHA2_512),
            # TODO: ideally we only send these when key is a cert,
            # but it doesn't actually break when not; meh. Really just wants
            # all the parameterization of this test rethought.
            (
                dict(algorithm="rsa-sha2-256-cert-v01@openssh.com"),
                SSH_AGENT_RSA_SHA2_256,
            ),
            (
                dict(algorithm="rsa-sha2-512-cert-v01@openssh.com"),
                SSH_AGENT_RSA_SHA2_512,
            ),
        ],
    )
    def signing_data(self, sign_kwargs, expected_flag):
        class FakeAgent:
            def _send_message(self, msg):
                # The thing we actually care most about, we're not testing
                # ssh-agent itself here
                self._sent_message = msg
                sig = Message()
                sig.add_string("lol")
                sig.rewind()
                return SSH2_AGENT_SIGN_RESPONSE, sig

        for do_cert in (False, True):
            agent = FakeAgent()
            # Get key kinda like how a real agent would give it to us - if
            # cert, it'd be the entire public blob, not just the pubkey. This
            # ensures the code under test sends _just the pubkey part_ back to
            # the agent during signature requests (bug was us sending _the
            # entire cert blob_, which somehow "worked ok" but always got us
            # SHA1)
            # NOTE: using lower level loader to avoid auto-cert-load when
            # testing regular key (agents expose them separately)
            inner_key = RSAKey.from_private_key_file(_support("rsa.key"))
>           blobby = inner_key.asbytes()
E           AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/agent.py:136: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_signing_datasign_kwargs1-2">agent.py::AgentKey_::signing_data[sign_kwargs1-2]</h3>
<details><summary> <pre>agent.py::AgentKey_::signing_data[sign_kwargs1-2]</pre></summary><pre>
self = <tests.agent.AgentKey_ object at 0x7eb2fb086c80>
sign_kwargs = {'algorithm': 'rsa-sha2-256'}, expected_flag = 2

    @mark.parametrize(
        "sign_kwargs,expected_flag",
        [
            # No algorithm kwarg: no flags (bitfield -> 0 int)
            (dict(), 0),
            (dict(algorithm="rsa-sha2-256"), SSH_AGENT_RSA_SHA2_256),
            (dict(algorithm="rsa-sha2-512"), SSH_AGENT_RSA_SHA2_512),
            # TODO: ideally we only send these when key is a cert,
            # but it doesn't actually break when not; meh. Really just wants
            # all the parameterization of this test rethought.
            (
                dict(algorithm="rsa-sha2-256-cert-v01@openssh.com"),
                SSH_AGENT_RSA_SHA2_256,
            ),
            (
                dict(algorithm="rsa-sha2-512-cert-v01@openssh.com"),
                SSH_AGENT_RSA_SHA2_512,
            ),
        ],
    )
    def signing_data(self, sign_kwargs, expected_flag):
        class FakeAgent:
            def _send_message(self, msg):
                # The thing we actually care most about, we're not testing
                # ssh-agent itself here
                self._sent_message = msg
                sig = Message()
                sig.add_string("lol")
                sig.rewind()
                return SSH2_AGENT_SIGN_RESPONSE, sig

        for do_cert in (False, True):
            agent = FakeAgent()
            # Get key kinda like how a real agent would give it to us - if
            # cert, it'd be the entire public blob, not just the pubkey. This
            # ensures the code under test sends _just the pubkey part_ back to
            # the agent during signature requests (bug was us sending _the
            # entire cert blob_, which somehow "worked ok" but always got us
            # SHA1)
            # NOTE: using lower level loader to avoid auto-cert-load when
            # testing regular key (agents expose them separately)
            inner_key = RSAKey.from_private_key_file(_support("rsa.key"))
>           blobby = inner_key.asbytes()
E           AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/agent.py:136: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_signing_datasign_kwargs2-4">agent.py::AgentKey_::signing_data[sign_kwargs2-4]</h3>
<details><summary> <pre>agent.py::AgentKey_::signing_data[sign_kwargs2-4]</pre></summary><pre>
self = <tests.agent.AgentKey_ object at 0x7eb2fba91ea0>
sign_kwargs = {'algorithm': 'rsa-sha2-512'}, expected_flag = 4

    @mark.parametrize(
        "sign_kwargs,expected_flag",
        [
            # No algorithm kwarg: no flags (bitfield -> 0 int)
            (dict(), 0),
            (dict(algorithm="rsa-sha2-256"), SSH_AGENT_RSA_SHA2_256),
            (dict(algorithm="rsa-sha2-512"), SSH_AGENT_RSA_SHA2_512),
            # TODO: ideally we only send these when key is a cert,
            # but it doesn't actually break when not; meh. Really just wants
            # all the parameterization of this test rethought.
            (
                dict(algorithm="rsa-sha2-256-cert-v01@openssh.com"),
                SSH_AGENT_RSA_SHA2_256,
            ),
            (
                dict(algorithm="rsa-sha2-512-cert-v01@openssh.com"),
                SSH_AGENT_RSA_SHA2_512,
            ),
        ],
    )
    def signing_data(self, sign_kwargs, expected_flag):
        class FakeAgent:
            def _send_message(self, msg):
                # The thing we actually care most about, we're not testing
                # ssh-agent itself here
                self._sent_message = msg
                sig = Message()
                sig.add_string("lol")
                sig.rewind()
                return SSH2_AGENT_SIGN_RESPONSE, sig

        for do_cert in (False, True):
            agent = FakeAgent()
            # Get key kinda like how a real agent would give it to us - if
            # cert, it'd be the entire public blob, not just the pubkey. This
            # ensures the code under test sends _just the pubkey part_ back to
            # the agent during signature requests (bug was us sending _the
            # entire cert blob_, which somehow "worked ok" but always got us
            # SHA1)
            # NOTE: using lower level loader to avoid auto-cert-load when
            # testing regular key (agents expose them separately)
            inner_key = RSAKey.from_private_key_file(_support("rsa.key"))
>           blobby = inner_key.asbytes()
E           AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/agent.py:136: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_signing_datasign_kwargs3-2">agent.py::AgentKey_::signing_data[sign_kwargs3-2]</h3>
<details><summary> <pre>agent.py::AgentKey_::signing_data[sign_kwargs3-2]</pre></summary><pre>
self = <tests.agent.AgentKey_ object at 0x7eb2fba91f90>
sign_kwargs = {'algorithm': 'rsa-sha2-256-cert-v01@openssh.com'}
expected_flag = 2

    @mark.parametrize(
        "sign_kwargs,expected_flag",
        [
            # No algorithm kwarg: no flags (bitfield -> 0 int)
            (dict(), 0),
            (dict(algorithm="rsa-sha2-256"), SSH_AGENT_RSA_SHA2_256),
            (dict(algorithm="rsa-sha2-512"), SSH_AGENT_RSA_SHA2_512),
            # TODO: ideally we only send these when key is a cert,
            # but it doesn't actually break when not; meh. Really just wants
            # all the parameterization of this test rethought.
            (
                dict(algorithm="rsa-sha2-256-cert-v01@openssh.com"),
                SSH_AGENT_RSA_SHA2_256,
            ),
            (
                dict(algorithm="rsa-sha2-512-cert-v01@openssh.com"),
                SSH_AGENT_RSA_SHA2_512,
            ),
        ],
    )
    def signing_data(self, sign_kwargs, expected_flag):
        class FakeAgent:
            def _send_message(self, msg):
                # The thing we actually care most about, we're not testing
                # ssh-agent itself here
                self._sent_message = msg
                sig = Message()
                sig.add_string("lol")
                sig.rewind()
                return SSH2_AGENT_SIGN_RESPONSE, sig

        for do_cert in (False, True):
            agent = FakeAgent()
            # Get key kinda like how a real agent would give it to us - if
            # cert, it'd be the entire public blob, not just the pubkey. This
            # ensures the code under test sends _just the pubkey part_ back to
            # the agent during signature requests (bug was us sending _the
            # entire cert blob_, which somehow "worked ok" but always got us
            # SHA1)
            # NOTE: using lower level loader to avoid auto-cert-load when
            # testing regular key (agents expose them separately)
            inner_key = RSAKey.from_private_key_file(_support("rsa.key"))
>           blobby = inner_key.asbytes()
E           AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/agent.py:136: AttributeError
</pre>
</details>
<h3 id="agentpyagentkey_signing_datasign_kwargs4-4">agent.py::AgentKey_::signing_data[sign_kwargs4-4]</h3>
<details><summary> <pre>agent.py::AgentKey_::signing_data[sign_kwargs4-4]</pre></summary><pre>
self = <tests.agent.AgentKey_ object at 0x7eb2fba91f60>
sign_kwargs = {'algorithm': 'rsa-sha2-512-cert-v01@openssh.com'}
expected_flag = 4

    @mark.parametrize(
        "sign_kwargs,expected_flag",
        [
            # No algorithm kwarg: no flags (bitfield -> 0 int)
            (dict(), 0),
            (dict(algorithm="rsa-sha2-256"), SSH_AGENT_RSA_SHA2_256),
            (dict(algorithm="rsa-sha2-512"), SSH_AGENT_RSA_SHA2_512),
            # TODO: ideally we only send these when key is a cert,
            # but it doesn't actually break when not; meh. Really just wants
            # all the parameterization of this test rethought.
            (
                dict(algorithm="rsa-sha2-256-cert-v01@openssh.com"),
                SSH_AGENT_RSA_SHA2_256,
            ),
            (
                dict(algorithm="rsa-sha2-512-cert-v01@openssh.com"),
                SSH_AGENT_RSA_SHA2_512,
            ),
        ],
    )
    def signing_data(self, sign_kwargs, expected_flag):
        class FakeAgent:
            def _send_message(self, msg):
                # The thing we actually care most about, we're not testing
                # ssh-agent itself here
                self._sent_message = msg
                sig = Message()
                sig.add_string("lol")
                sig.rewind()
                return SSH2_AGENT_SIGN_RESPONSE, sig

        for do_cert in (False, True):
            agent = FakeAgent()
            # Get key kinda like how a real agent would give it to us - if
            # cert, it'd be the entire public blob, not just the pubkey. This
            # ensures the code under test sends _just the pubkey part_ back to
            # the agent during signature requests (bug was us sending _the
            # entire cert blob_, which somehow "worked ok" but always got us
            # SHA1)
            # NOTE: using lower level loader to avoid auto-cert-load when
            # testing regular key (agents expose them separately)
            inner_key = RSAKey.from_private_key_file(_support("rsa.key"))
>           blobby = inner_key.asbytes()
E           AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/agent.py:136: AttributeError
</pre>
</details>
<h3 id="authpyauthhandler_bad_auth_type">auth.py::AuthHandler_::bad_auth_type</h3>
<details><summary> <pre>auth.py::AuthHandler_::bad_auth_type</pre></summary><pre>
self = <tests.auth.AuthHandler_ object at 0x7eb2fae138b0>

    def bad_auth_type(self):
        """
        verify that we get the right exception when an unsupported auth
        type is requested.
        """
        # Server won't allow password auth for this user, so should fail
        # and return just publickey allowed types
>       with server(
            connect=dict(username="unknown", password="error"),
            catch_error=True,
        ) as (_, _, err):

tests/auth.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b54850 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b56530>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthhandler_bad_password">auth.py::AuthHandler_::bad_password</h3>
<details><summary> <pre>auth.py::AuthHandler_::bad_password</pre></summary><pre>
self = <tests.auth.AuthHandler_ object at 0x7eb2f9bd7eb0>

    def bad_password(self):
        """
        verify that a bad password gets the right exception, and that a retry
        with the right password works.
        """
        # NOTE: Transport.connect doesn't do any auth upfront if no userauth
        # related kwargs given.
>       with server(defer=True) as (tc, ts):

tests/auth.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a805b0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a834f0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthhandler_multipart_auth">auth.py::AuthHandler_::multipart_auth</h3>
<details><summary> <pre>auth.py::AuthHandler_::multipart_auth</pre></summary><pre>
self = <tests.auth.AuthHandler_ object at 0x7eb2f9bd6230>

    def multipart_auth(self):
        """
        verify that multipart auth works.
        """
>       with server(defer=True) as (tc, ts):

tests/auth.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xfb95aef0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2fb95a4d0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthhandler_interactive_auth">auth.py::AuthHandler_::interactive_auth</h3>
<details><summary> <pre>auth.py::AuthHandler_::interactive_auth</pre></summary><pre>
self = <tests.auth.AuthHandler_ object at 0x7eb2f9bd5690>

    def interactive_auth(self):
        """
        verify keyboard-interactive auth works.
        """

        def handler(title, instructions, prompts):
            self.got_title = title
            self.got_instructions = instructions
            self.got_prompts = prompts
            return ["cat"]

>       with server(defer=True) as (tc, ts):

tests/auth.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xfafb4e80 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2fafb5150>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthhandler_interactive_fallback">auth.py::AuthHandler_::interactive_fallback</h3>
<details><summary> <pre>auth.py::AuthHandler_::interactive_fallback</pre></summary><pre>
self = <tests.auth.AuthHandler_ object at 0x7eb2f9bd5b40>

    def interactive_fallback(self):
        """
        verify that a password auth attempt will fallback to "interactive"
        if password auth isn't supported but interactive is.
        """
>       with server(defer=True) as (tc, ts):

tests/auth.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf934f4f0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f934f5b0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthhandler_utf8">auth.py::AuthHandler_::utf8</h3>
<details><summary> <pre>auth.py::AuthHandler_::utf8</pre></summary><pre>
self = <tests.auth.AuthHandler_ object at 0x7eb2f9bd5840>

    def utf8(self):
        """
        verify that utf-8 encoding happens in authentication.
        """
>       with server(defer=True) as (tc, ts):

tests/auth.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xfba939a0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2fba929e0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthhandler_non_utf8">auth.py::AuthHandler_::non_utf8</h3>
<details><summary> <pre>auth.py::AuthHandler_::non_utf8</pre></summary><pre>
self = <tests.auth.AuthHandler_ object at 0x7eb2f9bd5990>

    def non_utf8(self):
        """
        verify that non-utf-8 encoded passwords can be used for broken
        servers.
        """
>       with server(defer=True) as (tc, ts):

tests/auth.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf93408b0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f93438b0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthhandler_auth_exception_when_disconnected">auth.py::AuthHandler_::auth_exception_when_disconnected</h3>
<details><summary> <pre>auth.py::AuthHandler_::auth_exception_when_disconnected</pre></summary><pre>
self = <tests.auth.AuthHandler_ object at 0x7eb2f9bd5f00>

    def auth_exception_when_disconnected(self):
        """
        verify that we catch a server disconnecting during auth, and report
        it as an auth failure.
        """
>       with server(defer=True, skip_verify=True) as (tc, ts), raises(
            AuthenticationException
        ):

tests/auth.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9cad390 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9cad060>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthhandler_non_responsive_triggers_auth_exception">auth.py::AuthHandler_::non_responsive_triggers_auth_exception</h3>
<details><summary> <pre>auth.py::AuthHandler_::non_responsive_triggers_auth_exception</pre></summary><pre>
self = <tests.auth.AuthHandler_ object at 0x7eb2f9bd5c00>

    def non_responsive_triggers_auth_exception(self):
        """
        verify that authentication times out if server takes to long to
        respond (or never responds).
        """
>       with server(defer=True, skip_verify=True) as (tc, ts), raises(
            AuthenticationException
        ) as info:

tests/auth.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf949fc10 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f949f820>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthonlyhandler_fallback_pubkey_algorithmkey_type_algo_selected_when_no_server_sig_algs">auth.py::AuthOnlyHandler_::fallback_pubkey_algorithm::key_type_algo_selected_when_no_server_sig_algs</h3>
<details><summary> <pre>auth.py::AuthOnlyHandler_::fallback_pubkey_algorithm::key_type_algo_selected_when_no_server_sig_algs</pre></summary><pre>
self = <tests.auth.AuthOnlyHandler_.fallback_pubkey_algorithm object at 0x7eb2f9bd6380>

    @requires_sha1_signing
    def key_type_algo_selected_when_no_server_sig_algs(self):
        privkey = RSAKey.from_private_key_file(_support("rsa.key"))
        # Server pretending to be an apparently common setup:
        # - doesn't support (or have enabled) sha2
        # - also doesn't support (or have enabled) server-sig-algs/ext-info
        # This is the scenario in which Paramiko has to guess-the-algo, and
        # where servers that don't support sha2 or server-sig-algs can give
        # us trouble.
        server_init = dict(_disable_sha2_pubkey, server_sig_algs=False)
>       with self._server(
            pubkeys=[privkey],
            connect=dict(pkey=privkey),
            server_init=server_init,
            catch_error=True,
        ) as (tc, ts, err):

tests/auth.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a80a30 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a81fc0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthonlyhandler_fallback_pubkey_algorithmkey_type_algo_selection_is_cert_suffix_aware">auth.py::AuthOnlyHandler_::fallback_pubkey_algorithm::key_type_algo_selection_is_cert_suffix_aware</h3>
<details><summary> <pre>auth.py::AuthOnlyHandler_::fallback_pubkey_algorithm::key_type_algo_selection_is_cert_suffix_aware</pre></summary><pre>
self = <tests.auth.AuthOnlyHandler_.fallback_pubkey_algorithm object at 0x7eb2f9bd6470>

    @requires_sha1_signing
    def key_type_algo_selection_is_cert_suffix_aware(self):
        # This key has a cert next to it, which should trigger cert-aware
        # loading within key classes.
        privkey = PKey.from_path(_support("rsa.key"))
        server_init = dict(_disable_sha2_pubkey, server_sig_algs=False)
>       with self._server(
            pubkeys=[privkey],
            connect=dict(pkey=privkey),
            server_init=server_init,
            catch_error=True,
        ) as (tc, ts, err):

tests/auth.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9425a50 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9425300>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthonlyhandler_fallback_pubkey_algorithmuses_first_preferred_algo_if_key_type_not_in_list">auth.py::AuthOnlyHandler_::fallback_pubkey_algorithm::uses_first_preferred_algo_if_key_type_not_in_list</h3>
<details><summary> <pre>auth.py::AuthOnlyHandler_::fallback_pubkey_algorithm::uses_first_preferred_algo_if_key_type_not_in_list</pre></summary><pre>
self = <tests.auth.AuthOnlyHandler_.fallback_pubkey_algorithm object at 0x7eb2f9bd6590>

    @requires_sha1_signing
    def uses_first_preferred_algo_if_key_type_not_in_list(self):
        # This is functionally the same as legacy AuthHandler, just
        # arriving at the same place in a different manner.
        privkey = RSAKey.from_private_key_file(_support("rsa.key"))
        server_init = dict(_disable_sha2_pubkey, server_sig_algs=False)
>       with self._server(
            pubkeys=[privkey],
            connect=dict(pkey=privkey),
            server_init=server_init,
            client_init=_disable_sha1_pubkey,  # no ssh-rsa
            catch_error=True,
        ) as (tc, ts, err):

tests/auth.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf94c68f0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f94c4730>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = {'pubkeys': ['ssh-rsa']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpysha2signaturepubkeyspubkey_auth_honors_disabled_algorithms">auth.py::SHA2SignaturePubkeys::pubkey_auth_honors_disabled_algorithms</h3>
<details><summary> <pre>auth.py::SHA2SignaturePubkeys::pubkey_auth_honors_disabled_algorithms</pre></summary><pre>
self = <tests.auth.SHA2SignaturePubkeys object at 0x7eb2f9bd6ce0>

    def pubkey_auth_honors_disabled_algorithms(self):
        privkey = RSAKey.from_private_key_file(_support("rsa.key"))
>       with server(
            pubkeys=[privkey],
            connect=dict(pkey=privkey),
            init=dict(
                disabled_algorithms=dict(
                    pubkeys=["ssh-rsa", "rsa-sha2-256", "rsa-sha2-512"]
                )
            ),
            catch_error=True,
        ) as (_, _, err):

tests/auth.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a27100 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a27c40>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True
disabled_algorithms = {'pubkeys': ['ssh-rsa', 'rsa-sha2-256', 'rsa-sha2-512']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpysha2signaturepubkeysclient_sha2_disabled_server_sha1_disabled_no_match">auth.py::SHA2SignaturePubkeys::client_sha2_disabled_server_sha1_disabled_no_match</h3>
<details><summary> <pre>auth.py::SHA2SignaturePubkeys::client_sha2_disabled_server_sha1_disabled_no_match</pre></summary><pre>
self = <tests.auth.SHA2SignaturePubkeys object at 0x7eb2f9bd7220>

    def client_sha2_disabled_server_sha1_disabled_no_match(self):
        privkey = RSAKey.from_private_key_file(_support("rsa.key"))
>       with server(
            pubkeys=[privkey],
            connect=dict(pkey=privkey),
            client_init=_disable_sha2_pubkey,
            server_init=_disable_sha1_pubkey,
            catch_error=True,
        ) as (tc, ts, err):

tests/auth.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xfba921d0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2fba90130>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True
disabled_algorithms = {'pubkeys': ['rsa-sha2-256', 'rsa-sha2-512']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpysha2signaturepubkeysclient_sha1_disabled_server_sha2_disabled_no_match">auth.py::SHA2SignaturePubkeys::client_sha1_disabled_server_sha2_disabled_no_match</h3>
<details><summary> <pre>auth.py::SHA2SignaturePubkeys::client_sha1_disabled_server_sha2_disabled_no_match</pre></summary><pre>
self = <tests.auth.SHA2SignaturePubkeys object at 0x7eb2fae13c10>

    def client_sha1_disabled_server_sha2_disabled_no_match(self):
        privkey = RSAKey.from_private_key_file(_support("rsa.key"))
>       with server(
            pubkeys=[privkey],
            connect=dict(pkey=privkey),
            client_init=_disable_sha1_pubkey,
            server_init=_disable_sha2_pubkey,
            catch_error=True,
        ) as (tc, ts, err):

tests/auth.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf990b820 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f990a110>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = {'pubkeys': ['ssh-rsa']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpysha2signaturepubkeysssh_rsa_still_used_when_sha2_disabled">auth.py::SHA2SignaturePubkeys::ssh_rsa_still_used_when_sha2_disabled</h3>
<details><summary> <pre>auth.py::SHA2SignaturePubkeys::ssh_rsa_still_used_when_sha2_disabled</pre></summary><pre>
self = <tests.auth.SHA2SignaturePubkeys object at 0x7eb2f9bd60b0>

    @requires_sha1_signing
    def ssh_rsa_still_used_when_sha2_disabled(self):
        privkey = RSAKey.from_private_key_file(_support("rsa.key"))
        # NOTE: this works because key obj comparison uses public bytes
        # TODO: would be nice for PKey to grow a legit "give me another obj of
        # same class but just the public bits" using asbytes()
>       with server(
            pubkeys=[privkey], connect=dict(pkey=privkey), init=_disable_sha2
        ) as (tc, _):

tests/auth.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf993c2b0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f993dcf0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True
disabled_algorithms = {'keys': ['rsa-sha2-256', 'rsa-sha2-512']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpysha2signaturepubkeysfirst_client_preferred_algo_used_when_no_server_sig_algs">auth.py::SHA2SignaturePubkeys::first_client_preferred_algo_used_when_no_server_sig_algs</h3>
<details><summary> <pre>auth.py::SHA2SignaturePubkeys::first_client_preferred_algo_used_when_no_server_sig_algs</pre></summary><pre>
self = <tests.auth.SHA2SignaturePubkeys object at 0x7eb2f9bd6c50>

    @requires_sha1_signing
    def first_client_preferred_algo_used_when_no_server_sig_algs(self):
        privkey = RSAKey.from_private_key_file(_support("rsa.key"))
        # Server pretending to be an apparently common setup:
        # - doesn't support (or have enabled) sha2
        # - also doesn't support (or have enabled) server-sig-algs/ext-info
        # This is the scenario in which Paramiko has to guess-the-algo, and
        # where servers that don't support sha2 or server-sig-algs give us
        # trouble.
        server_init = dict(_disable_sha2_pubkey, server_sig_algs=False)
>       with server(
            pubkeys=[privkey],
            connect=dict(username="slowdive", pkey=privkey),
            server_init=server_init,
            catch_error=True,
        ) as (tc, ts, err):

tests/auth.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf94c5ed0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f94c6b60>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpysha2signaturepubkeyssha2_512">auth.py::SHA2SignaturePubkeys::sha2_512</h3>
<details><summary> <pre>auth.py::SHA2SignaturePubkeys::sha2_512</pre></summary><pre>
self = <tests.auth.SHA2SignaturePubkeys object at 0x7eb2f9bd64a0>

    def sha2_512(self):
        privkey = RSAKey.from_private_key_file(_support("rsa.key"))
>       with server(
            pubkeys=[privkey],
            connect=dict(pkey=privkey),
            init=dict(
                disabled_algorithms=dict(pubkeys=["ssh-rsa", "rsa-sha2-256"])
            ),
        ) as (tc, ts):

tests/auth.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf95ebaf0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f95e81c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True
disabled_algorithms = {'pubkeys': ['ssh-rsa', 'rsa-sha2-256']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpysha2signaturepubkeyssha2_256">auth.py::SHA2SignaturePubkeys::sha2_256</h3>
<details><summary> <pre>auth.py::SHA2SignaturePubkeys::sha2_256</pre></summary><pre>
self = <tests.auth.SHA2SignaturePubkeys object at 0x7eb2f9bd5c30>

    def sha2_256(self):
        privkey = RSAKey.from_private_key_file(_support("rsa.key"))
>       with server(
            pubkeys=[privkey],
            connect=dict(pkey=privkey),
            init=dict(
                disabled_algorithms=dict(pubkeys=["ssh-rsa", "rsa-sha2-512"])
            ),
        ) as (tc, ts):

tests/auth.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b4c880 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b4cdc0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True
disabled_algorithms = {'pubkeys': ['ssh-rsa', 'rsa-sha2-512']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpysha2signaturepubkeyssha2_256_when_client_only_enables_256">auth.py::SHA2SignaturePubkeys::sha2_256_when_client_only_enables_256</h3>
<details><summary> <pre>auth.py::SHA2SignaturePubkeys::sha2_256_when_client_only_enables_256</pre></summary><pre>
self = <tests.auth.SHA2SignaturePubkeys object at 0x7eb2f9bd58a0>

    def sha2_256_when_client_only_enables_256(self):
        privkey = RSAKey.from_private_key_file(_support("rsa.key"))
>       with server(
            pubkeys=[privkey],
            connect=dict(pkey=privkey),
            # Client-side only; server still accepts all 3.
            client_init=dict(
                disabled_algorithms=dict(pubkeys=["ssh-rsa", "rsa-sha2-512"])
            ),
        ) as (tc, ts):

tests/auth.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a27100 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a275b0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True
disabled_algorithms = {'pubkeys': ['ssh-rsa', 'rsa-sha2-512']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="authpyauthsource_base_classrepr_helper_prints_basic_kv_pairs">auth.py::AuthSource_::base_class::repr_helper_prints_basic_kv_pairs</h3>
<details><summary> <pre>auth.py::AuthSource_::base_class::repr_helper_prints_basic_kv_pairs</pre></summary><pre>
self = <tests.auth.AuthSource_.base_class object at 0x7eb2f9bd7130>

    def repr_helper_prints_basic_kv_pairs(self):
>       assert repr(AuthSource("foo")) == "AuthSource()"

tests/auth.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'AuthSource' object has no attribute '_repr'") raised in repr()] AuthSource object at 0x7eb2f9cad1e0>

    def __repr__(self):
>       return self._repr()
E       AttributeError: 'AuthSource' object has no attribute '_repr'

paramiko/auth_strategy.py:25: AttributeError
</pre>
</details>
<h3 id="authpyauthsource_base_classauthenticate_takes_transport_and_is_abstract">auth.py::AuthSource_::base_class::authenticate_takes_transport_and_is_abstract</h3>
<details><summary> <pre>auth.py::AuthSource_::base_class::authenticate_takes_transport_and_is_abstract</pre></summary><pre>
self = <tests.auth.AuthSource_.base_class object at 0x7eb2f9bd7490>

    def authenticate_takes_transport_and_is_abstract(self):
        # TODO: this test kinda just goes away once we're typed?
        with raises(TypeError):
            AuthSource("foo").authenticate()
>       with raises(NotImplementedError):
E       Failed: DID NOT RAISE <class 'NotImplementedError'>

tests/auth.py:352: Failed
</pre>
</details>
<h3 id="authpyauthsource_noneauth_authenticate_auths_none">auth.py::AuthSource_::NoneAuth_::authenticate_auths_none</h3>
<details><summary> <pre>auth.py::AuthSource_::NoneAuth_::authenticate_auths_none</pre></summary><pre>
self = <tests.auth.AuthSource_.NoneAuth_ object at 0x7eb2f9bd7370>

    def authenticate_auths_none(self):
        trans = Mock()
        result = NoneAuth("foo").authenticate(trans)
>       trans.auth_none.assert_called_once_with("foo")

tests/auth.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.auth_none' id='139307158692016'>, args = ('foo',)
kwargs = {}, msg = "Expected 'auth_none' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'auth_none' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="authpyauthsource_noneauth_repr_shows_class">auth.py::AuthSource_::NoneAuth_::repr_shows_class</h3>
<details><summary> <pre>auth.py::AuthSource_::NoneAuth_::repr_shows_class</pre></summary><pre>
self = <tests.auth.AuthSource_.NoneAuth_ object at 0x7eb2f9bd77f0>

    def repr_shows_class(self):
>       assert repr(NoneAuth("foo")) == "NoneAuth()"

tests/auth.py:363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'NoneAuth' object has no attribute '_repr'") raised in repr()] NoneAuth object at 0x7eb2f9a36020>

    def __repr__(self):
>       return self._repr()
E       AttributeError: 'NoneAuth' object has no attribute '_repr'

paramiko/auth_strategy.py:25: AttributeError
</pre>
</details>
<h3 id="authpyauthsource_password_repr_adds_username">auth.py::AuthSource_::Password_::repr_adds_username</h3>
<details><summary> <pre>auth.py::AuthSource_::Password_::repr_adds_username</pre></summary><pre>
self = <tests.auth.AuthSource_.Password_ object at 0x7eb2f9bd7970>

    def repr_adds_username(self):
        pw = Password("foo", password_getter=Mock())
>       assert repr(pw) == "Password(user='foo')"

tests/auth.py:375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'super' object has no attribute '_repr'") raised in repr()] Password object at 0x7eb2f94c6530>

    def __repr__(self):
>       return super()._repr(user=self.username)
E       AttributeError: 'super' object has no attribute '_repr'

paramiko/auth_strategy.py:58: AttributeError
</pre>
</details>
<h3 id="authpyauthsource_password_authenticate_gets_and_supplies_password">auth.py::AuthSource_::Password_::authenticate_gets_and_supplies_password</h3>
<details><summary> <pre>auth.py::AuthSource_::Password_::authenticate_gets_and_supplies_password</pre></summary><pre>
self = <tests.auth.AuthSource_.Password_ object at 0x7eb2f9bd7ac0>

    def authenticate_gets_and_supplies_password(self):
        getter = Mock(return_value="bar")
        trans = Mock()
        pw = Password("foo", password_getter=getter)
        result = pw.authenticate(trans)
>       trans.auth_password.assert_called_once_with("foo", "bar")

tests/auth.py:382: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.auth_password' id='139307152141248'>
args = ('foo', 'bar'), kwargs = {}
msg = "Expected 'auth_password' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'auth_password' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="authpyauthsource_privatekey_authenticate_calls_publickey_with_pkey">auth.py::AuthSource_::PrivateKey_::authenticate_calls_publickey_with_pkey</h3>
<details><summary> <pre>auth.py::AuthSource_::PrivateKey_::authenticate_calls_publickey_with_pkey</pre></summary><pre>
self = <tests.auth.AuthSource_.PrivateKey_ object at 0x7eb2f9bd47c0>

    def authenticate_calls_publickey_with_pkey(self):
        source = PrivateKey(username="foo")
        source.pkey = Mock()  # set by subclasses
        trans = Mock()
        result = source.authenticate(trans)
>       trans.auth_publickey.assert_called_once_with("foo", source.pkey)

tests/auth.py:391: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.auth_publickey' id='139307158351696'>
args = ('foo', <Mock id='139307158343920'>), kwargs = {}
msg = "Expected 'auth_publickey' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'auth_publickey' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="authpyauthsource_inmemoryprivatekey_repr_shows_pkey_repr">auth.py::AuthSource_::InMemoryPrivateKey_::repr_shows_pkey_repr</h3>
<details><summary> <pre>auth.py::AuthSource_::InMemoryPrivateKey_::repr_shows_pkey_repr</pre></summary><pre>
self = <tests.auth.AuthSource_.InMemoryPrivateKey_ object at 0x7eb2f9bd44c0>

    def repr_shows_pkey_repr(self):
        pkey = PKey.from_path(_support("ed25519.key"))
        source = InMemoryPrivateKey("foo", pkey)
>       assert (
            repr(source)
            == "InMemoryPrivateKey(pkey=PKey(alg=ED25519, bits=256, fp=SHA256:J6VESFdD3xSChn8y9PzWzeF+1tl892mOy2TqkMLO4ow))"  # noqa
        )

tests/auth.py:405: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'super' object has no attribute '_repr'") raised in repr()] InMemoryPrivateKey object at 0x7eb2fb9583a0>

    def __repr__(self):
>       rep = super()._repr(pkey=self.pkey)
E       AttributeError: 'super' object has no attribute '_repr'

paramiko/auth_strategy.py:83: AttributeError
</pre>
</details>
<h3 id="authpyauthsource_inmemoryprivatekey_repr_appends_agent_flag_when_agentkey">auth.py::AuthSource_::InMemoryPrivateKey_::repr_appends_agent_flag_when_AgentKey</h3>
<details><summary> <pre>auth.py::AuthSource_::InMemoryPrivateKey_::repr_appends_agent_flag_when_AgentKey</pre></summary><pre>
self = <tests.auth.AuthSource_.InMemoryPrivateKey_ object at 0x7eb2f9bd4430>

    def repr_appends_agent_flag_when_AgentKey(self):
        real_key = PKey.from_path(_support("ed25519.key"))
>       pkey = AgentKey(agent=None, blob=bytes(real_key))
E       TypeError: cannot convert 'NoneType' object to bytes

tests/auth.py:412: TypeError
</pre>
</details>
<h3 id="authpyauthsource_ondiskprivatekey_repr_reflects_source_path_and_pkey">auth.py::AuthSource_::OnDiskPrivateKey_::repr_reflects_source_path_and_pkey</h3>
<details><summary> <pre>auth.py::AuthSource_::OnDiskPrivateKey_::repr_reflects_source_path_and_pkey</pre></summary><pre>
self = <tests.auth.AuthSource_.OnDiskPrivateKey_ object at 0x7eb2f9bd6950>

    def repr_reflects_source_path_and_pkey(self):
        source = OnDiskPrivateKey(
            username="foo",
            source="ssh-config",
            path="of-exile",
            pkey="notreally",
        )
>       assert (
            repr(source)
            == "OnDiskPrivateKey(key='notreally', source='ssh-config', path='of-exile')"  # noqa
        )

tests/auth.py:452: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'OnDiskPrivateKey' object has no attribute '_repr'") raised in repr()] OnDiskPrivateKey object at 0x7eb2f9a25780>

    def __repr__(self):
>       return self._repr(key=self.pkey, source=self.source, path=str(self.path))
E       AttributeError: 'OnDiskPrivateKey' object has no attribute '_repr'

paramiko/auth_strategy.py:111: AttributeError
</pre>
</details>
<h3 id="authpyauthresult_dunder_strshows_str_not_repr_of_auth_source_and_result">auth.py::AuthResult_::dunder_str::shows_str_not_repr_of_auth_source_and_result</h3>
<details><summary> <pre>auth.py::AuthResult_::dunder_str::shows_str_not_repr_of_auth_source_and_result</pre></summary><pre>
self = <tests.auth.AuthResult_.dunder_str object at 0x7eb2f9bd4d30>

    def shows_str_not_repr_of_auth_source_and_result(self):
        result = AuthResult(self.strat)
        result.append(
            SourceResult(NoneAuth("foo"), ["password", "pubkey"])
        )
>       assert str(result) == "NoneAuth() -> ['password', 'pubkey']"

tests/auth.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/auth_strategy.py:150: in __str__
    return '\n'.join((f"{x.source} -> {x.result or 'success'}" for x in self))
paramiko/auth_strategy.py:150: in <genexpr>
    return '\n'.join((f"{x.source} -> {x.result or 'success'}" for x in self))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'NoneAuth' object has no attribute '_repr'") raised in repr()] NoneAuth object at 0x7eb2f920c490>

    def __repr__(self):
>       return self._repr()
E       AttributeError: 'NoneAuth' object has no attribute '_repr'

paramiko/auth_strategy.py:25: AttributeError
</pre>
</details>
<h3 id="authpyauthresult_dunder_strempty_list_result_values_show_success_string">auth.py::AuthResult_::dunder_str::empty_list_result_values_show_success_string</h3>
<details><summary> <pre>auth.py::AuthResult_::dunder_str::empty_list_result_values_show_success_string</pre></summary><pre>
self = <tests.auth.AuthResult_.dunder_str object at 0x7eb2f9bd46a0>

    def empty_list_result_values_show_success_string(self):
        result = AuthResult(self.strat)
        result.append(SourceResult(NoneAuth("foo"), []))
>       assert str(result) == "NoneAuth() -> success"

tests/auth.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/auth_strategy.py:150: in __str__
    return '\n'.join((f"{x.source} -> {x.result or 'success'}" for x in self))
paramiko/auth_strategy.py:150: in <genexpr>
    return '\n'.join((f"{x.source} -> {x.result or 'success'}" for x in self))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'NoneAuth' object has no attribute '_repr'") raised in repr()] NoneAuth object at 0x7eb2f95eb8e0>

    def __repr__(self):
>       return self._repr()
E       AttributeError: 'NoneAuth' object has no attribute '_repr'

paramiko/auth_strategy.py:25: AttributeError
</pre>
</details>
<h3 id="authpyauthfailure_str_is_newline_plus_result_str">auth.py::AuthFailure_::str_is_newline_plus_result_str</h3>
<details><summary> <pre>auth.py::AuthFailure_::str_is_newline_plus_result_str</pre></summary><pre>
self = <tests.auth.AuthFailure_ object at 0x7eb2f9bd5300>

    def str_is_newline_plus_result_str(self):
        result = AuthResult(None)
        result.append(SourceResult(NoneAuth("foo"), Exception("onoz")))
        fail = AuthFailure(result)
>       assert str(fail) == "\nNoneAuth() -> onoz"

tests/auth.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/auth_strategy.py:167: in __str__
    return '\n' + str(self.result)
paramiko/auth_strategy.py:150: in __str__
    return '\n'.join((f"{x.source} -> {x.result or 'success'}" for x in self))
paramiko/auth_strategy.py:150: in <genexpr>
    return '\n'.join((f"{x.source} -> {x.result or 'success'}" for x in self))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'NoneAuth' object has no attribute '_repr'") raised in repr()] NoneAuth object at 0x7eb2f9a26320>

    def __repr__(self):
>       return self._repr()
E       AttributeError: 'NoneAuth' object has no attribute '_repr'

paramiko/auth_strategy.py:25: AttributeError
</pre>
</details>
<h3 id="authpyauthstrategy_get_sources_is_abstract">auth.py::AuthStrategy_::get_sources_is_abstract</h3>
<details><summary> <pre>auth.py::AuthStrategy_::get_sources_is_abstract</pre></summary><pre>
self = <tests.auth.AuthStrategy_ object at 0x7eb2f9bd54e0>

    def get_sources_is_abstract(self):
>       with raises(NotImplementedError):
E       Failed: DID NOT RAISE <class 'NotImplementedError'>

tests/auth.py:526: Failed
</pre>
</details>
<h3 id="authpyauthstrategy_authenticaterequires_and_uses_transport_with_methods_returning_result">auth.py::AuthStrategy_::authenticate::requires_and_uses_transport_with_methods_returning_result</h3>
<details><summary> <pre>auth.py::AuthStrategy_::authenticate::requires_and_uses_transport_with_methods_returning_result</pre></summary><pre>
self = <tests.auth.AuthStrategy_.authenticate object at 0x7eb2faebebf0>

    def requires_and_uses_transport_with_methods_returning_result(self):
        with raises(TypeError):
            self.strat.authenticate()
        result = self.strat.authenticate(self.transport)
>       self.strat.get_sources.assert_called_once_with()

tests/auth.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock id='139307157824480'>, args = (), kwargs = {}
msg = "Expected 'mock' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="authpyauthstrategy_authenticatelogs_sources_attempted">auth.py::AuthStrategy_::authenticate::logs_sources_attempted</h3>
<details><summary> <pre>auth.py::AuthStrategy_::authenticate::logs_sources_attempted</pre></summary><pre>
self = <tests.auth.AuthStrategy_.authenticate object at 0x7eb2faebf040>

    def logs_sources_attempted(self):
        self.strat.log = Mock()
        self.strat.authenticate(self.transport)
>       self.strat.log.debug.assert_called_once_with("Trying NoneAuth()")

tests/auth.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.debug' id='139307180053872'>
args = ('Trying NoneAuth()',), kwargs = {}
msg = "Expected 'debug' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'debug' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="authpyauthstrategy_authenticateraises_authfailure_if_no_successes">auth.py::AuthStrategy_::authenticate::raises_AuthFailure_if_no_successes</h3>
<details><summary> <pre>auth.py::AuthStrategy_::authenticate::raises_AuthFailure_if_no_successes</pre></summary><pre>
self = <tests.auth.AuthStrategy_.authenticate object at 0x7eb2faebf5b0>

    def raises_AuthFailure_if_no_successes(self):
        self.strat.log = Mock()
        oops = Exception("onoz")
        self.source.authenticate.side_effect = oops
>       with raises(AuthFailure) as info:
E       Failed: DID NOT RAISE <class 'paramiko.auth_strategy.AuthFailure'>

tests/auth.py:559: Failed
</pre>
</details>
<h3 id="authpyauthstrategy_authenticateshort_circuits_on_successful_auth">auth.py::AuthStrategy_::authenticate::short_circuits_on_successful_auth</h3>
<details><summary> <pre>auth.py::AuthStrategy_::authenticate::short_circuits_on_successful_auth</pre></summary><pre>
self = <tests.auth.AuthStrategy_.authenticate object at 0x7eb2f9bd52d0>

    def short_circuits_on_successful_auth(self):
        kaboom = Mock(authenticate=Mock(side_effect=Exception("onoz")))
        self.strat.get_sources.return_value = [self.source, kaboom]
        result = self.strat.authenticate(self.transport)
        # No exception, and it's just a regular ol Result
>       assert isinstance(result, AuthResult)
E       assert False
E        +  where False = isinstance(None, AuthResult)

tests/auth.py:577: AssertionError
</pre>
</details>
<h3 id="pkeypypkey_from_pathloads_from_str">pkey.py::PKey_::from_path::loads_from_str</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::loads_from_str</pre></summary><pre>
self = <tests.pkey.PKey_.from_path object at 0x7eb2f9b269e0>

    def loads_from_str(self):
        key = PKey.from_path(str(_support("rsa.key")))
>       assert isinstance(key, RSAKey)
E       assert False
E        +  where False = isinstance(None, RSAKey)

tests/pkey.py:40: AssertionError
</pre>
</details>
<h3 id="pkeypypkey_from_pathexpands_user">pkey.py::PKey_::from_path::expands_user</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::expands_user</pre></summary><pre>
self = <tests.pkey.PKey_.from_path object at 0x7eb2f9b26890>
mPath = <MagicMock name='Path' id='139307157510448'>

    @patch("paramiko.pkey.Path")
    def expands_user(self, mPath):
        # real key for guts that want a real key format
        mykey = Path(_support("rsa.key"))
        pathy = mPath.return_value.expanduser.return_value
        # read_bytes for cryptography.io's loaders
        pathy.read_bytes.return_value = mykey.read_bytes()
        # open() for our own class loader
        pathy.open.return_value = mykey.open()
        # fake out exists() to avoid attempts to load cert
        pathy.exists.return_value = False
        PKey.from_path("whatever")  # we're not testing expanduser itself
        # Both key and cert paths
>       mPath.return_value.expanduser.assert_has_calls([call(), call()])

tests/pkey.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='Path().expanduser' id='139307148925856'>
calls = [call(), call()], any_order = False

    def assert_has_calls(self, calls, any_order=False):
        """assert the mock has been called with the specified calls.
        The `mock_calls` list is checked for the calls.

        If `any_order` is False (the default) then the calls must be
        sequential. There can be extra calls before or after the
        specified calls.

        If `any_order` is True then the calls can be in any order, but
        they must all appear in `mock_calls`."""
        expected = [self._call_matcher(c) for c in calls]
        cause = next((e for e in expected if isinstance(e, Exception)), None)
        all_calls = _CallList(self._call_matcher(c) for c in self.mock_calls)
        if not any_order:
            if expected not in all_calls:
                if cause is None:
                    problem = 'Calls not found.'
                else:
                    problem = ('Error processing expected calls.\n'
                               'Errors: {}').format(
                                   [e if isinstance(e, Exception) else None
                                    for e in expected])
>               raise AssertionError(
                    f'{problem}\n'
                    f'Expected: {_CallList(calls)}'
                    f'{self._calls_repr(prefix="Actual").rstrip(".")}'
                ) from cause
E               AssertionError: Calls not found.
E               Expected: [call(), call()]

/usr/lib/python3.10/unittest/mock.py:966: AssertionError
</pre>
</details>
<h3 id="pkeypypkey_from_pathraises_unknownkeytype_for_unknown_types">pkey.py::PKey_::from_path::raises_UnknownKeyType_for_unknown_types</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::raises_UnknownKeyType_for_unknown_types</pre></summary><pre>
self = <tests.pkey.PKey_.from_path object at 0x7eb2f9b24f40>

    def raises_UnknownKeyType_for_unknown_types(self):
        # I.e. a real, becomes a useful object via cryptography.io, key
        # class that we do NOT support. Chose Ed448 randomly as OpenSSH
        # doesn't seem to support it either, going by ssh-keygen...
        keypath = _support("ed448.key")
>       with raises(UnknownKeyType) as exc:
E       Failed: DID NOT RAISE <class 'paramiko.pkey.UnknownKeyType'>

tests/pkey.py:62: Failed
</pre>
</details>
<h3 id="pkeypypkey_from_pathleaves_cryptography_exceptions_untouched">pkey.py::PKey_::from_path::leaves_cryptography_exceptions_untouched</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::leaves_cryptography_exceptions_untouched</pre></summary><pre>
self = <tests.pkey.PKey_.from_path object at 0x7eb2f9b25690>

    def leaves_cryptography_exceptions_untouched(self):
        # a Python file is not a private key!
>       with raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/pkey.py:70: Failed
</pre>
</details>
<h3 id="pkeypypkey_from_pathautomatically_loads_certificatesexisting_cert_loaded_when_given_key_path">pkey.py::PKey_::from_path::automatically_loads_certificates::existing_cert_loaded_when_given_key_path</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::automatically_loads_certificates::existing_cert_loaded_when_given_key_path</pre></summary><pre>
self = <tests.pkey.PKey_.from_path.automatically_loads_certificates object at 0x7eb2f9b24f10>

    def existing_cert_loaded_when_given_key_path(self):
        key = PKey.from_path(_support("rsa.key"))
        # Public blob exists despite no .load_certificate call
>       assert key.public_blob is not None
E       AttributeError: 'NoneType' object has no attribute 'public_blob'

tests/pkey.py:79: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_from_pathautomatically_loads_certificatescan_be_given_cert_path_instead">pkey.py::PKey_::from_path::automatically_loads_certificates::can_be_given_cert_path_instead</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::automatically_loads_certificates::can_be_given_cert_path_instead</pre></summary><pre>
self = <tests.pkey.PKey_.from_path.automatically_loads_certificates object at 0x7eb2f9b24280>

    def can_be_given_cert_path_instead(self):
        key = PKey.from_path(_support("rsa.key-cert.pub"))
        # It's still a key, not a PublicBlob
>       assert isinstance(key, RSAKey)
E       assert False
E        +  where False = isinstance(None, RSAKey)

tests/pkey.py:91: AssertionError
</pre>
</details>
<h3 id="pkeypypkey_from_pathautomatically_loads_certificatesno_cert_load_if_no_cert">pkey.py::PKey_::from_path::automatically_loads_certificates::no_cert_load_if_no_cert</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::automatically_loads_certificates::no_cert_load_if_no_cert</pre></summary><pre>
self = <tests.pkey.PKey_.from_path.automatically_loads_certificates object at 0x7eb2f9b24c70>

    def no_cert_load_if_no_cert(self):
        # This key exists (it's a copy of the regular one) but has no
        # matching -cert.pub
        key = PKey.from_path(_support("rsa-lonely.key"))
>       assert key.public_blob is None
E       AttributeError: 'NoneType' object has no attribute 'public_blob'

tests/pkey.py:106: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_from_pathautomatically_loads_certificatesexcepts_usefully_if_no_key_only_cert">pkey.py::PKey_::from_path::automatically_loads_certificates::excepts_usefully_if_no_key_only_cert</h3>
<details><summary> <pre>pkey.py::PKey_::from_path::automatically_loads_certificates::excepts_usefully_if_no_key_only_cert</pre></summary><pre>
self = <tests.pkey.PKey_.from_path.automatically_loads_certificates object at 0x7eb2f9b25f00>

    def excepts_usefully_if_no_key_only_cert(self):
        # TODO: is that truly an error condition? the cert is ~the
        # pubkey and we still require the privkey for signing, yea?
        # This cert exists (it's a copy of the regular one) but there's
        # no rsa-missing.key to load.
>       with raises(FileNotFoundError) as info:
E       Failed: DID NOT RAISE <class 'FileNotFoundError'>

tests/pkey.py:113: Failed
</pre>
</details>
<h3 id="pkeypypkey_load_certificatersa_public_cert_blobs">pkey.py::PKey_::load_certificate::rsa_public_cert_blobs</h3>
<details><summary> <pre>pkey.py::PKey_::load_certificate::rsa_public_cert_blobs</pre></summary><pre>
self = <tests.pkey.PKey_.load_certificate object at 0x7eb2f9b264a0>

    def rsa_public_cert_blobs(self):
        # Data to test signing with (arbitrary)
        data = b"ice weasels"
        # Load key w/o cert at first (so avoiding .from_path)
        key = RSAKey.from_private_key_file(_support("rsa.key"))
>       assert key.public_blob is None
E       AttributeError: 'NoneType' object has no attribute 'public_blob'

tests/pkey.py:123: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_load_certificateloading_cert_of_different_type_from_key_raises_valueerror">pkey.py::PKey_::load_certificate::loading_cert_of_different_type_from_key_raises_ValueError</h3>
<details><summary> <pre>pkey.py::PKey_::load_certificate::loading_cert_of_different_type_from_key_raises_ValueError</pre></summary><pre>
self = <tests.pkey.PKey_.load_certificate object at 0x7eb2f9b24b50>

    def loading_cert_of_different_type_from_key_raises_ValueError(self):
        edkey = Ed25519Key.from_private_key_file(_support("ed25519.key"))
        err = "PublicBlob type ssh-rsa-cert-v01@openssh.com incompatible with key type ssh-ed25519"  # noqa
        with raises(ValueError, match=err):
>           edkey.load_certificate(_support("rsa.key-cert.pub"))
E           AttributeError: 'NoneType' object has no attribute 'load_certificate'

tests/pkey.py:163: AttributeError
</pre>
</details>
<h3 id="pkeypypkey_identifiers_classmethodsdefault_is_class_name_attribute">pkey.py::PKey_::identifiers_classmethods::default_is_class_name_attribute</h3>
<details><summary> <pre>pkey.py::PKey_::identifiers_classmethods::default_is_class_name_attribute</pre></summary><pre>
self = <tests.pkey.PKey_.identifiers_classmethods object at 0x7eb2f98e3d60>

    def default_is_class_name_attribute(self):
        # NOTE: not all classes _have_ this, only the ones that don't
        # customize identifiers().
        class MyKey(PKey):
            name = "it me"

>       assert MyKey.identifiers() == ["it me"]
E       AssertionError: assert None == ['it me']
E        +  where None = identifiers()
E        +    where identifiers = <class 'tests.pkey.PKey_.identifiers_classmethods.default_is_class_name_attribute.<locals>.MyKey'>.identifiers

tests/pkey.py:206: AssertionError
</pre>
</details>
<h3 id="pkeypypkey_identifiers_classmethodsrsa_is_all_combos_of_cert_and_sha_type">pkey.py::PKey_::identifiers_classmethods::rsa_is_all_combos_of_cert_and_sha_type</h3>
<details><summary> <pre>pkey.py::PKey_::identifiers_classmethods::rsa_is_all_combos_of_cert_and_sha_type</pre></summary><pre>
self = <tests.pkey.PKey_.identifiers_classmethods object at 0x7eb2f98e3b50>

    def rsa_is_all_combos_of_cert_and_sha_type(self):
>       assert RSAKey.identifiers() == [
            "ssh-rsa",
            "ssh-rsa-cert-v01@openssh.com",
            "rsa-sha2-256",
            "rsa-sha2-256-cert-v01@openssh.com",
            "rsa-sha2-512",
            "rsa-sha2-512-cert-v01@openssh.com",
        ]
E       AssertionError: assert None == ['ssh-rsa', 'ssh-rsa-cert-v01@openssh.com', 'rsa-sha2-256', 'rsa-sha2-256-cert-v01@openssh.com', 'rsa-sha2-512', 'rsa-sha2-512-cert-v01@openssh.com']
E        +  where None = identifiers()
E        +    where identifiers = RSAKey.identifiers

tests/pkey.py:209: AssertionError
</pre>
</details>
<h3 id="pkeypypkey_identifiers_classmethodsdss_is_protocol_name">pkey.py::PKey_::identifiers_classmethods::dss_is_protocol_name</h3>
<details><summary> <pre>pkey.py::PKey_::identifiers_classmethods::dss_is_protocol_name</pre></summary><pre>
self = <tests.pkey.PKey_.identifiers_classmethods object at 0x7eb2f98e2d10>

    def dss_is_protocol_name(self):
>       assert DSSKey.identifiers() == ["ssh-dss"]
E       AssertionError: assert None == ['ssh-dss']
E        +  where None = identifiers()
E        +    where identifiers = DSSKey.identifiers

tests/pkey.py:219: AssertionError
</pre>
</details>
<h3 id="pkeypypkey_identifiers_classmethodsed25519_is_protocol_name">pkey.py::PKey_::identifiers_classmethods::ed25519_is_protocol_name</h3>
<details><summary> <pre>pkey.py::PKey_::identifiers_classmethods::ed25519_is_protocol_name</pre></summary><pre>
self = <tests.pkey.PKey_.identifiers_classmethods object at 0x7eb2f98e2ad0>

    def ed25519_is_protocol_name(self):
>       assert Ed25519Key.identifiers() == ["ssh-ed25519"]
E       AssertionError: assert None == ['ssh-ed25519']
E        +  where None = identifiers()
E        +    where identifiers = Ed25519Key.identifiers

tests/pkey.py:222: AssertionError
</pre>
</details>
<h3 id="pkeypypkey_identifiers_classmethodsecdsa_is_all_curve_names">pkey.py::PKey_::identifiers_classmethods::ecdsa_is_all_curve_names</h3>
<details><summary> <pre>pkey.py::PKey_::identifiers_classmethods::ecdsa_is_all_curve_names</pre></summary><pre>
self = <tests.pkey.PKey_.identifiers_classmethods object at 0x7eb2f9b26590>

    def ecdsa_is_all_curve_names(self):
>       assert ECDSAKey.identifiers() == [
            "ecdsa-sha2-nistp256",
            "ecdsa-sha2-nistp384",
            "ecdsa-sha2-nistp521",
        ]
E       AssertionError: assert None == ['ecdsa-sha2-nistp256', 'ecdsa-sha2-nistp384', 'ecdsa-sha2-nistp521']
E        +  where None = identifiers()
E        +    where identifiers = ECDSAKey.identifiers

tests/pkey.py:225: AssertionError
</pre>
</details>
<h3 id="test_buffered_pipepybufferedpipetesttest_buffered_pipe">test_buffered_pipe.py::BufferedPipeTest::test_buffered_pipe</h3>
<details><summary> <pre>test_buffered_pipe.py::BufferedPipeTest::test_buffered_pipe</pre></summary><pre>
self = <tests.test_buffered_pipe.BufferedPipeTest testMethod=test_buffered_pipe>

    def test_buffered_pipe(self):
        p = BufferedPipe()
        self.assertTrue(not p.read_ready())
        p.feed("hello.")
>       self.assertTrue(p.read_ready())
E       AssertionError: None is not true

tests/test_buffered_pipe.py:48: AssertionError
</pre>
</details>
<h3 id="test_buffered_pipepybufferedpipetesttest_close_while_reading">test_buffered_pipe.py::BufferedPipeTest::test_close_while_reading</h3>
<details><summary> <pre>test_buffered_pipe.py::BufferedPipeTest::test_close_while_reading</pre></summary><pre>
self = <tests.test_buffered_pipe.BufferedPipeTest testMethod=test_close_while_reading>

    def test_close_while_reading(self):
        p = BufferedPipe()
        threading.Thread(target=close_thread, args=(p,)).start()
        data = p.read(1, 1.0)
>       self.assertEqual(b"", data)
E       AssertionError: b'' != None

tests/test_buffered_pipe.py:78: AssertionError
</pre>
</details>
<h3 id="test_buffered_pipepybufferedpipetesttest_delay">test_buffered_pipe.py::BufferedPipeTest::test_delay</h3>
<details><summary> <pre>test_buffered_pipe.py::BufferedPipeTest::test_delay</pre></summary><pre>
self = <tests.test_buffered_pipe.BufferedPipeTest testMethod=test_delay>

    def test_delay(self):
        p = BufferedPipe()
        self.assertTrue(not p.read_ready())
        threading.Thread(target=delay_thread, args=(p,)).start()
>       self.assertEqual(b"a", p.read(1, 0.1))
E       AssertionError: b'a' != None

tests/test_buffered_pipe.py:65: AssertionError
</pre>
</details>
<h3 id="test_buffered_pipepybufferedpipetesttest_or_pipe">test_buffered_pipe.py::BufferedPipeTest::test_or_pipe</h3>
<details><summary> <pre>test_buffered_pipe.py::BufferedPipeTest::test_or_pipe</pre></summary><pre>
self = <tests.test_buffered_pipe.BufferedPipeTest testMethod=test_or_pipe>

    def test_or_pipe(self):
>       p = pipe.make_pipe()
E       AttributeError: module 'paramiko.pipe' has no attribute 'make_pipe'. Did you mean: 'make_or_pipe'?

tests/test_buffered_pipe.py:81: AttributeError
</pre>
</details>
<h3 id="test_channelfilepytestchannelfiletest_read_recvs_from_channel">test_channelfile.py::TestChannelFile::test_read_recvs_from_channel</h3>
<details><summary> <pre>test_channelfile.py::TestChannelFile::test_read_recvs_from_channel</pre></summary><pre>
self = <tests.test_channelfile.TestChannelFile object at 0x7eb2f9ccc610>

    def test_read_recvs_from_channel(self):
        chan = MagicMock()
        cf = self.klass(chan)
        cf.read(100)
>       chan.recv.assert_called_once_with(100)

tests/test_channelfile.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.recv' id='139307160110080'>, args = (100,)
kwargs = {}, msg = "Expected 'recv' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'recv' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="test_channelfilepytestchannelfiletest_write_calls_channel_sendall">test_channelfile.py::TestChannelFile::test_write_calls_channel_sendall</h3>
<details><summary> <pre>test_channelfile.py::TestChannelFile::test_write_calls_channel_sendall</pre></summary><pre>
self = <tests.test_channelfile.TestChannelFile object at 0x7eb2f9ccc5e0>

    def test_write_calls_channel_sendall(self):
        chan = MagicMock()
        cf = self.klass(chan, mode="w")
        cf.write("ohai")
>       chan.sendall.assert_called_once_with(b"ohai")

tests/test_channelfile.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.sendall' id='139307148910720'>, args = (b'ohai',)
kwargs = {}, msg = "Expected 'sendall' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'sendall' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="test_channelfilepytestchannelstderrfiletest_read_calls_channel_recv_stderr">test_channelfile.py::TestChannelStderrFile::test_read_calls_channel_recv_stderr</h3>
<details><summary> <pre>test_channelfile.py::TestChannelStderrFile::test_read_calls_channel_recv_stderr</pre></summary><pre>
self = <tests.test_channelfile.TestChannelStderrFile object at 0x7eb2f9cccca0>

    def test_read_calls_channel_recv_stderr(self):
        chan = MagicMock()
        cf = ChannelStderrFile(chan)
        cf.read(100)
>       chan.recv_stderr.assert_called_once_with(100)

tests/test_channelfile.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.recv_stderr' id='139307158653008'>, args = (100,)
kwargs = {}, msg = "Expected 'recv_stderr' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'recv_stderr' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="test_channelfilepytestchannelstderrfiletest_write_calls_channel_sendall">test_channelfile.py::TestChannelStderrFile::test_write_calls_channel_sendall</h3>
<details><summary> <pre>test_channelfile.py::TestChannelStderrFile::test_write_calls_channel_sendall</pre></summary><pre>
self = <tests.test_channelfile.TestChannelStderrFile object at 0x7eb2f9cccdf0>

    def test_write_calls_channel_sendall(self):
        chan = MagicMock()
        cf = ChannelStderrFile(chan, mode="w")
        cf.write("ohai")
>       chan.sendall_stderr.assert_called_once_with(b"ohai")

tests/test_channelfile.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.sendall_stderr' id='139307149574640'>
args = (b'ohai',), kwargs = {}
msg = "Expected 'sendall_stderr' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'sendall_stderr' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="test_channelfilepytestchannelstdinfiletest_read_recvs_from_channel">test_channelfile.py::TestChannelStdinFile::test_read_recvs_from_channel</h3>
<details><summary> <pre>test_channelfile.py::TestChannelStdinFile::test_read_recvs_from_channel</pre></summary><pre>
self = <tests.test_channelfile.TestChannelStdinFile object at 0x7eb2f9ccd5d0>

    def test_read_recvs_from_channel(self):
        chan = MagicMock()
        cf = self.klass(chan)
        cf.read(100)
>       chan.recv.assert_called_once_with(100)

tests/test_channelfile.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.recv' id='139307158793824'>, args = (100,)
kwargs = {}, msg = "Expected 'recv' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'recv' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="test_channelfilepytestchannelstdinfiletest_write_calls_channel_sendall">test_channelfile.py::TestChannelStdinFile::test_write_calls_channel_sendall</h3>
<details><summary> <pre>test_channelfile.py::TestChannelStdinFile::test_write_calls_channel_sendall</pre></summary><pre>
self = <tests.test_channelfile.TestChannelStdinFile object at 0x7eb2f9ccd4e0>

    def test_write_calls_channel_sendall(self):
        chan = MagicMock()
        cf = self.klass(chan, mode="w")
        cf.write("ohai")
>       chan.sendall.assert_called_once_with(b"ohai")

tests/test_channelfile.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.sendall' id='139307157825056'>, args = (b'ohai',)
kwargs = {}, msg = "Expected 'sendall' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'sendall' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="test_channelfilepytestchannelstdinfiletest_close_calls_channel_shutdown_write">test_channelfile.py::TestChannelStdinFile::test_close_calls_channel_shutdown_write</h3>
<details><summary> <pre>test_channelfile.py::TestChannelStdinFile::test_close_calls_channel_shutdown_write</pre></summary><pre>
self = <tests.test_channelfile.TestChannelStdinFile object at 0x7eb2f9cccee0>

    def test_close_calls_channel_shutdown_write(self):
        chan = MagicMock()
        cf = ChannelStdinFile(chan, mode="wb")
        cf.flush = MagicMock()
        cf.close()
        # Sanity check that we still call BufferedFile.close()
>       cf.flush.assert_called_once_with()

tests/test_channelfile.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock id='139307159020368'>, args = (), kwargs = {}
msg = "Expected 'mock' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_auth_timeout">test_client.py::SSHClientTest::test_auth_timeout</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_auth_timeout</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_auth_timeout>

    @requires_sha1_signing
    @slow
    def test_auth_timeout(self):
        """
        verify that the SSHClient has a configurable auth timeout
        """
        # Connect with a half second auth timeout
>       self.assertRaises(
            AuthenticationException,
            self._test_connection,
            password="unresponsive-server",
            auth_timeout=0.5,
        )

tests/test_client.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_auth_trickledown">test_client.py::SSHClientTest::test_auth_trickledown</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_auth_trickledown</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_auth_trickledown>

    @requires_sha1_signing
    def test_auth_trickledown(self):
        """
        Failed key auth doesn't prevent subsequent pw auth from succeeding
        """
        # NOTE: re #387, re #394
        # If pkey module used within Client._auth isn't correctly handling auth
        # errors (e.g. if it allows things like ValueError to bubble up as per
        # midway through #394) client.connect() will fail (at key load step)
        # instead of succeeding (at password step)
        kwargs = dict(
            # Password-protected key whose passphrase is not 'pygmalion' (it's
            # 'television' as per tests/test_pkey.py). NOTE: must use
            # key_filename, loading the actual key here with PKey will except
            # immediately; we're testing the try/except crap within Client.
            key_filename=[_support("test_rsa_password.key")],
            # Actual password for default 'slowdive' user
            password="pygmalion",
        )
>       self._test_connection(**kwargs)

tests/test_client.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_auth_trickledown>
kwargs = {'key_filename': ['/testbed/tests/test_rsa_password.key'], 'password': 'pygmalion'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9427670>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_auth_trickledown_gssauth">test_client.py::SSHClientTest::test_auth_trickledown_gssauth</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_auth_trickledown_gssauth</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_auth_trickledown_gssauth>

    @requires_gss_auth
    def test_auth_trickledown_gssauth(self):
        """
        Failed gssapi-with-mic doesn't prevent subsequent key from succeeding
        """
        kwargs = dict(gss_auth=True, key_filename=[_support("rsa.key")])
>       self._test_connection(**kwargs)

tests/test_client.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_auth_trickledown_gssauth>
kwargs = {'gss_auth': True, 'key_filename': ['/testbed/tests/_support/rsa.key']}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9a26680>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_auth_trickledown_gsskex">test_client.py::SSHClientTest::test_auth_trickledown_gsskex</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_auth_trickledown_gsskex</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_auth_trickledown_gsskex>

    @requires_gss_auth
    def test_auth_trickledown_gsskex(self):
        """
        Failed gssapi-keyex doesn't prevent subsequent key from succeeding
        """
        kwargs = dict(gss_kex=True, key_filename=[_support("rsa.key")])
>       self._test_connection(**kwargs)

tests/test_client.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_auth_trickledown_gsskex>
kwargs = {'gss_kex': True, 'key_filename': ['/testbed/tests/_support/rsa.key']}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9424220>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_auto_add_policy">test_client.py::SSHClientTest::test_auto_add_policy</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_auto_add_policy</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_auto_add_policy>

    def test_auto_add_policy(self):
        """
        verify that SSHClient's AutoAddPolicy works.
        """
        threading.Thread(target=self._run).start()
        hostname = f"[{self.addr}]:{self.port}"
        key_file = _support("ecdsa-256.key")
        public_host_key = paramiko.ECDSAKey.from_private_key_file(key_file)

        self.tc = SSHClient()
        self.tc.set_missing_host_key_policy(paramiko.AutoAddPolicy())
>       self.assertEqual(0, len(self.tc.get_host_keys()))
E       TypeError: object of type 'NoneType' has no len()

tests/test_client.py:392: TypeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_banner_timeout">test_client.py::SSHClientTest::test_banner_timeout</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_banner_timeout</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_banner_timeout>

    def test_banner_timeout(self):
        """
        verify that the SSHClient has a configurable banner timeout.
        """
        # Start the thread with a 1 second wait.
        threading.Thread(target=self._run, kwargs={"delay": 1}).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:511: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_certs_allowed_as_key_filename_values">test_client.py::SSHClientTest::test_certs_allowed_as_key_filename_values</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_certs_allowed_as_key_filename_values</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_certs_allowed_as_key_filename_values>

    @requires_sha1_signing
    def test_certs_allowed_as_key_filename_values(self):
        # NOTE: giving cert path here, not key path. (Key path test is below.
        # They're similar except for which path is given; the expected auth and
        # server-side behavior is 100% identical.)
        # NOTE: only bothered whipping up one cert per overall class/family.
        for type_ in ("rsa", "dss", "ecdsa-256", "ed25519"):
            key_path = _support(f"{type_}.key")
>           self._test_connection(
                key_filename=key_path,
                public_blob=PublicBlob.from_file(f"{key_path}-cert.pub"),
            )

tests/test_client.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_certs_allowed_as_key_filename_values>
kwargs = {'key_filename': '/testbed/tests/_support/rsa.key'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9a82b90>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_certs_implicitly_loaded_alongside_key_filename_keys">test_client.py::SSHClientTest::test_certs_implicitly_loaded_alongside_key_filename_keys</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_certs_implicitly_loaded_alongside_key_filename_keys</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_certs_implicitly_loaded_alongside_key_filename_keys>

    @requires_sha1_signing
    def test_certs_implicitly_loaded_alongside_key_filename_keys(self):
        # NOTE: a regular test_connection() w/ rsa.key would incidentally
        # test this (because test_xxx.key-cert.pub exists) but incidental tests
        # stink, so NullServer and friends were updated to allow assertions
        # about the server-side key object's public blob. Thus, we can prove
        # that a specific cert was found, along with regular authorization
        # succeeding proving that the overall flow works.
        for type_ in ("rsa", "dss", "ecdsa-256", "ed25519"):
            key_path = _support(f"{type_}.key")
>           self._test_connection(
                key_filename=key_path,
                public_blob=PublicBlob.from_file(f"{key_path}-cert.pub"),
            )

tests/test_client.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_certs_implicitly_loaded_alongside_key_filename_keys>
kwargs = {'key_filename': '/testbed/tests/_support/rsa.key'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9425000>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_channel_timeout">test_client.py::SSHClientTest::test_channel_timeout</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_channel_timeout</pre></summary><pre>
/usr/lib/python3.10/unittest/mock.py:1376: in patched
    with self.decoration_helper(patched,
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
/usr/lib/python3.10/unittest/mock.py:1358: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.10/contextlib.py:492: in enter_context
    result = _cm_type.__enter__(cm)
/usr/lib/python3.10/unittest/mock.py:1447: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7eb2faeec610>

    def get_original(self):
        target = self.getter()
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if name in _builtins and isinstance(target, ModuleType):
            self.create = True

        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'paramiko.channel.Channel'> does not have the attribute '_set_remote_channel'

/usr/lib/python3.10/unittest/mock.py:1420: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_cleanup">test_client.py::SSHClientTest::test_cleanup</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_cleanup</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_cleanup>

    def test_cleanup(self):
        """
        verify that when an SSHClient is collected, its transport (and the
        transport's packetizer) is closed.
        """
        # Skipped on PyPy because it fails on CI for unknown reasons
        if platform.python_implementation() == "PyPy":
            return

        threading.Thread(target=self._run).start()

        self.tc = SSHClient()
        self.tc.set_missing_host_key_policy(paramiko.AutoAddPolicy())
>       assert len(self.tc.get_host_keys()) == 0
E       TypeError: object of type 'NoneType' has no len()

tests/test_client.py:444: TypeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_client">test_client.py::SSHClientTest::test_client</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_client</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_client>

    @requires_sha1_signing
    def test_client(self):
        """
        verify that the SSHClient stuff works too.
        """
>       self._test_connection(password="pygmalion")

tests/test_client.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_client>
kwargs = {'password': 'pygmalion'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9cb3010>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_client_can_be_used_as_context_manager">test_client.py::SSHClientTest::test_client_can_be_used_as_context_manager</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_client_can_be_used_as_context_manager</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_client_can_be_used_as_context_manager>

    def test_client_can_be_used_as_context_manager(self):
        """
        verify that an SSHClient can be used a context manager
        """
        threading.Thread(target=self._run).start()

        with SSHClient() as tc:
            self.tc = tc
            self.tc.set_missing_host_key_policy(paramiko.AutoAddPolicy())
>           assert len(self.tc.get_host_keys()) == 0
E           TypeError: object of type 'NoneType' has no len()

tests/test_client.py:493: TypeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_client_dsa">test_client.py::SSHClientTest::test_client_dsa</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_client_dsa</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_client_dsa>

    @requires_sha1_signing
    def test_client_dsa(self):
        """
        verify that SSHClient works with a DSA key.
        """
>       self._test_connection(key_filename=_support("dss.key"))

tests/test_client.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_client_dsa>
kwargs = {'key_filename': '/testbed/tests/_support/dss.key'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9cb31c0>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_client_ecdsa">test_client.py::SSHClientTest::test_client_ecdsa</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_client_ecdsa</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_client_ecdsa>

    @requires_sha1_signing
    def test_client_ecdsa(self):
        """
        verify that SSHClient works with an ECDSA key.
        """
>       self._test_connection(key_filename=_support("ecdsa-256.key"))

tests/test_client.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_client_ecdsa>
kwargs = {'key_filename': '/testbed/tests/_support/ecdsa-256.key'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2fae1b670>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_client_ed25519">test_client.py::SSHClientTest::test_client_ed25519</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_client_ed25519</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_client_ed25519>

    @requires_sha1_signing
    def test_client_ed25519(self):
>       self._test_connection(key_filename=_support("ed25519.key"))

tests/test_client.py:275: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_client_ed25519>
kwargs = {'key_filename': '/testbed/tests/_support/ed25519.key'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9a83610>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_client_rsa">test_client.py::SSHClientTest::test_client_rsa</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_client_rsa</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_client_rsa>

    @requires_sha1_signing
    def test_client_rsa(self):
        """
        verify that SSHClient works with an RSA key.
        """
>       self._test_connection(key_filename=_support("rsa.key"))

tests/test_client.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_client_rsa>
kwargs = {'key_filename': '/testbed/tests/_support/rsa.key'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2fafb7a90>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_closes_socket_on_socket_errors">test_client.py::SSHClientTest::test_closes_socket_on_socket_errors</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_closes_socket_on_socket_errors</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_closes_socket_on_socket_errors>
getaddrinfo = <MagicMock name='getaddrinfo' id='139307160114448'>
mocket = <MagicMock name='socket' id='139307157830048'>

    @patch("paramiko.client.socket.socket")
    @patch("paramiko.client.socket.getaddrinfo")
    def test_closes_socket_on_socket_errors(self, getaddrinfo, mocket):
        getaddrinfo.return_value = (
            ("irrelevant", None, None, None, "whatever"),
        )

        class SocksToBeYou(socket.error):
            pass

        my_socket = mocket.return_value
        my_socket.connect.side_effect = SocksToBeYou
        client = SSHClient()
>       with pytest.raises(SocksToBeYou):
E       Failed: DID NOT RAISE <class 'tests.test_client.SSHClientTest.test_closes_socket_on_socket_errors.<locals>.SocksToBeYou'>

tests/test_client.py:480: Failed
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_disabled_algorithms_defaults_to_none">test_client.py::SSHClientTest::test_disabled_algorithms_defaults_to_None</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_disabled_algorithms_defaults_to_None</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_disabled_algorithms_defaults_to_None>
Transport = <MagicMock name='Transport' id='139307180055744'>

    @patch("paramiko.client.Transport")
    def test_disabled_algorithms_defaults_to_None(self, Transport):
        SSHClient().connect("host", sock=Mock(), password="no")
>       assert Transport.call_args[1]["disabled_algorithms"] is None
E       TypeError: 'NoneType' object is not subscriptable

tests/test_client.py:741: TypeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_disabled_algorithms_passed_directly_if_given">test_client.py::SSHClientTest::test_disabled_algorithms_passed_directly_if_given</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_disabled_algorithms_passed_directly_if_given</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_disabled_algorithms_passed_directly_if_given>
Transport = <MagicMock name='Transport' id='139307151500400'>

    @patch("paramiko.client.Transport")
    def test_disabled_algorithms_passed_directly_if_given(self, Transport):
        SSHClient().connect(
            "host",
            sock=Mock(),
            password="no",
            disabled_algorithms={"keys": ["ssh-dss"]},
        )
>       call_arg = Transport.call_args[1]["disabled_algorithms"]
E       TypeError: 'NoneType' object is not subscriptable

tests/test_client.py:751: TypeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_host_key_negotiation_1">test_client.py::SSHClientTest::test_host_key_negotiation_1</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_host_key_negotiation_1</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_host_key_negotiation_1>

    def test_host_key_negotiation_1(self):
        host_key = paramiko.ECDSAKey.generate()
>       self._client_host_key_bad(host_key)

tests/test_client.py:667: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_host_key_negotiation_1>
host_key = None

    def _client_host_key_bad(self, host_key):
        threading.Thread(target=self._run).start()
        hostname = f"[{self.addr}]:{self.port}"

        self.tc = SSHClient()
        self.tc.set_missing_host_key_policy(paramiko.WarningPolicy())
        known_hosts = self.tc.get_host_keys()
>       known_hosts.add(hostname, host_key.get_name(), host_key)
E       AttributeError: 'NoneType' object has no attribute 'add'

tests/test_client.py:640: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_host_key_negotiation_2">test_client.py::SSHClientTest::test_host_key_negotiation_2</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_host_key_negotiation_2</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_host_key_negotiation_2>

    @requires_sha1_signing
    def test_host_key_negotiation_2(self):
        host_key = paramiko.RSAKey.generate(2048)
>       self._client_host_key_bad(host_key)

tests/test_client.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_host_key_negotiation_2>
host_key = None

    def _client_host_key_bad(self, host_key):
        threading.Thread(target=self._run).start()
        hostname = f"[{self.addr}]:{self.port}"

        self.tc = SSHClient()
        self.tc.set_missing_host_key_policy(paramiko.WarningPolicy())
        known_hosts = self.tc.get_host_keys()
>       known_hosts.add(hostname, host_key.get_name(), host_key)
E       AttributeError: 'NoneType' object has no attribute 'add'

tests/test_client.py:640: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_host_key_negotiation_3">test_client.py::SSHClientTest::test_host_key_negotiation_3</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_host_key_negotiation_3</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_host_key_negotiation_3>

    def test_host_key_negotiation_3(self):
>       self._client_host_key_good(paramiko.ECDSAKey, "ecdsa-256.key")

tests/test_client.py:675: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_host_key_negotiation_3>
ktype = <class 'paramiko.ecdsakey.ECDSAKey'>, kfile = 'ecdsa-256.key'

    def _client_host_key_good(self, ktype, kfile):
        threading.Thread(target=self._run).start()
        hostname = f"[{self.addr}]:{self.port}"

        self.tc = SSHClient()
        self.tc.set_missing_host_key_policy(paramiko.RejectPolicy())
        host_key = ktype.from_private_key_file(_support(kfile))
        known_hosts = self.tc.get_host_keys()
>       known_hosts.add(hostname, host_key.get_name(), host_key)
E       AttributeError: 'NoneType' object has no attribute 'add'

tests/test_client.py:657: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_host_key_negotiation_4">test_client.py::SSHClientTest::test_host_key_negotiation_4</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_host_key_negotiation_4</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_host_key_negotiation_4>

    @requires_sha1_signing
    def test_host_key_negotiation_4(self):
>       self._client_host_key_good(paramiko.RSAKey, "rsa.key")

tests/test_client.py:679: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_host_key_negotiation_4>
ktype = <class 'paramiko.rsakey.RSAKey'>, kfile = 'rsa.key'

    def _client_host_key_good(self, ktype, kfile):
        threading.Thread(target=self._run).start()
        hostname = f"[{self.addr}]:{self.port}"

        self.tc = SSHClient()
        self.tc.set_missing_host_key_policy(paramiko.RejectPolicy())
        host_key = ktype.from_private_key_file(_support(kfile))
        known_hosts = self.tc.get_host_keys()
>       known_hosts.add(hostname, host_key.get_name(), host_key)
E       AttributeError: 'NoneType' object has no attribute 'add'

tests/test_client.py:657: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_missing_key_policy_accepts_classes_or_instances">test_client.py::SSHClientTest::test_missing_key_policy_accepts_classes_or_instances</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_missing_key_policy_accepts_classes_or_instances</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_missing_key_policy_accepts_classes_or_instances>

    def test_missing_key_policy_accepts_classes_or_instances(self):
        """
        Client.missing_host_key_policy() can take classes or instances.
        """
        # AN ACTUAL UNIT TEST?! GOOD LORD
        # (But then we have to test a private API...meh.)
        client = SSHClient()
        # Default
        assert isinstance(client._policy, paramiko.RejectPolicy)
        # Hand in an instance (classic behavior)
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
>       assert isinstance(client._policy, paramiko.AutoAddPolicy)
E       AssertionError: assert False
E        +  where False = isinstance(<paramiko.client.RejectPolicy object at 0x7eb2f9c77fd0>, <class 'paramiko.client.AutoAddPolicy'>)
E        +    where <paramiko.client.RejectPolicy object at 0x7eb2f9c77fd0> = <paramiko.client.SSHClient object at 0x7eb2f9c75d20>._policy
E        +    and   <class 'paramiko.client.AutoAddPolicy'> = paramiko.AutoAddPolicy

tests/test_client.py:733: AssertionError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_multiple_key_files">test_client.py::SSHClientTest::test_multiple_key_files</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_multiple_key_files</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_multiple_key_files>

    @requires_sha1_signing
    def test_multiple_key_files(self):
        """
        verify that SSHClient accepts and tries multiple key files.
        """
        # This is dumb :(
        types_ = {
            "rsa": "ssh-rsa",
            "dss": "ssh-dss",
            "ecdsa": "ecdsa-sha2-nistp256",
        }
        # Various combos of attempted & valid keys
        # TODO: try every possible combo using itertools functions
        # TODO: use new key(s) fixture(s)
        for attempt, accept in (
            (["rsa", "dss"], ["dss"]),  # Original test #3
            (["dss", "rsa"], ["dss"]),  # Ordering matters sometimes, sadly
            (["dss", "rsa", "ecdsa-256"], ["dss"]),  # Try ECDSA but fail
            (["rsa", "ecdsa-256"], ["ecdsa"]),  # ECDSA success
        ):
            try:
>               self._test_connection(
                    key_filename=[
                        _support("{}.key".format(x)) for x in attempt
                    ],
                    allowed_keys=[types_[x] for x in accept],
                )

tests/test_client.py:298: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_multiple_key_files>
kwargs = {'key_filename': ['/testbed/tests/_support/rsa.key', '/testbed/tests/_support/dss.key']}
run_kwargs = {'allowed_keys': ['ssh-dss'], 'kill_event': <threading.Event object at 0x7eb2f98e26b0>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_multiple_key_files_failure">test_client.py::SSHClientTest::test_multiple_key_files_failure</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_multiple_key_files_failure</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_multiple_key_files_failure>

    @requires_sha1_signing
    def test_multiple_key_files_failure(self):
        """
        Expect failure when multiple keys in play and none are accepted
        """
        # Until #387 is fixed we have to catch a high-up exception since
        # various platforms trigger different errors here >_<
>       self.assertRaises(
            SSHException,
            self._test_connection,
            key_filename=[_support("rsa.key")],
            allowed_keys=["ecdsa-sha2-nistp256"],
        )

tests/test_client.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_newer_openssh_uses_rsa_sha2_for_certs_not_ssh_rsa">test_client.py::SSHClientTest::test_newer_openssh_uses_rsa_sha2_for_certs_not_ssh_rsa</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_newer_openssh_uses_rsa_sha2_for_certs_not_ssh_rsa</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_newer_openssh_uses_rsa_sha2_for_certs_not_ssh_rsa>

    @requires_sha1_signing
    def test_newer_openssh_uses_rsa_sha2_for_certs_not_ssh_rsa(self):
        # NOTE: 512 happens to be first in our list and is thus chosen
>       self._cert_algo_test(ver="7.8", alg="rsa-sha2-512")

tests/test_client.py:373: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_client.py:355: in _cert_algo_test
    self._test_connection(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_newer_openssh_uses_rsa_sha2_for_certs_not_ssh_rsa>
kwargs = {'key_filename': '/testbed/tests/_support/rsa.key-cert.pub'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f98e3d30>, 'public_blob': None, 'server_name': 'SSH-2.0-OpenSSH_7.8'}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_old_openssh_needs_ssh_rsa_for_certs_not_rsa_sha2">test_client.py::SSHClientTest::test_old_openssh_needs_ssh_rsa_for_certs_not_rsa_sha2</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_old_openssh_needs_ssh_rsa_for_certs_not_rsa_sha2</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_old_openssh_needs_ssh_rsa_for_certs_not_rsa_sha2>

    @requires_sha1_signing
    def test_old_openssh_needs_ssh_rsa_for_certs_not_rsa_sha2(self):
>       self._cert_algo_test(ver="7.7", alg="ssh-rsa")

tests/test_client.py:368: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_client.py:355: in _cert_algo_test
    self._test_connection(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_old_openssh_needs_ssh_rsa_for_certs_not_rsa_sha2>
kwargs = {'key_filename': '/testbed/tests/_support/rsa.key-cert.pub'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9909150>, 'public_blob': None, 'server_name': 'SSH-2.0-OpenSSH_7.7'}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_reject_policy">test_client.py::SSHClientTest::test_reject_policy</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_reject_policy</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_reject_policy>

    def test_reject_policy(self):
        """
        verify that SSHClient's RejectPolicy works.
        """
        threading.Thread(target=self._run).start()

        self.tc = SSHClient()
        self.tc.set_missing_host_key_policy(paramiko.RejectPolicy())
>       self.assertEqual(0, len(self.tc.get_host_keys()))
E       TypeError: object of type 'NoneType' has no len()

tests/test_client.py:604: TypeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_reject_policy_gsskex">test_client.py::SSHClientTest::test_reject_policy_gsskex</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_reject_policy_gsskex</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_reject_policy_gsskex>

    @requires_gss_auth
    def test_reject_policy_gsskex(self):
        """
        verify that SSHClient's RejectPolicy works,
        even if gssapi-keyex was enabled but not used.
        """
        # Test for a bug present in paramiko versions released before
        # 2017-08-01
        threading.Thread(target=self._run).start()

        self.tc = SSHClient()
        self.tc.set_missing_host_key_policy(paramiko.RejectPolicy())
>       self.assertEqual(0, len(self.tc.get_host_keys()))
E       TypeError: object of type 'NoneType' has no len()

tests/test_client.py:624: TypeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_save_host_keys">test_client.py::SSHClientTest::test_save_host_keys</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_save_host_keys</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_save_host_keys>

    def test_save_host_keys(self):
        """
        verify that SSHClient correctly saves a known_hosts file.
        """
        warnings.filterwarnings("ignore", "tempnam.*")

        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:411: AttributeError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_transport_factory_defaults_to_transport">test_client.py::SSHClientTest::test_transport_factory_defaults_to_Transport</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_transport_factory_defaults_to_Transport</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_transport_factory_defaults_to_Transport>
Transport = <MagicMock name='Transport' id='139307191446368'>

    @patch("paramiko.client.Transport")
    def test_transport_factory_defaults_to_Transport(self, Transport):
        sock, kex, creds, algos = Mock(), Mock(), Mock(), Mock()
        SSHClient().connect(
            "host",
            sock=sock,
            password="no",
            gss_kex=kex,
            gss_deleg_creds=creds,
            disabled_algorithms=algos,
        )
>       Transport.assert_called_once_with(
            sock, gss_kex=kex, gss_deleg_creds=creds, disabled_algorithms=algos
        )

tests/test_client.py:765: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='Transport' id='139307191446368'>
args = (<Mock id='139307191450304'>,)
kwargs = {'disabled_algorithms': <Mock id='139307157807952'>, 'gss_deleg_creds': <Mock id='139307157807424'>, 'gss_kex': <Mock id='139307157809488'>}
msg = "Expected 'Transport' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'Transport' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_transport_factory_may_be_specified">test_client.py::SSHClientTest::test_transport_factory_may_be_specified</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_transport_factory_may_be_specified</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_transport_factory_may_be_specified>
Transport = <MagicMock name='Transport' id='139307157507616'>

    @patch("paramiko.client.Transport")
    def test_transport_factory_may_be_specified(self, Transport):
        factory = Mock()
        sock, kex, creds, algos = Mock(), Mock(), Mock(), Mock()
        SSHClient().connect(
            "host",
            sock=sock,
            password="no",
            gss_kex=kex,
            gss_deleg_creds=creds,
            disabled_algorithms=algos,
            transport_factory=factory,
        )
>       factory.assert_called_once_with(
            sock, gss_kex=kex, gss_deleg_creds=creds, disabled_algorithms=algos
        )

tests/test_client.py:782: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock id='139307157508528'>, args = (<Mock id='139307157514288'>,)
kwargs = {'disabled_algorithms': <Mock id='139307157509920'>, 'gss_deleg_creds': <Mock id='139307157514576'>, 'gss_kex': <Mock id='139307157518608'>}
msg = "Expected 'mock' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="test_clientpysshclienttesttest_update_environment">test_client.py::SSHClientTest::test_update_environment</h3>
<details><summary> <pre>test_client.py::SSHClientTest::test_update_environment</pre></summary><pre>
self = <tests.test_client.SSHClientTest testMethod=test_update_environment>

    def test_update_environment(self):
        """
        Verify that environment variables can be set by the client.
        """
>       self._setup_for_env()

tests/test_client.py:699: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.SSHClientTest testMethod=test_update_environment>

    def _setup_for_env(self):
        threading.Thread(target=self._run).start()

        self.tc = SSHClient()
        self.tc.set_missing_host_key_policy(paramiko.AutoAddPolicy())
>       self.assertEqual(0, len(self.tc.get_host_keys()))
E       TypeError: object of type 'NoneType' has no len()

tests/test_client.py:686: TypeError
</pre>
</details>
<h3 id="test_clientpypasswordpassphraseteststest_passphrase_kwarg_not_used_for_password_auth">test_client.py::PasswordPassphraseTests::test_passphrase_kwarg_not_used_for_password_auth</h3>
<details><summary> <pre>test_client.py::PasswordPassphraseTests::test_passphrase_kwarg_not_used_for_password_auth</pre></summary><pre>
self = <tests.test_client.PasswordPassphraseTests testMethod=test_passphrase_kwarg_not_used_for_password_auth>

    @raises(SSHException)
    @requires_sha1_signing
    def test_passphrase_kwarg_not_used_for_password_auth(self):
        # Using the "right" password in the "wrong" field shouldn't work.
>       self._test_connection(passphrase="pygmalion")

tests/test_client.py:806: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.PasswordPassphraseTests testMethod=test_passphrase_kwarg_not_used_for_password_auth>
kwargs = {'passphrase': 'pygmalion'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9dd17b0>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpypasswordpassphraseteststest_passphrase_kwarg_used_for_key_passphrase">test_client.py::PasswordPassphraseTests::test_passphrase_kwarg_used_for_key_passphrase</h3>
<details><summary> <pre>test_client.py::PasswordPassphraseTests::test_passphrase_kwarg_used_for_key_passphrase</pre></summary><pre>
self = <tests.test_client.PasswordPassphraseTests testMethod=test_passphrase_kwarg_used_for_key_passphrase>

    @requires_sha1_signing
    def test_passphrase_kwarg_used_for_key_passphrase(self):
        # Straightforward again, with new passphrase kwarg.
>       self._test_connection(
            key_filename=_support("test_rsa_password.key"),
            passphrase="television",
        )

tests/test_client.py:811: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.PasswordPassphraseTests testMethod=test_passphrase_kwarg_used_for_key_passphrase>
kwargs = {'key_filename': '/testbed/tests/test_rsa_password.key', 'passphrase': 'television'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f949eb60>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpypasswordpassphraseteststest_password_kwarg_not_used_for_passphrase_when_passphrase_kwarg_given">test_client.py::PasswordPassphraseTests::test_password_kwarg_not_used_for_passphrase_when_passphrase_kwarg_given</h3>
<details><summary> <pre>test_client.py::PasswordPassphraseTests::test_password_kwarg_not_used_for_passphrase_when_passphrase_kwarg_given</pre></summary><pre>
self = <tests.test_client.PasswordPassphraseTests testMethod=test_password_kwarg_not_used_for_passphrase_when_passphrase_kwarg_given>

    @raises(AuthenticationException)  # TODO: more granular
    @requires_sha1_signing
    def test_password_kwarg_not_used_for_passphrase_when_passphrase_kwarg_given(  # noqa
        self,
    ):
        # Sanity: if we're given both fields, the password field is NOT used as
        # a passphrase.
>       self._test_connection(
            key_filename=_support("test_rsa_password.key"),
            password="television",
            passphrase="wat? lol no",
        )

tests/test_client.py:833: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.PasswordPassphraseTests testMethod=test_password_kwarg_not_used_for_passphrase_when_passphrase_kwarg_given>
kwargs = {'key_filename': '/testbed/tests/test_rsa_password.key', 'passphrase': 'wat? lol no', 'password': 'television'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9dd17e0>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpypasswordpassphraseteststest_password_kwarg_used_for_passphrase_when_no_passphrase_kwarg_given">test_client.py::PasswordPassphraseTests::test_password_kwarg_used_for_passphrase_when_no_passphrase_kwarg_given</h3>
<details><summary> <pre>test_client.py::PasswordPassphraseTests::test_password_kwarg_used_for_passphrase_when_no_passphrase_kwarg_given</pre></summary><pre>
self = <tests.test_client.PasswordPassphraseTests testMethod=test_password_kwarg_used_for_passphrase_when_no_passphrase_kwarg_given>

    @requires_sha1_signing
    def test_password_kwarg_used_for_passphrase_when_no_passphrase_kwarg_given(
        self,
    ):  # noqa
        # Backwards compatibility: passphrase in the password field.
>       self._test_connection(
            key_filename=_support("test_rsa_password.key"),
            password="television",
        )

tests/test_client.py:821: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.PasswordPassphraseTests testMethod=test_password_kwarg_used_for_passphrase_when_no_passphrase_kwarg_given>
kwargs = {'key_filename': '/testbed/tests/test_rsa_password.key', 'password': 'television'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f95e9630>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_clientpypasswordpassphraseteststest_password_kwarg_works_for_password_auth">test_client.py::PasswordPassphraseTests::test_password_kwarg_works_for_password_auth</h3>
<details><summary> <pre>test_client.py::PasswordPassphraseTests::test_password_kwarg_works_for_password_auth</pre></summary><pre>
self = <tests.test_client.PasswordPassphraseTests testMethod=test_password_kwarg_works_for_password_auth>

    @requires_sha1_signing
    def test_password_kwarg_works_for_password_auth(self):
        # Straightforward / duplicate of earlier basic password test.
>       self._test_connection(password="pygmalion")

tests/test_client.py:798: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_client.PasswordPassphraseTests testMethod=test_password_kwarg_works_for_password_auth>
kwargs = {'password': 'pygmalion'}
run_kwargs = {'allowed_keys': None, 'kill_event': <threading.Event object at 0x7eb2f9a26fb0>, 'public_blob': None, 'server_name': None}
key = 'server_name', host_key = None

    def _test_connection(self, **kwargs):
        """
        (Most) kwargs get passed directly into SSHClient.connect().

        The exceptions are ``allowed_keys``/``public_blob``/``server_name``
        which are stripped and handed to the ``NullServer`` used for testing.
        """
        run_kwargs = {"kill_event": self.kill_event}
        for key in ("allowed_keys", "public_blob", "server_name"):
            run_kwargs[key] = kwargs.pop(key, None)
        # Server setup
        threading.Thread(target=self._run, kwargs=run_kwargs).start()
        host_key = paramiko.RSAKey.from_private_key_file(_support("rsa.key"))
>       public_host_key = paramiko.RSAKey(data=host_key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_client.py:198: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_from_text">test_config.py::TestSSHConfig::test_from_text</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_from_text</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9490fd0>

    def test_from_text(self):
        config = SSHConfig.from_text("User foo")
>       assert config.lookup("foo.example.com")["user"] == "foo"
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:68: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_from_file">test_config.py::TestSSHConfig::test_from_file</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_from_file</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f94916f0>

    def test_from_file(self):
        with open(_config("robey")) as flo:
            config = SSHConfig.from_file(flo)
>       assert config.lookup("whatever")["user"] == "robey"
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:73: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_from_path">test_config.py::TestSSHConfig::test_from_path</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_from_path</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9491570>

    def test_from_path(self):
        # NOTE: DO NOT replace with use of load_config() :D
        config = SSHConfig.from_path(_config("robey"))
>       assert config.lookup("meh.example.com")["port"] == "3333"
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:78: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_parse_config">test_config.py::TestSSHConfig::test_parse_config</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_parse_config</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9491810>

    def test_parse_config(self):
        expected = [
            {"host": ["*"], "config": {}},
            {
                "host": ["*"],
                "config": {"identityfile": ["~/.ssh/id_rsa"], "user": "robey"},
            },
            {
                "host": ["*.example.com"],
                "config": {"user": "bjork", "port": "3333"},
            },
            {"host": ["*"], "config": {"crazy": "something dumb"}},
            {
                "host": ["spoo.example.com"],
                "config": {"crazy": "something else"},
            },
        ]
>       assert self.config._config == expected
E       AttributeError: 'NoneType' object has no attribute '_config'

tests/test_config.py:97: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_host_configircdangercom-values0">test_config.py::TestSSHConfig::test_host_config[irc.danger.com-values0]</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_host_config[irc.danger.com-values0]</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9491090>
host = 'irc.danger.com'
values = {'crazy': 'something dumb', 'hostname': 'irc.danger.com', 'user': 'robey'}

    @mark.parametrize(
        "host,values",
        (
            (
                "irc.danger.com",
                {
                    "crazy": "something dumb",
                    "hostname": "irc.danger.com",
                    "user": "robey",
                },
            ),
            (
                "irc.example.com",
                {
                    "crazy": "something dumb",
                    "hostname": "irc.example.com",
                    "user": "robey",
                    "port": "3333",
                },
            ),
            (
                "spoo.example.com",
                {
                    "crazy": "something dumb",
                    "hostname": "spoo.example.com",
                    "user": "robey",
                    "port": "3333",
                },
            ),
        ),
    )
    def test_host_config(self, host, values):
        expected = dict(
            values, hostname=host, identityfile=[expanduser("~/.ssh/id_rsa")]
        )
>       assert self.config.lookup(host) == expected
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:134: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_host_configircexamplecom-values1">test_config.py::TestSSHConfig::test_host_config[irc.example.com-values1]</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_host_config[irc.example.com-values1]</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f94918a0>
host = 'irc.example.com'
values = {'crazy': 'something dumb', 'hostname': 'irc.example.com', 'port': '3333', 'user': 'robey'}

    @mark.parametrize(
        "host,values",
        (
            (
                "irc.danger.com",
                {
                    "crazy": "something dumb",
                    "hostname": "irc.danger.com",
                    "user": "robey",
                },
            ),
            (
                "irc.example.com",
                {
                    "crazy": "something dumb",
                    "hostname": "irc.example.com",
                    "user": "robey",
                    "port": "3333",
                },
            ),
            (
                "spoo.example.com",
                {
                    "crazy": "something dumb",
                    "hostname": "spoo.example.com",
                    "user": "robey",
                    "port": "3333",
                },
            ),
        ),
    )
    def test_host_config(self, host, values):
        expected = dict(
            values, hostname=host, identityfile=[expanduser("~/.ssh/id_rsa")]
        )
>       assert self.config.lookup(host) == expected
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:134: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_host_configspooexamplecom-values2">test_config.py::TestSSHConfig::test_host_config[spoo.example.com-values2]</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_host_config[spoo.example.com-values2]</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9491c90>
host = 'spoo.example.com'
values = {'crazy': 'something dumb', 'hostname': 'spoo.example.com', 'port': '3333', 'user': 'robey'}

    @mark.parametrize(
        "host,values",
        (
            (
                "irc.danger.com",
                {
                    "crazy": "something dumb",
                    "hostname": "irc.danger.com",
                    "user": "robey",
                },
            ),
            (
                "irc.example.com",
                {
                    "crazy": "something dumb",
                    "hostname": "irc.example.com",
                    "user": "robey",
                    "port": "3333",
                },
            ),
            (
                "spoo.example.com",
                {
                    "crazy": "something dumb",
                    "hostname": "spoo.example.com",
                    "user": "robey",
                    "port": "3333",
                },
            ),
        ),
    )
    def test_host_config(self, host, values):
        expected = dict(
            values, hostname=host, identityfile=[expanduser("~/.ssh/id_rsa")]
        )
>       assert self.config.lookup(host) == expected
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:134: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_fabric_issue_33">test_config.py::TestSSHConfig::test_fabric_issue_33</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_fabric_issue_33</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9491c60>

        def test_fabric_issue_33(self):
            config = SSHConfig.from_text(
                """
    Host www13.*
        Port 22

    Host *.example.com
        Port 2222

    Host *
        Port 3333
    """
            )
            host = "www13.example.com"
            expected = {"hostname": host, "port": "22"}
>           assert config.lookup(host) == expected
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:151: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_proxycommand_config_equals_parsing">test_config.py::TestSSHConfig::test_proxycommand_config_equals_parsing</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_proxycommand_config_equals_parsing</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9491e10>

        def test_proxycommand_config_equals_parsing(self):
            """
            ProxyCommand should not split on equals signs within the value.
            """
            config = SSHConfig.from_text(
                """
    Host space-delimited
        ProxyCommand foo bar=biz baz

    Host equals-delimited
        ProxyCommand=foo bar=biz baz
    """
            )
            for host in ("space-delimited", "equals-delimited"):
>               value = config.lookup(host)["proxycommand"]
E               AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:167: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_proxycommand_interpolation">test_config.py::TestSSHConfig::test_proxycommand_interpolation</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_proxycommand_interpolation</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9490040>

        def test_proxycommand_interpolation(self):
            """
            ProxyCommand should perform interpolation on the value
            """
            config = SSHConfig.from_text(
                """
    Host specific
        Port 37
        ProxyCommand host %h port %p lol

    Host portonly
        Port 155

    Host *
        Port 25
        ProxyCommand host %h port %p
    """
            )
            for host, val in (
                ("foo.com", "host foo.com port 25"),
                ("specific", "host specific port 37 lol"),
                ("portonly", "host portonly port 155"),
            ):
>               assert config.lookup(host)["proxycommand"] == val
E               AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:193: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_proxycommand_tilde_expansion">test_config.py::TestSSHConfig::test_proxycommand_tilde_expansion</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_proxycommand_tilde_expansion</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f94900d0>

        def test_proxycommand_tilde_expansion(self):
            """
            Tilde (~) should be expanded inside ProxyCommand
            """
            config = SSHConfig.from_text(
                """
    Host test
        ProxyCommand    ssh -F ~/.ssh/test_config bastion nc %h %p
    """
            )
            expected = "ssh -F {}/.ssh/test_config bastion nc test 22".format(
                expanduser("~")
            )
>           got = config.lookup("test")["proxycommand"]
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:208: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_proxyjump_token_expansion">test_config.py::TestSSHConfig::test_proxyjump_token_expansion</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_proxyjump_token_expansion</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f94907c0>
getpass = <MagicMock name='getpass' id='139307148917824'>

        @patch("paramiko.config.getpass")
        def test_proxyjump_token_expansion(self, getpass):
            getpass.getuser.return_value = "gandalf"
            config = SSHConfig.from_text(
                """
    Host justhost
        ProxyJump jumpuser@%h
    Host userhost
        ProxyJump %r@%h:222
    Host allcustom
        ProxyJump %r@%h:%p
    """
            )
>           assert config.lookup("justhost")["proxyjump"] == "jumpuser@justhost"
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:224: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_controlpath_token_expansion">test_config.py::TestSSHConfig::test_controlpath_token_expansion</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_controlpath_token_expansion</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f94901c0>
getpass = <MagicMock name='getpass' id='139307159870128'>
socket = <MagicMock name='socket' id='139307137581264'>

        @patch("paramiko.config.getpass")
        def test_controlpath_token_expansion(self, getpass, socket):
            getpass.getuser.return_value = "gandalf"
            config = SSHConfig.from_text(
                """
    Host explicit_user
        User root
        ControlPath user %u remoteuser %r

    Host explicit_host
        HostName ohai
        ControlPath remoteuser %r host %h orighost %n

    Host hashbrowns
        ControlPath %C
            """
            )
>           result = config.lookup("explicit_user")["controlpath"]
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:247: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_negation">test_config.py::TestSSHConfig::test_negation</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_negation</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9490700>

        def test_negation(self):
            config = SSHConfig.from_text(
                """
    Host www13.* !*.example.com
        Port 22

    Host *.example.com !www13.*
        Port 2222

    Host www13.*
        Port 8080

    Host *
        Port 3333
    """
            )
            host = "www13.example.com"
            expected = {"hostname": host, "port": "8080"}
>           assert config.lookup(host) == expected
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:275: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_proxycommand">test_config.py::TestSSHConfig::test_proxycommand</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_proxycommand</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9490a30>

        def test_proxycommand(self):
            config = SSHConfig.from_text(
                """
    Host proxy-with-equal-divisor-and-space
    ProxyCommand = foo=bar

    Host proxy-with-equal-divisor-and-no-space
    ProxyCommand=foo=bar

    Host proxy-without-equal-divisor
    ProxyCommand foo=bar:%h-%p
    """
            )
            for host, values in {
                "proxy-with-equal-divisor-and-space": {
                    "hostname": "proxy-with-equal-divisor-and-space",
                    "proxycommand": "foo=bar",
                },
                "proxy-with-equal-divisor-and-no-space": {
                    "hostname": "proxy-with-equal-divisor-and-no-space",
                    "proxycommand": "foo=bar",
                },
                "proxy-without-equal-divisor": {
                    "hostname": "proxy-without-equal-divisor",
                    "proxycommand": "foo=bar:proxy-without-equal-divisor-22",
                },
            }.items():

>               assert config.lookup(host) == values
E               AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:305: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_identityfile">test_config.py::TestSSHConfig::test_identityfile</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_identityfile</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9490d30>
getpass = <MagicMock name='getpass' id='139307160115168'>
socket = <MagicMock name='socket' id='139307148928256'>

        @patch("paramiko.config.getpass")
        def test_identityfile(self, getpass, socket):
            getpass.getuser.return_value = "gandalf"
            config = SSHConfig.from_text(
                """
    IdentityFile id_dsa0

    Host *
    IdentityFile id_dsa1

    Host dsa2
    IdentityFile id_dsa2

    Host dsa2*
    IdentityFile id_dsa22

    Host hashbrowns
    IdentityFile %C
    """
            )
            for host, values in {
                "foo": {"hostname": "foo", "identityfile": ["id_dsa0", "id_dsa1"]},
                "dsa2": {
                    "hostname": "dsa2",
                    "identityfile": ["id_dsa0", "id_dsa1", "id_dsa2", "id_dsa22"],
                },
                "dsa22": {
                    "hostname": "dsa22",
                    "identityfile": ["id_dsa0", "id_dsa1", "id_dsa22"],
                },
                "hashbrowns": {
                    "hostname": "hashbrowns",
                    "identityfile": [
                        "id_dsa0",
                        "id_dsa1",
                        "a438e7dbf5308b923aba9db8fe2ca63447ac8688",
                    ],
                },
            }.items():
>               assert config.lookup(host) == values
E               AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:346: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_config_addressfamily_and_lazy_fqdn">test_config.py::TestSSHConfig::test_config_addressfamily_and_lazy_fqdn</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_config_addressfamily_and_lazy_fqdn</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9490cd0>

        def test_config_addressfamily_and_lazy_fqdn(self):
            """
            Ensure the code path honoring non-'all' AddressFamily doesn't asplode
            """
            config = SSHConfig.from_text(
                """
    AddressFamily inet
    IdentityFile something_%l_using_fqdn
    """
            )
            assert config.lookup(
                "meh"
>           )  # will die during lookup() if bug regresses
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:360: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_config_dos_crlf_succeeds">test_config.py::TestSSHConfig::test_config_dos_crlf_succeeds</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_config_dos_crlf_succeeds</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9cce260>

        def test_config_dos_crlf_succeeds(self):
            config = SSHConfig.from_text(
                """
    Host abcqwerty\r\nHostName 127.0.0.1\r\n
    """
            )
>           assert config.lookup("abcqwerty")["hostname"] == "127.0.0.1"
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:368: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_get_hostnames">test_config.py::TestSSHConfig::test_get_hostnames</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_get_hostnames</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9cce890>

    def test_get_hostnames(self):
        expected = {"*", "*.example.com", "spoo.example.com"}
>       assert self.config.get_hostnames() == expected
E       AttributeError: 'NoneType' object has no attribute 'get_hostnames'

tests/test_config.py:372: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_quoted_host_names">test_config.py::TestSSHConfig::test_quoted_host_names</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_quoted_host_names</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9ccdc00>

        def test_quoted_host_names(self):
            config = SSHConfig.from_text(
                """
    Host "param pam" param "pam"
        Port 1111

    Host "param2"
        Port 2222

    Host param3 parara
        Port 3333

    Host param4 "p a r" "p" "par" para
        Port 4444
    """
            )
            res = {
                "param pam": {"hostname": "param pam", "port": "1111"},
                "param": {"hostname": "param", "port": "1111"},
                "pam": {"hostname": "pam", "port": "1111"},
                "param2": {"hostname": "param2", "port": "2222"},
                "param3": {"hostname": "param3", "port": "3333"},
                "parara": {"hostname": "parara", "port": "3333"},
                "param4": {"hostname": "param4", "port": "4444"},
                "p a r": {"hostname": "p a r", "port": "4444"},
                "p": {"hostname": "p", "port": "4444"},
                "par": {"hostname": "par", "port": "4444"},
                "para": {"hostname": "para", "port": "4444"},
            }
            for host, values in res.items():
>               assert config.lookup(host) == values
E               AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:404: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_quoted_params_in_config">test_config.py::TestSSHConfig::test_quoted_params_in_config</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_quoted_params_in_config</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9ccdd50>

        def test_quoted_params_in_config(self):
            config = SSHConfig.from_text(
                """
    Host "param pam" param "pam"
        IdentityFile id_rsa

    Host "param2"
        IdentityFile "test rsa key"

    Host param3 parara
        IdentityFile id_rsa
        IdentityFile "test rsa key"
    """
            )
            res = {
                "param pam": {"hostname": "param pam", "identityfile": ["id_rsa"]},
                "param": {"hostname": "param", "identityfile": ["id_rsa"]},
                "pam": {"hostname": "pam", "identityfile": ["id_rsa"]},
                "param2": {"hostname": "param2", "identityfile": ["test rsa key"]},
                "param3": {
                    "hostname": "param3",
                    "identityfile": ["id_rsa", "test rsa key"],
                },
                "parara": {
                    "hostname": "parara",
                    "identityfile": ["id_rsa", "test rsa key"],
                },
            }
            for host, values in res.items():
>               assert config.lookup(host) == values
E               AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:435: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_quoted_host_in_config">test_config.py::TestSSHConfig::test_quoted_host_in_config</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_quoted_host_in_config</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9ccdf00>

    def test_quoted_host_in_config(self):
        conf = SSHConfig()
        correct_data = {
            "param": ["param"],
            '"param"': ["param"],
            "param pam": ["param", "pam"],
            '"param" "pam"': ["param", "pam"],
            '"param" pam': ["param", "pam"],
            'param "pam"': ["param", "pam"],
            'param "pam" p': ["param", "pam", "p"],
            '"param" pam "p"': ["param", "pam", "p"],
            '"pa ram"': ["pa ram"],
            '"pa ram" pam': ["pa ram", "pam"],
            'param "p a m"': ["param", "p a m"],
        }
        incorrect_data = ['param"', '"param', 'param "pam', 'param "pam" "p a']
        for host, values in correct_data.items():
>           assert conf._get_hosts(host) == values
E           AssertionError: assert None == ['param']
E            +  where None = _get_hosts('param')
E            +    where _get_hosts = <paramiko.config.SSHConfig object at 0x7eb2f8735f60>._get_hosts

tests/test_config.py:454: AssertionError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_invalid_line_format_excepts">test_config.py::TestSSHConfig::test_invalid_line_format_excepts</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_invalid_line_format_excepts</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9ccda80>

    def test_invalid_line_format_excepts(self):
>       with raises(ConfigParseError):
E       Failed: DID NOT RAISE <class 'paramiko.ssh_exception.ConfigParseError'>

tests/test_config.py:460: Failed
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_proxycommand_none_issue_415">test_config.py::TestSSHConfig::test_proxycommand_none_issue_415</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_proxycommand_none_issue_415</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9490250>

        def test_proxycommand_none_issue_415(self):
            config = SSHConfig.from_text(
                """
    Host proxycommand-standard-none
        ProxyCommand None

    Host proxycommand-with-equals-none
        ProxyCommand=None
    """
            )
            for host, values in {
                "proxycommand-standard-none": {
                    "hostname": "proxycommand-standard-none",
                    "proxycommand": None,
                },
                "proxycommand-with-equals-none": {
                    "hostname": "proxycommand-with-equals-none",
                    "proxycommand": None,
                },
            }.items():

>               assert config.lookup(host) == values
E               AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:484: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_proxycommand_none_masking">test_config.py::TestSSHConfig::test_proxycommand_none_masking</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_proxycommand_none_masking</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f9490970>

        def test_proxycommand_none_masking(self):
            # Re: https://github.com/paramiko/paramiko/issues/670
            config = SSHConfig.from_text(
                """
    Host specific-host
        ProxyCommand none

    Host other-host
        ProxyCommand other-proxy

    Host *
        ProxyCommand default-proxy
    """
            )
            # In versions <3.0, 'None' ProxyCommands got deleted, and this itself
            # caused bugs. In 3.0, we more cleanly map "none" to None. This test
            # has been altered accordingly but left around to ensure no
            # regressions.
>           assert config.lookup("specific-host")["proxycommand"] is None
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:504: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigtest_hostname_tokenization">test_config.py::TestSSHConfig::test_hostname_tokenization</h3>
<details><summary> <pre>test_config.py::TestSSHConfig::test_hostname_tokenization</pre></summary><pre>
self = <tests.test_config.TestSSHConfig object at 0x7eb2f94903a0>

    def test_hostname_tokenization(self):
>       result = load_config("hostname-tokenized").lookup("whatever")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:510: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_bool_true_ishyes">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[yes]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[yes]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9ccf220>
true_ish = 'yes'

    @mark.parametrize("true_ish", ("yes", "YES", "Yes", True))
    def test_SSHConfigDict_as_bool_true_ish(self, true_ish):
>       assert SSHConfigDict({"key": true_ish}).as_bool("key") is True
E       AssertionError: assert None is True
E        +  where None = as_bool('key')
E        +    where as_bool = {'key': 'yes'}.as_bool
E        +      where {'key': 'yes'} = SSHConfigDict({'key': 'yes'})

tests/test_config.py:526: AssertionError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_bool_true_ishyes_1">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[YES]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[YES]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9ccf640>
true_ish = 'YES'

    @mark.parametrize("true_ish", ("yes", "YES", "Yes", True))
    def test_SSHConfigDict_as_bool_true_ish(self, true_ish):
>       assert SSHConfigDict({"key": true_ish}).as_bool("key") is True
E       AssertionError: assert None is True
E        +  where None = as_bool('key')
E        +    where as_bool = {'key': 'YES'}.as_bool
E        +      where {'key': 'YES'} = SSHConfigDict({'key': 'YES'})

tests/test_config.py:526: AssertionError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_bool_true_ishyes_2">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[Yes]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[Yes]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9ccf970>
true_ish = 'Yes'

    @mark.parametrize("true_ish", ("yes", "YES", "Yes", True))
    def test_SSHConfigDict_as_bool_true_ish(self, true_ish):
>       assert SSHConfigDict({"key": true_ish}).as_bool("key") is True
E       AssertionError: assert None is True
E        +  where None = as_bool('key')
E        +    where as_bool = {'key': 'Yes'}.as_bool
E        +      where {'key': 'Yes'} = SSHConfigDict({'key': 'Yes'})

tests/test_config.py:526: AssertionError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_bool_true_ishtrue">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[True]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool_true_ish[True]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9cce1a0>
true_ish = True

    @mark.parametrize("true_ish", ("yes", "YES", "Yes", True))
    def test_SSHConfigDict_as_bool_true_ish(self, true_ish):
>       assert SSHConfigDict({"key": true_ish}).as_bool("key") is True
E       AssertionError: assert None is True
E        +  where None = as_bool('key')
E        +    where as_bool = {'key': True}.as_bool
E        +      where {'key': True} = SSHConfigDict({'key': True})

tests/test_config.py:526: AssertionError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_boolno">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[no]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[no]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9cce6b0>
false_ish = 'no'

    @mark.parametrize("false_ish", ("no", "NO", "No", False))
    def test_SSHConfigDict_as_bool(self, false_ish):
>       assert SSHConfigDict({"key": false_ish}).as_bool("key") is False
E       AssertionError: assert None is False
E        +  where None = as_bool('key')
E        +    where as_bool = {'key': 'no'}.as_bool
E        +      where {'key': 'no'} = SSHConfigDict({'key': 'no'})

tests/test_config.py:530: AssertionError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_boolno_1">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[NO]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[NO]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9ccdfc0>
false_ish = 'NO'

    @mark.parametrize("false_ish", ("no", "NO", "No", False))
    def test_SSHConfigDict_as_bool(self, false_ish):
>       assert SSHConfigDict({"key": false_ish}).as_bool("key") is False
E       AssertionError: assert None is False
E        +  where None = as_bool('key')
E        +    where as_bool = {'key': 'NO'}.as_bool
E        +      where {'key': 'NO'} = SSHConfigDict({'key': 'NO'})

tests/test_config.py:530: AssertionError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_boolno_2">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[No]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[No]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9cceda0>
false_ish = 'No'

    @mark.parametrize("false_ish", ("no", "NO", "No", False))
    def test_SSHConfigDict_as_bool(self, false_ish):
>       assert SSHConfigDict({"key": false_ish}).as_bool("key") is False
E       AssertionError: assert None is False
E        +  where None = as_bool('key')
E        +    where as_bool = {'key': 'No'}.as_bool
E        +      where {'key': 'No'} = SSHConfigDict({'key': 'No'})

tests/test_config.py:530: AssertionError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_boolfalse">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[False]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_bool[False]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9cceaa0>
false_ish = False

    @mark.parametrize("false_ish", ("no", "NO", "No", False))
    def test_SSHConfigDict_as_bool(self, false_ish):
>       assert SSHConfigDict({"key": false_ish}).as_bool("key") is False
E       AssertionError: assert None is False
E        +  where None = as_bool('key')
E        +    where as_bool = {'key': False}.as_bool
E        +      where {'key': False} = SSHConfigDict({'key': False})

tests/test_config.py:530: AssertionError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_int42_0">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int[42_0]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int[42_0]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9cced40>
int_val = '42'

    @mark.parametrize("int_val", ("42", 42))
    def test_SSHConfigDict_as_int(self, int_val):
>       assert SSHConfigDict({"key": int_val}).as_int("key") == 42
E       AssertionError: assert None == 42
E        +  where None = as_int('key')
E        +    where as_int = {'key': '42'}.as_int
E        +      where {'key': '42'} = SSHConfigDict({'key': '42'})

tests/test_config.py:534: AssertionError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_int42_1">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int[42_1]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int[42_1]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9cccf70>
int_val = 42

    @mark.parametrize("int_val", ("42", 42))
    def test_SSHConfigDict_as_int(self, int_val):
>       assert SSHConfigDict({"key": int_val}).as_int("key") == 42
E       AssertionError: assert None == 42
E        +  where None = as_int('key')
E        +    where as_int = {'key': 42}.as_int
E        +      where {'key': 42} = SSHConfigDict({'key': 42})

tests/test_config.py:534: AssertionError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_int_failuresnot-an-int">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int_failures[not an int]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int_failures[not an int]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9ccd180>
non_int = 'not an int'

    @mark.parametrize("non_int", ("not an int", None, object()))
    def test_SSHConfigDict_as_int_failures(self, non_int):
        conf = SSHConfigDict({"key": non_int})

        try:
            int(non_int)
        except Exception as e:
            exception_type = type(e)

>       with raises(exception_type):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_config.py:545: Failed
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_int_failuresnone">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int_failures[None]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int_failures[None]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9ccddb0>
non_int = None

    @mark.parametrize("non_int", ("not an int", None, object()))
    def test_SSHConfigDict_as_int_failures(self, non_int):
        conf = SSHConfigDict({"key": non_int})

        try:
            int(non_int)
        except Exception as e:
            exception_type = type(e)

>       with raises(exception_type):
E       Failed: DID NOT RAISE <class 'TypeError'>

tests/test_config.py:545: Failed
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfigdict_as_int_failuresnon_int2">test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int_failures[non_int2]</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfigDict_as_int_failures[non_int2]</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9ccc340>
non_int = <object object at 0x7eb2fc58b5d0>

    @mark.parametrize("non_int", ("not an int", None, object()))
    def test_SSHConfigDict_as_int_failures(self, non_int):
        conf = SSHConfigDict({"key": non_int})

        try:
            int(non_int)
        except Exception as e:
            exception_type = type(e)

>       with raises(exception_type):
E       Failed: DID NOT RAISE <class 'TypeError'>

tests/test_config.py:545: Failed
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfig_host_dicts_are_sshconfigdict_instances">test_config.py::TestSSHConfigDict::test_SSHConfig_host_dicts_are_SSHConfigDict_instances</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfig_host_dicts_are_SSHConfigDict_instances</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9cccb80>

        def test_SSHConfig_host_dicts_are_SSHConfigDict_instances(self):
            config = SSHConfig.from_text(
                """
    Host *.example.com
        Port 2222

    Host *
        Port 3333
    """
            )
>           assert config.lookup("foo.example.com").as_int("port") == 2222
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:558: AttributeError
</pre>
</details>
<h3 id="test_configpytestsshconfigdicttest_sshconfig_wildcard_host_dicts_are_sshconfigdict_instances">test_config.py::TestSSHConfigDict::test_SSHConfig_wildcard_host_dicts_are_SSHConfigDict_instances</h3>
<details><summary> <pre>test_config.py::TestSSHConfigDict::test_SSHConfig_wildcard_host_dicts_are_SSHConfigDict_instances</pre></summary><pre>
self = <tests.test_config.TestSSHConfigDict object at 0x7eb2f9ccd3c0>

        def test_SSHConfig_wildcard_host_dicts_are_SSHConfigDict_instances(self):
            config = SSHConfig.from_text(
                """
    Host *.example.com
        Port 2222

    Host *
        Port 3333
    """
            )
>           assert config.lookup("anything-else").as_int("port") == 3333
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:570: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_off_by_default">test_config.py::TestHostnameCanonicalization::test_off_by_default</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_off_by_default</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9ccd420>
socket = <MagicMock name='socket' id='139307157807088'>

    def test_off_by_default(self, socket):
>       result = load_config("basic").lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:579: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_explicit_no_same_as_default">test_config.py::TestHostnameCanonicalization::test_explicit_no_same_as_default</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_explicit_no_same_as_default</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9cceec0>
socket = <MagicMock name='socket' id='139307148906064'>

    def test_explicit_no_same_as_default(self, socket):
>       result = load_config("no-canon").lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:585: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_canonicalization_base_casescanon">test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon]</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon]</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9ccdcf0>
socket = <MagicMock name='socket' id='139307159012736'>, config_name = 'canon'

    @mark.parametrize(
        "config_name",
        ("canon", "canon-always", "canon-local", "canon-local-always"),
    )
    def test_canonicalization_base_cases(self, socket, config_name):
>       result = load_config(config_name).lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:595: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_canonicalization_base_casescanon-always">test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon-always]</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon-always]</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9ccf5b0>
socket = <MagicMock name='socket' id='139307137588896'>
config_name = 'canon-always'

    @mark.parametrize(
        "config_name",
        ("canon", "canon-always", "canon-local", "canon-local-always"),
    )
    def test_canonicalization_base_cases(self, socket, config_name):
>       result = load_config(config_name).lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:595: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_canonicalization_base_casescanon-local">test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon-local]</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon-local]</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9ccf670>
socket = <MagicMock name='socket' id='139307151192368'>
config_name = 'canon-local'

    @mark.parametrize(
        "config_name",
        ("canon", "canon-always", "canon-local", "canon-local-always"),
    )
    def test_canonicalization_base_cases(self, socket, config_name):
>       result = load_config(config_name).lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:595: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_canonicalization_base_casescanon-local-always">test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon-local-always]</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_canonicalization_base_cases[canon-local-always]</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9ccf3d0>
socket = <MagicMock name='socket' id='139307148937392'>
config_name = 'canon-local-always'

    @mark.parametrize(
        "config_name",
        ("canon", "canon-always", "canon-local", "canon-local-always"),
    )
    def test_canonicalization_base_cases(self, socket, config_name):
>       result = load_config(config_name).lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:595: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_uses_getaddrinfo_when_addressfamily_given">test_config.py::TestHostnameCanonicalization::test_uses_getaddrinfo_when_AddressFamily_given</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_uses_getaddrinfo_when_AddressFamily_given</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9ccde70>
socket = <MagicMock name='socket' id='139307151160416'>

    def test_uses_getaddrinfo_when_AddressFamily_given(self, socket):
        # Undo default 'always fails' mock
        socket.getaddrinfo.side_effect = None
        socket.getaddrinfo.return_value = [True]  # just need 1st value truthy
>       result = load_config("canon-ipv4").lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:604: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_canonicaldomains_may_be_set_to_space_separated_list">test_config.py::TestHostnameCanonicalization::test_CanonicalDomains_may_be_set_to_space_separated_list</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_CanonicalDomains_may_be_set_to_space_separated_list</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9ccf3a0>
socket = <MagicMock name='socket' id='139307151493632'>

    def test_CanonicalDomains_may_be_set_to_space_separated_list(self, socket):
        # Test config has a bogus domain, followed by paramiko.org
        socket.gethostbyname.side_effect = [socket.gaierror, True]
>       result = load_config("multi-canon-domains").lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:625: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_canonicalization_applies_to_single_dot_by_default">test_config.py::TestHostnameCanonicalization::test_canonicalization_applies_to_single_dot_by_default</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_canonicalization_applies_to_single_dot_by_default</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9a9dc90>
socket = <MagicMock name='socket' id='139307147476320'>

    def test_canonicalization_applies_to_single_dot_by_default(self, socket):
>       result = load_config("deep-canon").lookup("sub.www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:634: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_canonicalization_not_applied_to_two_dots_by_default">test_config.py::TestHostnameCanonicalization::test_canonicalization_not_applied_to_two_dots_by_default</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_canonicalization_not_applied_to_two_dots_by_default</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9a9dae0>
socket = <MagicMock name='socket' id='139307147803280'>

    def test_canonicalization_not_applied_to_two_dots_by_default(self, socket):
>       result = load_config("deep-canon").lookup("subber.sub.www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:639: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_hostname_depth_controllable_with_max_dots_directive">test_config.py::TestHostnameCanonicalization::test_hostname_depth_controllable_with_max_dots_directive</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_hostname_depth_controllable_with_max_dots_directive</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9a9ded0>
socket = <MagicMock name='socket' id='139307147165456'>

    def test_hostname_depth_controllable_with_max_dots_directive(self, socket):
        # This config sets MaxDots of 2, so now canonicalization occurs
>       result = load_config("deep-canon-maxdots").lookup("subber.sub.www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:645: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_max_dots_may_be_zero">test_config.py::TestHostnameCanonicalization::test_max_dots_may_be_zero</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_max_dots_may_be_zero</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9a9dde0>
socket = <MagicMock name='socket' id='139307146901872'>

    def test_max_dots_may_be_zero(self, socket):
>       result = load_config("zero-maxdots").lookup("sub.www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:650: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_fallback_yes_does_not_canonicalize_or_error">test_config.py::TestHostnameCanonicalization::test_fallback_yes_does_not_canonicalize_or_error</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_fallback_yes_does_not_canonicalize_or_error</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9a9e0e0>
socket = <MagicMock name='socket' id='139307147246560'>

    def test_fallback_yes_does_not_canonicalize_or_error(self, socket):
        socket.gethostbyname.side_effect = socket.gaierror
>       result = load_config("fallback-yes").lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:656: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_fallback_no_causes_errors_for_unresolvable_names">test_config.py::TestHostnameCanonicalization::test_fallback_no_causes_errors_for_unresolvable_names</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_fallback_no_causes_errors_for_unresolvable_names</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9a9e440>
socket = <MagicMock name='socket' id='139307157806512'>

    def test_fallback_no_causes_errors_for_unresolvable_names(self, socket):
        socket.gethostbyname.side_effect = socket.gaierror
        with raises(CouldNotCanonicalize) as info:
>           load_config("fallback-no").lookup("doesnotexist")
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:663: AttributeError
</pre>
</details>
<h3 id="test_configpytesthostnamecanonicalizationtest_identityfile_continues_being_appended_to">test_config.py::TestHostnameCanonicalization::test_identityfile_continues_being_appended_to</h3>
<details><summary> <pre>test_config.py::TestHostnameCanonicalization::test_identityfile_continues_being_appended_to</pre></summary><pre>
self = <tests.test_config.TestHostnameCanonicalization object at 0x7eb2f9a9e0b0>
socket = <MagicMock name='socket' id='139307151549120'>

    def test_identityfile_continues_being_appended_to(self, socket):
>       result = load_config("canon").lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:667: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchalltest_always_matches">test_config.py::TestMatchAll::test_always_matches</h3>
<details><summary> <pre>test_config.py::TestMatchAll::test_always_matches</pre></summary><pre>
self = <tests.test_config.TestMatchAll object at 0x7eb2f9a9e230>

    def test_always_matches(self):
>       result = load_config("match-all").lookup("general")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:700: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchalltest_may_not_mix_with_non_canonical_keywords">test_config.py::TestMatchAll::test_may_not_mix_with_non_canonical_keywords</h3>
<details><summary> <pre>test_config.py::TestMatchAll::test_may_not_mix_with_non_canonical_keywords</pre></summary><pre>
self = <tests.test_config.TestMatchAll object at 0x7eb2f9a9dcf0>

    def test_may_not_mix_with_non_canonical_keywords(self):
        for config in ("match-all-and-more", "match-all-and-more-before"):
            with raises(ConfigParseError):
>               load_config(config).lookup("whatever")
E               AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:706: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchalltest_may_come_after_canonical">test_config.py::TestMatchAll::test_may_come_after_canonical</h3>
<details><summary> <pre>test_config.py::TestMatchAll::test_may_come_after_canonical</pre></summary><pre>
self = <tests.test_config.TestMatchAll object at 0x7eb2f9a9c970>
socket = <MagicMock name='socket' id='139307157816896'>

    def test_may_come_after_canonical(self, socket):
>       result = load_config("match-all-after-canonical").lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:709: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchalltest_may_not_come_before_canonical">test_config.py::TestMatchAll::test_may_not_come_before_canonical</h3>
<details><summary> <pre>test_config.py::TestMatchAll::test_may_not_come_before_canonical</pre></summary><pre>
self = <tests.test_config.TestMatchAll object at 0x7eb2f9a9caf0>
socket = <MagicMock name='socket' id='139307151158592'>

    def test_may_not_come_before_canonical(self, socket):
>       with raises(ConfigParseError):
E       Failed: DID NOT RAISE <class 'paramiko.ssh_exception.ConfigParseError'>

tests/test_config.py:713: Failed
</pre>
</details>
<h3 id="test_configpytestmatchalltest_after_canonical_not_loaded_when_non_canonicalized">test_config.py::TestMatchAll::test_after_canonical_not_loaded_when_non_canonicalized</h3>
<details><summary> <pre>test_config.py::TestMatchAll::test_after_canonical_not_loaded_when_non_canonicalized</pre></summary><pre>
self = <tests.test_config.TestMatchAll object at 0x7eb2f9a9cfd0>
socket = <MagicMock name='socket' id='139307156119584'>

    def test_after_canonical_not_loaded_when_non_canonicalized(self, socket):
>       result = load_config("match-canonical-no").lookup("a-host")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:717: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchexectest_raises_invoke_importerrors_at_runtime">test_config.py::TestMatchExec::test_raises_invoke_ImportErrors_at_runtime</h3>
<details><summary> <pre>test_config.py::TestMatchExec::test_raises_invoke_ImportErrors_at_runtime</pre></summary><pre>
self = <tests.test_config.TestMatchExec object at 0x7eb2f9a9ca90>

    @patch("paramiko.config.invoke", new=None)
    @patch("paramiko.config.invoke_import_error", new=ImportError("meh"))
    def test_raises_invoke_ImportErrors_at_runtime(self):
        # Not an ideal test, but I don't know of a non-bad way to fake out
        # module-time ImportErrors. So we mock the symptoms. Meh!
        with raises(ImportError) as info:
>           load_config("match-exec").lookup("oh-noes")
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:755: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchexectest_accepts_single_possibly_quoted_argumentunquoted-rando">test_config.py::TestMatchExec::test_accepts_single_possibly_quoted_argument[unquoted-rando]</h3>
<details><summary> <pre>test_config.py::TestMatchExec::test_accepts_single_possibly_quoted_argument[unquoted-rando]</pre></summary><pre>
self = <tests.test_config.TestMatchExec object at 0x7eb2f9a9c610>
run = <MagicMock name='run' id='139307147796656'>, cmd = 'unquoted'
user = 'rando'

    @patch("paramiko.config.invoke.run")
    @mark.parametrize(
        "cmd,user",
        [
            ("unquoted", "rando"),
            ("quoted", "benjamin"),
            ("quoted spaced", "neil"),
        ],
    )
    def test_accepts_single_possibly_quoted_argument(self, run, cmd, user):
        run.side_effect = _expect(cmd)
>       result = load_config("match-exec").lookup("whatever")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:769: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchexectest_accepts_single_possibly_quoted_argumentquoted-benjamin">test_config.py::TestMatchExec::test_accepts_single_possibly_quoted_argument[quoted-benjamin]</h3>
<details><summary> <pre>test_config.py::TestMatchExec::test_accepts_single_possibly_quoted_argument[quoted-benjamin]</pre></summary><pre>
self = <tests.test_config.TestMatchExec object at 0x7eb2f9a9c1f0>
run = <MagicMock name='run' id='139307158788784'>, cmd = 'quoted'
user = 'benjamin'

    @patch("paramiko.config.invoke.run")
    @mark.parametrize(
        "cmd,user",
        [
            ("unquoted", "rando"),
            ("quoted", "benjamin"),
            ("quoted spaced", "neil"),
        ],
    )
    def test_accepts_single_possibly_quoted_argument(self, run, cmd, user):
        run.side_effect = _expect(cmd)
>       result = load_config("match-exec").lookup("whatever")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:769: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchexectest_accepts_single_possibly_quoted_argumentquoted-spaced-neil">test_config.py::TestMatchExec::test_accepts_single_possibly_quoted_argument[quoted spaced-neil]</h3>
<details><summary> <pre>test_config.py::TestMatchExec::test_accepts_single_possibly_quoted_argument[quoted spaced-neil]</pre></summary><pre>
self = <tests.test_config.TestMatchExec object at 0x7eb2f9a9c160>
run = <MagicMock name='run' id='139307147471184'>, cmd = 'quoted spaced'
user = 'neil'

    @patch("paramiko.config.invoke.run")
    @mark.parametrize(
        "cmd,user",
        [
            ("unquoted", "rando"),
            ("quoted", "benjamin"),
            ("quoted spaced", "neil"),
        ],
    )
    def test_accepts_single_possibly_quoted_argument(self, run, cmd, user):
        run.side_effect = _expect(cmd)
>       result = load_config("match-exec").lookup("whatever")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:769: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchexectest_does_not_match_nonzero_exit_codes">test_config.py::TestMatchExec::test_does_not_match_nonzero_exit_codes</h3>
<details><summary> <pre>test_config.py::TestMatchExec::test_does_not_match_nonzero_exit_codes</pre></summary><pre>
self = <tests.test_config.TestMatchExec object at 0x7eb2f9a9c940>
run = <MagicMock name='run' id='139307152999184'>

    @patch("paramiko.config.invoke.run")
    def test_does_not_match_nonzero_exit_codes(self, run):
        # Nothing will succeed -> no User ever gets loaded
        run.return_value = Result(exited=1)
>       result = load_config("match-exec").lookup("whatever")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:776: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchexectest_tokenizes_argument">test_config.py::TestMatchExec::test_tokenizes_argument</h3>
<details><summary> <pre>test_config.py::TestMatchExec::test_tokenizes_argument</pre></summary><pre>
self = <tests.test_config.TestMatchExec object at 0x7eb2f9a9cbb0>
run = <MagicMock name='run' id='139307147156240'>
getpass = <MagicMock name='getpass' id='139307159868448'>
socket = <MagicMock name='socket' id='139307147476800'>

    @patch("paramiko.config.getpass")
    @patch("paramiko.config.invoke.run")
    def test_tokenizes_argument(self, run, getpass, socket):
        getpass.getuser.return_value = "gandalf"
        # Actual exec value is "%C %d %h %L %l %n %p %r %u"
        parts = (
            "bf5ba06778434a9384ee4217e462f64888bd0cd2",
            expanduser("~"),
            "configured",
            "local",
            "some.fake.fqdn",
            "target",
            "22",
            "intermediate",
            "gandalf",
        )
        run.side_effect = _expect(" ".join(parts))
>       result = load_config("match-exec").lookup("target")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:796: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchexectest_works_with_canonical">test_config.py::TestMatchExec::test_works_with_canonical</h3>
<details><summary> <pre>test_config.py::TestMatchExec::test_works_with_canonical</pre></summary><pre>
self = <tests.test_config.TestMatchExec object at 0x7eb2f9a9ed70>
run = <MagicMock name='run' id='139307149584816'>
socket = <MagicMock name='socket' id='139307156114160'>

    @patch("paramiko.config.invoke.run")
    def test_works_with_canonical(self, run, socket):
        # Ensure both stanzas' exec components appear to match
        run.side_effect = _expect(["uncanonicalized", "canonicalized"])
>       result = load_config("match-exec-canonical").lookup("who-cares")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:803: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchexectest_may_be_negated">test_config.py::TestMatchExec::test_may_be_negated</h3>
<details><summary> <pre>test_config.py::TestMatchExec::test_may_be_negated</pre></summary><pre>
self = <tests.test_config.TestMatchExec object at 0x7eb2f9a9f0a0>
run = <MagicMock name='run' id='139307148902992'>

    @patch("paramiko.config.invoke.run")
    def test_may_be_negated(self, run):
        run.side_effect = _expect("this succeeds")
>       result = load_config("match-exec-negation").lookup("so-confusing")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:811: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchexectest_requires_an_argument">test_config.py::TestMatchExec::test_requires_an_argument</h3>
<details><summary> <pre>test_config.py::TestMatchExec::test_requires_an_argument</pre></summary><pre>
self = <tests.test_config.TestMatchExec object at 0x7eb2f9a9d9c0>

    def test_requires_an_argument(self):
>       with raises(ConfigParseError):
E       Failed: DID NOT RAISE <class 'paramiko.ssh_exception.ConfigParseError'>

tests/test_config.py:818: Failed
</pre>
</details>
<h3 id="test_configpytestmatchexectest_works_with_tokenized_hostname">test_config.py::TestMatchExec::test_works_with_tokenized_hostname</h3>
<details><summary> <pre>test_config.py::TestMatchExec::test_works_with_tokenized_hostname</pre></summary><pre>
self = <tests.test_config.TestMatchExec object at 0x7eb2f9a9dbd0>
run = <MagicMock name='run' id='139307147232064'>

    @patch("paramiko.config.invoke.run")
    def test_works_with_tokenized_hostname(self, run):
        run.side_effect = _expect("ping target")
>       result = load_config("hostname-exec-tokenized").lookup("target")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:824: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchhosttest_matches_target_name_when_no_hostname">test_config.py::TestMatchHost::test_matches_target_name_when_no_hostname</h3>
<details><summary> <pre>test_config.py::TestMatchHost::test_matches_target_name_when_no_hostname</pre></summary><pre>
self = <tests.test_config.TestMatchHost object at 0x7eb2f9a9d720>

    def test_matches_target_name_when_no_hostname(self):
>       result = load_config("match-host").lookup("target")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:830: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchhosttest_matches_hostname_from_global_setting">test_config.py::TestMatchHost::test_matches_hostname_from_global_setting</h3>
<details><summary> <pre>test_config.py::TestMatchHost::test_matches_hostname_from_global_setting</pre></summary><pre>
self = <tests.test_config.TestMatchHost object at 0x7eb2f9a9d3c0>

    def test_matches_hostname_from_global_setting(self):
        # Also works for ones set in regular Host stanzas
>       result = load_config("match-host-name").lookup("anything")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:835: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchhosttest_matches_hostname_from_earlier_match">test_config.py::TestMatchHost::test_matches_hostname_from_earlier_match</h3>
<details><summary> <pre>test_config.py::TestMatchHost::test_matches_hostname_from_earlier_match</pre></summary><pre>
self = <tests.test_config.TestMatchHost object at 0x7eb2f9a9d390>

    def test_matches_hostname_from_earlier_match(self):
        # Corner case: one Match matches original host, sets HostName,
        # subsequent Match matches the latter.
>       result = load_config("match-host-from-match").lookup("original-host")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:841: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchhosttest_may_be_globbed">test_config.py::TestMatchHost::test_may_be_globbed</h3>
<details><summary> <pre>test_config.py::TestMatchHost::test_may_be_globbed</pre></summary><pre>
self = <tests.test_config.TestMatchHost object at 0x7eb2f9a9d540>

    def test_may_be_globbed(self):
>       result = load_config("match-host-glob-list").lookup("whatever")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:845: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchhosttest_may_be_comma_separated_list">test_config.py::TestMatchHost::test_may_be_comma_separated_list</h3>
<details><summary> <pre>test_config.py::TestMatchHost::test_may_be_comma_separated_list</pre></summary><pre>
self = <tests.test_config.TestMatchHost object at 0x7eb2f9a9f070>

    def test_may_be_comma_separated_list(self):
        for target in ("somehost", "someotherhost"):
>           result = load_config("match-host-glob-list").lookup(target)
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:850: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchhosttest_comma_separated_list_may_have_internal_negation">test_config.py::TestMatchHost::test_comma_separated_list_may_have_internal_negation</h3>
<details><summary> <pre>test_config.py::TestMatchHost::test_comma_separated_list_may_have_internal_negation</pre></summary><pre>
self = <tests.test_config.TestMatchHost object at 0x7eb2f9a9d1e0>

    def test_comma_separated_list_may_have_internal_negation(self):
        conf = load_config("match-host-glob-list")
>       assert conf.lookup("good")["user"] == "perrin"
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:855: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchhosttest_matches_canonicalized_name">test_config.py::TestMatchHost::test_matches_canonicalized_name</h3>
<details><summary> <pre>test_config.py::TestMatchHost::test_matches_canonicalized_name</pre></summary><pre>
self = <tests.test_config.TestMatchHost object at 0x7eb2f9a9d000>
socket = <MagicMock name='socket' id='139307156120496'>

    def test_matches_canonicalized_name(self, socket):
        # Without 'canonical' explicitly declared, mind.
>       result = load_config("match-host-canonicalized").lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:860: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchhosttest_works_with_canonical_keyword">test_config.py::TestMatchHost::test_works_with_canonical_keyword</h3>
<details><summary> <pre>test_config.py::TestMatchHost::test_works_with_canonical_keyword</pre></summary><pre>
self = <tests.test_config.TestMatchHost object at 0x7eb2f9a9c340>
socket = <MagicMock name='socket' id='139307147237872'>

    def test_works_with_canonical_keyword(self, socket):
        # NOTE: distinct from 'happens to be canonicalized' above
>       result = load_config("match-host-canonicalized").lookup("docs")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:865: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchhosttest_may_be_negated">test_config.py::TestMatchHost::test_may_be_negated</h3>
<details><summary> <pre>test_config.py::TestMatchHost::test_may_be_negated</pre></summary><pre>
self = <tests.test_config.TestMatchHost object at 0x7eb2f9a9c670>

    def test_may_be_negated(self):
        conf = load_config("match-host-negated")
>       assert conf.lookup("docs")["user"] == "jeff"
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:870: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchhosttest_requires_an_argument">test_config.py::TestMatchHost::test_requires_an_argument</h3>
<details><summary> <pre>test_config.py::TestMatchHost::test_requires_an_argument</pre></summary><pre>
self = <tests.test_config.TestMatchHost object at 0x7eb2f9a9e710>

    def test_requires_an_argument(self):
>       with raises(ConfigParseError):
E       Failed: DID NOT RAISE <class 'paramiko.ssh_exception.ConfigParseError'>

tests/test_config.py:874: Failed
</pre>
</details>
<h3 id="test_configpytestmatchoriginalhosttest_matches_target_host_not_hostname">test_config.py::TestMatchOriginalHost::test_matches_target_host_not_hostname</h3>
<details><summary> <pre>test_config.py::TestMatchOriginalHost::test_matches_target_host_not_hostname</pre></summary><pre>
self = <tests.test_config.TestMatchOriginalHost object at 0x7eb2f9a9d8a0>

    def test_matches_target_host_not_hostname(self):
>       result = load_config("match-orighost").lookup("target")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:880: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchoriginalhosttest_matches_target_host_not_canonicalized_name">test_config.py::TestMatchOriginalHost::test_matches_target_host_not_canonicalized_name</h3>
<details><summary> <pre>test_config.py::TestMatchOriginalHost::test_matches_target_host_not_canonicalized_name</pre></summary><pre>
self = <tests.test_config.TestMatchOriginalHost object at 0x7eb2f9a9ed10>
socket = <MagicMock name='socket' id='139307158783360'>

    def test_matches_target_host_not_canonicalized_name(self, socket):
>       result = load_config("match-orighost-canonical").lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:885: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchoriginalhosttest_may_be_globbed">test_config.py::TestMatchOriginalHost::test_may_be_globbed</h3>
<details><summary> <pre>test_config.py::TestMatchOriginalHost::test_may_be_globbed</pre></summary><pre>
self = <tests.test_config.TestMatchOriginalHost object at 0x7eb2f9a9eb30>

    def test_may_be_globbed(self):
>       result = load_config("match-orighost").lookup("whatever")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:890: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchoriginalhosttest_may_be_comma_separated_list">test_config.py::TestMatchOriginalHost::test_may_be_comma_separated_list</h3>
<details><summary> <pre>test_config.py::TestMatchOriginalHost::test_may_be_comma_separated_list</pre></summary><pre>
self = <tests.test_config.TestMatchOriginalHost object at 0x7eb2f9a9ff10>

    def test_may_be_comma_separated_list(self):
        for target in ("comma", "separated"):
>           result = load_config("match-orighost").lookup(target)
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:895: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchoriginalhosttest_comma_separated_list_may_have_internal_negation">test_config.py::TestMatchOriginalHost::test_comma_separated_list_may_have_internal_negation</h3>
<details><summary> <pre>test_config.py::TestMatchOriginalHost::test_comma_separated_list_may_have_internal_negation</pre></summary><pre>
self = <tests.test_config.TestMatchOriginalHost object at 0x7eb2f9a9e9e0>

    def test_comma_separated_list_may_have_internal_negation(self):
>       result = load_config("match-orighost").lookup("nope")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:899: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchoriginalhosttest_may_be_negated">test_config.py::TestMatchOriginalHost::test_may_be_negated</h3>
<details><summary> <pre>test_config.py::TestMatchOriginalHost::test_may_be_negated</pre></summary><pre>
self = <tests.test_config.TestMatchOriginalHost object at 0x7eb2f9a9f100>

    def test_may_be_negated(self):
>       result = load_config("match-orighost").lookup("docs")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:903: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchoriginalhosttest_requires_an_argument">test_config.py::TestMatchOriginalHost::test_requires_an_argument</h3>
<details><summary> <pre>test_config.py::TestMatchOriginalHost::test_requires_an_argument</pre></summary><pre>
self = <tests.test_config.TestMatchOriginalHost object at 0x7eb2f9a24e50>

    def test_requires_an_argument(self):
>       with raises(ConfigParseError):
E       Failed: DID NOT RAISE <class 'paramiko.ssh_exception.ConfigParseError'>

tests/test_config.py:907: Failed
</pre>
</details>
<h3 id="test_configpytestmatchusertest_matches_configured_username">test_config.py::TestMatchUser::test_matches_configured_username</h3>
<details><summary> <pre>test_config.py::TestMatchUser::test_matches_configured_username</pre></summary><pre>
self = <tests.test_config.TestMatchUser object at 0x7eb2f9a244c0>

    def test_matches_configured_username(self):
>       result = load_config("match-user-explicit").lookup("anything")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:913: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchusertest_matches_local_username_by_default">test_config.py::TestMatchUser::test_matches_local_username_by_default</h3>
<details><summary> <pre>test_config.py::TestMatchUser::test_matches_local_username_by_default</pre></summary><pre>
self = <tests.test_config.TestMatchUser object at 0x7eb2f9a24370>
getuser = <MagicMock name='getuser' id='139307158788544'>

    @patch("paramiko.config.getpass.getuser")
    def test_matches_local_username_by_default(self, getuser):
        getuser.return_value = "gandalf"
>       result = load_config("match-user").lookup("anything")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:919: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchusertest_may_be_globbed">test_config.py::TestMatchUser::test_may_be_globbed</h3>
<details><summary> <pre>test_config.py::TestMatchUser::test_may_be_globbed</pre></summary><pre>
self = <tests.test_config.TestMatchUser object at 0x7eb2f9a243a0>
getuser = <MagicMock name='getuser' id='139307147152880'>

    @patch("paramiko.config.getpass.getuser")
    def test_may_be_globbed(self, getuser):
        for user in ("bilbo", "bombadil"):
            getuser.return_value = user
>           result = load_config("match-user").lookup("anything")
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:926: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchusertest_may_be_comma_separated_list">test_config.py::TestMatchUser::test_may_be_comma_separated_list</h3>
<details><summary> <pre>test_config.py::TestMatchUser::test_may_be_comma_separated_list</pre></summary><pre>
self = <tests.test_config.TestMatchUser object at 0x7eb2f9a24a90>
getuser = <MagicMock name='getuser' id='139307159879296'>

    @patch("paramiko.config.getpass.getuser")
    def test_may_be_comma_separated_list(self, getuser):
        for user in ("aragorn", "frodo"):
            getuser.return_value = user
>           result = load_config("match-user").lookup("anything")
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:933: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchusertest_comma_separated_list_may_have_internal_negation">test_config.py::TestMatchUser::test_comma_separated_list_may_have_internal_negation</h3>
<details><summary> <pre>test_config.py::TestMatchUser::test_comma_separated_list_may_have_internal_negation</pre></summary><pre>
self = <tests.test_config.TestMatchUser object at 0x7eb2f9a25150>
getuser = <MagicMock name='getuser' id='139307147153744'>

    @patch("paramiko.config.getpass.getuser")
    def test_comma_separated_list_may_have_internal_negation(self, getuser):
        getuser.return_value = "legolas"
>       result = load_config("match-user").lookup("anything")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:939: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchusertest_may_be_negated">test_config.py::TestMatchUser::test_may_be_negated</h3>
<details><summary> <pre>test_config.py::TestMatchUser::test_may_be_negated</pre></summary><pre>
self = <tests.test_config.TestMatchUser object at 0x7eb2f9a9fac0>
getuser = <MagicMock name='getuser' id='139307148921968'>

    @patch("paramiko.config.getpass.getuser")
    def test_may_be_negated(self, getuser):
        getuser.return_value = "saruman"
>       result = load_config("match-user").lookup("anything")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:948: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchusertest_requires_an_argument">test_config.py::TestMatchUser::test_requires_an_argument</h3>
<details><summary> <pre>test_config.py::TestMatchUser::test_requires_an_argument</pre></summary><pre>
self = <tests.test_config.TestMatchUser object at 0x7eb2f9a9ed40>

    def test_requires_an_argument(self):
>       with raises(ConfigParseError):
E       Failed: DID NOT RAISE <class 'paramiko.ssh_exception.ConfigParseError'>

tests/test_config.py:952: Failed
</pre>
</details>
<h3 id="test_configpytestmatchlocalusertest_matches_local_username">test_config.py::TestMatchLocalUser::test_matches_local_username</h3>
<details><summary> <pre>test_config.py::TestMatchLocalUser::test_matches_local_username</pre></summary><pre>
self = <tests.test_config.TestMatchLocalUser object at 0x7eb2f9a9cd60>
getuser = <MagicMock name='getuser' id='139307148931424'>

    @patch("paramiko.config.getpass.getuser")
    def test_matches_local_username(self, getuser):
        getuser.return_value = "gandalf"
>       result = load_config("match-localuser").lookup("anything")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:962: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchlocalusertest_may_be_globbed">test_config.py::TestMatchLocalUser::test_may_be_globbed</h3>
<details><summary> <pre>test_config.py::TestMatchLocalUser::test_may_be_globbed</pre></summary><pre>
self = <tests.test_config.TestMatchLocalUser object at 0x7eb2f9a9ce20>
getuser = <MagicMock name='getuser' id='139307149585296'>

    @patch("paramiko.config.getpass.getuser")
    def test_may_be_globbed(self, getuser):
        for user in ("bilbo", "bombadil"):
            getuser.return_value = user
>           result = load_config("match-localuser").lookup("anything")
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:969: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchlocalusertest_may_be_comma_separated_list">test_config.py::TestMatchLocalUser::test_may_be_comma_separated_list</h3>
<details><summary> <pre>test_config.py::TestMatchLocalUser::test_may_be_comma_separated_list</pre></summary><pre>
self = <tests.test_config.TestMatchLocalUser object at 0x7eb2f9a9ee90>
getuser = <MagicMock name='getuser' id='139307158689280'>

    @patch("paramiko.config.getpass.getuser")
    def test_may_be_comma_separated_list(self, getuser):
        for user in ("aragorn", "frodo"):
            getuser.return_value = user
>           result = load_config("match-localuser").lookup("anything")
E           AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:976: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchlocalusertest_comma_separated_list_may_have_internal_negation">test_config.py::TestMatchLocalUser::test_comma_separated_list_may_have_internal_negation</h3>
<details><summary> <pre>test_config.py::TestMatchLocalUser::test_comma_separated_list_may_have_internal_negation</pre></summary><pre>
self = <tests.test_config.TestMatchLocalUser object at 0x7eb2f9a24bb0>
getuser = <MagicMock name='getuser' id='139307153002208'>

    @patch("paramiko.config.getpass.getuser")
    def test_comma_separated_list_may_have_internal_negation(self, getuser):
        getuser.return_value = "legolas"
>       result = load_config("match-localuser").lookup("anything")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:982: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchlocalusertest_may_be_negated">test_config.py::TestMatchLocalUser::test_may_be_negated</h3>
<details><summary> <pre>test_config.py::TestMatchLocalUser::test_may_be_negated</pre></summary><pre>
self = <tests.test_config.TestMatchLocalUser object at 0x7eb2f9a24a00>
getuser = <MagicMock name='getuser' id='139307148917824'>

    @patch("paramiko.config.getpass.getuser")
    def test_may_be_negated(self, getuser):
        getuser.return_value = "saruman"
>       result = load_config("match-localuser").lookup("anything")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:991: AttributeError
</pre>
</details>
<h3 id="test_configpytestmatchlocalusertest_requires_an_argument">test_config.py::TestMatchLocalUser::test_requires_an_argument</h3>
<details><summary> <pre>test_config.py::TestMatchLocalUser::test_requires_an_argument</pre></summary><pre>
self = <tests.test_config.TestMatchLocalUser object at 0x7eb2f9a245b0>

    def test_requires_an_argument(self):
>       with raises(ConfigParseError):
E       Failed: DID NOT RAISE <class 'paramiko.ssh_exception.ConfigParseError'>

tests/test_config.py:995: Failed
</pre>
</details>
<h3 id="test_configpytestcomplexmatchingtest_originalhost_host">test_config.py::TestComplexMatching::test_originalhost_host</h3>
<details><summary> <pre>test_config.py::TestComplexMatching::test_originalhost_host</pre></summary><pre>
self = <tests.test_config.TestComplexMatching object at 0x7eb2f9a24940>

    def test_originalhost_host(self):
>       result = load_config("match-complex").lookup("target")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:1004: AttributeError
</pre>
</details>
<h3 id="test_configpytestcomplexmatchingtest_originalhost_localuser">test_config.py::TestComplexMatching::test_originalhost_localuser</h3>
<details><summary> <pre>test_config.py::TestComplexMatching::test_originalhost_localuser</pre></summary><pre>
self = <tests.test_config.TestComplexMatching object at 0x7eb2f9a24670>
getuser = <MagicMock name='getuser' id='139307147247184'>

    @patch("paramiko.config.getpass.getuser")
    def test_originalhost_localuser(self, getuser):
        getuser.return_value = "rando"
>       result = load_config("match-complex").lookup("remote")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:1011: AttributeError
</pre>
</details>
<h3 id="test_configpytestcomplexmatchingtest_everything_but_all">test_config.py::TestComplexMatching::test_everything_but_all</h3>
<details><summary> <pre>test_config.py::TestComplexMatching::test_everything_but_all</pre></summary><pre>
self = <tests.test_config.TestComplexMatching object at 0x7eb2f9a24910>
getuser = <MagicMock name='getuser' id='139307153006144'>

    @patch("paramiko.config.getpass.getuser")
    def test_everything_but_all(self, getuser):
        getuser.return_value = "rando"
>       result = load_config("match-complex").lookup("www")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:1017: AttributeError
</pre>
</details>
<h3 id="test_configpytestcomplexmatchingtest_everything_but_all_with_some_negated">test_config.py::TestComplexMatching::test_everything_but_all_with_some_negated</h3>
<details><summary> <pre>test_config.py::TestComplexMatching::test_everything_but_all_with_some_negated</pre></summary><pre>
self = <tests.test_config.TestComplexMatching object at 0x7eb2f9a24520>
getuser = <MagicMock name='getuser' id='139307147243344'>

    @patch("paramiko.config.getpass.getuser")
    def test_everything_but_all_with_some_negated(self, getuser):
        getuser.return_value = "rando"
>       result = load_config("match-complex").lookup("docs")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:1023: AttributeError
</pre>
</details>
<h3 id="test_configpytestcomplexmatchingtest_negated_canonical">test_config.py::TestComplexMatching::test_negated_canonical</h3>
<details><summary> <pre>test_config.py::TestComplexMatching::test_negated_canonical</pre></summary><pre>
self = <tests.test_config.TestComplexMatching object at 0x7eb2f9a26f20>
socket = <MagicMock name='socket' id='139307158694032'>

    def test_negated_canonical(self, socket):
        # !canonical in a config that is not canonicalized - does match
>       result = load_config("match-canonical-no").lookup("specific")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:1028: AttributeError
</pre>
</details>
<h3 id="test_configpytestfinalmatchingtest_finally">test_config.py::TestFinalMatching::test_finally</h3>
<details><summary> <pre>test_config.py::TestFinalMatching::test_finally</pre></summary><pre>
self = <tests.test_config.TestFinalMatching object at 0x7eb2f9a26bf0>

    def test_finally(self):
>       result = load_config("match-final").lookup("finally")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:1037: AttributeError
</pre>
</details>
<h3 id="test_configpytestfinalmatchingtest_default_port">test_config.py::TestFinalMatching::test_default_port</h3>
<details><summary> <pre>test_config.py::TestFinalMatching::test_default_port</pre></summary><pre>
self = <tests.test_config.TestFinalMatching object at 0x7eb2f9a279a0>

    def test_default_port(self):
>       result = load_config("match-final").lookup("default-port")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:1042: AttributeError
</pre>
</details>
<h3 id="test_configpytestfinalmatchingtest_negated">test_config.py::TestFinalMatching::test_negated</h3>
<details><summary> <pre>test_config.py::TestFinalMatching::test_negated</pre></summary><pre>
self = <tests.test_config.TestFinalMatching object at 0x7eb2f9a25450>

    def test_negated(self):
>       result = load_config("match-final").lookup("jump")
E       AttributeError: 'NoneType' object has no attribute 'lookup'

tests/test_config.py:1047: AttributeError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_buffering_flushes">test_file.py::BufferedFileTest::test_buffering_flushes</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_buffering_flushes</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_buffering_flushes>

    def test_buffering_flushes(self):
        """
        verify that flushing happens automatically on buffer crossing.
        """
        f = LoopbackFile("r+", 16)
        f.write(b"Too small.")
>       self.assertEqual(f.read(4), b"")
E       AssertionError: None != b''

tests/test_file.py:143: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_flush">test_file.py::BufferedFileTest::test_flush</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_flush</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_flush>

    def test_flush(self):
        """
        verify that flush will force a write.
        """
        f = LoopbackFile("r+", 512)
        f.write("Not\nquite\n512 bytes.\n")
>       self.assertEqual(f.read(1), b"")
E       AssertionError: None != b''

tests/test_file.py:128: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_lf">test_file.py::BufferedFileTest::test_lf</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_lf</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_lf>

    def test_lf(self):
        """
        try to trick the linefeed detector.
        """
        f = LoopbackFile("r+U")
        f.write(b"First line.\r")
>       self.assertEqual(f.readline(), "First line.\n")
E       AssertionError: None != 'First line.\n'

tests/test_file.py:104: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_read_all">test_file.py::BufferedFileTest::test_read_all</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_read_all</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_read_all>

    def test_read_all(self):
        """
        verify that read(-1) returns everything left in the file.
        """
        f = LoopbackFile("r+", 16)
        f.write(b"The first thing you need to do is open your eyes. ")
        f.write(b"Then, you need to close them again.\n")
        s = f.read(-1)
>       self.assertEqual(
            s,
            b"The first thing you need to do is open your eyes. Then, you "
            + b"need to close them again.\n",
        )
E       AssertionError: None != b'The first thing you need to do is open [44 chars]n.\n'

tests/test_file.py:158: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_readable">test_file.py::BufferedFileTest::test_readable</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_readable</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_readable>

    def test_readable(self):
        f = LoopbackFile("r")
>       self.assertTrue(f.readable())
E       AssertionError: None is not true

tests/test_file.py:167: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_readinto">test_file.py::BufferedFileTest::test_readinto</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_readinto</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_readinto>

    def test_readinto(self):
        data = bytearray(5)
        f = LoopbackFile("r+")
        f._write(b"hello")
        f.readinto(data)
>       self.assertEqual(data, b"hello")
E       AssertionError: bytearray(b'\x00\x00\x00\x00\x00') != b'hello'

tests/test_file.py:184: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_readline">test_file.py::BufferedFileTest::test_readline</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_readline</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_readline>

    def test_readline(self):
        f = LoopbackFile("r+U")
        f.write(
            b"First line.\nSecond line.\r\nThird line.\n"
            + b"Fourth line.\nFinal line non-terminated."
        )

>       self.assertEqual(f.readline(), "First line.\n")
E       AssertionError: None != 'First line.\n'

tests/test_file.py:78: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_writable">test_file.py::BufferedFileTest::test_writable</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_writable</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_writable>

    def test_writable(self):
        f = LoopbackFile("w")
>       self.assertTrue(f.writable())
E       AssertionError: None is not true

tests/test_file.py:174: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_write">test_file.py::BufferedFileTest::test_write</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_write</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_write>

    def test_write(self):
        """
        verify that write buffering is on.
        """
        f = LoopbackFile("r+", 1)
        f.write(b"Complete line.\nIncomplete line.")
>       self.assertEqual(f.readline(), "Complete line.\n")
E       AssertionError: None != 'Complete line.\n'

tests/test_file.py:116: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_write_bad_type">test_file.py::BufferedFileTest::test_write_bad_type</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_write_bad_type</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_write_bad_type>

    def test_write_bad_type(self):
        with LoopbackFile("wb") as f:
>           self.assertRaises(TypeError, f.write, object())
E           AssertionError: TypeError not raised by write

tests/test_file.py:189: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_write_bytearray">test_file.py::BufferedFileTest::test_write_bytearray</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_write_bytearray</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_write_bytearray>

    @needs_builtin("memoryview")
    def test_write_bytearray(self):
        with LoopbackFile("rb+") as f:
            f.write(bytearray(12))
>           self.assertEqual(f.read(), 12 * b"\0")
E           AssertionError: None != b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'

tests/test_file.py:201: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_write_memoryview">test_file.py::BufferedFileTest::test_write_memoryview</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_write_memoryview</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_write_memoryview>

    @needs_builtin("memoryview")
    def test_write_memoryview(self):
        data = 3 * b"pretend giant block of data\n"
        offsets = range(0, len(data), 8)
        with LoopbackFile("rb+") as f:
            view = memoryview(data)
            for offset in offsets:
                f.write(view[offset : offset + 8])
>           self.assertEqual(f.read(), data)
E           AssertionError: None != b'pretend giant block of data\npretend gi[44 chars]ta\n'

tests/test_file.py:220: AssertionError
</pre>
</details>
<h3 id="test_filepybufferedfiletesttest_write_unicode_as_binary">test_file.py::BufferedFileTest::test_write_unicode_as_binary</h3>
<details><summary> <pre>test_file.py::BufferedFileTest::test_write_unicode_as_binary</pre></summary><pre>
self = <tests.test_file.BufferedFileTest testMethod=test_write_unicode_as_binary>

    def test_write_unicode_as_binary(self):
        text = "\xa7 why is writing text to a binary file allowed?\n"
        with LoopbackFile("rb+") as f:
            f.write(text)
>           self.assertEqual(f.read(), text.encode("utf-8"))
E           AssertionError: None != b'\xc2\xa7 why is writing text to a binary file allowed?\n'

tests/test_file.py:195: AssertionError
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystesttest_add">test_hostkeys.py::HostKeysTest::test_add</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTest::test_add</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTest testMethod=test_add>

    def test_add(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
        hh = "|1|BMsIC6cUIP2zBuXR3t2LRcJYjzM=|hpkJMysjTk/+zzUUzxQEa2ieq6c="
>       key = paramiko.RSAKey(data=decodebytes(keyblob))

tests/test_hostkeys.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PKey(alg=None, bits=None, fp=None)
msg = paramiko.Message(b'\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x01#\x00\x00\x00\x81\x00\xf1\xb3\xf5d\x0e\xc3\t\x90\xc1\xf4\x9d...ad\xcf\xf6\xc0\x94\n\x85\x80\xaa\x1c\xf8J%38\x83b\xa5\x88\x01;V\xd2\xb6\x13&\xfc\xc6\x034\xe62?4\xfd\nl\x14\x7f\x8fsc')
data = b'\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x01#\x00\x00\x00\x81\x00\xf1\xb3\xf5d\x0e\xc3\t\x90\xc1\xf4\x9d,\xe7Iw\xd4\xc0FC...xad\xcf\xf6\xc0\x94\n\x85\x80\xaa\x1c\xf8J%38\x83b\xa5\x88\x01;V\xd2\xb6\x13&\xfc\xc6\x034\xe62?4\xfd\nl\x14\x7f\x8fsc'
filename = None, password = None, key = None, file_obj = None

    def __init__(self, msg=None, data=None, filename=None, password=None, key=None, file_obj=None):
        self.key = None
        self.public_blob = None
        if file_obj is not None:
            self._from_private_key(file_obj, password)
            return
        if filename is not None:
            self._from_private_key_file(filename, password)
            return
        if msg is None and data is not None:
            msg = Message(data)
        if key is not None:
            self.key = key
        else:
            self._check_type_and_load_cert(msg=msg, key_type=self.name, cert_type='ssh-rsa-cert-v01@openssh.com')
>           self.key = rsa.RSAPublicNumbers(e=msg.get_mpint(), n=msg.get_mpint()).public_key(default_backend())
E           TypeError: argument 'e': 'NoneType' object cannot be converted to 'PyLong'

paramiko/rsakey.py:35: TypeError
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystesttest_delitem">test_hostkeys.py::HostKeysTest::test_delitem</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTest::test_delitem</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTest testMethod=test_delitem>

    def test_delitem(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
        target = "happy.example.com"
>       hostdict[target]  # will KeyError if not present

tests/test_hostkeys.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.hostkeys.HostKeys object at 0x7eb2f9b57790>
key = 'happy.example.com'

    def __getitem__(self, key):
        ret = self.lookup(key)
        if ret is None:
>           raise KeyError(key)
E           KeyError: 'happy.example.com'

paramiko/hostkeys.py:126: KeyError
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystesttest_dict">test_hostkeys.py::HostKeysTest::test_dict</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTest::test_dict</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTest testMethod=test_dict>

    def test_dict(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
>       self.assertTrue("secure.example.com" in hostdict)
E       AssertionError: False is not true

tests/test_hostkeys.py:107: AssertionError
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystesttest_dict_set">test_hostkeys.py::HostKeysTest::test_dict_set</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTest::test_dict_set</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTest testMethod=test_dict_set>

    def test_dict_set(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
>       key = paramiko.RSAKey(data=decodebytes(keyblob))

tests/test_hostkeys.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PKey(alg=None, bits=None, fp=None)
msg = paramiko.Message(b'\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x01#\x00\x00\x00\x81\x00\xf1\xb3\xf5d\x0e\xc3\t\x90\xc1\xf4\x9d...ad\xcf\xf6\xc0\x94\n\x85\x80\xaa\x1c\xf8J%38\x83b\xa5\x88\x01;V\xd2\xb6\x13&\xfc\xc6\x034\xe62?4\xfd\nl\x14\x7f\x8fsc')
data = b'\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x01#\x00\x00\x00\x81\x00\xf1\xb3\xf5d\x0e\xc3\t\x90\xc1\xf4\x9d,\xe7Iw\xd4\xc0FC...xad\xcf\xf6\xc0\x94\n\x85\x80\xaa\x1c\xf8J%38\x83b\xa5\x88\x01;V\xd2\xb6\x13&\xfc\xc6\x034\xe62?4\xfd\nl\x14\x7f\x8fsc'
filename = None, password = None, key = None, file_obj = None

    def __init__(self, msg=None, data=None, filename=None, password=None, key=None, file_obj=None):
        self.key = None
        self.public_blob = None
        if file_obj is not None:
            self._from_private_key(file_obj, password)
            return
        if filename is not None:
            self._from_private_key_file(filename, password)
            return
        if msg is None and data is not None:
            msg = Message(data)
        if key is not None:
            self.key = key
        else:
            self._check_type_and_load_cert(msg=msg, key_type=self.name, cert_type='ssh-rsa-cert-v01@openssh.com')
>           self.key = rsa.RSAPublicNumbers(e=msg.get_mpint(), n=msg.get_mpint()).public_key(default_backend())
E           TypeError: argument 'e': 'NoneType' object cannot be converted to 'PyLong'

paramiko/rsakey.py:35: TypeError
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystesttest_entry_delitem">test_hostkeys.py::HostKeysTest::test_entry_delitem</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTest::test_entry_delitem</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTest testMethod=test_entry_delitem>

    def test_entry_delitem(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
        target = "happy.example.com"
>       entry = hostdict[target]

tests/test_hostkeys.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.hostkeys.HostKeys object at 0x7eb2f92a7e80>
key = 'happy.example.com'

    def __getitem__(self, key):
        ret = self.lookup(key)
        if ret is None:
>           raise KeyError(key)
E           KeyError: 'happy.example.com'

paramiko/hostkeys.py:126: KeyError
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystesttest_load">test_hostkeys.py::HostKeysTest::test_load</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTest::test_load</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTest testMethod=test_load>

    def test_load(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
>       assert len(hostdict) == 4

tests/test_hostkeys.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/hostkeys.py:121: in __len__
    return len(self.keys())
/usr/lib/python3.10/_collections_abc.py:866: in __len__
    return len(self._mapping)
paramiko/hostkeys.py:121: in __len__
    return len(self.keys())
E   RecursionError: maximum recursion depth exceeded
!!! Recursion detected (same locals & position)
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystabstesttest_add">test_hostkeys.py::HostKeysTabsTest::test_add</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTabsTest::test_add</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTabsTest testMethod=test_add>

    def test_add(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
        hh = "|1|BMsIC6cUIP2zBuXR3t2LRcJYjzM=|hpkJMysjTk/+zzUUzxQEa2ieq6c="
>       key = paramiko.RSAKey(data=decodebytes(keyblob))

tests/test_hostkeys.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PKey(alg=None, bits=None, fp=None)
msg = paramiko.Message(b'\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x01#\x00\x00\x00\x81\x00\xf1\xb3\xf5d\x0e\xc3\t\x90\xc1\xf4\x9d...ad\xcf\xf6\xc0\x94\n\x85\x80\xaa\x1c\xf8J%38\x83b\xa5\x88\x01;V\xd2\xb6\x13&\xfc\xc6\x034\xe62?4\xfd\nl\x14\x7f\x8fsc')
data = b'\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x01#\x00\x00\x00\x81\x00\xf1\xb3\xf5d\x0e\xc3\t\x90\xc1\xf4\x9d,\xe7Iw\xd4\xc0FC...xad\xcf\xf6\xc0\x94\n\x85\x80\xaa\x1c\xf8J%38\x83b\xa5\x88\x01;V\xd2\xb6\x13&\xfc\xc6\x034\xe62?4\xfd\nl\x14\x7f\x8fsc'
filename = None, password = None, key = None, file_obj = None

    def __init__(self, msg=None, data=None, filename=None, password=None, key=None, file_obj=None):
        self.key = None
        self.public_blob = None
        if file_obj is not None:
            self._from_private_key(file_obj, password)
            return
        if filename is not None:
            self._from_private_key_file(filename, password)
            return
        if msg is None and data is not None:
            msg = Message(data)
        if key is not None:
            self.key = key
        else:
            self._check_type_and_load_cert(msg=msg, key_type=self.name, cert_type='ssh-rsa-cert-v01@openssh.com')
>           self.key = rsa.RSAPublicNumbers(e=msg.get_mpint(), n=msg.get_mpint()).public_key(default_backend())
E           TypeError: argument 'e': 'NoneType' object cannot be converted to 'PyLong'

paramiko/rsakey.py:35: TypeError
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystabstesttest_delitem">test_hostkeys.py::HostKeysTabsTest::test_delitem</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTabsTest::test_delitem</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTabsTest testMethod=test_delitem>

    def test_delitem(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
        target = "happy.example.com"
>       hostdict[target]  # will KeyError if not present

tests/test_hostkeys.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.hostkeys.HostKeys object at 0x7eb2f9cb0c70>
key = 'happy.example.com'

    def __getitem__(self, key):
        ret = self.lookup(key)
        if ret is None:
>           raise KeyError(key)
E           KeyError: 'happy.example.com'

paramiko/hostkeys.py:126: KeyError
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystabstesttest_dict">test_hostkeys.py::HostKeysTabsTest::test_dict</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTabsTest::test_dict</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTabsTest testMethod=test_dict>

    def test_dict(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
>       self.assertTrue("secure.example.com" in hostdict)
E       AssertionError: False is not true

tests/test_hostkeys.py:107: AssertionError
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystabstesttest_dict_set">test_hostkeys.py::HostKeysTabsTest::test_dict_set</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTabsTest::test_dict_set</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTabsTest testMethod=test_dict_set>

    def test_dict_set(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
>       key = paramiko.RSAKey(data=decodebytes(keyblob))

tests/test_hostkeys.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PKey(alg=None, bits=None, fp=None)
msg = paramiko.Message(b'\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x01#\x00\x00\x00\x81\x00\xf1\xb3\xf5d\x0e\xc3\t\x90\xc1\xf4\x9d...ad\xcf\xf6\xc0\x94\n\x85\x80\xaa\x1c\xf8J%38\x83b\xa5\x88\x01;V\xd2\xb6\x13&\xfc\xc6\x034\xe62?4\xfd\nl\x14\x7f\x8fsc')
data = b'\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x01#\x00\x00\x00\x81\x00\xf1\xb3\xf5d\x0e\xc3\t\x90\xc1\xf4\x9d,\xe7Iw\xd4\xc0FC...xad\xcf\xf6\xc0\x94\n\x85\x80\xaa\x1c\xf8J%38\x83b\xa5\x88\x01;V\xd2\xb6\x13&\xfc\xc6\x034\xe62?4\xfd\nl\x14\x7f\x8fsc'
filename = None, password = None, key = None, file_obj = None

    def __init__(self, msg=None, data=None, filename=None, password=None, key=None, file_obj=None):
        self.key = None
        self.public_blob = None
        if file_obj is not None:
            self._from_private_key(file_obj, password)
            return
        if filename is not None:
            self._from_private_key_file(filename, password)
            return
        if msg is None and data is not None:
            msg = Message(data)
        if key is not None:
            self.key = key
        else:
            self._check_type_and_load_cert(msg=msg, key_type=self.name, cert_type='ssh-rsa-cert-v01@openssh.com')
>           self.key = rsa.RSAPublicNumbers(e=msg.get_mpint(), n=msg.get_mpint()).public_key(default_backend())
E           TypeError: argument 'e': 'NoneType' object cannot be converted to 'PyLong'

paramiko/rsakey.py:35: TypeError
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystabstesttest_entry_delitem">test_hostkeys.py::HostKeysTabsTest::test_entry_delitem</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTabsTest::test_entry_delitem</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTabsTest testMethod=test_entry_delitem>

    def test_entry_delitem(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
        target = "happy.example.com"
>       entry = hostdict[target]

tests/test_hostkeys.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.hostkeys.HostKeys object at 0x7eb2f942f190>
key = 'happy.example.com'

    def __getitem__(self, key):
        ret = self.lookup(key)
        if ret is None:
>           raise KeyError(key)
E           KeyError: 'happy.example.com'

paramiko/hostkeys.py:126: KeyError
</pre>
</details>
<h3 id="test_hostkeyspyhostkeystabstesttest_load">test_hostkeys.py::HostKeysTabsTest::test_load</h3>
<details><summary> <pre>test_hostkeys.py::HostKeysTabsTest::test_load</pre></summary><pre>
self = <tests.test_hostkeys.HostKeysTabsTest testMethod=test_load>

    def test_load(self):
        hostdict = paramiko.HostKeys("hostfile.temp")
>       assert len(hostdict) == 4

tests/test_hostkeys.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/hostkeys.py:121: in __len__
    return len(self.keys())
/usr/lib/python3.10/_collections_abc.py:866: in __len__
    return len(self._mapping)
paramiko/hostkeys.py:121: in __len__
    return len(self.keys())
E   RecursionError: maximum recursion depth exceeded
!!! Recursion detected (same locals & position)
</pre>
</details>
<h3 id="test_kexpykextesttest_gex_client">test_kex.py::KexTest::test_gex_client</h3>
<details><summary> <pre>test_kex.py::KexTest::test_gex_client</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_gex_client>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_gex_old_client">test_kex.py::KexTest::test_gex_old_client</h3>
<details><summary> <pre>test_kex.py::KexTest::test_gex_old_client</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_gex_old_client>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_gex_server">test_kex.py::KexTest::test_gex_server</h3>
<details><summary> <pre>test_kex.py::KexTest::test_gex_server</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_gex_server>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_gex_server_with_old_client">test_kex.py::KexTest::test_gex_server_with_old_client</h3>
<details><summary> <pre>test_kex.py::KexTest::test_gex_server_with_old_client</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_gex_server_with_old_client>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_gex_sha256_client">test_kex.py::KexTest::test_gex_sha256_client</h3>
<details><summary> <pre>test_kex.py::KexTest::test_gex_sha256_client</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_gex_sha256_client>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_gex_sha256_old_client">test_kex.py::KexTest::test_gex_sha256_old_client</h3>
<details><summary> <pre>test_kex.py::KexTest::test_gex_sha256_old_client</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_gex_sha256_old_client>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_gex_sha256_server">test_kex.py::KexTest::test_gex_sha256_server</h3>
<details><summary> <pre>test_kex.py::KexTest::test_gex_sha256_server</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_gex_sha256_server>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_gex_sha256_server_with_old_client">test_kex.py::KexTest::test_gex_sha256_server_with_old_client</h3>
<details><summary> <pre>test_kex.py::KexTest::test_gex_sha256_server_with_old_client</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_gex_sha256_server_with_old_client>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_group1_client">test_kex.py::KexTest::test_group1_client</h3>
<details><summary> <pre>test_kex.py::KexTest::test_group1_client</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_group1_client>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_group1_server">test_kex.py::KexTest::test_group1_server</h3>
<details><summary> <pre>test_kex.py::KexTest::test_group1_server</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_group1_server>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_kex_c25519_client">test_kex.py::KexTest::test_kex_c25519_client</h3>
<details><summary> <pre>test_kex.py::KexTest::test_kex_c25519_client</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_kex_c25519_client>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_kex_c25519_server">test_kex.py::KexTest::test_kex_c25519_server</h3>
<details><summary> <pre>test_kex.py::KexTest::test_kex_c25519_server</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_kex_c25519_server>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_kex_group14_sha256_client">test_kex.py::KexTest::test_kex_group14_sha256_client</h3>
<details><summary> <pre>test_kex.py::KexTest::test_kex_group14_sha256_client</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_kex_group14_sha256_client>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_kex_group14_sha256_server">test_kex.py::KexTest::test_kex_group14_sha256_server</h3>
<details><summary> <pre>test_kex.py::KexTest::test_kex_group14_sha256_server</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_kex_group14_sha256_server>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_kex_group16_sha512_client">test_kex.py::KexTest::test_kex_group16_sha512_client</h3>
<details><summary> <pre>test_kex.py::KexTest::test_kex_group16_sha512_client</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_kex_group16_sha512_client>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_kex_group16_sha512_server">test_kex.py::KexTest::test_kex_group16_sha512_server</h3>
<details><summary> <pre>test_kex.py::KexTest::test_kex_group16_sha512_server</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_kex_group16_sha512_server>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_kex_nistp256_client">test_kex.py::KexTest::test_kex_nistp256_client</h3>
<details><summary> <pre>test_kex.py::KexTest::test_kex_nistp256_client</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_kex_nistp256_client>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_kexpykextesttest_kex_nistp256_server">test_kex.py::KexTest::test_kex_nistp256_server</h3>
<details><summary> <pre>test_kex.py::KexTest::test_kex_nistp256_server</pre></summary><pre>
self = <tests.test_kex.KexTest testMethod=test_kex_nistp256_server>

    def setUp(self):
        self._original_urandom = os.urandom
        os.urandom = dummy_urandom
>       self._original_generate_key_pair = KexNistp256._generate_key_pair
E       AttributeError: type object 'KexNistp256' has no attribute '_generate_key_pair'

tests/test_kex.py:131: AttributeError
</pre>
</details>
<h3 id="test_messagepymessagetesttest_add">test_message.py::MessageTest::test_add</h3>
<details><summary> <pre>test_message.py::MessageTest::test_add</pre></summary><pre>
self = <tests.test_message.MessageTest testMethod=test_add>

    def test_add(self):
        msg = Message()
        msg.add(5)
        msg.add(0x1122334455)
        msg.add(0xF00000000000000000)
        msg.add(True)
        msg.add("cat")
        msg.add(["a", "b"])
>       self.assertEqual(msg.asbytes(), self.__d)
E       AssertionError: None != b'\x00\x00\x00\x05\xff\x00\x00\x00\x05\x1[101 chars]3a,b'

tests/test_message.py:95: AssertionError
</pre>
</details>
<h3 id="test_messagepymessagetesttest_bytes_str_and_repr">test_message.py::MessageTest::test_bytes_str_and_repr</h3>
<details><summary> <pre>test_message.py::MessageTest::test_bytes_str_and_repr</pre></summary><pre>
self = <tests.test_message.MessageTest testMethod=test_bytes_str_and_repr>

    def test_bytes_str_and_repr(self):
        msg = Message(self.__d)
        assert str(msg) == f"paramiko.Message({self.__d!r})"
        assert repr(msg) == str(msg)
>       assert bytes(msg) == msg.asbytes() == self.__d
E       TypeError: __bytes__ returned non-bytes (type NoneType)

tests/test_message.py:113: TypeError
</pre>
</details>
<h3 id="test_messagepymessagetesttest_decode">test_message.py::MessageTest::test_decode</h3>
<details><summary> <pre>test_message.py::MessageTest::test_decode</pre></summary><pre>
self = <tests.test_message.MessageTest testMethod=test_decode>

    def test_decode(self):
        msg = Message(self.__a)
>       self.assertEqual(msg.get_int(), 23)
E       AssertionError: None != 23

tests/test_message.py:67: AssertionError
</pre>
</details>
<h3 id="test_messagepymessagetesttest_encode">test_message.py::MessageTest::test_encode</h3>
<details><summary> <pre>test_message.py::MessageTest::test_encode</pre></summary><pre>
self = <tests.test_message.MessageTest testMethod=test_encode>

    def test_encode(self):
        msg = Message()
        msg.add_int(23)
        msg.add_int(123789456)
        msg.add_string("q")
        msg.add_string("hello")
        msg.add_string("x" * 1000)
>       self.assertEqual(msg.asbytes(), self.__a)
E       AssertionError: None != b'\x00\x00\x00\x17\x07`\xe0\x90\x00\x00\x[1040 chars]xxxx'

tests/test_message.py:46: AssertionError
</pre>
</details>
<h3 id="test_messagepymessagetesttest_misc">test_message.py::MessageTest::test_misc</h3>
<details><summary> <pre>test_message.py::MessageTest::test_misc</pre></summary><pre>
self = <tests.test_message.MessageTest testMethod=test_misc>

    def test_misc(self):
        msg = Message(self.__d)
>       self.assertEqual(msg.get_adaptive_int(), 5)
E       AssertionError: None != 5

tests/test_message.py:99: AssertionError
</pre>
</details>
<h3 id="test_packetizerpypacketizertesttest_closed">test_packetizer.py::PacketizerTest::test_closed</h3>
<details><summary> <pre>test_packetizer.py::PacketizerTest::test_closed</pre></summary><pre>
self = <tests.test_packetizer.PacketizerTest testMethod=test_closed>

    def test_closed(self):
        if sys.platform.startswith("win"):  # no SIGALRM on windows
            return
        rsock = LoopSocket()
        wsock = LoopSocket()
        rsock.link(wsock)
        p = Packetizer(wsock)
        p.set_log(util.get_logger("paramiko.transport"))
>       p.set_hexdump(True)
E       AttributeError: 'Packetizer' object has no attribute 'set_hexdump'

tests/test_packetizer.py:101: AttributeError
</pre>
</details>
<h3 id="test_packetizerpypacketizertesttest_read">test_packetizer.py::PacketizerTest::test_read</h3>
<details><summary> <pre>test_packetizer.py::PacketizerTest::test_read</pre></summary><pre>
self = <tests.test_packetizer.PacketizerTest testMethod=test_read>

    def test_read(self):
        rsock = LoopSocket()
        wsock = LoopSocket()
        rsock.link(wsock)
        p = Packetizer(rsock)
        p.set_log(util.get_logger("paramiko.transport"))
>       p.set_hexdump(True)
E       AttributeError: 'Packetizer' object has no attribute 'set_hexdump'

tests/test_packetizer.py:77: AttributeError
</pre>
</details>
<h3 id="test_packetizerpypacketizertesttest_write">test_packetizer.py::PacketizerTest::test_write</h3>
<details><summary> <pre>test_packetizer.py::PacketizerTest::test_write</pre></summary><pre>
self = <tests.test_packetizer.PacketizerTest testMethod=test_write>

    def test_write(self):
        rsock = LoopSocket()
        wsock = LoopSocket()
        rsock.link(wsock)
        p = Packetizer(wsock)
        p.set_log(util.get_logger("paramiko.transport"))
>       p.set_hexdump(True)
E       AttributeError: 'Packetizer' object has no attribute 'set_hexdump'

tests/test_packetizer.py:47: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_compare_dss">test_pkey.py::KeyTest::test_compare_dss</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_compare_dss</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_compare_dss>

    def test_compare_dss(self):
        # verify that the private & public keys compare equal
        key = DSSKey.from_private_key_file(_support("dss.key"))
        self.assertEqual(key, key)
>       pub = DSSKey(data=key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_pkey.py:239: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_compare_ecdsa_256">test_pkey.py::KeyTest::test_compare_ecdsa_256</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_compare_ecdsa_256</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_compare_ecdsa_256>

    def test_compare_ecdsa_256(self):
        # verify that the private & public keys compare equal
        key = ECDSAKey.from_private_key_file(_support("ecdsa-256.key"))
        self.assertEqual(key, key)
>       pub = ECDSAKey(data=key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_pkey.py:356: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_compare_ecdsa_384">test_pkey.py::KeyTest::test_compare_ecdsa_384</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_compare_ecdsa_384</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_compare_ecdsa_384>

    def test_compare_ecdsa_384(self):
        # verify that the private & public keys compare equal
        key = ECDSAKey.from_private_key_file(_support("test_ecdsa_384.key"))
        self.assertEqual(key, key)
>       pub = ECDSAKey(data=key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_pkey.py:419: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_compare_ecdsa_521">test_pkey.py::KeyTest::test_compare_ecdsa_521</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_compare_ecdsa_521</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_compare_ecdsa_521>

    def test_compare_ecdsa_521(self):
        # verify that the private & public keys compare equal
        key = ECDSAKey.from_private_key_file(_support("test_ecdsa_521.key"))
        self.assertEqual(key, key)
>       pub = ECDSAKey(data=key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_pkey.py:474: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_compare_rsa">test_pkey.py::KeyTest::test_compare_rsa</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_compare_rsa</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_compare_rsa>

    def test_compare_rsa(self):
        # verify that the private & public keys compare equal
        key = RSAKey.from_private_key_file(_support("rsa.key"))
        self.assertEqual(key, key)
>       pub = RSAKey(data=key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_pkey.py:230: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_ed25519">test_pkey.py::KeyTest::test_ed25519</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_ed25519</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_ed25519>

    def test_ed25519(self):
        key1 = Ed25519Key.from_private_key_file(_support("ed25519.key"))
        key2 = Ed25519Key.from_private_key_file(
            _support("test_ed25519_password.key"), b"abc123"
        )
>       self.assertNotEqual(key1.asbytes(), key2.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_pkey.py:575: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_ed25519_compare">test_pkey.py::KeyTest::test_ed25519_compare</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_ed25519_compare</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_ed25519_compare>

    def test_ed25519_compare(self):
        # verify that the private & public keys compare equal
        key = Ed25519Key.from_private_key_file(_support("ed25519.key"))
        self.assertEqual(key, key)
>       pub = Ed25519Key(data=key.asbytes())
E       AttributeError: 'NoneType' object has no attribute 'asbytes'

tests/test_pkey.py:593: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_ed25519_load_from_file_obj">test_pkey.py::KeyTest::test_ed25519_load_from_file_obj</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_ed25519_load_from_file_obj</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_ed25519_load_from_file_obj>

    def test_ed25519_load_from_file_obj(self):
        with open(_support("ed25519.key")) as pkey_fileobj:
            key = Ed25519Key.from_private_key(pkey_fileobj)
        self.assertEqual(key, key)
>       self.assertTrue(key.can_sign())
E       AttributeError: 'NoneType' object has no attribute 'can_sign'

tests/test_pkey.py:627: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_existing_keyfiles_still_work_ok">test_pkey.py::KeyTest::test_existing_keyfiles_still_work_ok</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_existing_keyfiles_still_work_ok</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_existing_keyfiles_still_work_ok>

    def test_existing_keyfiles_still_work_ok(self):
>       self._test_keyfile_race(exists=True)

tests/test_pkey.py:676: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/unittest/mock.py:1379: in patched
    return func(*newargs, **newkeywargs)
tests/test_pkey.py:658: in _test_keyfile_race
    key = ECDSAKey(filename=source, password=password)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PKey(alg=None, bits=None, fp=None), msg = None, data = None
filename = '/testbed/tests/test_ecdsa_384.key', password = 'television'
vals = None, file_obj = None, validate_point = True

    def __init__(self, msg=None, data=None, filename=None, password=None, vals=None, file_obj=None, validate_point=True):
        self.verifying_key = None
        self.signing_key = None
        self.public_blob = None
        if file_obj is not None:
            self._from_private_key(file_obj, password)
            return
        if filename is not None:
>           self._from_private_key_file(filename, password)
E           AttributeError: 'ECDSAKey' object has no attribute '_from_private_key_file'. Did you mean: 'from_private_key_file'?

paramiko/ecdsakey.py:61: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_generate_dss">test_pkey.py::KeyTest::test_generate_dss</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_generate_dss</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_generate_dss>

    def test_generate_dss(self):
        key = DSSKey.generate(1024)
>       msg = key.sign_ssh_data(b"jerri blank")
E       AttributeError: 'NoneType' object has no attribute 'sign_ssh_data'

tests/test_pkey.py:292: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_generate_ecdsa">test_pkey.py::KeyTest::test_generate_ecdsa</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_generate_ecdsa</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_generate_ecdsa>

    def test_generate_ecdsa(self):
        key = ECDSAKey.generate()
>       msg = key.sign_ssh_data(b"jerri blank")
E       AttributeError: 'NoneType' object has no attribute 'sign_ssh_data'

tests/test_pkey.py:298: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_generate_key_bytes">test_pkey.py::KeyTest::test_generate_key_bytes</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_generate_key_bytes</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_generate_key_bytes>

    def test_generate_key_bytes(self):
        key = util.generate_key_bytes(md5, x1234, "happy birthday", 30)
        exp = b"\x61\xE1\xF2\x72\xF4\xC1\xC4\x56\x15\x86\xBD\x32\x24\x98\xC0\xE9\x24\x67\x27\x80\xF4\x7B\xB3\x7D\xDA\x7D\x54\x01\x9E\x64"  # noqa
>       self.assertEqual(exp, key)
E       AssertionError: b"a\xe1\xf2r\xf4\xc1\xc4V\x15\x86\xbd2$\x[38 chars]x9ed" != None

tests/test_pkey.py:155: AssertionError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_generate_rsa">test_pkey.py::KeyTest::test_generate_rsa</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_generate_rsa</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_generate_rsa>

    @requires_sha1_signing
    def test_generate_rsa(self):
        key = RSAKey.generate(1024)
>       msg = key.sign_ssh_data(b"jerri blank")
E       AttributeError: 'NoneType' object has no attribute 'sign_ssh_data'

tests/test_pkey.py:286: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_keyfile_is_actually_encrypted">test_pkey.py::KeyTest::test_keyfile_is_actually_encrypted</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_keyfile_is_actually_encrypted</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_keyfile_is_actually_encrypted>

    def test_keyfile_is_actually_encrypted(self):
        # Read an existing encrypted private key
        file_ = _support("test_rsa_password.key")
        password = "television"
        newfile = file_ + ".new"
        newpassword = "radio"
>       key = RSAKey(filename=file_, password=password)

tests/test_pkey.py:635: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PKey(alg=None, bits=None, fp=None), msg = None, data = None
filename = '/testbed/tests/test_rsa_password.key', password = 'television'
key = None, file_obj = None

    def __init__(self, msg=None, data=None, filename=None, password=None, key=None, file_obj=None):
        self.key = None
        self.public_blob = None
        if file_obj is not None:
            self._from_private_key(file_obj, password)
            return
        if filename is not None:
>           self._from_private_key_file(filename, password)
E           AttributeError: 'RSAKey' object has no attribute '_from_private_key_file'. Did you mean: 'from_private_key_file'?

paramiko/rsakey.py:27: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_dss">test_pkey.py::KeyTest::test_load_dss</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_dss</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_dss>

    def test_load_dss(self):
        key = DSSKey.from_private_key_file(_support("dss.key"))
>       self.assertEqual("ssh-dss", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:201: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_dss_password">test_pkey.py::KeyTest::test_load_dss_password</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_dss_password</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_dss_password>

    def test_load_dss_password(self):
        key = DSSKey.from_private_key_file(
            _support("test_dss_password.key"), "television"
        )
>       self.assertEqual("ssh-dss", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:219: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_ecdsa_256">test_pkey.py::KeyTest::test_load_ecdsa_256</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_ecdsa_256</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_ecdsa_256>

    def test_load_ecdsa_256(self):
        key = ECDSAKey.from_private_key_file(_support("ecdsa-256.key"))
>       self.assertEqual("ecdsa-sha2-nistp256", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:327: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_ecdsa_384">test_pkey.py::KeyTest::test_load_ecdsa_384</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_ecdsa_384</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_ecdsa_384>

    def test_load_ecdsa_384(self):
        key = ECDSAKey.from_private_key_file(_support("test_ecdsa_384.key"))
>       self.assertEqual("ecdsa-sha2-nistp384", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:379: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_ecdsa_521">test_pkey.py::KeyTest::test_load_ecdsa_521</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_ecdsa_521</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_ecdsa_521>

    def test_load_ecdsa_521(self):
        key = ECDSAKey.from_private_key_file(_support("test_ecdsa_521.key"))
>       self.assertEqual("ecdsa-sha2-nistp521", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:442: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_ecdsa_password_256">test_pkey.py::KeyTest::test_load_ecdsa_password_256</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_ecdsa_password_256</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_ecdsa_password_256>

    def test_load_ecdsa_password_256(self):
        key = ECDSAKey.from_private_key_file(
            _support("test_ecdsa_password_256.key"), b"television"
        )
>       self.assertEqual("ecdsa-sha2-nistp256", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:345: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_ecdsa_password_384">test_pkey.py::KeyTest::test_load_ecdsa_password_384</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_ecdsa_password_384</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_ecdsa_password_384>

    def test_load_ecdsa_password_384(self):
        key = ECDSAKey.from_private_key_file(
            _support("test_ecdsa_password_384.key"), b"television"
        )
>       self.assertEqual("ecdsa-sha2-nistp384", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:397: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_ecdsa_password_521">test_pkey.py::KeyTest::test_load_ecdsa_password_521</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_ecdsa_password_521</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_ecdsa_password_521>

    def test_load_ecdsa_password_521(self):
        key = ECDSAKey.from_private_key_file(
            _support("test_ecdsa_password_521.key"), b"television"
        )
>       self.assertEqual("ecdsa-sha2-nistp521", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:463: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_ecdsa_transmutes_crypto_exceptions">test_pkey.py::KeyTest::test_load_ecdsa_transmutes_crypto_exceptions</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_ecdsa_transmutes_crypto_exceptions</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_ecdsa_transmutes_crypto_exceptions>

    def test_load_ecdsa_transmutes_crypto_exceptions(self):
        path = _support("ecdsa-256.key")
        # TODO: nix unittest for pytest
        for exception in (TypeError("onoz"), UnsupportedAlgorithm("oops")):
            with patch(
                "paramiko.ecdsakey.serialization.load_der_private_key"
            ) as loader:
                loader.side_effect = exception
>               with pytest.raises(SSHException, match=str(exception)):
E               Failed: DID NOT RAISE <class 'paramiko.ssh_exception.SSHException'>

tests/test_pkey.py:412: Failed
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_openssh_format_dss_key">test_pkey.py::KeyTest::test_load_openssh_format_DSS_key</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_openssh_format_DSS_key</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_openssh_format_DSS_key>

    def test_load_openssh_format_DSS_key(self):
        key = DSSKey.from_private_key_file(
            _support("test_dss_openssh.key"), b"television"
        )
>       self.assertEqual("ssh-dss", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:525: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_openssh_format_ec_key">test_pkey.py::KeyTest::test_load_openssh_format_EC_key</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_openssh_format_EC_key</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_openssh_format_EC_key>

    def test_load_openssh_format_EC_key(self):
        key = ECDSAKey.from_private_key_file(
            _support("test_ecdsa_384_openssh.key"), b"television"
        )
>       self.assertEqual("ecdsa-sha2-nistp384", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:536: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_openssh_format_rsa_key">test_pkey.py::KeyTest::test_load_openssh_format_RSA_key</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_openssh_format_RSA_key</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_openssh_format_RSA_key>

    def test_load_openssh_format_RSA_key(self):
        key = RSAKey.from_private_key_file(
            _support("test_rsa_openssh.key"), b"television"
        )
>       self.assertEqual("ssh-rsa", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:499: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_rsa">test_pkey.py::KeyTest::test_load_rsa</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_rsa</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_rsa>

    def test_load_rsa(self):
        key = RSAKey.from_private_key_file(_support("rsa.key"))
>       self.assertEqual("ssh-rsa", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:159: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_rsa_password">test_pkey.py::KeyTest::test_load_rsa_password</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_rsa_password</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_rsa_password>

    def test_load_rsa_password(self):
        key = RSAKey.from_private_key_file(
            _support("test_rsa_password.key"), "television"
        )
>       self.assertEqual("ssh-rsa", key.get_name())
E       AttributeError: 'NoneType' object has no attribute 'get_name'

tests/test_pkey.py:192: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_load_rsa_transmutes_crypto_exceptions">test_pkey.py::KeyTest::test_load_rsa_transmutes_crypto_exceptions</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_load_rsa_transmutes_crypto_exceptions</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_load_rsa_transmutes_crypto_exceptions>

    def test_load_rsa_transmutes_crypto_exceptions(self):
        # TODO: nix unittest for pytest
        for exception in (TypeError("onoz"), UnsupportedAlgorithm("oops")):
            with patch(
                "paramiko.rsakey.serialization.load_der_private_key"
            ) as loader:
                loader.side_effect = exception
>               with pytest.raises(SSHException, match=str(exception)):
E               Failed: DID NOT RAISE <class 'paramiko.ssh_exception.SSHException'>

tests/test_pkey.py:180: Failed
</pre>
</details>
<h3 id="test_pkeypykeytesttest_loading_empty_keys_errors_usefully">test_pkey.py::KeyTest::test_loading_empty_keys_errors_usefully</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_loading_empty_keys_errors_usefully</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_loading_empty_keys_errors_usefully>

    def test_loading_empty_keys_errors_usefully(self):
        # #1599 - raise SSHException instead of IndexError
>       with pytest.raises(SSHException, match="no lines"):
E       Failed: DID NOT RAISE <class 'paramiko.ssh_exception.SSHException'>

tests/test_pkey.py:185: Failed
</pre>
</details>
<h3 id="test_pkeypykeytesttest_loading_openssh_rsa_keys_uses_correct_p_q">test_pkey.py::KeyTest::test_loading_openssh_RSA_keys_uses_correct_p_q</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_loading_openssh_RSA_keys_uses_correct_p_q</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_loading_openssh_RSA_keys_uses_correct_p_q>

    def test_loading_openssh_RSA_keys_uses_correct_p_q(self):
        # Re #1723 - not the most elegant test but given how deep it is...
        with patch(
            "paramiko.rsakey.rsa.RSAPrivateNumbers", wraps=RSAPrivateNumbers
        ) as spy:
            # Load key
            RSAKey.from_private_key_file(
                _support("test_rsa_openssh.key"), b"television"
            )
            # Ensure spy saw the correct P and Q values as derived from
            # hardcoded test private key value
>           kwargs = spy.call_args[1]
E           TypeError: 'NoneType' object is not subscriptable

tests/test_pkey.py:517: TypeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_new_keyfiles_avoid_descriptor_race_integration">test_pkey.py::KeyTest::test_new_keyfiles_avoid_descriptor_race_integration</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_new_keyfiles_avoid_descriptor_race_integration</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_new_keyfiles_avoid_descriptor_race_integration>

    def test_new_keyfiles_avoid_descriptor_race_integration(self):
        # Integration-style version of above
        password = "television"
        newpassword = "radio"
        source = _support("test_ecdsa_384.key")
        new = source + ".new"
        # Load fixture key
>       key = ECDSAKey(filename=source, password=password)

tests/test_pkey.py:685: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PKey(alg=None, bits=None, fp=None), msg = None, data = None
filename = '/testbed/tests/test_ecdsa_384.key', password = 'television'
vals = None, file_obj = None, validate_point = True

    def __init__(self, msg=None, data=None, filename=None, password=None, vals=None, file_obj=None, validate_point=True):
        self.verifying_key = None
        self.signing_key = None
        self.public_blob = None
        if file_obj is not None:
            self._from_private_key(file_obj, password)
            return
        if filename is not None:
>           self._from_private_key_file(filename, password)
E           AttributeError: 'ECDSAKey' object has no attribute '_from_private_key_file'. Did you mean: 'from_private_key_file'?

paramiko/ecdsakey.py:61: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_new_keyfiles_avoid_file_descriptor_race_on_chmod">test_pkey.py::KeyTest::test_new_keyfiles_avoid_file_descriptor_race_on_chmod</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_new_keyfiles_avoid_file_descriptor_race_on_chmod</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_new_keyfiles_avoid_file_descriptor_race_on_chmod>

    def test_new_keyfiles_avoid_file_descriptor_race_on_chmod(self):
>       self._test_keyfile_race(exists=False)

tests/test_pkey.py:673: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/unittest/mock.py:1379: in patched
    return func(*newargs, **newkeywargs)
tests/test_pkey.py:658: in _test_keyfile_race
    key = ECDSAKey(filename=source, password=password)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PKey(alg=None, bits=None, fp=None), msg = None, data = None
filename = '/testbed/tests/test_ecdsa_384.key', password = 'television'
vals = None, file_obj = None, validate_point = True

    def __init__(self, msg=None, data=None, filename=None, password=None, vals=None, file_obj=None, validate_point=True):
        self.verifying_key = None
        self.signing_key = None
        self.public_blob = None
        if file_obj is not None:
            self._from_private_key(file_obj, password)
            return
        if filename is not None:
>           self._from_private_key_file(filename, password)
E           AttributeError: 'ECDSAKey' object has no attribute '_from_private_key_file'. Did you mean: 'from_private_key_file'?

paramiko/ecdsakey.py:61: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_salt_size">test_pkey.py::KeyTest::test_salt_size</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_salt_size</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_salt_size>

    def test_salt_size(self):
        # Read an existing encrypted private key
        file_ = _support("test_rsa_password.key")
        password = "television"
        newfile = file_ + ".new"
        newpassword = "radio"
>       key = RSAKey(filename=file_, password=password)

tests/test_pkey.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PKey(alg=None, bits=None, fp=None), msg = None, data = None
filename = '/testbed/tests/test_rsa_password.key', password = 'television'
key = None, file_obj = None

    def __init__(self, msg=None, data=None, filename=None, password=None, key=None, file_obj=None):
        self.key = None
        self.public_blob = None
        if file_obj is not None:
            self._from_private_key(file_obj, password)
            return
        if filename is not None:
>           self._from_private_key_file(filename, password)
E           AttributeError: 'RSAKey' object has no attribute '_from_private_key_file'. Did you mean: 'from_private_key_file'?

paramiko/rsakey.py:27: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_sign_and_verify_rsa_sha2_256">test_pkey.py::KeyTest::test_sign_and_verify_rsa_sha2_256</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_sign_and_verify_rsa_sha2_256</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_sign_and_verify_rsa_sha2_256>

    def test_sign_and_verify_rsa_sha2_256(self):
>       self._sign_and_verify_rsa("rsa-sha2-256", SIGNED_RSA_256)

tests/test_pkey.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pkey.KeyTest testMethod=test_sign_and_verify_rsa_sha2_256>
algorithm = 'rsa-sha2-256'
saved_sig = 'cc:6:60:e0:0:2c:ac:9e:26:bc:d5:68:64:3f:9f:a7:e5:aa:41:eb:88:4a:25:5:9c:93:84:66:ef:ef:60:f4:34:fb:f4:c8:3d:55:33:6a:...16:8f:84:a3:86:68:c:94:90:7d:6e:cc:81:12:d8:b6:ad:aa:31:a8:13:3d:63:81:3e:bb:5:b6:38:4d:2:d:1b:5b:70:de:83:cc:3a:cb:31'

    def _sign_and_verify_rsa(self, algorithm, saved_sig):
        key = RSAKey.from_private_key_file(_support("rsa.key"))
>       msg = key.sign_ssh_data(b"ice weasels", algorithm)
E       AttributeError: 'NoneType' object has no attribute 'sign_ssh_data'

tests/test_pkey.py:246: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_sign_and_verify_rsa_sha2_512">test_pkey.py::KeyTest::test_sign_and_verify_rsa_sha2_512</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_sign_and_verify_rsa_sha2_512</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_sign_and_verify_rsa_sha2_512>

    def test_sign_and_verify_rsa_sha2_512(self):
>       self._sign_and_verify_rsa("rsa-sha2-512", SIGNED_RSA_512)

tests/test_pkey.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pkey.KeyTest testMethod=test_sign_and_verify_rsa_sha2_512>
algorithm = 'rsa-sha2-512'
saved_sig = '87:46:8b:75:92:33:78:a0:22:35:32:39:23:c6:ab:e1:6:92:ad:bc:7f:6e:ab:19:32:e4:78:b2:2c:8f:1d:c:65:da:fc:a5:7:ca:b6:55:...a:c6:6c:99:36:3a:84:d6:9c:2a:34:8c:7f:f4:bb:c9:a5:9a:6c:11:f2:cf:da:51:5e:1e:7f:90:27:34:de:b2:f3:15:4f:db:47:32:6b:a7'

    def _sign_and_verify_rsa(self, algorithm, saved_sig):
        key = RSAKey.from_private_key_file(_support("rsa.key"))
>       msg = key.sign_ssh_data(b"ice weasels", algorithm)
E       AttributeError: 'NoneType' object has no attribute 'sign_ssh_data'

tests/test_pkey.py:246: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_sign_and_verify_ssh_rsa">test_pkey.py::KeyTest::test_sign_and_verify_ssh_rsa</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_sign_and_verify_ssh_rsa</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_sign_and_verify_ssh_rsa>

    @requires_sha1_signing
    def test_sign_and_verify_ssh_rsa(self):
>       self._sign_and_verify_rsa("ssh-rsa", SIGNED_RSA)

tests/test_pkey.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_pkey.KeyTest testMethod=test_sign_and_verify_ssh_rsa>
algorithm = 'ssh-rsa'
saved_sig = '20:d7:8a:31:21:cb:f7:92:12:f2:a4:89:37:f5:78:af:e6:16:b6:25:b9:97:3d:a2:cd:5f:ca:20:21:73:4c:ad:34:73:8f:20:77:28:e2:...c:d9:1d:43:86:0f:1c:70:e2:93:12:34:f3:ac:c5:0a:2f:14:50:66:59:f1:88:ee:c1:4a:e9:d1:9c:4e:46:f0:0e:47:6f:38:74:f1:44:a8'

    def _sign_and_verify_rsa(self, algorithm, saved_sig):
        key = RSAKey.from_private_key_file(_support("rsa.key"))
>       msg = key.sign_ssh_data(b"ice weasels", algorithm)
E       AttributeError: 'NoneType' object has no attribute 'sign_ssh_data'

tests/test_pkey.py:246: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_sign_dss">test_pkey.py::KeyTest::test_sign_dss</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_sign_dss</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_sign_dss>

    def test_sign_dss(self):
        # verify that the dss private key can sign and verify
        key = DSSKey.from_private_key_file(_support("dss.key"))
>       msg = key.sign_ssh_data(b"ice weasels")
E       AttributeError: 'NoneType' object has no attribute 'sign_ssh_data'

tests/test_pkey.py:271: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_sign_ecdsa_256">test_pkey.py::KeyTest::test_sign_ecdsa_256</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_sign_ecdsa_256</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_sign_ecdsa_256>

    def test_sign_ecdsa_256(self):
        # verify that the rsa private key can sign and verify
        key = ECDSAKey.from_private_key_file(_support("ecdsa-256.key"))
>       msg = key.sign_ssh_data(b"ice weasels")
E       AttributeError: 'NoneType' object has no attribute 'sign_ssh_data'

tests/test_pkey.py:364: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_sign_ecdsa_384">test_pkey.py::KeyTest::test_sign_ecdsa_384</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_sign_ecdsa_384</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_sign_ecdsa_384>

    def test_sign_ecdsa_384(self):
        # verify that the rsa private key can sign and verify
        key = ECDSAKey.from_private_key_file(_support("test_ecdsa_384.key"))
>       msg = key.sign_ssh_data(b"ice weasels")
E       AttributeError: 'NoneType' object has no attribute 'sign_ssh_data'

tests/test_pkey.py:427: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_sign_ecdsa_521">test_pkey.py::KeyTest::test_sign_ecdsa_521</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_sign_ecdsa_521</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_sign_ecdsa_521>

    def test_sign_ecdsa_521(self):
        # verify that the rsa private key can sign and verify
        key = ECDSAKey.from_private_key_file(_support("test_ecdsa_521.key"))
>       msg = key.sign_ssh_data(b"ice weasels")
E       AttributeError: 'NoneType' object has no attribute 'sign_ssh_data'

tests/test_pkey.py:482: AttributeError
</pre>
</details>
<h3 id="test_pkeypykeytesttest_stringification">test_pkey.py::KeyTest::test_stringification</h3>
<details><summary> <pre>test_pkey.py::KeyTest::test_stringification</pre></summary><pre>
self = <tests.test_pkey.KeyTest testMethod=test_stringification>

    def test_stringification(self):
        key = RSAKey.from_private_key_file(_support("rsa.key"))
        comparable = TEST_KEY_BYTESTR
>       self.assertEqual(str(key), comparable)
E       AssertionError: 'None' != '\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x01#\[121 chars]\x1f'
E       - None
E       +    ssh-rsa   #    ӏVk%<T$E#>ғfD ae#̬S#VlEpvoM߉DUXL<דw⯕ٿw˟0)#y{l    Pru Π܎/f0yFmm

tests/test_pkey.py:568: AssertionError
</pre>
</details>
<h3 id="test_proxypytestproxycommandtest_send_writes_to_process_stdin_returning_length">test_proxy.py::TestProxyCommand::test_send_writes_to_process_stdin_returning_length</h3>
<details><summary> <pre>test_proxy.py::TestProxyCommand::test_send_writes_to_process_stdin_returning_length</pre></summary><pre>
self = <tests.test_proxy.TestProxyCommand object at 0x7eb2faebe9e0>
Popen = <MagicMock name='Popen' id='139307148459024'>

    @patch("paramiko.proxy.subprocess.Popen")
    def test_send_writes_to_process_stdin_returning_length(self, Popen):
        proxy = ProxyCommand("hi")
        written = proxy.send(b"data")
>       Popen.return_value.stdin.write.assert_called_once_with(b"data")

tests/test_proxy.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='Popen().stdin.write' id='139307148963424'>
args = (b'data',), kwargs = {}
msg = "Expected 'write' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'write' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError
</pre>
</details>
<h3 id="test_proxypytestproxycommandtest_send_raises_proxycommandfailure_on_error">test_proxy.py::TestProxyCommand::test_send_raises_ProxyCommandFailure_on_error</h3>
<details><summary> <pre>test_proxy.py::TestProxyCommand::test_send_raises_ProxyCommandFailure_on_error</pre></summary><pre>
self = <tests.test_proxy.TestProxyCommand object at 0x7eb2faebdd50>
Popen = <MagicMock name='Popen' id='139307148933440'>

    @patch("paramiko.proxy.subprocess.Popen")
    def test_send_raises_ProxyCommandFailure_on_error(self, Popen):
        Popen.return_value.stdin.write.side_effect = IOError(0, "whoops")
>       with raises(ProxyCommandFailure) as info:
E       Failed: DID NOT RAISE <class 'paramiko.ssh_exception.ProxyCommandFailure'>

tests/test_proxy.py:32: Failed
</pre>
</details>
<h3 id="test_proxypytestproxycommandtest_recv_reads_from_process_stdout_returning_bytes">test_proxy.py::TestProxyCommand::test_recv_reads_from_process_stdout_returning_bytes</h3>
<details><summary> <pre>test_proxy.py::TestProxyCommand::test_recv_reads_from_process_stdout_returning_bytes</pre></summary><pre>
self = <tests.test_proxy.TestProxyCommand object at 0x7eb2faebca90>
select = <MagicMock name='select' id='139307137590720'>
os_read = <MagicMock name='read' id='139307149585200'>
Popen = <MagicMock name='Popen' id='139307149586256'>

    @patch("paramiko.proxy.subprocess.Popen")
    @patch("paramiko.proxy.os.read")
    @patch("paramiko.proxy.select")
    def test_recv_reads_from_process_stdout_returning_bytes(
        self, select, os_read, Popen
    ):
        stdout = Popen.return_value.stdout
        select.return_value = [stdout], None, None
        fileno = stdout.fileno.return_value
        # Force os.read to return smaller-than-requested chunks
        os_read.side_effect = [b"was", b"t", b"e", b"of ti", b"me"]
        proxy = ProxyCommand("hi")
        # Ask for 5 bytes (ie b"waste")
        data = proxy.recv(5)
        # Ensure we got "waste" stitched together
>       assert data == b"waste"
E       AssertionError: assert None == b'waste'

tests/test_proxy.py:52: AssertionError
</pre>
</details>
<h3 id="test_proxypytestproxycommandtest_recv_returns_buffer_on_timeout_if_any_read">test_proxy.py::TestProxyCommand::test_recv_returns_buffer_on_timeout_if_any_read</h3>
<details><summary> <pre>test_proxy.py::TestProxyCommand::test_recv_returns_buffer_on_timeout_if_any_read</pre></summary><pre>
self = <tests.test_proxy.TestProxyCommand object at 0x7eb2faebded0>
select = <MagicMock name='select' id='139307180167312'>
os_read = <MagicMock name='read' id='139307148944208'>
Popen = <MagicMock name='Popen' id='139307153011280'>

    @patch("paramiko.proxy.subprocess.Popen")
    @patch("paramiko.proxy.os.read")
    @patch("paramiko.proxy.select")
    def test_recv_returns_buffer_on_timeout_if_any_read(
        self, select, os_read, Popen
    ):
        stdout = Popen.return_value.stdout
        select.return_value = [stdout], None, None
        fileno = stdout.fileno.return_value
        os_read.side_effect = [b"was", socket.timeout]
        proxy = ProxyCommand("hi")
        data = proxy.recv(5)
>       assert data == b"was"  # not b"waste"
E       AssertionError: assert None == b'was'

tests/test_proxy.py:74: AssertionError
</pre>
</details>
<h3 id="test_proxypytestproxycommandtest_recv_raises_timeout_if_nothing_read">test_proxy.py::TestProxyCommand::test_recv_raises_timeout_if_nothing_read</h3>
<details><summary> <pre>test_proxy.py::TestProxyCommand::test_recv_raises_timeout_if_nothing_read</pre></summary><pre>
self = <tests.test_proxy.TestProxyCommand object at 0x7eb2fafb46a0>
select = <MagicMock name='select' id='139307147991248'>
os_read = <MagicMock name='read' id='139307147996240'>
Popen = <MagicMock name='Popen' id='139307152134192'>

    @patch("paramiko.proxy.subprocess.Popen")
    @patch("paramiko.proxy.os.read")
    @patch("paramiko.proxy.select")
    def test_recv_raises_timeout_if_nothing_read(self, select, os_read, Popen):
        stdout = Popen.return_value.stdout
        select.return_value = [stdout], None, None
        fileno = stdout.fileno.return_value
        os_read.side_effect = socket.timeout
        proxy = ProxyCommand("hi")
>       with raises(socket.timeout):
E       Failed: DID NOT RAISE <class 'TimeoutError'>

tests/test_proxy.py:86: Failed
</pre>
</details>
<h3 id="test_proxypytestproxycommandtest_recv_raises_proxycommandfailure_on_non_timeout_error">test_proxy.py::TestProxyCommand::test_recv_raises_ProxyCommandFailure_on_non_timeout_error</h3>
<details><summary> <pre>test_proxy.py::TestProxyCommand::test_recv_raises_ProxyCommandFailure_on_non_timeout_error</pre></summary><pre>
self = <tests.test_proxy.TestProxyCommand object at 0x7eb2fafb7340>
select = <MagicMock name='select' id='139307147363472'>
os_read = <MagicMock name='read' id='139307147377488'>
Popen = <MagicMock name='Popen' id='139307147468640'>

    @patch("paramiko.proxy.subprocess.Popen")
    @patch("paramiko.proxy.os.read")
    @patch("paramiko.proxy.select")
    def test_recv_raises_ProxyCommandFailure_on_non_timeout_error(
        self, select, os_read, Popen
    ):
        select.return_value = [Popen.return_value.stdout], None, None
        os_read.side_effect = IOError(0, "whoops")
>       with raises(ProxyCommandFailure) as info:
E       Failed: DID NOT RAISE <class 'paramiko.ssh_exception.ProxyCommandFailure'>

tests/test_proxy.py:98: Failed
</pre>
</details>
<h3 id="test_proxypytestproxycommandtest_close_kills_subprocess">test_proxy.py::TestProxyCommand::test_close_kills_subprocess</h3>
<details><summary> <pre>test_proxy.py::TestProxyCommand::test_close_kills_subprocess</pre></summary><pre>
self = <tests.test_proxy.TestProxyCommand object at 0x7eb2fafb5c00>
os_kill = <MagicMock name='kill' id='139307151190304'>
Popen = <MagicMock name='Popen' id='139307151184160'>

    @patch("paramiko.proxy.subprocess.Popen")
    @patch("paramiko.proxy.os.kill")
    def test_close_kills_subprocess(self, os_kill, Popen):
        proxy = ProxyCommand("hi")
>       proxy.close()
E       AttributeError: 'ProxyCommand' object has no attribute 'close'

tests/test_proxy.py:107: AttributeError
</pre>
</details>
<h3 id="test_proxypytestproxycommandtest_closed_exposes_whether_subprocess_has_exited">test_proxy.py::TestProxyCommand::test_closed_exposes_whether_subprocess_has_exited</h3>
<details><summary> <pre>test_proxy.py::TestProxyCommand::test_closed_exposes_whether_subprocess_has_exited</pre></summary><pre>
self = <tests.test_proxy.TestProxyCommand object at 0x7eb2fafb5060>
Popen = <MagicMock name='Popen' id='139307157504160'>

    @patch("paramiko.proxy.subprocess.Popen")
    def test_closed_exposes_whether_subprocess_has_exited(self, Popen):
        proxy = ProxyCommand("hi")
        Popen.return_value.returncode = None
>       assert proxy.closed is False
E       AttributeError: 'ProxyCommand' object has no attribute 'closed'

tests/test_proxy.py:114: AttributeError
</pre>
</details>
<h3 id="test_proxypytestproxycommandtest_timeout_affects_whether_timeout_is_raised">test_proxy.py::TestProxyCommand::test_timeout_affects_whether_timeout_is_raised</h3>
<details><summary> <pre>test_proxy.py::TestProxyCommand::test_timeout_affects_whether_timeout_is_raised</pre></summary><pre>
self = <tests.test_proxy.TestProxyCommand object at 0x7eb2fafb6530>
select = <MagicMock name='select' id='139307148947328'>
os_read = <MagicMock name='read' id='139307160120640'>
Popen = <MagicMock name='Popen' id='139307147801648'>
time = <MagicMock name='time' id='139307158792096'>

    @patch("paramiko.proxy.time.time")
    @patch("paramiko.proxy.subprocess.Popen")
    @patch("paramiko.proxy.os.read")
    @patch("paramiko.proxy.select")
    def test_timeout_affects_whether_timeout_is_raised(
        self, select, os_read, Popen, time
    ):
        stdout = Popen.return_value.stdout
        select.return_value = [stdout], None, None
        # Base case: None timeout means no timing out
        os_read.return_value = b"meh"
        proxy = ProxyCommand("hello")
        assert proxy.timeout is None
        # Implicit 'no raise' check
>       assert proxy.recv(3) == b"meh"
E       AssertionError: assert None == b'meh'
E        +  where None = recv(3)
E        +    where recv = <paramiko.proxy.ProxyCommand object at 0x7eb2f9055000>.recv

tests/test_proxy.py:134: AssertionError
</pre>
</details>
<h3 id="test_sftppytestsftptest_file">test_sftp.py::TestSFTP::test_file</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_file</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9190550 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9190f10>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_close">test_sftp.py::TestSFTP::test_close</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_close</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf98e04c0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f98e37c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_sftp_can_be_used_as_context_manager">test_sftp.py::TestSFTP::test_sftp_can_be_used_as_context_manager</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_sftp_can_be_used_as_context_manager</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b4f760 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b4f8e0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_write">test_sftp.py::TestSFTP::test_write</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_write</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf98e2e30 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f98e1cf0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_sftp_file_can_be_used_as_context_manager">test_sftp.py::TestSFTP::test_sftp_file_can_be_used_as_context_manager</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_sftp_file_can_be_used_as_context_manager</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9069c60 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f906b280>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_append">test_sftp.py::TestSFTP::test_append</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_append</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf90552a0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9057580>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_rename">test_sftp.py::TestSFTP::test_rename</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_rename</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b6ece0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b6d690>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptesta_posix_rename">test_sftp.py::TestSFTP::testa_posix_rename</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::testa_posix_rename</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf94248b0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9427730>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_folder">test_sftp.py::TestSFTP::test_folder</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_folder</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf98e1330 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f98e3100>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_listdir">test_sftp.py::TestSFTP::test_listdir</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_listdir</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a7f790 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a7f700>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_listdir_iter">test_sftp.py::TestSFTP::test_listdir_iter</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_listdir_iter</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xfafd1390 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2fafd1120>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_listdir_in_locale">test_sftp.py::TestSFTP::test_listdir_in_locale</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_listdir_in_locale</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9200550 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9202740>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_setstat">test_sftp.py::TestSFTP::test_setstat</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_setstat</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b6c400 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b6f580>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_fsetstat">test_sftp.py::TestSFTP::test_fsetstat</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_fsetstat</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf934d450 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f934f5e0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_readline_seek">test_sftp.py::TestSFTP::test_readline_seek</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_readline_seek</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9205ed0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f92046a0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_write_seek">test_sftp.py::TestSFTP::test_write_seek</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_write_seek</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a81f60 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a83820>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_symlink">test_sftp.py::TestSFTP::test_symlink</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_symlink</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9c77b20 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9c75360>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_flush_seek">test_sftp.py::TestSFTP::test_flush_seek</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_flush_seek</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9c8b610 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9c8abf0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_realpath">test_sftp.py::TestSFTP::test_realpath</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_realpath</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf95eb640 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f95eba60>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_mkdir">test_sftp.py::TestSFTP::test_mkdir</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_mkdir</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf90f0d60 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f90f10c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_chdir">test_sftp.py::TestSFTP::test_chdir</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_chdir</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9207700 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f92060b0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_get_put">test_sftp.py::TestSFTP::test_get_put</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_get_put</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf920e320 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f920dba0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_get_without_prefetch">test_sftp.py::TestSFTP::test_get_without_prefetch</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_get_without_prefetch</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf8734b20 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f8736080>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_check">test_sftp.py::TestSFTP::test_check</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_check</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b4ed70 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b4edd0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_x_flag">test_sftp.py::TestSFTP::test_x_flag</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_x_flag</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9ba4880 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9ba7c70>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_utf8">test_sftp.py::TestSFTP::test_utf8</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_utf8</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf920eb90 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f920cf70>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_utf8_chdir">test_sftp.py::TestSFTP::test_utf8_chdir</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_utf8_chdir</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf8736ef0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f8737160>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_bad_readv">test_sftp.py::TestSFTP::test_bad_readv</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_bad_readv</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b571c0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b54bb0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_put_without_confirm">test_sftp.py::TestSFTP::test_put_without_confirm</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_put_without_confirm</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf90a1390 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f90a28c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_getcwd">test_sftp.py::TestSFTP::test_getcwd</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_getcwd</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf90f2650 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f90f2260>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_seek_append">test_sftp.py::TestSFTP::test_seek_append</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_seek_append</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf8734a60 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f8737670>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_putfo_empty_file">test_sftp.py::TestSFTP::test_putfo_empty_file</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_putfo_empty_file</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9479120 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f94790c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_non_utf8_data">test_sftp.py::TestSFTP::test_non_utf8_data</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_non_utf8_data</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf90a2b60 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f90a2a10>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_sftp_attributes_locale_time">test_sftp.py::TestSFTP::test_sftp_attributes_locale_time</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_sftp_attributes_locale_time</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf92a4640 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f92a7790>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_sftp_attributes_empty_str">test_sftp.py::TestSFTP::test_sftp_attributes_empty_str</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_sftp_attributes_empty_str</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9207850 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9206740>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftppytestsftptest_write_memoryview">test_sftp.py::TestSFTP::test_write_memoryview</h3>
<details><summary> <pre>test_sftp.py::TestSFTP::test_write_memoryview</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9478070 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9478fa0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftp_bigpytestbigsftptest_lots_of_files">test_sftp_big.py::TestBigSFTP::test_lots_of_files</h3>
<details><summary> <pre>test_sftp_big.py::TestBigSFTP::test_lots_of_files</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a35660 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a36a40>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftp_bigpytestbigsftptest_big_file">test_sftp_big.py::TestBigSFTP::test_big_file</h3>
<details><summary> <pre>test_sftp_big.py::TestBigSFTP::test_big_file</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9069f30 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9069000>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftp_bigpytestbigsftptest_big_file_pipelined">test_sftp_big.py::TestBigSFTP::test_big_file_pipelined</h3>
<details><summary> <pre>test_sftp_big.py::TestBigSFTP::test_big_file_pipelined</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf934f3a0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f934d9c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftp_bigpytestbigsftptest_prefetch_seek">test_sftp_big.py::TestBigSFTP::test_prefetch_seek</h3>
<details><summary> <pre>test_sftp_big.py::TestBigSFTP::test_prefetch_seek</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a7c4c0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a7e530>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftp_bigpytestbigsftptest_readv_seek">test_sftp_big.py::TestBigSFTP::test_readv_seek</h3>
<details><summary> <pre>test_sftp_big.py::TestBigSFTP::test_readv_seek</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf8734cd0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f8737c40>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftp_bigpytestbigsftptest_lots_of_prefetching">test_sftp_big.py::TestBigSFTP::test_lots_of_prefetching</h3>
<details><summary> <pre>test_sftp_big.py::TestBigSFTP::test_lots_of_prefetching</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf94865c0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f94849d0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftp_bigpytestbigsftptest_prefetch_readv">test_sftp_big.py::TestBigSFTP::test_prefetch_readv</h3>
<details><summary> <pre>test_sftp_big.py::TestBigSFTP::test_prefetch_readv</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9205450 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9207550>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftp_bigpytestbigsftptest_large_readv">test_sftp_big.py::TestBigSFTP::test_large_readv</h3>
<details><summary> <pre>test_sftp_big.py::TestBigSFTP::test_large_readv</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf90542b0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9055660>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftp_bigpytestbigsftptest_big_file_big_buffer">test_sftp_big.py::TestBigSFTP::test_big_file_big_buffer</h3>
<details><summary> <pre>test_sftp_big.py::TestBigSFTP::test_big_file_big_buffer</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf908a710 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f908a110>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftp_bigpytestbigsftptest_big_file_renegotiate">test_sftp_big.py::TestBigSFTP::test_big_file_renegotiate</h3>
<details><summary> <pre>test_sftp_big.py::TestBigSFTP::test_big_file_renegotiate</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9487160 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f94852d0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_sftp_bigpytestbigsftptest_prefetch_limit">test_sftp_big.py::TestBigSFTP::test_prefetch_limit</h3>
<details><summary> <pre>test_sftp_big.py::TestBigSFTP::test_prefetch_limit</pre></summary><pre>
@pytest.fixture  # (scope='session')
    def sftp_server():
        """
        Set up an in-memory SFTP server thread. Yields the client Transport/socket.

        The resulting client Transport (along with all the server components) will
        be the same object throughout the test session; the `sftp` fixture then
        creates new higher level client objects wrapped around the client
        Transport, as necessary.
        """
        # Sockets & transports
        socks = LoopSocket()
        sockc = LoopSocket()
        sockc.link(socks)
        # TODO: reuse with new server fixture if possible
>       tc = Transport(sockc)

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b6c5e0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b6c5b0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_ssh_exceptionpyexceptionstringdisplaytesttest_badhostkeyexception">test_ssh_exception.py::ExceptionStringDisplayTest::test_BadHostKeyException</h3>
<details><summary> <pre>test_ssh_exception.py::ExceptionStringDisplayTest::test_BadHostKeyException</pre></summary><pre>
self = <tests.test_ssh_exception.ExceptionStringDisplayTest testMethod=test_BadHostKeyException>

    def test_BadHostKeyException(self):
        got_key = RSAKey.generate(2048)
        wanted_key = RSAKey.generate(2048)
        exc = BadHostKeyException("myhost", got_key, wanted_key)
        expected = "Host key for server 'myhost' does not match: got '{}', expected '{}'"  # noqa
>       assert str(exc) == expected.format(
            got_key.get_base64(), wanted_key.get_base64()
        )

tests/test_ssh_exception.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = BadHostKeyException('myhost', None, None)

    def __str__(self):
        msg = "Host key for server '{}' does not match: got '{}', expected '{}'"
>       return msg.format(self.hostname, self.key.get_base64(), self.expected_key.get_base64())
E       AttributeError: 'NoneType' object has no attribute 'get_base64'

paramiko/ssh_exception.py:95: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_can_override_packetizer_used">test_transport.py::TransportTest::test_can_override_packetizer_used</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_can_override_packetizer_used</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_can_override_packetizer_used>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9203e20 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f92034c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_channel_can_be_used_as_context_manager">test_transport.py::TransportTest::test_channel_can_be_used_as_context_manager</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_channel_can_be_used_as_context_manager</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_channel_can_be_used_as_context_manager>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf908b790 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f908ac20>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_channel_exception">test_transport.py::TransportTest::test_channel_exception</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_channel_exception</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_channel_exception>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a7c130 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a7f8e0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_channel_send_memoryview">test_transport.py::TransportTest::test_channel_send_memoryview</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_channel_send_memoryview</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_channel_send_memoryview>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a83430 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a81420>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_channel_send_misc">test_transport.py::TransportTest::test_channel_send_misc</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_channel_send_misc</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_channel_send_misc>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a81f60 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a82e90>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_client_does_not_respond_to_msg_unimplemented">test_transport.py::TransportTest::test_client_does_not_respond_to_MSG_UNIMPLEMENTED</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_client_does_not_respond_to_MSG_UNIMPLEMENTED</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_client_does_not_respond_to_MSG_UNIMPLEMENTED>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf934f550 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f934e560>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_compression">test_transport.py::TransportTest::test_compression</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_compression</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_compression>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9427ee0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f94241c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_compute_key">test_transport.py::TransportTest::test_compute_key</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_compute_key</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_compute_key>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9203970 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9200e20>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_exec_command">test_transport.py::TransportTest::test_exec_command</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_exec_command</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_exec_command>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b01540 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b01270>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_exit_status">test_transport.py::TransportTest::test_exit_status</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_exit_status</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_exit_status>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf920f550 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f920dcc0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_handshake_timeout">test_transport.py::TransportTest::test_handshake_timeout</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_handshake_timeout</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_handshake_timeout>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf98e3a00 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f98e3df0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_invoke_shell">test_transport.py::TransportTest::test_invoke_shell</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_invoke_shell</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_invoke_shell>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf8736f80 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f8736c50>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_keepalive">test_transport.py::TransportTest::test_keepalive</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_keepalive</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_keepalive>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9ba61a0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9ba4310>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_long_banner">test_transport.py::TransportTest::test_long_banner</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_long_banner</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_long_banner>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf90a16c0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f90a2c20>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_port_forwarding">test_transport.py::TransportTest::test_port_forwarding</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_port_forwarding</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_port_forwarding>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9054970 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f90574f0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_rekey_deadlock">test_transport.py::TransportTest::test_rekey_deadlock</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_rekey_deadlock</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_rekey_deadlock>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf95172b0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f95145e0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_renegotiate">test_transport.py::TransportTest::test_renegotiate</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_renegotiate</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_renegotiate>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf98e3e80 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f98e13c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_reverse_port_forwarding">test_transport.py::TransportTest::test_reverse_port_forwarding</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_reverse_port_forwarding</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_reverse_port_forwarding>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a35030 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a34e80>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_sanitze_packet_size">test_transport.py::TransportTest::test_sanitze_packet_size</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_sanitze_packet_size</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_sanitze_packet_size>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9057d60 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9056d70>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_sanitze_window_size">test_transport.py::TransportTest::test_sanitze_window_size</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_sanitze_window_size</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_sanitze_window_size>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf920efe0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f920f370>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_security_options">test_transport.py::TransportTest::test_security_options</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_security_options</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_security_options>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf990a620 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f990a590>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_select">test_transport.py::TransportTest::test_select</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_select</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_select>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf934d390 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f934f610>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_select_after_close">test_transport.py::TransportTest::test_select_after_close</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_select_after_close</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_select_after_close>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a376a0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a35360>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_send_ready">test_transport.py::TransportTest::test_send_ready</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_send_ready</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_send_ready>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a7e7a0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a7fc40>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_server_does_not_respond_to_msg_unimplemented">test_transport.py::TransportTest::test_server_does_not_respond_to_MSG_UNIMPLEMENTED</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_server_does_not_respond_to_MSG_UNIMPLEMENTED</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_server_does_not_respond_to_MSG_UNIMPLEMENTED>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf92a78e0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f92a5b10>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_server_rejects_arbitrary_global_request_without_auth">test_transport.py::TransportTest::test_server_rejects_arbitrary_global_request_without_auth</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_server_rejects_arbitrary_global_request_without_auth</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_server_rejects_arbitrary_global_request_without_auth>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf94247f0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9427d00>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_server_rejects_client_msg_userauth_success">test_transport.py::TransportTest::test_server_rejects_client_MSG_USERAUTH_SUCCESS</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_server_rejects_client_MSG_USERAUTH_SUCCESS</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_server_rejects_client_MSG_USERAUTH_SUCCESS>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf91213f0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9123670>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_server_rejects_open_channel_without_auth">test_transport.py::TransportTest::test_server_rejects_open_channel_without_auth</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_server_rejects_open_channel_without_auth</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_server_rejects_open_channel_without_auth>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf8736ce0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f8735f30>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_server_rejects_port_forward_without_auth">test_transport.py::TransportTest::test_server_rejects_port_forward_without_auth</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_server_rejects_port_forward_without_auth</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_server_rejects_port_forward_without_auth>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf90f25c0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f90f0340>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_server_transports_reject_client_message_types">test_transport.py::TransportTest::test_server_transports_reject_client_message_types</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_server_transports_reject_client_message_types</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_server_transports_reject_client_message_types>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b4f400 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b4d720>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_simple">test_transport.py::TransportTest::test_simple</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_simple</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_simple>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf852f640 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f852c730>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_special">test_transport.py::TransportTest::test_special</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_special</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_special>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf934f3a0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f934d570>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_stderr_select">test_transport.py::TransportTest::test_stderr_select</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_stderr_select</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_stderr_select>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a37220 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a36770>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttest_x11">test_transport.py::TransportTest::test_x11</h3>
<details><summary> <pre>test_transport.py::TransportTest::test_x11</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=test_x11>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b6cdf0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b6f850>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytransporttesttestb_security_options_reset">test_transport.py::TransportTest::testb_security_options_reset</h3>
<details><summary> <pre>test_transport.py::TransportTest::testb_security_options_reset</pre></summary><pre>
self = <tests.test_transport.TransportTest testMethod=testb_security_options_reset>

    def setUp(self):
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
>       self.tc = Transport(self.sockc)

tests/test_transport.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9479b70 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f94798a0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_can_override_packetizer_used">test_transport.py::ServiceRequestingTransportTest::test_can_override_packetizer_used</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_can_override_packetizer_used</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_can_override_packetizer_used>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9517c40 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9516890>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_channel_can_be_used_as_context_manager">test_transport.py::ServiceRequestingTransportTest::test_channel_can_be_used_as_context_manager</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_channel_can_be_used_as_context_manager</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_channel_can_be_used_as_context_manager>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9120910 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9121ff0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_channel_exception">test_transport.py::ServiceRequestingTransportTest::test_channel_exception</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_channel_exception</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_channel_exception>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf95e8790 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f95ea6b0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_channel_send_memoryview">test_transport.py::ServiceRequestingTransportTest::test_channel_send_memoryview</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_channel_send_memoryview</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_channel_send_memoryview>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf85ec2b0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f85ec250>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_channel_send_misc">test_transport.py::ServiceRequestingTransportTest::test_channel_send_misc</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_channel_send_misc</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_channel_send_misc>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9426ce0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9424a00>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_client_does_not_respond_to_msg_unimplemented">test_transport.py::ServiceRequestingTransportTest::test_client_does_not_respond_to_MSG_UNIMPLEMENTED</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_client_does_not_respond_to_MSG_UNIMPLEMENTED</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_client_does_not_respond_to_MSG_UNIMPLEMENTED>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a81a80 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a82c50>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_compression">test_transport.py::ServiceRequestingTransportTest::test_compression</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_compression</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_compression>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf935b430 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9359810>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_compute_key">test_transport.py::ServiceRequestingTransportTest::test_compute_key</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_compute_key</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_compute_key>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf920fbb0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f920d900>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_exec_command">test_transport.py::ServiceRequestingTransportTest::test_exec_command</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_exec_command</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_exec_command>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9478100 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f94784f0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_exit_status">test_transport.py::ServiceRequestingTransportTest::test_exit_status</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_exit_status</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_exit_status>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b4f6a0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b4e0b0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_handshake_timeout">test_transport.py::ServiceRequestingTransportTest::test_handshake_timeout</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_handshake_timeout</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_handshake_timeout>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf920b250 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f920a950>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_invoke_shell">test_transport.py::ServiceRequestingTransportTest::test_invoke_shell</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_invoke_shell</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_invoke_shell>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf942d5d0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f942cb80>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_keepalive">test_transport.py::ServiceRequestingTransportTest::test_keepalive</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_keepalive</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_keepalive>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a370d0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a34c40>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_long_banner">test_transport.py::ServiceRequestingTransportTest::test_long_banner</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_long_banner</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_long_banner>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9c8b1f0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9c8ad40>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_port_forwarding">test_transport.py::ServiceRequestingTransportTest::test_port_forwarding</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_port_forwarding</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_port_forwarding>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9120940 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9123580>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_rekey_deadlock">test_transport.py::ServiceRequestingTransportTest::test_rekey_deadlock</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_rekey_deadlock</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_rekey_deadlock>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a7c4c0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a7db70>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_renegotiate">test_transport.py::ServiceRequestingTransportTest::test_renegotiate</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_renegotiate</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_renegotiate>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9cb3c70 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9cb19f0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_reverse_port_forwarding">test_transport.py::ServiceRequestingTransportTest::test_reverse_port_forwarding</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_reverse_port_forwarding</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_reverse_port_forwarding>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9c749d0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9c74220>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_sanitze_packet_size">test_transport.py::ServiceRequestingTransportTest::test_sanitze_packet_size</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_sanitze_packet_size</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_sanitze_packet_size>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf934ec20 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f934f3a0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_sanitze_window_size">test_transport.py::ServiceRequestingTransportTest::test_sanitze_window_size</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_sanitze_window_size</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_sanitze_window_size>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a83fa0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a82b90>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_security_options">test_transport.py::ServiceRequestingTransportTest::test_security_options</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_security_options</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_security_options>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf85ed1b0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f85ed150>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_select">test_transport.py::ServiceRequestingTransportTest::test_select</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_select</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_select>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9c8aa40 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9c8ba90>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_select_after_close">test_transport.py::ServiceRequestingTransportTest::test_select_after_close</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_select_after_close</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_select_after_close>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b57af0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b578e0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_send_ready">test_transport.py::ServiceRequestingTransportTest::test_send_ready</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_send_ready</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_send_ready>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a7cf10 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a7ded0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_server_does_not_respond_to_msg_unimplemented">test_transport.py::ServiceRequestingTransportTest::test_server_does_not_respond_to_MSG_UNIMPLEMENTED</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_server_does_not_respond_to_MSG_UNIMPLEMENTED</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_server_does_not_respond_to_MSG_UNIMPLEMENTED>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf920ada0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f92099c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_server_rejects_arbitrary_global_request_without_auth">test_transport.py::ServiceRequestingTransportTest::test_server_rejects_arbitrary_global_request_without_auth</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_server_rejects_arbitrary_global_request_without_auth</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_server_rejects_arbitrary_global_request_without_auth>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf947b3a0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f947a9e0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_server_rejects_client_msg_userauth_success">test_transport.py::ServiceRequestingTransportTest::test_server_rejects_client_MSG_USERAUTH_SUCCESS</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_server_rejects_client_MSG_USERAUTH_SUCCESS</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_server_rejects_client_MSG_USERAUTH_SUCCESS>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf868ba00 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f8688580>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_server_rejects_open_channel_without_auth">test_transport.py::ServiceRequestingTransportTest::test_server_rejects_open_channel_without_auth</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_server_rejects_open_channel_without_auth</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_server_rejects_open_channel_without_auth>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf920e8c0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f920eaa0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_server_rejects_port_forward_without_auth">test_transport.py::ServiceRequestingTransportTest::test_server_rejects_port_forward_without_auth</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_server_rejects_port_forward_without_auth</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_server_rejects_port_forward_without_auth>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9a35360 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9a35930>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_server_transports_reject_client_message_types">test_transport.py::ServiceRequestingTransportTest::test_server_transports_reject_client_message_types</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_server_transports_reject_client_message_types</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_server_transports_reject_client_message_types>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b553f0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b565f0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_simple">test_transport.py::ServiceRequestingTransportTest::test_simple</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_simple</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_simple>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9ab2260 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9ab1420>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_special">test_transport.py::ServiceRequestingTransportTest::test_special</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_special</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_special>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf935a0b0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f935a620>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_stderr_select">test_transport.py::ServiceRequestingTransportTest::test_stderr_select</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_stderr_select</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_stderr_select>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf833c6a0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f833c6d0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttest_x11">test_transport.py::ServiceRequestingTransportTest::test_x11</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::test_x11</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=test_x11>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf868bac0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f8688d90>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyservicerequestingtransporttesttestb_security_options_reset">test_transport.py::ServiceRequestingTransportTest::testb_security_options_reset</h3>
<details><summary> <pre>test_transport.py::ServiceRequestingTransportTest::testb_security_options_reset</pre></summary><pre>
self = <tests.test_transport.ServiceRequestingTransportTest testMethod=testb_security_options_reset>

    def setUp(self):
        # Copypasta (Transport init is load-bearing)
        self.socks = LoopSocket()
        self.sockc = LoopSocket()
        self.sockc.link(self.socks)
        # New class who dis
>       self.tc = ServiceRequestingTransport(self.sockc)

tests/test_transport.py:1088: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
paramiko/transport.py:1266: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b6d990 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b6f850>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'ServiceRequestingTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyalgorithmdisablingteststest_implementation_refers_to_public_algo_lists">test_transport.py::AlgorithmDisablingTests::test_implementation_refers_to_public_algo_lists</h3>
<details><summary> <pre>test_transport.py::AlgorithmDisablingTests::test_implementation_refers_to_public_algo_lists</pre></summary><pre>
self = <tests.test_transport.AlgorithmDisablingTests testMethod=test_implementation_refers_to_public_algo_lists>

    def test_implementation_refers_to_public_algo_lists(self):
>       t = Transport(
            sock=Mock(),
            disabled_algorithms={
                "ciphers": ["aes128-cbc"],
                "macs": ["hmac-md5"],
                "keys": ["ssh-dss"],
                "kex": ["diffie-hellman-group14-sha256"],
                "compression": ["zlib"],
            },
        )

tests/test_transport.py:1126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9425780 (unconnected)>
sock = <Mock id='139307151149712'>, default_window_size = 2097152
default_max_packet_size = 32768, gss_kex = False, gss_deleg_creds = True
disabled_algorithms = {'ciphers': ['aes128-cbc'], 'compression': ['zlib'], 'kex': ['diffie-hellman-group14-sha256'], 'keys': ['ssh-dss'], ...}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyalgorithmdisablingteststest_preferred_lists_default_to_private_attribute_contents">test_transport.py::AlgorithmDisablingTests::test_preferred_lists_default_to_private_attribute_contents</h3>
<details><summary> <pre>test_transport.py::AlgorithmDisablingTests::test_preferred_lists_default_to_private_attribute_contents</pre></summary><pre>
self = <tests.test_transport.AlgorithmDisablingTests testMethod=test_preferred_lists_default_to_private_attribute_contents>

    def test_preferred_lists_default_to_private_attribute_contents(self):
>       t = Transport(sock=Mock())

tests/test_transport.py:1094: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9204c40 (unconnected)>
sock = <Mock id='139307148920912'>, default_window_size = 2097152
default_max_packet_size = 32768, gss_kex = False, gss_deleg_creds = True
disabled_algorithms = None, server_sig_algs = True, strict_kex = True
packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyalgorithmdisablingteststest_preferred_lists_filter_disabled_algorithms">test_transport.py::AlgorithmDisablingTests::test_preferred_lists_filter_disabled_algorithms</h3>
<details><summary> <pre>test_transport.py::AlgorithmDisablingTests::test_preferred_lists_filter_disabled_algorithms</pre></summary><pre>
self = <tests.test_transport.AlgorithmDisablingTests testMethod=test_preferred_lists_filter_disabled_algorithms>

    def test_preferred_lists_filter_disabled_algorithms(self):
>       t = Transport(
            sock=Mock(),
            disabled_algorithms={
                "ciphers": ["aes128-cbc"],
                "macs": ["hmac-md5"],
                "keys": ["ssh-dss"],
                "kex": ["diffie-hellman-group14-sha256"],
            },
        )

tests/test_transport.py:1106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf8501b40 (unconnected)>
sock = <Mock id='139307135284224'>, default_window_size = 2097152
default_max_packet_size = 32768, gss_kex = False, gss_deleg_creds = True
disabled_algorithms = {'ciphers': ['aes128-cbc'], 'kex': ['diffie-hellman-group14-sha256'], 'keys': ['ssh-dss'], 'macs': ['hmac-md5']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytestsha2signaturekeyexchangetest_base_case_ssh_rsa_still_used_as_fallback">test_transport.py::TestSHA2SignatureKeyExchange::test_base_case_ssh_rsa_still_used_as_fallback</h3>
<details><summary> <pre>test_transport.py::TestSHA2SignatureKeyExchange::test_base_case_ssh_rsa_still_used_as_fallback</pre></summary><pre>
self = <tests.test_transport.TestSHA2SignatureKeyExchange testMethod=test_base_case_ssh_rsa_still_used_as_fallback>

    @requires_sha1_signing
    def test_base_case_ssh_rsa_still_used_as_fallback(self):
        # Prove that ssh-rsa is used if either, or both, participants have SHA2
        # algorithms disabled
        for which in ("init", "client_init", "server_init"):
>           with server(**{which: _disable_sha2}) as (tc, _):

tests/test_transport.py:1178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9ba5d50 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9ba4df0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True
disabled_algorithms = {'keys': ['rsa-sha2-256', 'rsa-sha2-512']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytestsha2signaturekeyexchangetest_client_sha1_disabled_server_sha2_disabled_no_match">test_transport.py::TestSHA2SignatureKeyExchange::test_client_sha1_disabled_server_sha2_disabled_no_match</h3>
<details><summary> <pre>test_transport.py::TestSHA2SignatureKeyExchange::test_client_sha1_disabled_server_sha2_disabled_no_match</pre></summary><pre>
self = <tests.test_transport.TestSHA2SignatureKeyExchange testMethod=test_client_sha1_disabled_server_sha2_disabled_no_match>

    def test_client_sha1_disabled_server_sha2_disabled_no_match(self):
>       self._incompatible_peers(
            client_init=_disable_sha1, server_init=_disable_sha2
        )

tests/test_transport.py:1218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_transport.py:1194: in _incompatible_peers
    with server(
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf852c9d0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f852c910>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = {'keys': ['ssh-rsa']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytestsha2signaturekeyexchangetest_client_sha2_disabled_server_sha1_disabled_no_match">test_transport.py::TestSHA2SignatureKeyExchange::test_client_sha2_disabled_server_sha1_disabled_no_match</h3>
<details><summary> <pre>test_transport.py::TestSHA2SignatureKeyExchange::test_client_sha2_disabled_server_sha1_disabled_no_match</pre></summary><pre>
self = <tests.test_transport.TestSHA2SignatureKeyExchange testMethod=test_client_sha2_disabled_server_sha1_disabled_no_match>

    def test_client_sha2_disabled_server_sha1_disabled_no_match(self):
>       self._incompatible_peers(
            client_init=_disable_sha2, server_init=_disable_sha1
        )

tests/test_transport.py:1213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_transport.py:1194: in _incompatible_peers
    with server(
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9517220 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9517640>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True
disabled_algorithms = {'keys': ['rsa-sha2-256', 'rsa-sha2-512']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytestsha2signaturekeyexchangetest_explicit_client_hostkey_not_limited">test_transport.py::TestSHA2SignatureKeyExchange::test_explicit_client_hostkey_not_limited</h3>
<details><summary> <pre>test_transport.py::TestSHA2SignatureKeyExchange::test_explicit_client_hostkey_not_limited</pre></summary><pre>
self = <tests.test_transport.TestSHA2SignatureKeyExchange testMethod=test_explicit_client_hostkey_not_limited>

    def test_explicit_client_hostkey_not_limited(self):
        # Be very explicit about the hostkey on BOTH ends,
        # and ensure it still ends up choosing sha2-512.
        # (This is a regression test vs previous implementation which overwrote
        # the entire preferred-hostkeys structure when given an explicit key as
        # a client.)
        hostkey = RSAKey.from_private_key_file(_support("rsa.key"))
        connect = dict(
            hostkey=hostkey, username="slowdive", password="pygmalion"
        )
>       with server(hostkey=hostkey, connect=connect) as (tc, _):

tests/test_transport.py:1232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf90f1000 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f90f2440>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytestsha2signaturekeyexchangetest_kex_with_sha2_256">test_transport.py::TestSHA2SignatureKeyExchange::test_kex_with_sha2_256</h3>
<details><summary> <pre>test_transport.py::TestSHA2SignatureKeyExchange::test_kex_with_sha2_256</pre></summary><pre>
self = <tests.test_transport.TestSHA2SignatureKeyExchange testMethod=test_kex_with_sha2_256>

    def test_kex_with_sha2_256(self):
        # No 512 -> you get 256
>       with server(
            init=dict(disabled_algorithms=dict(keys=["rsa-sha2-512"]))
        ) as (tc, _):

tests/test_transport.py:1188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b03a60 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b00190>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = {'keys': ['rsa-sha2-512']}
server_sig_algs = True, strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytestsha2signaturekeyexchangetest_kex_with_sha2_512">test_transport.py::TestSHA2SignatureKeyExchange::test_kex_with_sha2_512</h3>
<details><summary> <pre>test_transport.py::TestSHA2SignatureKeyExchange::test_kex_with_sha2_512</pre></summary><pre>
self = <tests.test_transport.TestSHA2SignatureKeyExchange testMethod=test_kex_with_sha2_512>

    def test_kex_with_sha2_512(self):
        # It's the default!
>       with server() as (tc, _):

tests/test_transport.py:1183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9016bc0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9017160>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytestextinfotest_client_uses_server_sig_algs_for_pubkey_auth">test_transport.py::TestExtInfo::test_client_uses_server_sig_algs_for_pubkey_auth</h3>
<details><summary> <pre>test_transport.py::TestExtInfo::test_client_uses_server_sig_algs_for_pubkey_auth</pre></summary><pre>
self = <tests.test_transport.TestExtInfo testMethod=test_client_uses_server_sig_algs_for_pubkey_auth>

    def test_client_uses_server_sig_algs_for_pubkey_auth(self):
        privkey = RSAKey.from_private_key_file(_support("rsa.key"))
>       with server(
            pubkeys=[privkey],
            connect=dict(pkey=privkey),
            server_init=dict(
                disabled_algorithms=dict(pubkeys=["rsa-sha2-512"])
            ),
        ) as (tc, _):

tests/test_transport.py:1251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b6c3a0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b6f6d0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpytestextinfotest_ext_info_handshake_exposed_in_client_kexinit">test_transport.py::TestExtInfo::test_ext_info_handshake_exposed_in_client_kexinit</h3>
<details><summary> <pre>test_transport.py::TestExtInfo::test_ext_info_handshake_exposed_in_client_kexinit</pre></summary><pre>
self = <tests.test_transport.TestExtInfo testMethod=test_ext_info_handshake_exposed_in_client_kexinit>

    def test_ext_info_handshake_exposed_in_client_kexinit(self):
>       with server() as (tc, _):

tests/test_transport.py:1238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9ba5210 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9ba5ba0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_kex_algos_includes_kex_strict_c">test_transport.py::TestStrictKex::test_kex_algos_includes_kex_strict_c</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_kex_algos_includes_kex_strict_c</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9ab29e0>

    def test_kex_algos_includes_kex_strict_c(self):
>       with server() as (tc, _):

tests/test_transport.py:1280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b577f0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b54700>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_mode_agreementtrue-true">test_transport.py::TestStrictKex::test_mode_agreement[True-True]</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_mode_agreement[True-True]</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9ab39d0>
server_active = True, client_active = True

    @mark.parametrize(
        "server_active,client_active",
        itertools.product([True, False], repeat=2),
    )
    def test_mode_agreement(self, server_active, client_active):
>       with server(
            server_init=dict(strict_kex=server_active),
            client_init=dict(strict_kex=client_active),
        ) as (tc, ts):

tests/test_transport.py:1289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf859c790 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f859f7c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_mode_agreementtrue-false">test_transport.py::TestStrictKex::test_mode_agreement[True-False]</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_mode_agreement[True-False]</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9ab3a30>
server_active = True, client_active = False

    @mark.parametrize(
        "server_active,client_active",
        itertools.product([True, False], repeat=2),
    )
    def test_mode_agreement(self, server_active, client_active):
>       with server(
            server_init=dict(strict_kex=server_active),
            client_init=dict(strict_kex=client_active),
        ) as (tc, ts):

tests/test_transport.py:1289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9424460 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f94253c0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = False, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_mode_agreementfalse-true">test_transport.py::TestStrictKex::test_mode_agreement[False-True]</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_mode_agreement[False-True]</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9ab1810>
server_active = False, client_active = True

    @mark.parametrize(
        "server_active,client_active",
        itertools.product([True, False], repeat=2),
    )
    def test_mode_agreement(self, server_active, client_active):
>       with server(
            server_init=dict(strict_kex=server_active),
            client_init=dict(strict_kex=client_active),
        ) as (tc, ts):

tests/test_transport.py:1289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b557b0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b578b0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_mode_agreementfalse-false">test_transport.py::TestStrictKex::test_mode_agreement[False-False]</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_mode_agreement[False-False]</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9ab3070>
server_active = False, client_active = False

    @mark.parametrize(
        "server_active,client_active",
        itertools.product([True, False], repeat=2),
    )
    def test_mode_agreement(self, server_active, client_active):
>       with server(
            server_init=dict(strict_kex=server_active),
            client_init=dict(strict_kex=client_active),
        ) as (tc, ts):

tests/test_transport.py:1289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9057ac0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9054370>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = False, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_mode_advertised_by_default">test_transport.py::TestStrictKex::test_mode_advertised_by_default</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_mode_advertised_by_default</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9ab2710>

    def test_mode_advertised_by_default(self):
        # NOTE: no explicit strict_kex overrides...
>       with server() as (tc, ts):

tests/test_transport.py:1302: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf92031c0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9200eb0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_messageordererror_non_kex_messages_in_initial_kex90">test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[90]</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[90]</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9ab1c30>, ptype = 90

    @mark.parametrize(
        "ptype",
        (
            # "normal" but definitely out-of-order message
            MSG_CHANNEL_OPEN,
            # Normally ignored, but not in this case
            MSG_IGNORE,
            # Normally triggers debug parsing, but not in this case
            MSG_DEBUG,
            # Normally ignored, but...you get the idea
            MSG_UNIMPLEMENTED,
            # Not real, so would normally trigger us /sending/
            # MSG_UNIMPLEMENTED, but...
            MSG_FUGGEDABOUTIT,
        ),
    )
    def test_MessageOrderError_non_kex_messages_in_initial_kex(self, ptype):
        class AttackTransport(Transport):
            # Easiest apparent spot on server side which is:
            # - late enough for both ends to have handshook on strict mode
            # - early enough to be in the window of opportunity for Terrapin
            # attack; essentially during actual kex, when the engine is
            # waiting for things like MSG_KEXECDH_REPLY (for eg curve25519).
            def _negotiate_keys(self, m):
                self.clear_to_send_lock.acquire()
                try:
                    self.clear_to_send.clear()
                finally:
                    self.clear_to_send_lock.release()
                if self.local_kex_init is None:
                    # remote side wants to renegotiate
                    self._send_kex_init()
                self._parse_kex_init(m)
                # Here, we would normally kick over to kex_engine, but instead
                # we want the server to send the OOO message.
                m = Message()
                m.add_byte(byte_chr(ptype))
                # rest of packet unnecessary...
                self._send_message(m)

        with raises(MessageOrderError):
>           with server(server_transport_factory=AttackTransport) as (tc, _):

tests/test_transport.py:1353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf935ac20 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f935afb0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_messageordererror_non_kex_messages_in_initial_kex2">test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[2]</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[2]</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9ab3940>, ptype = 2

    @mark.parametrize(
        "ptype",
        (
            # "normal" but definitely out-of-order message
            MSG_CHANNEL_OPEN,
            # Normally ignored, but not in this case
            MSG_IGNORE,
            # Normally triggers debug parsing, but not in this case
            MSG_DEBUG,
            # Normally ignored, but...you get the idea
            MSG_UNIMPLEMENTED,
            # Not real, so would normally trigger us /sending/
            # MSG_UNIMPLEMENTED, but...
            MSG_FUGGEDABOUTIT,
        ),
    )
    def test_MessageOrderError_non_kex_messages_in_initial_kex(self, ptype):
        class AttackTransport(Transport):
            # Easiest apparent spot on server side which is:
            # - late enough for both ends to have handshook on strict mode
            # - early enough to be in the window of opportunity for Terrapin
            # attack; essentially during actual kex, when the engine is
            # waiting for things like MSG_KEXECDH_REPLY (for eg curve25519).
            def _negotiate_keys(self, m):
                self.clear_to_send_lock.acquire()
                try:
                    self.clear_to_send.clear()
                finally:
                    self.clear_to_send_lock.release()
                if self.local_kex_init is None:
                    # remote side wants to renegotiate
                    self._send_kex_init()
                self._parse_kex_init(m)
                # Here, we would normally kick over to kex_engine, but instead
                # we want the server to send the OOO message.
                m = Message()
                m.add_byte(byte_chr(ptype))
                # rest of packet unnecessary...
                self._send_message(m)

        with raises(MessageOrderError):
>           with server(server_transport_factory=AttackTransport) as (tc, _):

tests/test_transport.py:1353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b01de0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b01990>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_messageordererror_non_kex_messages_in_initial_kex4">test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[4]</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[4]</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9b02410>, ptype = 4

    @mark.parametrize(
        "ptype",
        (
            # "normal" but definitely out-of-order message
            MSG_CHANNEL_OPEN,
            # Normally ignored, but not in this case
            MSG_IGNORE,
            # Normally triggers debug parsing, but not in this case
            MSG_DEBUG,
            # Normally ignored, but...you get the idea
            MSG_UNIMPLEMENTED,
            # Not real, so would normally trigger us /sending/
            # MSG_UNIMPLEMENTED, but...
            MSG_FUGGEDABOUTIT,
        ),
    )
    def test_MessageOrderError_non_kex_messages_in_initial_kex(self, ptype):
        class AttackTransport(Transport):
            # Easiest apparent spot on server side which is:
            # - late enough for both ends to have handshook on strict mode
            # - early enough to be in the window of opportunity for Terrapin
            # attack; essentially during actual kex, when the engine is
            # waiting for things like MSG_KEXECDH_REPLY (for eg curve25519).
            def _negotiate_keys(self, m):
                self.clear_to_send_lock.acquire()
                try:
                    self.clear_to_send.clear()
                finally:
                    self.clear_to_send_lock.release()
                if self.local_kex_init is None:
                    # remote side wants to renegotiate
                    self._send_kex_init()
                self._parse_kex_init(m)
                # Here, we would normally kick over to kex_engine, but instead
                # we want the server to send the OOO message.
                m = Message()
                m.add_byte(byte_chr(ptype))
                # rest of packet unnecessary...
                self._send_message(m)

        with raises(MessageOrderError):
>           with server(server_transport_factory=AttackTransport) as (tc, _):

tests/test_transport.py:1353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf906b220 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9068e50>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_messageordererror_non_kex_messages_in_initial_kex3">test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[3]</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[3]</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9b02380>, ptype = 3

    @mark.parametrize(
        "ptype",
        (
            # "normal" but definitely out-of-order message
            MSG_CHANNEL_OPEN,
            # Normally ignored, but not in this case
            MSG_IGNORE,
            # Normally triggers debug parsing, but not in this case
            MSG_DEBUG,
            # Normally ignored, but...you get the idea
            MSG_UNIMPLEMENTED,
            # Not real, so would normally trigger us /sending/
            # MSG_UNIMPLEMENTED, but...
            MSG_FUGGEDABOUTIT,
        ),
    )
    def test_MessageOrderError_non_kex_messages_in_initial_kex(self, ptype):
        class AttackTransport(Transport):
            # Easiest apparent spot on server side which is:
            # - late enough for both ends to have handshook on strict mode
            # - early enough to be in the window of opportunity for Terrapin
            # attack; essentially during actual kex, when the engine is
            # waiting for things like MSG_KEXECDH_REPLY (for eg curve25519).
            def _negotiate_keys(self, m):
                self.clear_to_send_lock.acquire()
                try:
                    self.clear_to_send.clear()
                finally:
                    self.clear_to_send_lock.release()
                if self.local_kex_init is None:
                    # remote side wants to renegotiate
                    self._send_kex_init()
                self._parse_kex_init(m)
                # Here, we would normally kick over to kex_engine, but instead
                # we want the server to send the OOO message.
                m = Message()
                m.add_byte(byte_chr(ptype))
                # rest of packet unnecessary...
                self._send_message(m)

        with raises(MessageOrderError):
>           with server(server_transport_factory=AttackTransport) as (tc, _):

tests/test_transport.py:1353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf868aef0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f8689d80>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_messageordererror_non_kex_messages_in_initial_kex253">test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[253]</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_MessageOrderError_non_kex_messages_in_initial_kex[253]</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9b02440>
ptype = 253

    @mark.parametrize(
        "ptype",
        (
            # "normal" but definitely out-of-order message
            MSG_CHANNEL_OPEN,
            # Normally ignored, but not in this case
            MSG_IGNORE,
            # Normally triggers debug parsing, but not in this case
            MSG_DEBUG,
            # Normally ignored, but...you get the idea
            MSG_UNIMPLEMENTED,
            # Not real, so would normally trigger us /sending/
            # MSG_UNIMPLEMENTED, but...
            MSG_FUGGEDABOUTIT,
        ),
    )
    def test_MessageOrderError_non_kex_messages_in_initial_kex(self, ptype):
        class AttackTransport(Transport):
            # Easiest apparent spot on server side which is:
            # - late enough for both ends to have handshook on strict mode
            # - early enough to be in the window of opportunity for Terrapin
            # attack; essentially during actual kex, when the engine is
            # waiting for things like MSG_KEXECDH_REPLY (for eg curve25519).
            def _negotiate_keys(self, m):
                self.clear_to_send_lock.acquire()
                try:
                    self.clear_to_send.clear()
                finally:
                    self.clear_to_send_lock.release()
                if self.local_kex_init is None:
                    # remote side wants to renegotiate
                    self._send_kex_init()
                self._parse_kex_init(m)
                # Here, we would normally kick over to kex_engine, but instead
                # we want the server to send the OOO message.
                m = Message()
                m.add_byte(byte_chr(ptype))
                # rest of packet unnecessary...
                self._send_message(m)

        with raises(MessageOrderError):
>           with server(server_transport_factory=AttackTransport) as (tc, _):

tests/test_transport.py:1353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9ba5630 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9ba5480>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_sshexception_raised_on_out_of_order_messages_when_not_strict">test_transport.py::TestStrictKex::test_SSHException_raised_on_out_of_order_messages_when_not_strict</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_SSHException_raised_on_out_of_order_messages_when_not_strict</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9b027a0>

    def test_SSHException_raised_on_out_of_order_messages_when_not_strict(
        self,
    ):
        # This is kind of dumb (either situation is still fatal!) but whatever,
        # may as well be strict with our new strict flag...
        with raises(SSHException) as info:  # would be true either way, but
>           with server(
                client_init=dict(strict_kex=False),
            ) as (tc, _):

tests/test_transport.py:1362: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b57490 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b578b0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = False, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_error_not_raised_when_kexinit_not_seq_0_but_unstrict">test_transport.py::TestStrictKex::test_error_not_raised_when_kexinit_not_seq_0_but_unstrict</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_error_not_raised_when_kexinit_not_seq_0_but_unstrict</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9b02c80>

    def test_error_not_raised_when_kexinit_not_seq_0_but_unstrict(self):
>       with server(
            client_init=dict(
                # Disable strict kex
                strict_kex=False,
                # Give our clientside a packetizer that sets all kexinit
                # Message objects to have .seqno==17, which would trigger the
                # new logic if we'd forgotten to wrap it in strict-kex check
                packetizer_class=BadSeqPacketizer,
            ),
        ):

tests/test_transport.py:1370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf98e0250 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f98e18a0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = False
packetizer_class = <class 'tests.test_transport.BadSeqPacketizer'>

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_messageordererror_raised_when_kexinit_not_seq_0_and_strict">test_transport.py::TestStrictKex::test_MessageOrderError_raised_when_kexinit_not_seq_0_and_strict</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_MessageOrderError_raised_when_kexinit_not_seq_0_and_strict</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9b02b30>

    def test_MessageOrderError_raised_when_kexinit_not_seq_0_and_strict(self):
        with raises(MessageOrderError):
>           with server(
                # Give our clientside a packetizer that sets all kexinit
                # Message objects to have .seqno==17, which should trigger the
                # new logic (given we are NOT disabling strict-mode)
                client_init=dict(packetizer_class=BadSeqPacketizer),
            ):

tests/test_transport.py:1384: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9b4c100 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9b4fd90>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True
packetizer_class = <class 'tests.test_transport.BadSeqPacketizer'>

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_sequence_numbers_reset_on_newkeys_when_strict">test_transport.py::TestStrictKex::test_sequence_numbers_reset_on_newkeys_when_strict</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_sequence_numbers_reset_on_newkeys_when_strict</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9ab3d60>

    def test_sequence_numbers_reset_on_newkeys_when_strict(self):
>       with server(defer=True) as (tc, ts):

tests/test_transport.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf92a41c0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f92a7f40>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = True, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_sequence_numbers_not_reset_on_newkeys_when_not_strict">test_transport.py::TestStrictKex::test_sequence_numbers_not_reset_on_newkeys_when_not_strict</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_sequence_numbers_not_reset_on_newkeys_when_not_strict</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9ab0040>

    def test_sequence_numbers_not_reset_on_newkeys_when_not_strict(self):
>       with server(defer=True, client_init=dict(strict_kex=False)) as (
            tc,
            ts,
        ):

tests/test_transport.py:1404: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf90567d0 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f9057fa0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = False, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'Transport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_transportpyteststrictkextest_sequence_number_rollover_detected">test_transport.py::TestStrictKex::test_sequence_number_rollover_detected</h3>
<details><summary> <pre>test_transport.py::TestStrictKex::test_sequence_number_rollover_detected</pre></summary><pre>
self = <tests.test_transport.TestStrictKex object at 0x7eb2f9b02b60>

    def test_sequence_number_rollover_detected(self):
        class RolloverTransport(Transport):
            def __init__(self, *args, **kwargs):
                super().__init__(*args, **kwargs)
                # Induce an about-to-rollover seqno, such that it rolls over
                # during initial kex. (Sequence numbers are uint32, so we need
                # the largest possible 32bit integer such that incrementing it
                # will roll over to 0.)
                last_seq = 2**32 - 1
                setattr(
                    self.packetizer,
                    "_Packetizer__sequence_number_in",
                    last_seq,
                )
                setattr(
                    self.packetizer,
                    "_Packetizer__sequence_number_out",
                    last_seq,
                )

        with raises(
            SSHException,
            match=r"Sequence number rolled over during initial kex!",
        ):
>           with server(
                client_init=dict(
                    # Disable strict kex - this should happen always
                    strict_kex=False,
                ),
                # Transport which tickles its packetizer seqno's
                transport_factory=RolloverTransport,
            ):

tests/test_transport.py:1440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
tests/_util.py:407: in server
    tc = transport_factory(sockc, **dict(init, **client_init))
tests/test_transport.py:1419: in __init__
    super().__init__(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <paramiko.Transport at 0xf9359a20 (unconnected)>
sock = <tests._loop.LoopSocket object at 0x7eb2f935b3d0>
default_window_size = 2097152, default_max_packet_size = 32768, gss_kex = False
gss_deleg_creds = True, disabled_algorithms = None, server_sig_algs = True
strict_kex = False, packetizer_class = None

    def __init__(self, sock, default_window_size=DEFAULT_WINDOW_SIZE, default_max_packet_size=DEFAULT_MAX_PACKET_SIZE, gss_kex=False, gss_deleg_creds=True, disabled_algorithms=None, server_sig_algs=True, strict_kex=True, packetizer_class=None):
        """
        Create a new SSH session over an existing socket, or socket-like
        object.  This only creates the `.Transport` object; it doesn't begin
        the SSH session yet.  Use `connect` or `start_client` to begin a client
        session, or `start_server` to begin a server session.

        If the object is not actually a socket, it must have the following
        methods:

        - ``send(bytes)``: Writes from 1 to ``len(bytes)`` bytes, and returns
          an int representing the number of bytes written.  Returns
          0 or raises ``EOFError`` if the stream has been closed.
        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a
          string.  Returns 0 or raises ``EOFError`` if the stream has been
          closed.
        - ``close()``: Closes the socket.
        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.

        For ease of use, you may also pass in an address (as a tuple) or a host
        string as the ``sock`` argument.  (A host string is a hostname with an
        optional port (separated by ``":"``) which will be converted into a
        tuple of ``(hostname, port)``.)  A socket will be connected to this
        address and used for communication.  Exceptions from the ``socket``
        call may be thrown in this case.

        .. note::
            Modifying the the window and packet sizes might have adverse
            effects on your channels created from this transport. The default
            values are the same as in the OpenSSH code base and have been
            battle tested.

        :param socket sock:
            a socket or socket-like object to create the session over.
        :param int default_window_size:
            sets the default window size on the transport. (defaults to
            2097152)
        :param int default_max_packet_size:
            sets the default max packet size on the transport. (defaults to
            32768)
        :param bool gss_kex:
            Whether to enable GSSAPI key exchange when GSSAPI is in play.
            Default: ``False``.
        :param bool gss_deleg_creds:
            Whether to enable GSSAPI credential delegation when GSSAPI is in
            play. Default: ``True``.
        :param dict disabled_algorithms:
            If given, must be a dictionary mapping algorithm type to an
            iterable of algorithm identifiers, which will be disabled for the
            lifetime of the transport.

            Keys should match the last word in the class' builtin algorithm
            tuple attributes, such as ``"ciphers"`` to disable names within
            ``_preferred_ciphers``; or ``"kex"`` to disable something defined
            inside ``_preferred_kex``. Values should exactly match members of
            the matching attribute.

            For example, if you need to disable
            ``diffie-hellman-group16-sha512`` key exchange (perhaps because
            your code talks to a server which implements it differently from
            Paramiko), specify ``disabled_algorithms={"kex":
            ["diffie-hellman-group16-sha512"]}``.
        :param bool server_sig_algs:
            Whether to send an extra message to compatible clients, in server
            mode, with a list of supported pubkey algorithms. Default:
            ``True``.
        :param bool strict_kex:
            Whether to advertise (and implement, if client also advertises
            support for) a "strict kex" mode for safer handshaking. Default:
            ``True``.
        :param packetizer_class:
            Which class to use for instantiating the internal packet handler.
            Default: ``None`` (i.e.: use `Packetizer` as normal).

        .. versionchanged:: 1.15
            Added the ``default_window_size`` and ``default_max_packet_size``
            arguments.
        .. versionchanged:: 1.15
            Added the ``gss_kex`` and ``gss_deleg_creds`` kwargs.
        .. versionchanged:: 2.6
            Added the ``disabled_algorithms`` kwarg.
        .. versionchanged:: 2.9
            Added the ``server_sig_algs`` kwarg.
        .. versionchanged:: 3.4
            Added the ``strict_kex`` kwarg.
        .. versionchanged:: 3.4
            Added the ``packetizer_class`` kwarg.
        """
        self.active = False
        self.hostname = None
        self.server_extensions = {}
        self.advertise_strict_kex = strict_kex
        self.agreed_on_strict_kex = False
        if isinstance(sock, str):
            hl = sock.split(':', 1)
            self.hostname = hl[0]
            if len(hl) == 1:
                sock = (hl[0], 22)
            else:
                sock = (hl[0], int(hl[1]))
        if type(sock) is tuple:
            hostname, port = sock
            self.hostname = hostname
            reason = 'No suitable address family'
            addrinfos = socket.getaddrinfo(hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
            for family, socktype, proto, canonname, sockaddr in addrinfos:
                if socktype == socket.SOCK_STREAM:
                    af = family
                    sock = socket.socket(af, socket.SOCK_STREAM)
                    try:
                        sock.connect((hostname, port))
                    except socket.error as e:
                        reason = str(e)
                    else:
                        break
            else:
                raise SSHException('Unable to connect to {}: {}'.format(hostname, reason))
        threading.Thread.__init__(self)
        self.daemon = True
        self.sock = sock
        self.sock.settimeout(self._active_check_timeout)
        self.packetizer = (packetizer_class or Packetizer)(sock)
        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID
        self.remote_version = ''
        self.local_cipher = self.remote_cipher = ''
        self.local_kex_init = self.remote_kex_init = None
        self.local_mac = self.remote_mac = None
        self.local_compression = self.remote_compression = None
        self.session_id = None
        self.host_key_type = None
        self.host_key = None
        self.use_gss_kex = gss_kex
        self.gss_kex_used = False
        self.kexgss_ctxt = None
        self.gss_host = None
        if self.use_gss_kex:
            self.kexgss_ctxt = GSSAuth('gssapi-keyex', gss_deleg_creds)
            self._preferred_kex = self._preferred_gsskex + self._preferred_kex
        self.kex_engine = None
        self.H = None
        self.K = None
        self.initial_kex_done = False
        self.in_kex = False
        self.authenticated = False
        self._expected_packet = tuple()
        self.lock = threading.Lock()
        self._channels = ChannelMap()
        self.channel_events = {}
        self.channels_seen = {}
        self._channel_counter = 0
        self.default_max_packet_size = default_max_packet_size
        self.default_window_size = default_window_size
        self._forward_agent_handler = None
        self._x11_handler = None
        self._tcp_handler = None
        self.saved_exception = None
        self.clear_to_send = threading.Event()
        self.clear_to_send_lock = threading.Lock()
        self.clear_to_send_timeout = 30.0
        self.log_name = 'paramiko.transport'
        self.logger = util.get_logger(self.log_name)
        self.packetizer.set_log(self.logger)
        self.auth_handler = None
        self.global_response = None
        self.completion_event = None
        self.banner_timeout = 15
        self.handshake_timeout = 15
        self.auth_timeout = 30
        self.channel_timeout = 60 * 60
        self.disabled_algorithms = disabled_algorithms or {}
        self.server_sig_algs = server_sig_algs
        self.server_mode = False
        self.server_object = None
        self.server_key_dict = {}
        self.server_accepts = []
        self.server_accept_cv = threading.Condition(self.lock)
        self.subsystem_table = {}
>       self._handler_table = {MSG_EXT_INFO: self._parse_ext_info, MSG_NEWKEYS: self._parse_newkeys, MSG_GLOBAL_REQUEST: self._parse_global_request, MSG_REQUEST_SUCCESS: self._parse_request_success, MSG_REQUEST_FAILURE: self._parse_request_failure, MSG_CHANNEL_OPEN_SUCCESS: self._parse_channel_open_success, MSG_CHANNEL_OPEN_FAILURE: self._parse_channel_open_failure, MSG_CHANNEL_OPEN: self._parse_channel_open, MSG_KEXINIT: self._negotiate_keys}
E       AttributeError: 'RolloverTransport' object has no attribute '_parse_ext_info'

paramiko/transport.py:262: AttributeError
</pre>
</details>
<h3 id="test_utilpyutiltesttest_generate_key_bytes">test_util.py::UtilTest::test_generate_key_bytes</h3>
<details><summary> <pre>test_util.py::UtilTest::test_generate_key_bytes</pre></summary><pre>
self = <tests.test_util.UtilTest testMethod=test_generate_key_bytes>

    def test_generate_key_bytes(self):
        key_bytes = paramiko.util.generate_key_bytes(
            sha1, b"ABCDEFGH", "This is my secret passphrase.", 64
        )
>       hexy = "".join([f"{byte:02x}" for byte in key_bytes])
E       TypeError: 'NoneType' object is not iterable

tests/test_util.py:102: TypeError
</pre>
</details>
<h3 id="test_utilpyutiltesttest_host_keys">test_util.py::UtilTest::test_host_keys</h3>
<details><summary> <pre>test_util.py::UtilTest::test_host_keys</pre></summary><pre>
self = <tests.test_util.UtilTest testMethod=test_host_keys>

    def test_host_keys(self):
        with open("hostfile.temp", "w") as f:
            f.write(test_hosts_file)
        try:
            hostdict = paramiko.util.load_host_keys("hostfile.temp")
>           assert 2 == len(hostdict)
E           TypeError: object of type 'NoneType' has no len()

tests/test_util.py:111: TypeError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/paramiko/auth_handler.py b/paramiko/auth_handler.py</span>
<span class="gh">index bab316dc..aca8902c 100644</span>
<span class="gd">--- a/paramiko/auth_handler.py</span>
<span class="gi">+++ b/paramiko/auth_handler.py</span>
<span class="gu">@@ -58,6 +58,72 @@ class GssapiWithMicAuthHandler:</span>
<span class="w"> </span>    def __init__(self, delegate, sshgss):
<span class="w"> </span>        self._delegate = delegate
<span class="w"> </span>        self.sshgss = sshgss
<span class="gi">+</span>
<span class="gi">+    def _parse_service_request(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Parse incoming service request.&quot;&quot;&quot;</span>
<span class="gi">+        service = m.get_text()</span>
<span class="gi">+        if self._delegate.transport.server_mode and service == &#39;ssh-userauth&#39;:</span>
<span class="gi">+            # Accept service request</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_SERVICE_ACCEPT)</span>
<span class="gi">+            m.add_string(&#39;ssh-userauth&#39;)</span>
<span class="gi">+            self._delegate.transport._send_message(m)</span>
<span class="gi">+            return</span>
<span class="gi">+        self._delegate.transport._disconnect_reason = DISCONNECT_SERVICE_NOT_AVAILABLE</span>
<span class="gi">+        raise SSHException(&#39;Service request &quot;{}&quot; not supported&#39;.format(service))</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_request(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Parse incoming userauth request.&quot;&quot;&quot;</span>
<span class="gi">+        username = m.get_text()</span>
<span class="gi">+        service = m.get_text()</span>
<span class="gi">+        method = m.get_text()</span>
<span class="gi">+        if method != &#39;gssapi-with-mic&#39;:</span>
<span class="gi">+            return self._delegate._parse_userauth_request(m)</span>
<span class="gi">+        self._delegate.auth_username = username</span>
<span class="gi">+        self._delegate.transport.gss_kex_used = True</span>
<span class="gi">+        self._delegate.transport._expected_packet = (MSG_USERAUTH_GSSAPI_TOKEN,)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.sshgss.ssh_init_sec_context()</span>
<span class="gi">+            token = self.sshgss.ssh_get_mic(self._delegate.transport.session_id)</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_USERAUTH_GSSAPI_RESPONSE)</span>
<span class="gi">+            m.add_string(token)</span>
<span class="gi">+            self._delegate.transport._send_message(m)</span>
<span class="gi">+        except GSS_EXCEPTIONS as e:</span>
<span class="gi">+            self._delegate.transport.saved_exception = e</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_gssapi_token(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Parse incoming GSSAPI token.&quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            token = m.get_string()</span>
<span class="gi">+            self.sshgss.ssh_init_sec_context(token)</span>
<span class="gi">+            token = self.sshgss.ssh_get_mic(self._delegate.transport.session_id)</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_USERAUTH_GSSAPI_TOKEN)</span>
<span class="gi">+            m.add_string(token)</span>
<span class="gi">+            self._delegate.transport._send_message(m)</span>
<span class="gi">+        except GSS_EXCEPTIONS as e:</span>
<span class="gi">+            self._delegate.transport.saved_exception = e</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_userauth_gssapi_mic(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Parse incoming GSSAPI MIC.&quot;&quot;&quot;</span>
<span class="gi">+        mic_token = m.get_string()</span>
<span class="gi">+        if self.sshgss.ssh_check_mic(self._delegate.transport.session_id, mic_token):</span>
<span class="gi">+            m = Message()</span>
<span class="gi">+            m.add_byte(cMSG_USERAUTH_SUCCESS)</span>
<span class="gi">+            self._delegate.transport._send_message(m)</span>
<span class="gi">+            self._delegate.transport._auth_handler = self._delegate</span>
<span class="gi">+            self._delegate.transport.auth_handler = self._delegate</span>
<span class="gi">+            self._delegate.transport._expected_packet = tuple(self._delegate.transport._preferred_packets)</span>
<span class="gi">+            self._delegate.transport.authenticated = True</span>
<span class="gi">+            self._delegate.transport._log(INFO, &#39;Authentication successful.&#39;)</span>
<span class="gi">+            self._delegate.transport.auth_event.set()</span>
<span class="gi">+            self._delegate.transport.auth_event = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SSHException(&#39;GSSAPI MIC check failed&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>    __handler_table = {MSG_SERVICE_REQUEST: _parse_service_request, MSG_USERAUTH_REQUEST: _parse_userauth_request, MSG_USERAUTH_GSSAPI_TOKEN: _parse_userauth_gssapi_token, MSG_USERAUTH_GSSAPI_MIC: _parse_userauth_gssapi_mic}

<span class="w"> </span>class AuthOnlyHandler(AuthHandler):
<span class="gh">diff --git a/paramiko/auth_strategy.py b/paramiko/auth_strategy.py</span>
<span class="gh">index 808a2ff8..3f6b59d3 100644</span>
<span class="gd">--- a/paramiko/auth_strategy.py</span>
<span class="gi">+++ b/paramiko/auth_strategy.py</span>
<span class="gu">@@ -147,7 +147,7 @@ class AuthResult(list):</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return &#39;\n&#39;.join((f&#39;{x.source} -&gt; {x.result or &#39;success&#39;}&#39; for x in self))</span>
<span class="gi">+        return &#39;\n&#39;.join((f&quot;{x.source} -&gt; {x.result or &#39;success&#39;}&quot; for x in self))</span>

<span class="w"> </span>class AuthFailure(AuthenticationException):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gh">diff --git a/paramiko/channel.py b/paramiko/channel.py</span>
<span class="gh">index aea2a48a..137f01a1 100644</span>
<span class="gd">--- a/paramiko/channel.py</span>
<span class="gi">+++ b/paramiko/channel.py</span>
<span class="gu">@@ -378,6 +378,47 @@ class Channel(ClosingContextManager):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gi">+    def _request_success(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Handle a success response from the remote server.&quot;&quot;&quot;</span>
<span class="gi">+        self.event.set()</span>
<span class="gi">+        self.event_ready = True</span>
<span class="gi">+</span>
<span class="gi">+    def _request_failed(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Handle a failure response from the remote server.&quot;&quot;&quot;</span>
<span class="gi">+        self.event.set()</span>
<span class="gi">+        self.event_ready = False</span>
<span class="gi">+</span>
<span class="gi">+    def _feed(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Feed data from the remote server into our buffer.&quot;&quot;&quot;</span>
<span class="gi">+        data = m.get_binary()</span>
<span class="gi">+        self.in_buffer.feed(data)</span>
<span class="gi">+</span>
<span class="gi">+    def _feed_extended(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Feed extended data from the remote server into our buffer.&quot;&quot;&quot;</span>
<span class="gi">+        code = m.get_int()</span>
<span class="gi">+        data = m.get_binary()</span>
<span class="gi">+        if code != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+        self.in_stderr_buffer.feed(data)</span>
<span class="gi">+</span>
<span class="gi">+    def _window_adjust(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Handle a window adjustment from the remote server.&quot;&quot;&quot;</span>
<span class="gi">+        nbytes = m.get_int()</span>
<span class="gi">+        self.out_window_size += nbytes</span>
<span class="gi">+        self.out_buffer_cv.notify()</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_request(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Handle a channel request from the remote server.&quot;&quot;&quot;</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_eof(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Handle an EOF from the remote server.&quot;&quot;&quot;</span>
<span class="gi">+        self.eof_received = True</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_close(self, m):</span>
<span class="gi">+        &quot;&quot;&quot;Handle a close request from the remote server.&quot;&quot;&quot;</span>
<span class="gi">+        self.close()</span>
<span class="gi">+</span>
<span class="w"> </span>    def get_id(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the `int` ID # for this channel.
<span class="gh">diff --git a/paramiko/common.py b/paramiko/common.py</span>
<span class="gh">index 0ff1c371..469a0844 100644</span>
<span class="gd">--- a/paramiko/common.py</span>
<span class="gi">+++ b/paramiko/common.py</span>
<span class="gu">@@ -3,6 +3,20 @@ Common constants and global variables.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import logging
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="gi">+def byte_chr(n):</span>
<span class="gi">+    &quot;&quot;&quot;Convert an integer to a single byte character.&quot;&quot;&quot;</span>
<span class="gi">+    return bytes([n])</span>
<span class="gi">+</span>
<span class="gi">+def byte_ord(c):</span>
<span class="gi">+    &quot;&quot;&quot;Convert a single byte character to an integer.&quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(c, int):</span>
<span class="gi">+        return c</span>
<span class="gi">+    return ord(c)</span>
<span class="gi">+</span>
<span class="gi">+def byte_mask(c, mask):</span>
<span class="gi">+    &quot;&quot;&quot;Return the byte c with the given mask applied as an integer.&quot;&quot;&quot;</span>
<span class="gi">+    return byte_ord(c) &amp; mask</span>
<span class="w"> </span>MSG_DISCONNECT, MSG_IGNORE, MSG_UNIMPLEMENTED, MSG_DEBUG, MSG_SERVICE_REQUEST, MSG_SERVICE_ACCEPT, MSG_EXT_INFO = range(1, 8)
<span class="w"> </span>MSG_KEXINIT, MSG_NEWKEYS = range(20, 22)
<span class="w"> </span>MSG_USERAUTH_REQUEST, MSG_USERAUTH_FAILURE, MSG_USERAUTH_SUCCESS, MSG_USERAUTH_BANNER = range(50, 54)
<span class="gh">diff --git a/paramiko/kex_curve25519.py b/paramiko/kex_curve25519.py</span>
<span class="gh">index 372a471e..2f27af9c 100644</span>
<span class="gd">--- a/paramiko/kex_curve25519.py</span>
<span class="gi">+++ b/paramiko/kex_curve25519.py</span>
<span class="gu">@@ -11,6 +11,16 @@ c_MSG_KEXECDH_INIT, c_MSG_KEXECDH_REPLY = [byte_chr(c) for c in range(30, 32)]</span>

<span class="w"> </span>class KexCurve25519:
<span class="w"> </span>    hash_algo = hashlib.sha256
<span class="gi">+    name = &#39;curve25519-sha256@libssh.org&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def is_available(cls):</span>
<span class="gi">+        &quot;&quot;&quot;Check if curve25519 is available on this system.&quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            X25519PrivateKey.generate()</span>
<span class="gi">+            return True</span>
<span class="gi">+        except UnsupportedAlgorithm:</span>
<span class="gi">+            return False</span>

<span class="w"> </span>    def __init__(self, transport):
<span class="w"> </span>        self.transport = transport
<span class="gh">diff --git a/paramiko/pkey.py b/paramiko/pkey.py</span>
<span class="gh">index 6877d95a..ff33666b 100644</span>
<span class="gd">--- a/paramiko/pkey.py</span>
<span class="gi">+++ b/paramiko/pkey.py</span>
<span class="gu">@@ -25,6 +25,15 @@ except ImportError:</span>
<span class="w"> </span>    from cryptography.hazmat.primitives.ciphers.algorithms import TripleDES
<span class="w"> </span>OPENSSH_AUTH_MAGIC = b&#39;openssh-key-v1\x00&#39;

<span class="gi">+def _unpad_openssh(data):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Remove padding from OpenSSH private key data.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    padding_length = data[-1]</span>
<span class="gi">+    if not all(c == padding_length for c in data[-padding_length:]):</span>
<span class="gi">+        raise SSHException(&quot;Invalid key padding&quot;)</span>
<span class="gi">+    return data[:-padding_length]</span>
<span class="gi">+</span>
<span class="w"> </span>class UnknownKeyType(Exception):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    An unknown public/private key algorithm was attempted to be read.
<span class="gh">diff --git a/paramiko/transport.py b/paramiko/transport.py</span>
<span class="gh">index 26bad78a..fa6506d1 100644</span>
<span class="gd">--- a/paramiko/transport.py</span>
<span class="gi">+++ b/paramiko/transport.py</span>
<span class="gu">@@ -40,6 +40,12 @@ try:</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    from cryptography.hazmat.primitives.ciphers.algorithms import TripleDES
<span class="w"> </span>_active_threads = []
<span class="gi">+</span>
<span class="gi">+def _join_lingering_threads():</span>
<span class="gi">+    &quot;&quot;&quot;Join any lingering threads when the interpreter exits.&quot;&quot;&quot;</span>
<span class="gi">+    for thr in _active_threads:</span>
<span class="gi">+        thr.join()</span>
<span class="gi">+</span>
<span class="w"> </span>import atexit
<span class="w"> </span>atexit.register(_join_lingering_threads)

<span class="gh">diff --git a/paramiko/util.py b/paramiko/util.py</span>
<span class="gh">index 38d866e1..7f9af3c7 100644</span>
<span class="gd">--- a/paramiko/util.py</span>
<span class="gi">+++ b/paramiko/util.py</span>
<span class="gu">@@ -100,4 +100,56 @@ def b(s, encoding=&#39;utf8&#39;):</span>

<span class="w"> </span>def u(s, encoding=&#39;utf8&#39;):
<span class="w"> </span>    &quot;&quot;&quot;cast bytes or unicode to unicode&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    pass</span>
<span class="gi">+</span>
<span class="gi">+def clamp_value(minimum, val, maximum):</span>
<span class="gi">+    &quot;&quot;&quot;Clamp a value between minimum and maximum values.&quot;&quot;&quot;</span>
<span class="gi">+    return max(minimum, min(val, maximum))</span>
<span class="gi">+</span>
<span class="gi">+def get_logger(name):</span>
<span class="gi">+    &quot;&quot;&quot;Get a logger with the specified name.</span>
<span class="gi">+</span>
<span class="gi">+    This logger is configured to output messages in a format suitable for paramiko.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    logger = logging.getLogger(name)</span>
<span class="gi">+    if not logger.handlers:</span>
<span class="gi">+        handler = logging.StreamHandler()</span>
<span class="gi">+        handler.setFormatter(logging.Formatter(&#39;%(levelname)s:%(name)s:%(message)s&#39;))</span>
<span class="gi">+        logger.addHandler(handler)</span>
<span class="gi">+    return logger</span>
<span class="gi">+</span>
<span class="gi">+def constant_time_bytes_eq(a, b):</span>
<span class="gi">+    &quot;&quot;&quot;Compare two byte strings in constant time.</span>
<span class="gi">+</span>
<span class="gi">+    This function is intended to prevent timing attacks by ensuring that</span>
<span class="gi">+    the comparison of two byte strings takes the same amount of time</span>
<span class="gi">+    regardless of how many characters are the same between the two strings.</span>
<span class="gi">+</span>
<span class="gi">+    :param bytes a: first byte string</span>
<span class="gi">+    :param bytes b: second byte string</span>
<span class="gi">+    :return: True if the strings are equal, False otherwise</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if len(a) != len(b):</span>
<span class="gi">+        return False</span>
<span class="gi">+    result = 0</span>
<span class="gi">+    for x, y in zip(a, b):</span>
<span class="gi">+        result |= x ^ y</span>
<span class="gi">+    return result == 0</span>
<span class="gi">+</span>
<span class="gi">+def safe_string(s):</span>
<span class="gi">+    &quot;&quot;&quot;Convert a potentially unsafe string to a safe one by escaping non-printable bytes.</span>
<span class="gi">+</span>
<span class="gi">+    :param bytes s: The string to make safe</span>
<span class="gi">+    :return: A safe version of the string with non-printable bytes escaped</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    out = []</span>
<span class="gi">+    for c in s:</span>
<span class="gi">+        if isinstance(c, int):</span>
<span class="gi">+            val = c</span>
<span class="gi">+        else:</span>
<span class="gi">+            val = ord(c)</span>
<span class="gi">+        if (val &gt;= 32) and (val &lt;= 127):</span>
<span class="gi">+            out.append(chr(val))</span>
<span class="gi">+        else:</span>
<span class="gi">+            out.append(&#39;%{:02x}&#39;.format(val))</span>
<span class="gi">+    return &#39;&#39;.join(out).encode(&#39;ascii&#39;)</span>
\ No newline at end of file
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>