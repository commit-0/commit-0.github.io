
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands graphene - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-graphene" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands graphene
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-graphene" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test graphene
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_connectionpytest_connection" class="md-nav__link">
    <span class="md-ellipsis">
      test_connection.py::test_connection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_connectionpytest_connection_extra_abstract_fields" class="md-nav__link">
    <span class="md-ellipsis">
      test_connection.py::test_connection_extra_abstract_fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_connectionpytest_connection_override_fields" class="md-nav__link">
    <span class="md-ellipsis">
      test_connection.py::test_connection_override_fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_connectionpytest_edge" class="md-nav__link">
    <span class="md-ellipsis">
      test_connection.py::test_edge
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_connectionpytest_edge_with_bases" class="md-nav__link">
    <span class="md-ellipsis">
      test_connection.py::test_edge_with_bases
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_connectionpytest_edge_with_nonnull_node" class="md-nav__link">
    <span class="md-ellipsis">
      test_connection.py::test_edge_with_nonnull_node
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_connectionpytest_connectionfield" class="md-nav__link">
    <span class="md-ellipsis">
      test_connection.py::test_connectionfield
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_connectionpytest_connectionfield_node_deprecated" class="md-nav__link">
    <span class="md-ellipsis">
      test_connection.py::test_connectionfield_node_deprecated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_connectionpytest_connectionfield_custom_args" class="md-nav__link">
    <span class="md-ellipsis">
      test_connection.py::test_connectionfield_custom_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_connectionpytest_connectionfield_required" class="md-nav__link">
    <span class="md-ellipsis">
      test_connection.py::test_connectionfield_required
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_connectionpytest_connectionfield_strict_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_connection.py::test_connectionfield_strict_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestuuidglobalidtest_str_schema_correct" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestUUIDGlobalID::test_str_schema_correct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestuuidglobalidtest_get_by_id" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestUUIDGlobalID::test_get_by_id
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestsimpleglobalidtest_str_schema_correct" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestSimpleGlobalID::test_str_schema_correct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestsimpleglobalidtest_get_by_id" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestSimpleGlobalID::test_get_by_id
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestcustomglobalidtest_str_schema_correct" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestCustomGlobalID::test_str_schema_correct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestcustomglobalidtest_get_by_id" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestCustomGlobalID::test_get_by_id
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestincompletecustomglobalidtest_must_define_to_global_id" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestIncompleteCustomGlobalID::test_must_define_to_global_id
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_custom_global_idpytestincompletecustomglobalidtest_must_define_resolve_global_id" class="md-nav__link">
    <span class="md-ellipsis">
      test_custom_global_id.py::TestIncompleteCustomGlobalID::test_must_define_resolve_global_id
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_global_idpytest_global_id_defaults_to_required_and_node" class="md-nav__link">
    <span class="md-ellipsis">
      test_global_id.py::test_global_id_defaults_to_required_and_node
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_global_idpytest_global_id_allows_overriding_of_node_and_required" class="md-nav__link">
    <span class="md-ellipsis">
      test_global_id.py::test_global_id_allows_overriding_of_node_and_required
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_global_idpytest_global_id_defaults_to_info_parent_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_global_id.py::test_global_id_defaults_to_info_parent_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_global_idpytest_global_id_allows_setting_customer_parent_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_global_id.py::test_global_id_allows_setting_customer_parent_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1293pytest_schema_printable_with_default_datetime_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_1293.py::test_schema_printable_with_default_datetime_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesdate-2022-02-02" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[Date-"2022-02-02"]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesgenericscalar-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[GenericScalar-"foo"]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesint-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[Int-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesbigint-12345678901234567890" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[BigInt-12345678901234567890]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesfloat-11" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[Float-1.1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesstring-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[String-"foo"]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesboolean-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[Boolean-true]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesid-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[ID-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesdatetime-2022-02-02t111111" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[DateTime-"2022-02-02T11:11:11"]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesuuid-cbebbc62-758e-4f75-a890-bc73b5017d81" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[UUID-"cbebbc62-758e-4f75-a890-bc73b5017d81"]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesdecimal-11" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[Decimal-"1.1"]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesjsonstring-keyfoovaluebar" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[JSONString-"{\"key\":\"foo\",\"value\":\"bar\"}"]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_1419pytest_parse_literal_with_variablesbase64-q2hlbg8gd29ycmxkcg" class="md-nav__link">
    <span class="md-ellipsis">
      test_1419.py::test_parse_literal_with_variables[Base64-"Q2hlbG8gd29ycmxkCg=="]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_313pytest_create_post" class="md-nav__link">
    <span class="md-ellipsis">
      test_313.py::test_create_post
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_356pytest_issue" class="md-nav__link">
    <span class="md-ellipsis">
      test_356.py::test_issue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_490pytest_issue" class="md-nav__link">
    <span class="md-ellipsis">
      test_490.py::test_issue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_720pytest_issue" class="md-nav__link">
    <span class="md-ellipsis">
      test_720.py::test_issue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_argumentpytest_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_argument.py::test_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_argumentpytest_argument_comparasion" class="md-nav__link">
    <span class="md-ellipsis">
      test_argument.py::test_argument_comparasion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_argumentpytest_argument_required" class="md-nav__link">
    <span class="md-ellipsis">
      test_argument.py::test_argument_required
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_argumentpytest_to_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_argument.py::test_to_arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_argumentpytest_to_arguments_deprecated" class="md-nav__link">
    <span class="md-ellipsis">
      test_argument.py::test_to_arguments_deprecated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_argumentpytest_to_arguments_required_deprecated" class="md-nav__link">
    <span class="md-ellipsis">
      test_argument.py::test_to_arguments_required_deprecated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_argumentpytest_to_arguments_raises_if_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_argument.py::test_to_arguments_raises_if_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_argumentpytest_to_arguments_raises_if_inputfield" class="md-nav__link">
    <span class="md-ellipsis">
      test_argument.py::test_to_arguments_raises_if_inputfield
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_argumentpytest_argument_with_lazy_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_argument.py::test_argument_with_lazy_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_argumentpytest_argument_with_lazy_partial_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_argument.py::test_argument_with_lazy_partial_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_basepytest_basetype_create" class="md-nav__link">
    <span class="md-ellipsis">
      test_base.py::test_basetype_create
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_basepytest_basetype_create_extra" class="md-nav__link">
    <span class="md-ellipsis">
      test_base.py::test_basetype_create_extra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_definitionpytest_defines_a_query_only_schema" class="md-nav__link">
    <span class="md-ellipsis">
      test_definition.py::test_defines_a_query_only_schema
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_definitionpytest_defines_a_mutation_schema" class="md-nav__link">
    <span class="md-ellipsis">
      test_definition.py::test_defines_a_mutation_schema
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_definitionpytest_defines_a_subscription_schema" class="md-nav__link">
    <span class="md-ellipsis">
      test_definition.py::test_defines_a_subscription_schema
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_definitionpytest_includes_nested_input_objects_in_the_map" class="md-nav__link">
    <span class="md-ellipsis">
      test_definition.py::test_includes_nested_input_objects_in_the_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_definitionpytest_includes_interfaces_thunk_subtypes_in_the_type_map" class="md-nav__link">
    <span class="md-ellipsis">
      test_definition.py::test_includes_interfaces_thunk_subtypes_in_the_type_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_definitionpytest_includes_types_in_union" class="md-nav__link">
    <span class="md-ellipsis">
      test_definition.py::test_includes_types_in_union
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_definitionpytest_maps_enum" class="md-nav__link">
    <span class="md-ellipsis">
      test_definition.py::test_maps_enum
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_definitionpytest_includes_interfaces_subtypes_in_the_type_map" class="md-nav__link">
    <span class="md-ellipsis">
      test_definition.py::test_includes_interfaces_subtypes_in_the_type_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_definitionpytest_stringifies_simple_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_definition.py::test_stringifies_simple_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_definitionpytest_does_not_mutate_passed_field_definitions" class="md-nav__link">
    <span class="md-ellipsis">
      test_definition.py::test_does_not_mutate_passed_field_definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_definitionpytest_graphene_graphql_type_can_be_copied" class="md-nav__link">
    <span class="md-ellipsis">
      test_definition.py::test_graphene_graphql_type_can_be_copied
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dynamicpytest_dynamic" class="md-nav__link">
    <span class="md-ellipsis">
      test_dynamic.py::test_dynamic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dynamicpytest_nonnull" class="md-nav__link">
    <span class="md-ellipsis">
      test_dynamic.py::test_nonnull
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dynamicpytest_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_dynamic.py::test_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dynamicpytest_list_non_null" class="md-nav__link">
    <span class="md-ellipsis">
      test_dynamic.py::test_list_non_null
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dynamicpytest_partial" class="md-nav__link">
    <span class="md-ellipsis">
      test_dynamic.py::test_partial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_from_python3_enum_uses_default_builtin_doc" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_from_python3_enum_uses_default_builtin_doc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_from_builtin_enum_accepts_lambda_description" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_from_builtin_enum_accepts_lambda_description
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_from_python3_enum_uses_enum_doc" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_from_python3_enum_uses_enum_doc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_value_as_unmounted_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_value_as_unmounted_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_value_as_unmounted_inputfield" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_value_as_unmounted_inputfield
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_value_as_unmounted_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_value_as_unmounted_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_can_be_initialized" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_can_be_initialized
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_to_enum_comparison_should_differ" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_to_enum_comparison_should_differ
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_resolver" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_resolver
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_resolver_compat" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_resolver_compat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_with_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_with_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_resolver_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_resolver_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_field_enum_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_field_enum_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_mutation_enum_input" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_mutation_enum_input
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_mutation_enum_input_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_mutation_enum_input_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_hashable_enum" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_hashable_enum
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_enumpytest_enum_description_member_not_interpreted_as_property" class="md-nav__link">
    <span class="md-ellipsis">
      test_enum.py::test_enum_description_member_not_interpreted_as_property
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_required" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_required
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_source" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_source
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_source_dict_or_attr" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_source_dict_or_attr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_with_lazy_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_with_lazy_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_with_lazy_partial_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_with_lazy_partial_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_with_string_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_with_string_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_source_func" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_source_func
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_source_method" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_source_method
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_source_as_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_source_as_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_name_as_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_name_as_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_fieldpytest_field_source_argument_as_kw" class="md-nav__link">
    <span class="md-ellipsis">
      test_field.py::test_field_source_argument_as_kw
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputfieldpytest_inputfield_required" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputfield.py::test_inputfield_required
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputfieldpytest_inputfield_deprecated" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputfield.py::test_inputfield_deprecated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputfieldpytest_inputfield_with_lazy_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputfield.py::test_inputfield_with_lazy_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputfieldpytest_inputfield_with_lazy_partial_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputfield.py::test_inputfield_with_lazy_partial_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputfieldpytest_inputfield_with_string_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputfield.py::test_inputfield_with_string_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputobjecttypepytest_ordered_fields_in_inputobjecttype" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputobjecttype.py::test_ordered_fields_in_inputobjecttype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputobjecttypepytest_generate_inputobjecttype_unmountedtype" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputobjecttype.py::test_generate_inputobjecttype_unmountedtype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputobjecttypepytest_generate_inputobjecttype_as_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputobjecttype.py::test_generate_inputobjecttype_as_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputobjecttypepytest_generate_inputobjecttype_inherit_abstracttype" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputobjecttype.py::test_generate_inputobjecttype_inherit_abstracttype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputobjecttypepytest_generate_inputobjecttype_inherit_abstracttype_reversed" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputobjecttype.py::test_generate_inputobjecttype_inherit_abstracttype_reversed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputobjecttypepytest_inputobjecttype_of_input" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputobjecttype.py::test_inputobjecttype_of_input
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_inputobjecttypepytest_inputobjecttype_default_input_as_undefined" class="md-nav__link">
    <span class="md-ellipsis">
      test_inputobjecttype.py::test_inputobjecttype_default_input_as_undefined
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interfacepytest_ordered_fields_in_interface" class="md-nav__link">
    <span class="md-ellipsis">
      test_interface.py::test_ordered_fields_in_interface
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interfacepytest_generate_interface_unmountedtype" class="md-nav__link">
    <span class="md-ellipsis">
      test_interface.py::test_generate_interface_unmountedtype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interfacepytest_generate_interface_inherit_abstracttype" class="md-nav__link">
    <span class="md-ellipsis">
      test_interface.py::test_generate_interface_inherit_abstracttype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interfacepytest_generate_interface_inherit_interface" class="md-nav__link">
    <span class="md-ellipsis">
      test_interface.py::test_generate_interface_inherit_interface
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interfacepytest_generate_interface_inherit_abstracttype_reversed" class="md-nav__link">
    <span class="md-ellipsis">
      test_interface.py::test_generate_interface_inherit_abstracttype_reversed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interfacepytest_resolve_type_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_interface.py::test_resolve_type_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interfacepytest_resolve_type_custom" class="md-nav__link">
    <span class="md-ellipsis">
      test_interface.py::test_resolve_type_custom
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interfacepytest_resolve_type_custom_interferes" class="md-nav__link">
    <span class="md-ellipsis">
      test_interface.py::test_resolve_type_custom_interferes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mountedtypepytest_mounted_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_mountedtype.py::test_mounted_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mountedtypepytest_mounted_type_custom" class="md-nav__link">
    <span class="md-ellipsis">
      test_mountedtype.py::test_mounted_type_custom
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mutationpytest_generate_mutation_no_args" class="md-nav__link">
    <span class="md-ellipsis">
      test_mutation.py::test_generate_mutation_no_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mutationpytest_generate_mutation_with_meta" class="md-nav__link">
    <span class="md-ellipsis">
      test_mutation.py::test_generate_mutation_with_meta
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mutationpytest_mutation_custom_output_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_mutation.py::test_mutation_custom_output_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mutationpytest_mutation_execution" class="md-nav__link">
    <span class="md-ellipsis">
      test_mutation.py::test_mutation_execution
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mutationpytest_mutation_no_fields_output" class="md-nav__link">
    <span class="md-ellipsis">
      test_mutation.py::test_mutation_no_fields_output
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mutationpytest_mutation_allow_to_have_custom_args" class="md-nav__link">
    <span class="md-ellipsis">
      test_mutation.py::test_mutation_allow_to_have_custom_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mutationpytest_mutation_default_args_output" class="md-nav__link">
    <span class="md-ellipsis">
      test_mutation.py::test_mutation_default_args_output
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mutationpytest_mutation_as_subclass" class="md-nav__link">
    <span class="md-ellipsis">
      test_mutation.py::test_mutation_as_subclass
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objecttypepytest_generate_lazy_objecttype" class="md-nav__link">
    <span class="md-ellipsis">
      test_objecttype.py::test_generate_lazy_objecttype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objecttypepytest_ordered_fields_in_objecttype" class="md-nav__link">
    <span class="md-ellipsis">
      test_objecttype.py::test_ordered_fields_in_objecttype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objecttypepytest_generate_objecttype_inherit_abstracttype" class="md-nav__link">
    <span class="md-ellipsis">
      test_objecttype.py::test_generate_objecttype_inherit_abstracttype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objecttypepytest_generate_objecttype_inherit_abstracttype_reversed" class="md-nav__link">
    <span class="md-ellipsis">
      test_objecttype.py::test_generate_objecttype_inherit_abstracttype_reversed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objecttypepytest_generate_objecttype_unmountedtype" class="md-nav__link">
    <span class="md-ellipsis">
      test_objecttype.py::test_generate_objecttype_unmountedtype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objecttypepytest_objecttype_no_fields_output" class="md-nav__link">
    <span class="md-ellipsis">
      test_objecttype.py::test_objecttype_no_fields_output
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_objecttypepytest_objecttype_meta_with_annotations" class="md-nav__link">
    <span class="md-ellipsis">
      test_objecttype.py::test_objecttype_meta_with_annotations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_source" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_source
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_union" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_union
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_interface" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_interface
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_dynamic" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_dynamic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_default_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_default_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_wrong_default_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_wrong_default_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_default_value_ignored_by_resolver" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_default_value_ignored_by_resolver
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_resolve_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_resolve_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_input_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_input_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_middlewares" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_middlewares
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_objecttype_on_instances" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_objecttype_on_instances
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_big_list_query_benchmark" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_big_list_query_benchmark
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_big_list_query_compiled_query_benchmark" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_big_list_query_compiled_query_benchmark
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_big_list_of_containers_query_benchmark" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_big_list_of_containers_query_benchmark
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_big_list_of_containers_multiple_fields_query_benchmark" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_big_list_of_containers_multiple_fields_query_benchmark
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_big_list_of_containers_multiple_fields_custom_resolvers_query_benchmark" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_big_list_of_containers_multiple_fields_custom_resolvers_query_benchmark
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_query_annotated_resolvers" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_query_annotated_resolvers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_querypytest_default_as_kwarg_to_nonnull" class="md-nav__link">
    <span class="md-ellipsis">
      test_query.py::test_default_as_kwarg_to_NonNull
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_scalars_serializationpytest_serializes_output_int" class="md-nav__link">
    <span class="md-ellipsis">
      test_scalars_serialization.py::test_serializes_output_int
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_scalars_serializationpytest_serializes_output_float" class="md-nav__link">
    <span class="md-ellipsis">
      test_scalars_serialization.py::test_serializes_output_float
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_scalars_serializationpytest_serializes_output_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_scalars_serialization.py::test_serializes_output_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_schemapytest_schema" class="md-nav__link">
    <span class="md-ellipsis">
      test_schema.py::test_schema
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_schemapytest_schema_get_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_schema.py::test_schema_get_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_schemapytest_schema_get_type_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_schema.py::test_schema_get_type_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_schemapytest_schema_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_schema.py::test_schema_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_schemapytest_schema_introspect" class="md-nav__link">
    <span class="md-ellipsis">
      test_schema.py::test_schema_introspect
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_schemapytest_schema_requires_query_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_schema.py::test_schema_requires_query_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_list_with_lazy_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_list_with_lazy_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_list_with_lazy_partial_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_list_with_lazy_partial_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_list_with_string_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_list_with_string_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_list_inherited_works_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_list_inherited_works_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_list_inherited_works_nonnull" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_list_inherited_works_nonnull
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_nonnull" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_nonnull
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_nonnull_with_lazy_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_nonnull_with_lazy_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_nonnull_with_lazy_partial_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_nonnull_with_lazy_partial_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_nonnull_with_string_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_nonnull_with_string_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_nonnull_inherited_works_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_nonnull_inherited_works_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_nonnull_inherited_dont_work_nonnull" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_nonnull_inherited_dont_work_nonnull
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_list_comparasion" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_list_comparasion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_structurespytest_nonnull_comparasion" class="md-nav__link">
    <span class="md-ellipsis">
      test_structures.py::test_nonnull_comparasion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_mappytest_enum" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_map.py::test_enum
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_mappytest_objecttype" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_map.py::test_objecttype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_mappytest_required_argument_with_default_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_map.py::test_required_argument_with_default_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_mappytest_dynamic_objecttype" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_map.py::test_dynamic_objecttype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_mappytest_interface" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_map.py::test_interface
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_mappytest_inputobject" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_map.py::test_inputobject
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_mappytest_inputobject_undefined" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_map.py::test_inputobject_undefined
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_mappytest_objecttype_camelcase" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_map.py::test_objecttype_camelcase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_mappytest_objecttype_camelcase_disabled" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_map.py::test_objecttype_camelcase_disabled
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_mappytest_objecttype_with_possible_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_map.py::test_objecttype_with_possible_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_type_mappytest_interface_with_interfaces" class="md-nav__link">
    <span class="md-ellipsis">
      test_type_map.py::test_interface_with_interfaces
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_unionpytest_union_can_be_mounted" class="md-nav__link">
    <span class="md-ellipsis">
      test_union.py::test_union_can_be_mounted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_crunchpytest_crunchsingle-item-array-uncrunched4-crunched4" class="md-nav__link">
    <span class="md-ellipsis">
      test_crunch.py::test_crunch[single-item array-uncrunched4-crunched4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_crunchpytest_crunchmulti-primitive-all-distinct-array-uncrunched5-crunched5" class="md-nav__link">
    <span class="md-ellipsis">
      test_crunch.py::test_crunch[multi-primitive all distinct array-uncrunched5-crunched5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_crunchpytest_crunchmulti-primitive-repeated-array-uncrunched6-crunched6" class="md-nav__link">
    <span class="md-ellipsis">
      test_crunch.py::test_crunch[multi-primitive repeated array-uncrunched6-crunched6]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_crunchpytest_crunchone-level-nested-array-uncrunched7-crunched7" class="md-nav__link">
    <span class="md-ellipsis">
      test_crunch.py::test_crunch[one-level nested array-uncrunched7-crunched7]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_crunchpytest_crunchtwo-level-nested-array-uncrunched8-crunched8" class="md-nav__link">
    <span class="md-ellipsis">
      test_crunch.py::test_crunch[two-level nested array-uncrunched8-crunched8]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_crunchpytest_crunchsingle-item-object-uncrunched10-crunched10" class="md-nav__link">
    <span class="md-ellipsis">
      test_crunch.py::test_crunch[single-item object-uncrunched10-crunched10]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_crunchpytest_crunchmulti-item-all-distinct-object-uncrunched11-crunched11" class="md-nav__link">
    <span class="md-ellipsis">
      test_crunch.py::test_crunch[multi-item all distinct object-uncrunched11-crunched11]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_crunchpytest_crunchmulti-item-repeated-object-uncrunched12-crunched12" class="md-nav__link">
    <span class="md-ellipsis">
      test_crunch.py::test_crunch[multi-item repeated object-uncrunched12-crunched12]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_crunchpytest_crunchcomplex-array-uncrunched13-crunched13" class="md-nav__link">
    <span class="md-ellipsis">
      test_crunch.py::test_crunch[complex array-uncrunched13-crunched13]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_crunchpytest_crunchcomplex-object-uncrunched14-crunched14" class="md-nav__link">
    <span class="md-ellipsis">
      test_crunch.py::test_crunch[complex object-uncrunched14-crunched14]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_basic_dataloader" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_basic_dataloader
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_build_a_simple_data_loader" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_build_a_simple_data_loader
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_can_build_a_data_loader_from_a_partial" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_can_build_a_data_loader_from_a_partial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_supports_loading_multiple_keys_in_one_call" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_supports_loading_multiple_keys_in_one_call
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_batches_multiple_requests" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_batches_multiple_requests
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_batches_multiple_requests_with_max_batch_sizes" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_batches_multiple_requests_with_max_batch_sizes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_coalesces_identical_requests" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_coalesces_identical_requests
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_caches_repeated_requests" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_caches_repeated_requests
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_clears_single_value_in_loader" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_clears_single_value_in_loader
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_clears_all_values_in_loader" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_clears_all_values_in_loader
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_allows_priming_the_cache" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_allows_priming_the_cache
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_does_not_prime_keys_that_already_exist" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_does_not_prime_keys_that_already_exist
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_resolves_to_error_to_indicate_failure" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_resolves_to_error_to_indicate_failure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_can_represent_failures_and_successes_simultaneously" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_can_represent_failures_and_successes_simultaneously
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_caches_failed_fetches" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_caches_failed_fetches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_caches_failed_fetches_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_caches_failed_fetches_2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_batches_loads_occuring_within_promises" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_batches_loads_occuring_within_promises
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_catches_error_if_loader_resolver_fails" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_catches_error_if_loader_resolver_fails
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_can_call_a_loader_from_a_loader" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_can_call_a_loader_from_a_loader
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloaderpytest_dataloader_clear_with_missing_key_works" class="md-nav__link">
    <span class="md-ellipsis">
      test_dataloader.py::test_dataloader_clear_with_missing_key_works
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_warn_deprecation" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_warn_deprecation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_deprecated_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_deprecated_decorator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_deprecated_class" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_deprecated_class
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_deprecated_decorator_text" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_deprecated_decorator_text
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deprecatedpytest_deprecated_class_text" class="md-nav__link">
    <span class="md-ellipsis">
      test_deprecated.py::test_deprecated_class_text
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_module_loadingpytest_import_string_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_module_loading.py::test_import_string_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_orderedtypepytest_orderedtype_resetcounter" class="md-nav__link">
    <span class="md-ellipsis">
      test_orderedtype.py::test_orderedtype_resetcounter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_str_converterspytest_snake_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_str_converters.py::test_snake_case
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-graphene"><strong>OpenHands</strong>: graphene</h1>
<h2 id="pytest-summary-for-test-graphene">Pytest Summary for test <code>graphene</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">229</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">83</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">312</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">312</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_connectionpytest_connection">test_connection.py::test_connection</h3>
<details><summary> <pre>test_connection.py::test_connection</pre></summary><pre>
def test_connection():
        class MyObjectConnection(Connection):
            extra = String()

            class Meta:
                node = MyObject

            class Edge:
                other = String()

        assert MyObjectConnection._meta.name == "MyObjectConnection"
        fields = MyObjectConnection._meta.fields
        assert list(fields) == ["page_info", "edges", "extra"]
        edge_field = fields["edges"]
        pageinfo_field = fields["page_info"]

        assert isinstance(edge_field, Field)
>       assert isinstance(edge_field.type, NonNull)
E       AttributeError: 'Field' object has no attribute 'type'

graphene/relay/tests/test_connection.py:40: AttributeError
</pre>
</details>
<h3 id="test_connectionpytest_connection_extra_abstract_fields">test_connection.py::test_connection_extra_abstract_fields</h3>
<details><summary> <pre>test_connection.py::test_connection_extra_abstract_fields</pre></summary><pre>
def test_connection_extra_abstract_fields():
        class ConnectionWithNodes(Connection):
            class Meta:
                abstract = True

            @classmethod
            def __init_subclass_with_meta__(cls, node=None, name=None, **options):
                _meta = ConnectionOptions(cls)

                _meta.fields = {
                    "nodes": Field(
                        NonNull(List(node)),
                        description="Contains all the nodes in this connection.",
                    ),
                }

                return super(ConnectionWithNodes, cls).__init_subclass_with_meta__(
                    node=node, name=name, _meta=_meta, **options
                )

        class MyObjectConnection(ConnectionWithNodes):
            class Meta:
                node = MyObject

            class Edge:
                other = String()

        assert MyObjectConnection._meta.name == "MyObjectConnection"
        fields = MyObjectConnection._meta.fields
        assert list(fields) == ["nodes", "page_info", "edges"]
        edge_field = fields["edges"]
        pageinfo_field = fields["page_info"]
        nodes_field = fields["nodes"]

        assert isinstance(edge_field, Field)
>       assert isinstance(edge_field.type, NonNull)
E       AttributeError: 'Field' object has no attribute 'type'

graphene/relay/tests/test_connection.py:97: AttributeError
</pre>
</details>
<h3 id="test_connectionpytest_connection_override_fields">test_connection.py::test_connection_override_fields</h3>
<details><summary> <pre>test_connection.py::test_connection_override_fields</pre></summary><pre>
def test_connection_override_fields():
        class ConnectionWithNodes(Connection):
            class Meta:
                abstract = True

            @classmethod
            def __init_subclass_with_meta__(cls, node=None, name=None, **options):
                _meta = ConnectionOptions(cls)
                base_name = (
                    re.sub("Connection$", "", name or cls.__name__) or node._meta.name
                )

                edge_class = get_edge_class(cls, node, base_name)

                _meta.fields = {
                    "page_info": Field(
                        NonNull(
                            PageInfo,
                            name="pageInfo",
                            required=True,
                            description="Pagination data for this connection.",
                        )
                    ),
                    "edges": Field(
                        NonNull(List(NonNull(edge_class))),
                        description="Contains the nodes in this connection.",
                    ),
                }

                return super(ConnectionWithNodes, cls).__init_subclass_with_meta__(
                    node=node, name=name, _meta=_meta, **options
                )

        class MyObjectConnection(ConnectionWithNodes):
            class Meta:
                node = MyObject

        assert MyObjectConnection._meta.name == "MyObjectConnection"
        fields = MyObjectConnection._meta.fields
        assert list(fields) == ["page_info", "edges"]
        edge_field = fields["edges"]
        pageinfo_field = fields["page_info"]

        assert isinstance(edge_field, Field)
>       assert isinstance(edge_field.type, NonNull)
E       AttributeError: 'Field' object has no attribute 'type'

graphene/relay/tests/test_connection.py:155: AttributeError
</pre>
</details>
<h3 id="test_connectionpytest_edge">test_connection.py::test_edge</h3>
<details><summary> <pre>test_connection.py::test_edge</pre></summary><pre>
def test_edge():
        class MyObjectConnection(Connection):
            class Meta:
                node = MyObject

            class Edge:
                other = String()

        Edge = MyObjectConnection.Edge
>       assert Edge._meta.name == "MyObjectEdge"
E       AssertionError: assert 'EdgeBase' == 'MyObjectEdge'
E         
E         - MyObjectEdge
E         + EdgeBase

graphene/relay/tests/test_connection.py:190: AssertionError
</pre>
</details>
<h3 id="test_connectionpytest_edge_with_bases">test_connection.py::test_edge_with_bases</h3>
<details><summary> <pre>test_connection.py::test_edge_with_bases</pre></summary><pre>
def test_edge_with_bases():
        class BaseEdge:
            extra = String()

        class MyObjectConnection(Connection):
            class Meta:
                node = MyObject

            class Edge(BaseEdge):
                other = String()

        Edge = MyObjectConnection.Edge
>       assert Edge._meta.name == "MyObjectEdge"
E       AssertionError: assert 'EdgeBase' == 'MyObjectEdge'
E         
E         - MyObjectEdge
E         + EdgeBase

graphene/relay/tests/test_connection.py:213: AssertionError
</pre>
</details>
<h3 id="test_connectionpytest_edge_with_nonnull_node">test_connection.py::test_edge_with_nonnull_node</h3>
<details><summary> <pre>test_connection.py::test_edge_with_nonnull_node</pre></summary><pre>
def test_edge_with_nonnull_node():
        class MyObjectConnection(Connection):
            class Meta:
                node = NonNull(MyObject)

        edge_fields = MyObjectConnection.Edge._meta.fields
        assert isinstance(edge_fields["node"], Field)
>       assert isinstance(edge_fields["node"].type, NonNull)
E       AttributeError: 'Field' object has no attribute 'type'

graphene/relay/tests/test_connection.py:231: AttributeError
</pre>
</details>
<h3 id="test_connectionpytest_connectionfield">test_connection.py::test_connectionfield</h3>
<details><summary> <pre>test_connection.py::test_connectionfield</pre></summary><pre>
def test_connectionfield():
        class MyObjectConnection(Connection):
            class Meta:
                node = MyObject

        field = ConnectionField(MyObjectConnection)
>       assert field.args == {
            "before": Argument(String),
            "after": Argument(String),
            "first": Argument(Int),
            "last": Argument(Int),
        }
E       AssertionError: assert [<graphene.ty...7fe41c7f0e10>] == {'after': <gr...7fe41c7f0350>}
E         
E         Use -v to get more diff

graphene/relay/tests/test_connection.py:252: AssertionError
</pre>
</details>
<h3 id="test_connectionpytest_connectionfield_node_deprecated">test_connection.py::test_connectionfield_node_deprecated</h3>
<details><summary> <pre>test_connection.py::test_connectionfield_node_deprecated</pre></summary><pre>
def test_connectionfield_node_deprecated():
        field = ConnectionField(MyObject)
        with raises(Exception) as exc_info:
            field.type

>       assert "ConnectionFields now need a explicit ConnectionType for Nodes." in str(
            exc_info.value
        )
E       assert 'ConnectionFields now need a explicit ConnectionType for Nodes.' in "'IterableConnectionField' object has no attribute 'type'"
E        +  where "'IterableConnectionField' object has no attribute 'type'" = str(AttributeError("'IterableConnectionField' object has no attribute 'type'"))
E        +    where AttributeError("'IterableConnectionField' object has no attribute 'type'") = <ExceptionInfo AttributeError("'IterableConnectionField' object has no attribute 'type'") tblen=1>.value

graphene/relay/tests/test_connection.py:265: AssertionError
</pre>
</details>
<h3 id="test_connectionpytest_connectionfield_custom_args">test_connection.py::test_connectionfield_custom_args</h3>
<details><summary> <pre>test_connection.py::test_connectionfield_custom_args</pre></summary><pre>
def test_connectionfield_custom_args():
        class MyObjectConnection(Connection):
            class Meta:
                node = MyObject

        field = ConnectionField(
            MyObjectConnection, before=String(required=True), extra=String()
        )
>       assert field.args == {
            "before": Argument(NonNull(String)),
            "after": Argument(String),
            "first": Argument(Int),
            "last": Argument(Int),
            "extra": Argument(String),
        }
E       AssertionError: assert [<graphene.ty...7fe41c55ca90>] == {'after': <gr...c55db50>, ...}
E         
E         Use -v to get more diff

graphene/relay/tests/test_connection.py:278: AssertionError
</pre>
</details>
<h3 id="test_connectionpytest_connectionfield_required">test_connection.py::test_connectionfield_required</h3>
<details><summary> <pre>test_connection.py::test_connectionfield_required</pre></summary><pre>
def test_connectionfield_required():
        class MyObjectConnection(Connection):
            class Meta:
                node = MyObject

        class Query(ObjectType):
            test_connection = ConnectionField(MyObjectConnection, required=True)

            def resolve_test_connection(root, info, **args):
                return []

>       schema = Schema(query=Query)

graphene/relay/tests/test_connection.py:298: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_connectionpytest_connectionfield_strict_types">test_connection.py::test_connectionfield_strict_types</h3>
<details><summary> <pre>test_connection.py::test_connectionfield_strict_types</pre></summary><pre>
def test_connectionfield_strict_types():
        class MyObjectConnection(Connection):
            class Meta:
                node = MyObject
                strict_types = True

        connection_field = ConnectionField(MyObjectConnection)
>       edges_field_type = connection_field.type._meta.fields["edges"].type
E       AttributeError: 'IterableConnectionField' object has no attribute 'type'

graphene/relay/tests/test_connection.py:311: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestuuidglobalidtest_str_schema_correct">test_custom_global_id.py::TestUUIDGlobalID::test_str_schema_correct</h3>
<details><summary> <pre>test_custom_global_id.py::TestUUIDGlobalID::test_str_schema_correct</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestUUIDGlobalID object at 0x7fe41c844a10>

    def test_str_schema_correct(self):
        """
        Check that the schema has the expected and custom node interface and user type and that they both use UUIDs
        """
>       parsed = re.findall(r"(.+) \{\n\s*([\w\W]*?)\n\}", str(self.schema))
E       AttributeError: 'TestUUIDGlobalID' object has no attribute 'schema'

graphene/relay/tests/test_custom_global_id.py:45: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestuuidglobalidtest_get_by_id">test_custom_global_id.py::TestUUIDGlobalID::test_get_by_id</h3>
<details><summary> <pre>test_custom_global_id.py::TestUUIDGlobalID::test_get_by_id</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestUUIDGlobalID object at 0x7fe41c8453d0>

    def test_get_by_id(self):
        query = """query userById($id: UUID!) {
            user(id: $id) {
                id
                name
            }
        }"""
        # UUID need to be converted to string for serialization
        result = graphql_sync(
>           self.graphql_schema,
            query,
            variable_values={"id": str(self.user_list[0]["id"])},
        )
E       AttributeError: 'TestUUIDGlobalID' object has no attribute 'graphql_schema'

graphene/relay/tests/test_custom_global_id.py:70: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestsimpleglobalidtest_str_schema_correct">test_custom_global_id.py::TestSimpleGlobalID::test_str_schema_correct</h3>
<details><summary> <pre>test_custom_global_id.py::TestSimpleGlobalID::test_str_schema_correct</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestSimpleGlobalID object at 0x7fe41c844c90>

    def test_str_schema_correct(self):
        """
        Check that the schema has the expected and custom node interface and user type and that they both use UUIDs
        """
>       parsed = re.findall(r"(.+) \{\n\s*([\w\W]*?)\n\}", str(self.schema))
E       AttributeError: 'TestSimpleGlobalID' object has no attribute 'schema'

graphene/relay/tests/test_custom_global_id.py:113: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestsimpleglobalidtest_get_by_id">test_custom_global_id.py::TestSimpleGlobalID::test_get_by_id</h3>
<details><summary> <pre>test_custom_global_id.py::TestSimpleGlobalID::test_get_by_id</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestSimpleGlobalID object at 0x7fe41c845710>

    def test_get_by_id(self):
        query = """query {
            user(id: "my global primary key in clear 3") {
                id
                name
            }
        }"""
>       result = graphql_sync(self.graphql_schema, query)
E       AttributeError: 'TestSimpleGlobalID' object has no attribute 'graphql_schema'

graphene/relay/tests/test_custom_global_id.py:136: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestcustomglobalidtest_str_schema_correct">test_custom_global_id.py::TestCustomGlobalID::test_str_schema_correct</h3>
<details><summary> <pre>test_custom_global_id.py::TestCustomGlobalID::test_str_schema_correct</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestCustomGlobalID object at 0x7fe41c845d50>

    def test_str_schema_correct(self):
        """
        Check that the schema has the expected and custom node interface and user type and that they both use UUIDs
        """
>       parsed = re.findall(r"(.+) \{\n\s*([\w\W]*?)\n\}", str(self.schema))
E       AttributeError: 'TestCustomGlobalID' object has no attribute 'schema'

graphene/relay/tests/test_custom_global_id.py:192: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestcustomglobalidtest_get_by_id">test_custom_global_id.py::TestCustomGlobalID::test_get_by_id</h3>
<details><summary> <pre>test_custom_global_id.py::TestCustomGlobalID::test_get_by_id</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestCustomGlobalID object at 0x7fe41c8466d0>

    def test_get_by_id(self):
        query = """query {
            user(id: 2) {
                id
                name
            }
        }"""
>       result = graphql_sync(self.graphql_schema, query)
E       AttributeError: 'TestCustomGlobalID' object has no attribute 'graphql_schema'

graphene/relay/tests/test_custom_global_id.py:215: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestincompletecustomglobalidtest_must_define_to_global_id">test_custom_global_id.py::TestIncompleteCustomGlobalID::test_must_define_to_global_id</h3>
<details><summary> <pre>test_custom_global_id.py::TestIncompleteCustomGlobalID::test_must_define_to_global_id</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestIncompleteCustomGlobalID object at 0x7fe41c847c10>

    def test_must_define_to_global_id(self):
        """
        Test that if the `to_global_id` method is not defined, we can query the object, but we can't request its ID.
        """

        class CustomGlobalIDType(BaseGlobalIDType):
            graphene_type = Int

            @classmethod
            def resolve_global_id(cls, info, global_id):
                _type = info.return_type.graphene_type._meta.name
                return _type, global_id

        class CustomNode(Node):
            class Meta:
                global_id_type = CustomGlobalIDType

        class User(ObjectType):
            class Meta:
                interfaces = [CustomNode]

            name = String()

            @classmethod
            def get_node(cls, _type, _id):
                return self.users[_id]

        class RootQuery(ObjectType):
            user = CustomNode.Field(User)

>       self.schema = Schema(query=RootQuery, types=[User])

graphene/relay/tests/test_custom_global_id.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <RootQuery meta=<ObjectTypeOptions name='RootQuery'>>
mutation = None, subscription = None
types = [<User meta=<ObjectTypeOptions name='User'>>], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_custom_global_idpytestincompletecustomglobalidtest_must_define_resolve_global_id">test_custom_global_id.py::TestIncompleteCustomGlobalID::test_must_define_resolve_global_id</h3>
<details><summary> <pre>test_custom_global_id.py::TestIncompleteCustomGlobalID::test_must_define_resolve_global_id</pre></summary><pre>
self = <graphene.relay.tests.test_custom_global_id.TestIncompleteCustomGlobalID object at 0x7fe41c847d10>

    def test_must_define_resolve_global_id(self):
        """
        Test that if the `resolve_global_id` method is not defined, we can't query the object by ID.
        """

        class CustomGlobalIDType(BaseGlobalIDType):
            graphene_type = Int

            @classmethod
            def to_global_id(cls, _type, _id):
                return _id

        class CustomNode(Node):
            class Meta:
                global_id_type = CustomGlobalIDType

        class User(ObjectType):
            class Meta:
                interfaces = [CustomNode]

            name = String()

            @classmethod
            def get_node(cls, _type, _id):
                return self.users[_id]

        class RootQuery(ObjectType):
            user = CustomNode.Field(User)

>       self.schema = Schema(query=RootQuery, types=[User])

graphene/relay/tests/test_custom_global_id.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <RootQuery meta=<ObjectTypeOptions name='RootQuery'>>
mutation = None, subscription = None
types = [<User meta=<ObjectTypeOptions name='User'>>], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_global_idpytest_global_id_defaults_to_required_and_node">test_global_id.py::test_global_id_defaults_to_required_and_node</h3>
<details><summary> <pre>test_global_id.py::test_global_id_defaults_to_required_and_node</pre></summary><pre>
def test_global_id_defaults_to_required_and_node():
        gid = GlobalID()
>       assert isinstance(gid.type, NonNull)
E       AttributeError: 'GlobalID' object has no attribute 'type'

graphene/relay/tests/test_global_id.py:34: AttributeError
</pre>
</details>
<h3 id="test_global_idpytest_global_id_allows_overriding_of_node_and_required">test_global_id.py::test_global_id_allows_overriding_of_node_and_required</h3>
<details><summary> <pre>test_global_id.py::test_global_id_allows_overriding_of_node_and_required</pre></summary><pre>
def test_global_id_allows_overriding_of_node_and_required():
        gid = GlobalID(node=CustomNode, required=False)
>       assert gid.type == ID
E       AttributeError: 'GlobalID' object has no attribute 'type'

graphene/relay/tests/test_global_id.py:41: AttributeError
</pre>
</details>
<h3 id="test_global_idpytest_global_id_defaults_to_info_parent_type">test_global_id.py::test_global_id_defaults_to_info_parent_type</h3>
<details><summary> <pre>test_global_id.py::test_global_id_defaults_to_info_parent_type</pre></summary><pre>
def test_global_id_defaults_to_info_parent_type():
        my_id = "1"
        gid = GlobalID()
        id_resolver = gid.wrap_resolve(lambda *_: my_id)
>       my_global_id = id_resolver(None, Info(User))
E       TypeError: 'NoneType' object is not callable

graphene/relay/tests/test_global_id.py:49: TypeError
</pre>
</details>
<h3 id="test_global_idpytest_global_id_allows_setting_customer_parent_type">test_global_id.py::test_global_id_allows_setting_customer_parent_type</h3>
<details><summary> <pre>test_global_id.py::test_global_id_allows_setting_customer_parent_type</pre></summary><pre>
def test_global_id_allows_setting_customer_parent_type():
        my_id = "1"
        gid = GlobalID(parent_type=User)
        id_resolver = gid.wrap_resolve(lambda *_: my_id)
>       my_global_id = id_resolver(None, None)
E       TypeError: 'NoneType' object is not callable

graphene/relay/tests/test_global_id.py:57: TypeError
</pre>
</details>
<h3 id="test_1293pytest_schema_printable_with_default_datetime_value">test_1293.py::test_schema_printable_with_default_datetime_value</h3>
<details><summary> <pre>test_1293.py::test_schema_printable_with_default_datetime_value</pre></summary><pre>
def test_schema_printable_with_default_datetime_value():
>       schema = graphene.Schema(query=Query, mutation=Mutations)

graphene/tests/issues/test_1293.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = <Mutations meta=<ObjectTypeOptions name='Mutations'>>
subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesdate-2022-02-02">test_1419.py::test_parse_literal_with_variables[Date-"2022-02-02"]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[Date-"2022-02-02"]</pre></summary><pre>
input_type = <Date meta=<ScalarOptions name='Date'>>
input_value = '"2022-02-02"'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesgenericscalar-foo">test_1419.py::test_parse_literal_with_variables[GenericScalar-"foo"]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[GenericScalar-"foo"]</pre></summary><pre>
input_type = <GenericScalar meta=<ScalarOptions name='GenericScalar'>>
input_value = '"foo"'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesint-1">test_1419.py::test_parse_literal_with_variables[Int-1]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[Int-1]</pre></summary><pre>
input_type = <Int meta=<ScalarOptions name='Int'>>, input_value = '1'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesbigint-12345678901234567890">test_1419.py::test_parse_literal_with_variables[BigInt-12345678901234567890]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[BigInt-12345678901234567890]</pre></summary><pre>
input_type = <BigInt meta=<ScalarOptions name='BigInt'>>
input_value = '12345678901234567890'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesfloat-11">test_1419.py::test_parse_literal_with_variables[Float-1.1]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[Float-1.1]</pre></summary><pre>
input_type = <Float meta=<ScalarOptions name='Float'>>, input_value = '1.1'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesstring-foo">test_1419.py::test_parse_literal_with_variables[String-"foo"]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[String-"foo"]</pre></summary><pre>
input_type = <String meta=<ScalarOptions name='String'>>, input_value = '"foo"'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesboolean-true">test_1419.py::test_parse_literal_with_variables[Boolean-true]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[Boolean-true]</pre></summary><pre>
input_type = <Boolean meta=<ScalarOptions name='Boolean'>>, input_value = 'true'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesid-1">test_1419.py::test_parse_literal_with_variables[ID-1]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[ID-1]</pre></summary><pre>
input_type = <ID meta=<ScalarOptions name='ID'>>, input_value = '1'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesdatetime-2022-02-02t111111">test_1419.py::test_parse_literal_with_variables[DateTime-"2022-02-02T11:11:11"]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[DateTime-"2022-02-02T11:11:11"]</pre></summary><pre>
input_type = <DateTime meta=<ScalarOptions name='DateTime'>>
input_value = '"2022-02-02T11:11:11"'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesuuid-cbebbc62-758e-4f75-a890-bc73b5017d81">test_1419.py::test_parse_literal_with_variables[UUID-"cbebbc62-758e-4f75-a890-bc73b5017d81"]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[UUID-"cbebbc62-758e-4f75-a890-bc73b5017d81"]</pre></summary><pre>
input_type = <UUID meta=<ScalarOptions name='UUID'>>
input_value = '"cbebbc62-758e-4f75-a890-bc73b5017d81"'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesdecimal-11">test_1419.py::test_parse_literal_with_variables[Decimal-"1.1"]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[Decimal-"1.1"]</pre></summary><pre>
input_type = <Decimal meta=<ScalarOptions name='Decimal'>>
input_value = '"1.1"'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesjsonstring-keyfoovaluebar">test_1419.py::test_parse_literal_with_variables[JSONString-"{\"key\":\"foo\",\"value\":\"bar\"}"]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[JSONString-"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"]</pre></summary><pre>
input_type = <JSONString meta=<ScalarOptions name='JSONString'>>
input_value = '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_1419pytest_parse_literal_with_variablesbase64-q2hlbg8gd29ycmxkcg">test_1419.py::test_parse_literal_with_variables[Base64-"Q2hlbG8gd29ycmxkCg=="]</h3>
<details><summary> <pre>test_1419.py::test_parse_literal_with_variables[Base64-"Q2hlbG8gd29ycmxkCg=="]</pre></summary><pre>
input_type = <Base64 meta=<ScalarOptions name='Base64'>>
input_value = '"Q2hlbG8gd29ycmxkCg=="'

    @pytest.mark.parametrize(
        "input_type,input_value",
        [
            (Date, '"2022-02-02"'),
            (GenericScalar, '"foo"'),
            (Int, "1"),
            (BigInt, "12345678901234567890"),
            (Float, "1.1"),
            (String, '"foo"'),
            (Boolean, "true"),
            (ID, "1"),
            (DateTime, '"2022-02-02T11:11:11"'),
            (UUID, '"cbebbc62-758e-4f75-a890-bc73b5017d81"'),
            (Decimal, '"1.1"'),
            (JSONString, '"{\\"key\\":\\"foo\\",\\"value\\":\\"bar\\"}"'),
            (Base64, '"Q2hlbG8gd29ycmxkCg=="'),
        ],
    )
    def test_parse_literal_with_variables(input_type, input_value):
        # input_b needs to be evaluated as literal while the variable dict for
        # input_a is passed along.

        class Query(ObjectType):
            generic = GenericScalar(input_a=GenericScalar(), input_b=input_type())

            def resolve_generic(self, info, input_a=None, input_b=None):
                return input

>       schema = Schema(query=Query)

graphene/tests/issues/test_1419.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_313pytest_create_post">test_313.py::test_create_post</h3>
<details><summary> <pre>test_313.py::test_create_post</pre></summary><pre>
def test_create_post():
        query_string = """
        mutation {
          createPost(text: "Try this out") {
            result {
              __typename
            }
          }
        }
        """

>       schema = graphene.Schema(query=Query, mutation=Mutations)

graphene/tests/issues/test_313.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = <Mutations meta=<ObjectTypeOptions name='Mutations'>>
subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_356pytest_issue">test_356.py::test_issue</h3>
<details><summary> <pre>test_356.py::test_issue</pre></summary><pre>
def test_issue():
        class Query(graphene.ObjectType):
            things = relay.ConnectionField(MyUnion)

        with raises(Exception) as exc_info:
            graphene.Schema(query=Query)

>       assert str(exc_info.value) == (
            "Query fields cannot be resolved."
            " IterableConnectionField type has to be a subclass of Connection."
            ' Received "MyUnion".'
        )
E       assert "'TypeMap' ob...te 'add_type'" == 'Query fields...ed "MyUnion".'
E         
E         - Query fields cannot be resolved. IterableConnectionField type has to be a subclass of Connection. Received "MyUnion".
E         + 'TypeMap' object has no attribute 'add_type'

graphene/tests/issues/test_356.py:29: AssertionError
</pre>
</details>
<h3 id="test_490pytest_issue">test_490.py::test_issue</h3>
<details><summary> <pre>test_490.py::test_issue</pre></summary><pre>
def test_issue():
        query_string = """
        query myQuery {
          someField(from: "Oh")
        }
        """

>       schema = graphene.Schema(query=Query)

graphene/tests/issues/test_490.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_720pytest_issue">test_720.py::test_issue</h3>
<details><summary> <pre>test_720.py::test_issue</pre></summary><pre>
def test_issue():
        query_string = """
        query myQuery {
          myField(input: {x: 1})
        }
        """

>       schema = graphene.Schema(query=Query)

graphene/tests/issues/test_720.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_argumentpytest_argument">test_argument.py::test_argument</h3>
<details><summary> <pre>test_argument.py::test_argument</pre></summary><pre>
def test_argument():
        arg = Argument(String, default_value="a", description="desc", name="b")
>       assert arg.type == String
E       AttributeError: 'Argument' object has no attribute 'type'

graphene/types/tests/test_argument.py:14: AttributeError
</pre>
</details>
<h3 id="test_argumentpytest_argument_comparasion">test_argument.py::test_argument_comparasion</h3>
<details><summary> <pre>test_argument.py::test_argument_comparasion</pre></summary><pre>
def test_argument_comparasion():
        arg1 = Argument(
            String,
            name="Hey",
            description="Desc",
            default_value="default",
            deprecation_reason="deprecated",
        )
        arg2 = Argument(
            String,
            name="Hey",
            description="Desc",
            default_value="default",
            deprecation_reason="deprecated",
        )

>       assert arg1 == arg2

graphene/types/tests/test_argument.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.types.argument.Argument object at 0x7fe41c3eb3d0>
other = <graphene.types.argument.Argument object at 0x7fe41c3eb690>

    def __eq__(self, other):
>       return isinstance(other, Argument) and (self.name == other.name and self.type == other.type and (self.default_value == other.default_value) and (self.description == other.description) and (self.deprecation_reason == other.deprecation_reason))
E       AttributeError: 'Argument' object has no attribute 'type'

graphene/types/argument.py:77: AttributeError
</pre>
</details>
<h3 id="test_argumentpytest_argument_required">test_argument.py::test_argument_required</h3>
<details><summary> <pre>test_argument.py::test_argument_required</pre></summary><pre>
def test_argument_required():
        arg = Argument(String, required=True)
>       assert arg.type == NonNull(String)
E       AttributeError: 'Argument' object has no attribute 'type'

graphene/types/tests/test_argument.py:42: AttributeError
</pre>
</details>
<h3 id="test_argumentpytest_to_arguments">test_argument.py::test_to_arguments</h3>
<details><summary> <pre>test_argument.py::test_to_arguments</pre></summary><pre>
def test_to_arguments():
        args = {"arg_string": Argument(String), "unmounted_arg": String(required=True)}

        my_args = to_arguments(args)
>       assert my_args == {
            "arg_string": Argument(String),
            "unmounted_arg": Argument(String, required=True),
        }
E       AssertionError: assert [<graphene.ty...7fe41c56b010>] == {'arg_string'...7fe41c721010>}
E         
E         Use -v to get more diff

graphene/types/tests/test_argument.py:49: AssertionError
</pre>
</details>
<h3 id="test_argumentpytest_to_arguments_deprecated">test_argument.py::test_to_arguments_deprecated</h3>
<details><summary> <pre>test_argument.py::test_to_arguments_deprecated</pre></summary><pre>
def test_to_arguments_deprecated():
        args = {"unmounted_arg": String(required=False, deprecation_reason="deprecated")}

        my_args = to_arguments(args)
>       assert my_args == {
            "unmounted_arg": Argument(
                String, required=False, deprecation_reason="deprecated"
            ),
        }
E       AssertionError: assert [<graphene.ty...7fe41c5364d0>] == {'unmounted_a...7fe41c55cc50>}
E         
E         Use -v to get more diff

graphene/types/tests/test_argument.py:59: AssertionError
</pre>
</details>
<h3 id="test_argumentpytest_to_arguments_required_deprecated">test_argument.py::test_to_arguments_required_deprecated</h3>
<details><summary> <pre>test_argument.py::test_to_arguments_required_deprecated</pre></summary><pre>
def test_to_arguments_required_deprecated():
        args = {
            "unmounted_arg": String(
                required=True, name="arg", deprecation_reason="deprecated"
            )
        }

>       with raises(AssertionError) as exc_info:
E       Failed: DID NOT RAISE <class 'AssertionError'>

graphene/types/tests/test_argument.py:73: Failed
</pre>
</details>
<h3 id="test_argumentpytest_to_arguments_raises_if_field">test_argument.py::test_to_arguments_raises_if_field</h3>
<details><summary> <pre>test_argument.py::test_to_arguments_raises_if_field</pre></summary><pre>
def test_to_arguments_raises_if_field():
        args = {"arg_string": Field(String)}

        with raises(ValueError) as exc_info:
            to_arguments(args)

>       assert str(exc_info.value) == (
            "Expected arg_string to be Argument, but received Field. Try using "
            "Argument(String)."
        )
E       assert "Unknown argu...field.Field'>" == 'Expected arg...ment(String).'
E         
E         - Expected arg_string to be Argument, but received Field. Try using Argument(String).
E         + Unknown argument "arg_string" of type <class 'graphene.types.field.Field'>

graphene/types/tests/test_argument.py:85: AssertionError
</pre>
</details>
<h3 id="test_argumentpytest_to_arguments_raises_if_inputfield">test_argument.py::test_to_arguments_raises_if_inputfield</h3>
<details><summary> <pre>test_argument.py::test_to_arguments_raises_if_inputfield</pre></summary><pre>
def test_to_arguments_raises_if_inputfield():
        args = {"arg_string": InputField(String)}

        with raises(ValueError) as exc_info:
            to_arguments(args)

>       assert str(exc_info.value) == (
            "Expected arg_string to be Argument, but received InputField. Try "
            "using Argument(String)."
        )
E       assert "Unknown argu....InputField'>" == 'Expected arg...ment(String).'
E         
E         - Expected arg_string to be Argument, but received InputField. Try using Argument(String).
E         + Unknown argument "arg_string" of type <class 'graphene.types.inputfield.InputField'>

graphene/types/tests/test_argument.py:97: AssertionError
</pre>
</details>
<h3 id="test_argumentpytest_argument_with_lazy_type">test_argument.py::test_argument_with_lazy_type</h3>
<details><summary> <pre>test_argument.py::test_argument_with_lazy_type</pre></summary><pre>
def test_argument_with_lazy_type():
        MyType = object()
        arg = Argument(lambda: MyType)
>       assert arg.type == MyType
E       AttributeError: 'Argument' object has no attribute 'type'

graphene/types/tests/test_argument.py:106: AttributeError
</pre>
</details>
<h3 id="test_argumentpytest_argument_with_lazy_partial_type">test_argument.py::test_argument_with_lazy_partial_type</h3>
<details><summary> <pre>test_argument.py::test_argument_with_lazy_partial_type</pre></summary><pre>
def test_argument_with_lazy_partial_type():
        MyType = object()
        arg = Argument(partial(lambda: MyType))
>       assert arg.type == MyType
E       AttributeError: 'Argument' object has no attribute 'type'

graphene/types/tests/test_argument.py:112: AttributeError
</pre>
</details>
<h3 id="test_basepytest_basetype_create">test_base.py::test_basetype_create</h3>
<details><summary> <pre>test_base.py::test_basetype_create</pre></summary><pre>
def test_basetype_create():
>       MyBaseType = CustomType.create_type("MyBaseType")
E       AttributeError: type object 'CustomType' has no attribute 'create_type'

graphene/types/tests/test_base.py:51: AttributeError
</pre>
</details>
<h3 id="test_basepytest_basetype_create_extra">test_base.py::test_basetype_create_extra</h3>
<details><summary> <pre>test_base.py::test_basetype_create_extra</pre></summary><pre>
def test_basetype_create_extra():
>       MyBaseType = CustomType.create_type("MyBaseType", name="Base", description="Desc")
E       AttributeError: type object 'CustomType' has no attribute 'create_type'

graphene/types/tests/test_base.py:59: AttributeError
</pre>
</details>
<h3 id="test_definitionpytest_defines_a_query_only_schema">test_definition.py::test_defines_a_query_only_schema</h3>
<details><summary> <pre>test_definition.py::test_defines_a_query_only_schema</pre></summary><pre>
def test_defines_a_query_only_schema():
>       blog_schema = Schema(Query)

graphene/types/tests/test_definition.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_definitionpytest_defines_a_mutation_schema">test_definition.py::test_defines_a_mutation_schema</h3>
<details><summary> <pre>test_definition.py::test_defines_a_mutation_schema</pre></summary><pre>
def test_defines_a_mutation_schema():
>       blog_schema = Schema(Query, mutation=Mutation)

graphene/types/tests/test_definition.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = <Mutation meta=<ObjectTypeOptions name='Mutation'>>
subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_definitionpytest_defines_a_subscription_schema">test_definition.py::test_defines_a_subscription_schema</h3>
<details><summary> <pre>test_definition.py::test_defines_a_subscription_schema</pre></summary><pre>
def test_defines_a_subscription_schema():
>       blog_schema = Schema(Query, subscription=Subscription)

graphene/types/tests/test_definition.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None
subscription = <Subscription meta=<ObjectTypeOptions name='Subscription'>>
types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_definitionpytest_includes_nested_input_objects_in_the_map">test_definition.py::test_includes_nested_input_objects_in_the_map</h3>
<details><summary> <pre>test_definition.py::test_includes_nested_input_objects_in_the_map</pre></summary><pre>
def test_includes_nested_input_objects_in_the_map():
        class NestedInputObject(InputObjectType):
            value = String()

        class SomeInputObject(InputObjectType):
            nested = InputField(NestedInputObject)

        class SomeMutation(Mutation):
            mutate_something = Field(Article, input=Argument(SomeInputObject))

        class SomeSubscription(Mutation):
            subscribe_to_something = Field(Article, input=Argument(SomeInputObject))

>       schema = Schema(query=Query, mutation=SomeMutation, subscription=SomeSubscription)

graphene/types/tests/test_definition.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = <SomeMutation meta=<ObjectTypeOptions name='SomeMutation'>>
subscription = <SomeSubscription meta=<ObjectTypeOptions name='SomeSubscription'>>
types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_definitionpytest_includes_interfaces_thunk_subtypes_in_the_type_map">test_definition.py::test_includes_interfaces_thunk_subtypes_in_the_type_map</h3>
<details><summary> <pre>test_definition.py::test_includes_interfaces_thunk_subtypes_in_the_type_map</pre></summary><pre>
def test_includes_interfaces_thunk_subtypes_in_the_type_map():
        class SomeInterface(Interface):
            f = Int()

        class SomeSubtype(ObjectType):
            class Meta:
                interfaces = (SomeInterface,)

        class Query(ObjectType):
            iface = Field(lambda: SomeInterface)

>       schema = Schema(query=Query, types=[SomeSubtype])

graphene/types/tests/test_definition.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<SomeSubtype meta=<ObjectTypeOptions name='SomeSubtype'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_definitionpytest_includes_types_in_union">test_definition.py::test_includes_types_in_union</h3>
<details><summary> <pre>test_definition.py::test_includes_types_in_union</pre></summary><pre>
def test_includes_types_in_union():
        class SomeType(ObjectType):
            a = String()

        class OtherType(ObjectType):
            b = String()

        class MyUnion(Union):
            class Meta:
                types = (SomeType, OtherType)

        class Query(ObjectType):
            union = Field(MyUnion)

>       schema = Schema(query=Query)

graphene/types/tests/test_definition.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_definitionpytest_maps_enum">test_definition.py::test_maps_enum</h3>
<details><summary> <pre>test_definition.py::test_maps_enum</pre></summary><pre>
def test_maps_enum():
        class SomeType(ObjectType):
            a = String()

        class OtherType(ObjectType):
            b = String()

        class MyUnion(Union):
            class Meta:
                types = (SomeType, OtherType)

        class Query(ObjectType):
            union = Field(MyUnion)

>       schema = Schema(query=Query)

graphene/types/tests/test_definition.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_definitionpytest_includes_interfaces_subtypes_in_the_type_map">test_definition.py::test_includes_interfaces_subtypes_in_the_type_map</h3>
<details><summary> <pre>test_definition.py::test_includes_interfaces_subtypes_in_the_type_map</pre></summary><pre>
def test_includes_interfaces_subtypes_in_the_type_map():
        class SomeInterface(Interface):
            f = Int()

        class SomeSubtype(ObjectType):
            class Meta:
                interfaces = (SomeInterface,)

        class Query(ObjectType):
            iface = Field(SomeInterface)

>       schema = Schema(query=Query, types=[SomeSubtype])

graphene/types/tests/test_definition.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<SomeSubtype meta=<ObjectTypeOptions name='SomeSubtype'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_definitionpytest_stringifies_simple_types">test_definition.py::test_stringifies_simple_types</h3>
<details><summary> <pre>test_definition.py::test_stringifies_simple_types</pre></summary><pre>
def test_stringifies_simple_types():
        assert str(Int) == "Int"
        assert str(Article) == "Article"
        assert str(MyInterface) == "MyInterface"
        assert str(MyUnion) == "MyUnion"
        assert str(MyEnum) == "MyEnum"
        assert str(MyInputObjectType) == "MyInputObjectType"
>       assert str(NonNull(Int)) == "Int!"

graphene/types/tests/test_definition.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.types.structures.NonNull object at 0x7fe41c3c8650>

    def __str__(self):
>       return f'{self.of_type}!'
E       AttributeError: 'NonNull' object has no attribute 'of_type'

graphene/types/structures.py:81: AttributeError
</pre>
</details>
<h3 id="test_definitionpytest_does_not_mutate_passed_field_definitions">test_definition.py::test_does_not_mutate_passed_field_definitions</h3>
<details><summary> <pre>test_definition.py::test_does_not_mutate_passed_field_definitions</pre></summary><pre>
def test_does_not_mutate_passed_field_definitions():
        class CommonFields:
            field1 = String()
            field2 = String(id=String())

        class TestObject1(CommonFields, ObjectType):
            pass

        class TestObject2(CommonFields, ObjectType):
            pass

>       assert TestObject1._meta.fields == TestObject2._meta.fields
E       AssertionError: assert {'field1': <g...7fe41c4d6810>} == {'field1': <g...7fe41c504b50>}
E         
E         Differing items:
E         {'field1': <graphene.types.field.Field object at 0x7fe41c4d4b90>} != {'field1': <graphene.types.field.Field object at 0x7fe41c879510>}
E         {'field2': <graphene.types.field.Field object at 0x7fe41c4d6810>} != {'field2': <graphene.types.field.Field object at 0x7fe41c504b50>}
E         Use -v to get more diff

graphene/types/tests/test_definition.py:305: AssertionError
</pre>
</details>
<h3 id="test_definitionpytest_graphene_graphql_type_can_be_copied">test_definition.py::test_graphene_graphql_type_can_be_copied</h3>
<details><summary> <pre>test_definition.py::test_graphene_graphql_type_can_be_copied</pre></summary><pre>
def test_graphene_graphql_type_can_be_copied():
        class Query(ObjectType):
            field = String()

            def resolve_field(self, info):
                return ""

>       schema = Schema(query=Query)

graphene/types/tests/test_definition.py:327: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_dynamicpytest_dynamic">test_dynamic.py::test_dynamic</h3>
<details><summary> <pre>test_dynamic.py::test_dynamic</pre></summary><pre>
def test_dynamic():
        dynamic = Dynamic(lambda: String)
>       assert dynamic.get_type() == String
E       AttributeError: 'Dynamic' object has no attribute 'get_type'

graphene/types/tests/test_dynamic.py:10: AttributeError
</pre>
</details>
<h3 id="test_dynamicpytest_nonnull">test_dynamic.py::test_nonnull</h3>
<details><summary> <pre>test_dynamic.py::test_nonnull</pre></summary><pre>
def test_nonnull():
        dynamic = Dynamic(lambda: NonNull(String))
>       assert dynamic.get_type().of_type == String
E       AttributeError: 'Dynamic' object has no attribute 'get_type'

graphene/types/tests/test_dynamic.py:16: AttributeError
</pre>
</details>
<h3 id="test_dynamicpytest_list">test_dynamic.py::test_list</h3>
<details><summary> <pre>test_dynamic.py::test_list</pre></summary><pre>
def test_list():
        dynamic = Dynamic(lambda: List(String))
>       assert dynamic.get_type().of_type == String
E       AttributeError: 'Dynamic' object has no attribute 'get_type'

graphene/types/tests/test_dynamic.py:22: AttributeError
</pre>
</details>
<h3 id="test_dynamicpytest_list_non_null">test_dynamic.py::test_list_non_null</h3>
<details><summary> <pre>test_dynamic.py::test_list_non_null</pre></summary><pre>
def test_list_non_null():
        dynamic = Dynamic(lambda: List(NonNull(String)))
>       assert dynamic.get_type().of_type.of_type == String
E       AttributeError: 'Dynamic' object has no attribute 'get_type'

graphene/types/tests/test_dynamic.py:28: AttributeError
</pre>
</details>
<h3 id="test_dynamicpytest_partial">test_dynamic.py::test_partial</h3>
<details><summary> <pre>test_dynamic.py::test_partial</pre></summary><pre>
def test_partial():
        def __type(_type):
            return _type

        dynamic = Dynamic(partial(__type, String))
>       assert dynamic.get_type() == String
E       AttributeError: 'Dynamic' object has no attribute 'get_type'

graphene/types/tests/test_dynamic.py:37: AttributeError
</pre>
</details>
<h3 id="test_enumpytest_enum_from_python3_enum_uses_default_builtin_doc">test_enum.py::test_enum_from_python3_enum_uses_default_builtin_doc</h3>
<details><summary> <pre>test_enum.py::test_enum_from_python3_enum_uses_default_builtin_doc</pre></summary><pre>
def test_enum_from_python3_enum_uses_default_builtin_doc():
        RGB = Enum("RGB", "RED,GREEN,BLUE")
>       assert RGB._meta.description == "An enumeration."
E       AssertionError: assert None == 'An enumeration.'
E        +  where None = <EnumOptions name='RGB'>.description
E        +    where <EnumOptions name='RGB'> = <RGB meta=<EnumOptions name='RGB'>>._meta

graphene/types/tests/test_enum.py:80: AssertionError
</pre>
</details>
<h3 id="test_enumpytest_enum_from_builtin_enum_accepts_lambda_description">test_enum.py::test_enum_from_builtin_enum_accepts_lambda_description</h3>
<details><summary> <pre>test_enum.py::test_enum_from_builtin_enum_accepts_lambda_description</pre></summary><pre>
def test_enum_from_builtin_enum_accepts_lambda_description():
        def custom_description(value):
            if not value:
                return "StarWars Episodes"

            return "New Hope Episode" if value == Episode.NEWHOPE else "Other"

        def custom_deprecation_reason(value):
            return "meh" if value == Episode.NEWHOPE else None

        PyEpisode = PyEnum("PyEpisode", "NEWHOPE,EMPIRE,JEDI")
        Episode = Enum.from_enum(
            PyEpisode,
            description=custom_description,
            deprecation_reason=custom_deprecation_reason,
        )

>       class Query(ObjectType):

graphene/types/tests/test_enum.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.enum.PyEpisode object at 0x7fe41c5c7c90>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'PyEpisode' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_enumpytest_enum_from_python3_enum_uses_enum_doc">test_enum.py::test_enum_from_python3_enum_uses_enum_doc</h3>
<details><summary> <pre>test_enum.py::test_enum_from_python3_enum_uses_enum_doc</pre></summary><pre>
def test_enum_from_python3_enum_uses_enum_doc():
        from enum import Enum as PyEnum

        class Color(PyEnum):
            """This is the description"""

            RED = 1
            GREEN = 2
            BLUE = 3

        RGB = Enum.from_enum(Color)
        assert RGB._meta.enum == Color
>       assert RGB._meta.description == "This is the description"
E       AssertionError: assert None == 'This is the description'
E        +  where None = <EnumOptions name='Color'>.description
E        +    where <EnumOptions name='Color'> = <Color meta=<EnumOptions name='Color'>>._meta

graphene/types/tests/test_enum.py:130: AssertionError
</pre>
</details>
<h3 id="test_enumpytest_enum_value_as_unmounted_field">test_enum.py::test_enum_value_as_unmounted_field</h3>
<details><summary> <pre>test_enum.py::test_enum_value_as_unmounted_field</pre></summary><pre>
def test_enum_value_as_unmounted_field():
        class RGB(Enum):
            RED = 1
            GREEN = 2
            BLUE = 3

        unmounted = RGB()
        unmounted_field = unmounted.Field()
>       assert isinstance(unmounted_field, Field)
E       assert False
E        +  where False = isinstance(None, Field)

graphene/types/tests/test_enum.py:156: AssertionError
</pre>
</details>
<h3 id="test_enumpytest_enum_value_as_unmounted_inputfield">test_enum.py::test_enum_value_as_unmounted_inputfield</h3>
<details><summary> <pre>test_enum.py::test_enum_value_as_unmounted_inputfield</pre></summary><pre>
def test_enum_value_as_unmounted_inputfield():
        class RGB(Enum):
            RED = 1
            GREEN = 2
            BLUE = 3

        unmounted = RGB()
        unmounted_field = unmounted.InputField()
>       assert isinstance(unmounted_field, InputField)
E       assert False
E        +  where False = isinstance(None, InputField)

graphene/types/tests/test_enum.py:168: AssertionError
</pre>
</details>
<h3 id="test_enumpytest_enum_value_as_unmounted_argument">test_enum.py::test_enum_value_as_unmounted_argument</h3>
<details><summary> <pre>test_enum.py::test_enum_value_as_unmounted_argument</pre></summary><pre>
def test_enum_value_as_unmounted_argument():
        class RGB(Enum):
            RED = 1
            GREEN = 2
            BLUE = 3

        unmounted = RGB()
        unmounted_field = unmounted.Argument()
>       assert isinstance(unmounted_field, Argument)
E       assert False
E        +  where False = isinstance(None, Argument)

graphene/types/tests/test_enum.py:180: AssertionError
</pre>
</details>
<h3 id="test_enumpytest_enum_can_be_initialized">test_enum.py::test_enum_can_be_initialized</h3>
<details><summary> <pre>test_enum.py::test_enum_can_be_initialized</pre></summary><pre>
def test_enum_can_be_initialized():
        class RGB(Enum):
            RED = 1
            GREEN = 2
            BLUE = 3

>       assert RGB.get(1) == RGB.RED
E       AttributeError: type object 'RGB' has no attribute 'get'

graphene/types/tests/test_enum.py:201: AttributeError
</pre>
</details>
<h3 id="test_enumpytest_enum_to_enum_comparison_should_differ">test_enum.py::test_enum_to_enum_comparison_should_differ</h3>
<details><summary> <pre>test_enum.py::test_enum_to_enum_comparison_should_differ</pre></summary><pre>
def test_enum_to_enum_comparison_should_differ():
        class RGB1(Enum):
            RED = 1
            GREEN = 2
            BLUE = 3

        class RGB2(Enum):
            RED = 1
            GREEN = 2
            BLUE = 3

>       assert RGB1.RED != RGB2.RED
E       AssertionError: assert <EnumMeta.RED: 1> != <EnumMeta.RED: 1>
E        +  where <EnumMeta.RED: 1> = <RGB1 meta=<EnumOptions name='RGB1'>>.RED
E        +  and   <EnumMeta.RED: 1> = <RGB2 meta=<EnumOptions name='RGB2'>>.RED

graphene/types/tests/test_enum.py:228: AssertionError
</pre>
</details>
<h3 id="test_enumpytest_enum_types">test_enum.py::test_enum_types</h3>
<details><summary> <pre>test_enum.py::test_enum_types</pre></summary><pre>
def test_enum_types():
        from enum import Enum as PyEnum

        class Color(PyEnum):
            """Primary colors"""

            RED = 1
            YELLOW = 2
            BLUE = 3

        GColor = Enum.from_enum(Color)

>       class Query(ObjectType):

graphene/types/tests/test_enum.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.enum.Color object at 0x7fe41c4fa5d0>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'Color' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_enumpytest_enum_resolver">test_enum.py::test_enum_resolver</h3>
<details><summary> <pre>test_enum.py::test_enum_resolver</pre></summary><pre>
def test_enum_resolver():
        from enum import Enum as PyEnum

        class Color(PyEnum):
            RED = 1
            GREEN = 2
            BLUE = 3

        GColor = Enum.from_enum(Color)

>       class Query(ObjectType):

graphene/types/tests/test_enum.py:298: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.enum.Color object at 0x7fe41c674050>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'Color' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_enumpytest_enum_resolver_compat">test_enum.py::test_enum_resolver_compat</h3>
<details><summary> <pre>test_enum.py::test_enum_resolver_compat</pre></summary><pre>
def test_enum_resolver_compat():
        from enum import Enum as PyEnum

        class Color(PyEnum):
            RED = 1
            GREEN = 2
            BLUE = 3

        GColor = Enum.from_enum(Color)

>       class Query(ObjectType):

graphene/types/tests/test_enum.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.enum.Color object at 0x7fe41c6d8410>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'Color' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_enumpytest_enum_with_name">test_enum.py::test_enum_with_name</h3>
<details><summary> <pre>test_enum.py::test_enum_with_name</pre></summary><pre>
def test_enum_with_name():
        from enum import Enum as PyEnum

        class Color(PyEnum):
            RED = 1
            YELLOW = 2
            BLUE = 3

        GColor = Enum.from_enum(Color, description="original colors")
>       UniqueGColor = Enum.from_enum(
            Color, name="UniqueColor", description="unique colors"
        )
E       TypeError: Enum.from_enum() got an unexpected keyword argument 'name'

graphene/types/tests/test_enum.py:355: TypeError
</pre>
</details>
<h3 id="test_enumpytest_enum_resolver_invalid">test_enum.py::test_enum_resolver_invalid</h3>
<details><summary> <pre>test_enum.py::test_enum_resolver_invalid</pre></summary><pre>
def test_enum_resolver_invalid():
        from enum import Enum as PyEnum

        class Color(PyEnum):
            RED = 1
            GREEN = 2
            BLUE = 3

        GColor = Enum.from_enum(Color)

>       class Query(ObjectType):

graphene/types/tests/test_enum.py:402: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.enum.Color object at 0x7fe41c667ad0>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'Color' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_enumpytest_field_enum_argument">test_enum.py::test_field_enum_argument</h3>
<details><summary> <pre>test_enum.py::test_field_enum_argument</pre></summary><pre>
def test_field_enum_argument():
        class Color(Enum):
            RED = 1
            GREEN = 2
            BLUE = 3

>       class Brick(ObjectType):

graphene/types/tests/test_enum.py:421: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_enum.test_field_enum_argument.<locals>.Color object at 0x7fe41c6483d0>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'Color' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_enumpytest_mutation_enum_input">test_enum.py::test_mutation_enum_input</h3>
<details><summary> <pre>test_enum.py::test_mutation_enum_input</pre></summary><pre>
def test_mutation_enum_input():
        class RGB(Enum):
            """Available colors"""

            RED = 1
            GREEN = 2
            BLUE = 3

        color_input = None

>       class CreatePaint(Mutation):

graphene/types/tests/test_enum.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/mutation.py:75: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_enum.test_mutation_enum_input.<locals>.RGB object at 0x7fe41c4dd450>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'RGB' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_enumpytest_mutation_enum_input_type">test_enum.py::test_mutation_enum_input_type</h3>
<details><summary> <pre>test_enum.py::test_mutation_enum_input_type</pre></summary><pre>
def test_mutation_enum_input_type():
        class RGB(Enum):
            """Available colors"""

            RED = 1
            GREEN = 2
            BLUE = 3

>       class ColorInput(InputObjectType):

graphene/types/tests/test_enum.py:500: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/inputobjecttype.py:80: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=InputField))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_enum.test_mutation_enum_input_type.<locals>.RGB object at 0x7fe41c4079d0>
_as = <class 'graphene.types.inputfield.InputField'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'RGB' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_enumpytest_hashable_enum">test_enum.py::test_hashable_enum</h3>
<details><summary> <pre>test_enum.py::test_hashable_enum</pre></summary><pre>
def test_hashable_enum():
        class RGB(Enum):
            """Available colors"""

            RED = 1
            GREEN = 2
            BLUE = 3

        color_map = {RGB.RED: "a", RGB.BLUE: "b", 1: "c"}

>       assert color_map[RGB.RED] == "a"
E       AssertionError: assert 'c' == 'a'
E         
E         - a
E         + c

graphene/types/tests/test_enum.py:548: AssertionError
</pre>
</details>
<h3 id="test_enumpytest_enum_description_member_not_interpreted_as_property">test_enum.py::test_enum_description_member_not_interpreted_as_property</h3>
<details><summary> <pre>test_enum.py::test_enum_description_member_not_interpreted_as_property</pre></summary><pre>
def test_enum_description_member_not_interpreted_as_property():
        class RGB(Enum):
            """Description"""

            red = "red"
            green = "green"
            blue = "blue"
            description = "description"
            deprecation_reason = "deprecation_reason"

>       class Query(ObjectType):

graphene/types/tests/test_enum.py:596: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_enum.test_enum_description_member_not_interpreted_as_property.<locals>.RGB object at 0x7fe41c77c350>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'RGB' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_fieldpytest_field_basic">test_field.py::test_field_basic</h3>
<details><summary> <pre>test_field.py::test_field_basic</pre></summary><pre>
def test_field_basic():
        MyType = object()
        args = {"my arg": Argument(True)}

        def resolver():
            return None

        deprecation_reason = "Deprecated now"
        description = "My Field"
        my_default = "something"
        field = Field(
            MyType,
            name="name",
            args=args,
            resolver=resolver,
            description=description,
            deprecation_reason=deprecation_reason,
            default_value=my_default,
        )
        assert field.name == "name"
>       assert field.args == args
E       AssertionError: assert [<graphene.ty...7fe41c621090>] == {'my arg': <g...7fe41c621090>}
E         
E         Use -v to get more diff

graphene/types/tests/test_field.py:40: AssertionError
</pre>
</details>
<h3 id="test_fieldpytest_field_required">test_field.py::test_field_required</h3>
<details><summary> <pre>test_field.py::test_field_required</pre></summary><pre>
def test_field_required():
        MyType = object()
        field = Field(MyType, required=True)
>       assert isinstance(field.type, NonNull)
E       AttributeError: 'Field' object has no attribute 'type'

graphene/types/tests/test_field.py:50: AttributeError
</pre>
</details>
<h3 id="test_fieldpytest_field_source">test_field.py::test_field_source</h3>
<details><summary> <pre>test_field.py::test_field_source</pre></summary><pre>
def test_field_source():
        MyType = object()
>       field = Field(MyType, source="value")

graphene/types/tests/test_field.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.types.field.Field object at 0x7fe41c6bcb90>
type_ = <object object at 0x7fe41dd854e0>, args = None, resolver = None
source = 'value', deprecation_reason = None, name = None, description = None
required = False, _creation_counter = None, default_value = None
extra_args = {}

    def __init__(self, type_, args=None, resolver=None, source=None, deprecation_reason=None, name=None, description=None, required=False, _creation_counter=None, default_value=None, **extra_args):
        super(Field, self).__init__(_creation_counter=_creation_counter)
        assert not args or isinstance(args, Mapping), f'Arguments in a field have to be a mapping, received "{args}".'
        assert not (source and resolver), 'A Field cannot have a source and a resolver in at the same time.'
        assert not callable(default_value), f'The default value can not be a function but received "{base_type(default_value)}".'
        if required:
            type_ = NonNull(type_)
        if isinstance(name, (Argument, UnmountedType)):
            extra_args['name'] = name
            name = None
        if isinstance(source, (Argument, UnmountedType)):
            extra_args['source'] = source
            source = None
        self.name = name
        self._type = type_
        self.args = to_arguments(args or {}, extra_args)
        if source:
>           resolver = partial(source_resolver, source)
E           NameError: name 'source_resolver' is not defined

graphene/types/field.py:73: NameError
</pre>
</details>
<h3 id="test_fieldpytest_field_source_dict_or_attr">test_field.py::test_field_source_dict_or_attr</h3>
<details><summary> <pre>test_field.py::test_field_source_dict_or_attr</pre></summary><pre>
def test_field_source_dict_or_attr():
        MyType = object()
>       field = Field(MyType, source="value")

graphene/types/tests/test_field.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.types.field.Field object at 0x7fe41c5d7290>
type_ = <object object at 0x7fe41dd87340>, args = None, resolver = None
source = 'value', deprecation_reason = None, name = None, description = None
required = False, _creation_counter = None, default_value = None
extra_args = {}

    def __init__(self, type_, args=None, resolver=None, source=None, deprecation_reason=None, name=None, description=None, required=False, _creation_counter=None, default_value=None, **extra_args):
        super(Field, self).__init__(_creation_counter=_creation_counter)
        assert not args or isinstance(args, Mapping), f'Arguments in a field have to be a mapping, received "{args}".'
        assert not (source and resolver), 'A Field cannot have a source and a resolver in at the same time.'
        assert not callable(default_value), f'The default value can not be a function but received "{base_type(default_value)}".'
        if required:
            type_ = NonNull(type_)
        if isinstance(name, (Argument, UnmountedType)):
            extra_args['name'] = name
            name = None
        if isinstance(source, (Argument, UnmountedType)):
            extra_args['source'] = source
            source = None
        self.name = name
        self._type = type_
        self.args = to_arguments(args or {}, extra_args)
        if source:
>           resolver = partial(source_resolver, source)
E           NameError: name 'source_resolver' is not defined

graphene/types/field.py:73: NameError
</pre>
</details>
<h3 id="test_fieldpytest_field_with_lazy_type">test_field.py::test_field_with_lazy_type</h3>
<details><summary> <pre>test_field.py::test_field_with_lazy_type</pre></summary><pre>
def test_field_with_lazy_type():
        MyType = object()
        field = Field(lambda: MyType)
>       assert field.type == MyType
E       AttributeError: 'Field' object has no attribute 'type'

graphene/types/tests/test_field.py:79: AttributeError
</pre>
</details>
<h3 id="test_fieldpytest_field_with_lazy_partial_type">test_field.py::test_field_with_lazy_partial_type</h3>
<details><summary> <pre>test_field.py::test_field_with_lazy_partial_type</pre></summary><pre>
def test_field_with_lazy_partial_type():
        MyType = object()
        field = Field(partial(lambda: MyType))
>       assert field.type == MyType
E       AttributeError: 'Field' object has no attribute 'type'

graphene/types/tests/test_field.py:85: AttributeError
</pre>
</details>
<h3 id="test_fieldpytest_field_with_string_type">test_field.py::test_field_with_string_type</h3>
<details><summary> <pre>test_field.py::test_field_with_string_type</pre></summary><pre>
def test_field_with_string_type():
        field = Field("graphene.types.tests.utils.MyLazyType")
>       assert field.type == MyLazyType
E       AttributeError: 'Field' object has no attribute 'type'

graphene/types/tests/test_field.py:90: AttributeError
</pre>
</details>
<h3 id="test_fieldpytest_field_source_func">test_field.py::test_field_source_func</h3>
<details><summary> <pre>test_field.py::test_field_source_func</pre></summary><pre>
def test_field_source_func():
        MyType = object()
>       field = Field(MyType, source="value_func")

graphene/types/tests/test_field.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.types.field.Field object at 0x7fe41c6eac50>
type_ = <object object at 0x7fe41dd86160>, args = None, resolver = None
source = 'value_func', deprecation_reason = None, name = None
description = None, required = False, _creation_counter = None
default_value = None, extra_args = {}

    def __init__(self, type_, args=None, resolver=None, source=None, deprecation_reason=None, name=None, description=None, required=False, _creation_counter=None, default_value=None, **extra_args):
        super(Field, self).__init__(_creation_counter=_creation_counter)
        assert not args or isinstance(args, Mapping), f'Arguments in a field have to be a mapping, received "{args}".'
        assert not (source and resolver), 'A Field cannot have a source and a resolver in at the same time.'
        assert not callable(default_value), f'The default value can not be a function but received "{base_type(default_value)}".'
        if required:
            type_ = NonNull(type_)
        if isinstance(name, (Argument, UnmountedType)):
            extra_args['name'] = name
            name = None
        if isinstance(source, (Argument, UnmountedType)):
            extra_args['source'] = source
            source = None
        self.name = name
        self._type = type_
        self.args = to_arguments(args or {}, extra_args)
        if source:
>           resolver = partial(source_resolver, source)
E           NameError: name 'source_resolver' is not defined

graphene/types/field.py:73: NameError
</pre>
</details>
<h3 id="test_fieldpytest_field_source_method">test_field.py::test_field_source_method</h3>
<details><summary> <pre>test_field.py::test_field_source_method</pre></summary><pre>
def test_field_source_method():
        MyType = object()
>       field = Field(MyType, source="value_method")

graphene/types/tests/test_field.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.types.field.Field object at 0x7fe41c4d6f10>
type_ = <object object at 0x7fe41dd84f90>, args = None, resolver = None
source = 'value_method', deprecation_reason = None, name = None
description = None, required = False, _creation_counter = None
default_value = None, extra_args = {}

    def __init__(self, type_, args=None, resolver=None, source=None, deprecation_reason=None, name=None, description=None, required=False, _creation_counter=None, default_value=None, **extra_args):
        super(Field, self).__init__(_creation_counter=_creation_counter)
        assert not args or isinstance(args, Mapping), f'Arguments in a field have to be a mapping, received "{args}".'
        assert not (source and resolver), 'A Field cannot have a source and a resolver in at the same time.'
        assert not callable(default_value), f'The default value can not be a function but received "{base_type(default_value)}".'
        if required:
            type_ = NonNull(type_)
        if isinstance(name, (Argument, UnmountedType)):
            extra_args['name'] = name
            name = None
        if isinstance(source, (Argument, UnmountedType)):
            extra_args['source'] = source
            source = None
        self.name = name
        self._type = type_
        self.args = to_arguments(args or {}, extra_args)
        if source:
>           resolver = partial(source_resolver, source)
E           NameError: name 'source_resolver' is not defined

graphene/types/field.py:73: NameError
</pre>
</details>
<h3 id="test_fieldpytest_field_source_as_argument">test_field.py::test_field_source_as_argument</h3>
<details><summary> <pre>test_field.py::test_field_source_as_argument</pre></summary><pre>
def test_field_source_as_argument():
        MyType = object()
        field = Field(MyType, source=String())
>       assert "source" in field.args
E       AssertionError: assert 'source' in [<graphene.types.argument.Argument object at 0x7fe41c632710>]
E        +  where [<graphene.types.argument.Argument object at 0x7fe41c632710>] = <graphene.types.field.Field object at 0x7fe41c633310>.args

graphene/types/tests/test_field.py:118: AssertionError
</pre>
</details>
<h3 id="test_fieldpytest_field_name_as_argument">test_field.py::test_field_name_as_argument</h3>
<details><summary> <pre>test_field.py::test_field_name_as_argument</pre></summary><pre>
def test_field_name_as_argument():
        MyType = object()
        field = Field(MyType, name=String())
>       assert "name" in field.args
E       AssertionError: assert 'name' in [<graphene.types.argument.Argument object at 0x7fe41c7f69d0>]
E        +  where [<graphene.types.argument.Argument object at 0x7fe41c7f69d0>] = <graphene.types.field.Field object at 0x7fe41c7f6ed0>.args

graphene/types/tests/test_field.py:125: AssertionError
</pre>
</details>
<h3 id="test_fieldpytest_field_source_argument_as_kw">test_field.py::test_field_source_argument_as_kw</h3>
<details><summary> <pre>test_field.py::test_field_source_argument_as_kw</pre></summary><pre>
def test_field_source_argument_as_kw():
        MyType = object()
        deprecation_reason = "deprecated"
        field = Field(
            MyType,
            b=NonNull(True),
            c=Argument(None, deprecation_reason=deprecation_reason),
            a=NonNull(False),
        )
>       assert list(field.args) == ["b", "c", "a"]
E       AssertionError: assert [<graphene.ty...7fe41c4cee90>] == ['b', 'c', 'a']
E         
E         At index 0 diff: <graphene.types.argument.Argument object at 0x7fe41c4ce490> != 'b'
E         Use -v to get more diff

graphene/types/tests/test_field.py:138: AssertionError
</pre>
</details>
<h3 id="test_inputfieldpytest_inputfield_required">test_inputfield.py::test_inputfield_required</h3>
<details><summary> <pre>test_inputfield.py::test_inputfield_required</pre></summary><pre>
def test_inputfield_required():
        MyType = object()
        field = InputField(MyType, required=True)
>       assert isinstance(field.type, NonNull)
E       AttributeError: 'InputField' object has no attribute 'type'

graphene/types/tests/test_inputfield.py:13: AttributeError
</pre>
</details>
<h3 id="test_inputfieldpytest_inputfield_deprecated">test_inputfield.py::test_inputfield_deprecated</h3>
<details><summary> <pre>test_inputfield.py::test_inputfield_deprecated</pre></summary><pre>
def test_inputfield_deprecated():
        MyType = object()
        deprecation_reason = "deprecated"
        field = InputField(MyType, required=False, deprecation_reason=deprecation_reason)
>       assert isinstance(field.type, type(MyType))
E       AttributeError: 'InputField' object has no attribute 'type'

graphene/types/tests/test_inputfield.py:21: AttributeError
</pre>
</details>
<h3 id="test_inputfieldpytest_inputfield_with_lazy_type">test_inputfield.py::test_inputfield_with_lazy_type</h3>
<details><summary> <pre>test_inputfield.py::test_inputfield_with_lazy_type</pre></summary><pre>
def test_inputfield_with_lazy_type():
        MyType = object()
        field = InputField(lambda: MyType)
>       assert field.type == MyType
E       AttributeError: 'InputField' object has no attribute 'type'

graphene/types/tests/test_inputfield.py:36: AttributeError
</pre>
</details>
<h3 id="test_inputfieldpytest_inputfield_with_lazy_partial_type">test_inputfield.py::test_inputfield_with_lazy_partial_type</h3>
<details><summary> <pre>test_inputfield.py::test_inputfield_with_lazy_partial_type</pre></summary><pre>
def test_inputfield_with_lazy_partial_type():
        MyType = object()
        field = InputField(partial(lambda: MyType))
>       assert field.type == MyType
E       AttributeError: 'InputField' object has no attribute 'type'

graphene/types/tests/test_inputfield.py:42: AttributeError
</pre>
</details>
<h3 id="test_inputfieldpytest_inputfield_with_string_type">test_inputfield.py::test_inputfield_with_string_type</h3>
<details><summary> <pre>test_inputfield.py::test_inputfield_with_string_type</pre></summary><pre>
def test_inputfield_with_string_type():
        field = InputField("graphene.types.tests.utils.MyLazyType")
>       assert field.type == MyLazyType
E       AttributeError: 'InputField' object has no attribute 'type'

graphene/types/tests/test_inputfield.py:47: AttributeError
</pre>
</details>
<h3 id="test_inputobjecttypepytest_ordered_fields_in_inputobjecttype">test_inputobjecttype.py::test_ordered_fields_in_inputobjecttype</h3>
<details><summary> <pre>test_inputobjecttype.py::test_ordered_fields_in_inputobjecttype</pre></summary><pre>
def test_ordered_fields_in_inputobjecttype():
>       class MyInputObjectType(InputObjectType):

graphene/types/tests/test_inputobjecttype.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/inputobjecttype.py:80: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=InputField))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_inputobjecttype.MyScalar object at 0x7fe41c4cfcd0>
_as = <class 'graphene.types.inputfield.InputField'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_inputobjecttypepytest_generate_inputobjecttype_unmountedtype">test_inputobjecttype.py::test_generate_inputobjecttype_unmountedtype</h3>
<details><summary> <pre>test_inputobjecttype.py::test_generate_inputobjecttype_unmountedtype</pre></summary><pre>
def test_generate_inputobjecttype_unmountedtype():
>       class MyInputObjectType(InputObjectType):

graphene/types/tests/test_inputobjecttype.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/inputobjecttype.py:80: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=InputField))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_inputobjecttype.MyScalar object at 0x7fe41c536d10>
_as = <class 'graphene.types.inputfield.InputField'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_inputobjecttypepytest_generate_inputobjecttype_as_argument">test_inputobjecttype.py::test_generate_inputobjecttype_as_argument</h3>
<details><summary> <pre>test_inputobjecttype.py::test_generate_inputobjecttype_as_argument</pre></summary><pre>
def test_generate_inputobjecttype_as_argument():
>       class MyInputObjectType(InputObjectType):

graphene/types/tests/test_inputobjecttype.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/inputobjecttype.py:80: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=InputField))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_inputobjecttype.MyScalar object at 0x7fe41c6a0dd0>
_as = <class 'graphene.types.inputfield.InputField'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_inputobjecttypepytest_generate_inputobjecttype_inherit_abstracttype">test_inputobjecttype.py::test_generate_inputobjecttype_inherit_abstracttype</h3>
<details><summary> <pre>test_inputobjecttype.py::test_generate_inputobjecttype_inherit_abstracttype</pre></summary><pre>
def test_generate_inputobjecttype_inherit_abstracttype():
        class MyAbstractType:
            field1 = MyScalar(MyType)

>       class MyInputObjectType(InputObjectType, MyAbstractType):

graphene/types/tests/test_inputobjecttype.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/inputobjecttype.py:80: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=InputField))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_inputobjecttype.MyScalar object at 0x7fe41c6bf910>
_as = <class 'graphene.types.inputfield.InputField'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_inputobjecttypepytest_generate_inputobjecttype_inherit_abstracttype_reversed">test_inputobjecttype.py::test_generate_inputobjecttype_inherit_abstracttype_reversed</h3>
<details><summary> <pre>test_inputobjecttype.py::test_generate_inputobjecttype_inherit_abstracttype_reversed</pre></summary><pre>
def test_generate_inputobjecttype_inherit_abstracttype_reversed():
        class MyAbstractType:
            field1 = MyScalar(MyType)

>       class MyInputObjectType(MyAbstractType, InputObjectType):

graphene/types/tests/test_inputobjecttype.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/inputobjecttype.py:80: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=InputField))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_inputobjecttype.MyScalar object at 0x7fe41c6dbb50>
_as = <class 'graphene.types.inputfield.InputField'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_inputobjecttypepytest_inputobjecttype_of_input">test_inputobjecttype.py::test_inputobjecttype_of_input</h3>
<details><summary> <pre>test_inputobjecttype.py::test_inputobjecttype_of_input</pre></summary><pre>
def test_inputobjecttype_of_input():
        class Child(InputObjectType):
            first_name = String()
            last_name = String()

            @property
            def full_name(self):
                return f"{self.first_name} {self.last_name}"

        class Parent(InputObjectType):
            child = InputField(Child)

        class Query(ObjectType):
            is_child = Boolean(parent=Parent())

            def resolve_is_child(self, info, parent):
                return (
                    isinstance(parent.child, Child)
                    and parent.child.full_name == "Peter Griffin"
                )

>       schema = Schema(query=Query)

graphene/types/tests/test_inputobjecttype.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_inputobjecttypepytest_inputobjecttype_default_input_as_undefined">test_inputobjecttype.py::test_inputobjecttype_default_input_as_undefined</h3>
<details><summary> <pre>test_inputobjecttype.py::test_inputobjecttype_default_input_as_undefined</pre></summary><pre>
set_default_input_object_type_to_undefined = None

    def test_inputobjecttype_default_input_as_undefined(
        set_default_input_object_type_to_undefined,
    ):
        class TestUndefinedInput(InputObjectType):
            required_field = String(required=True)
            optional_field = String()

        class Query(ObjectType):
            undefined_optionals_work = Field(NonNull(Boolean), input=TestUndefinedInput())

            def resolve_undefined_optionals_work(self, info, input: TestUndefinedInput):
                # Confirm that optional_field comes as Undefined
                return (
                    input.required_field == "required" and input.optional_field is Undefined
                )

>       schema = Schema(query=Query)

graphene/types/tests/test_inputobjecttype.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_interfacepytest_ordered_fields_in_interface">test_interface.py::test_ordered_fields_in_interface</h3>
<details><summary> <pre>test_interface.py::test_ordered_fields_in_interface</pre></summary><pre>
def test_ordered_fields_in_interface():
>       class MyInterface(Interface):

graphene/types/tests/test_interface.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/interface.py:50: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_interface.MyScalar object at 0x7fe41c983350>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_interfacepytest_generate_interface_unmountedtype">test_interface.py::test_generate_interface_unmountedtype</h3>
<details><summary> <pre>test_interface.py::test_generate_interface_unmountedtype</pre></summary><pre>
def test_generate_interface_unmountedtype():
>       class MyInterface(Interface):

graphene/types/tests/test_interface.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/interface.py:50: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_interface.MyScalar object at 0x7fe41c4c5590>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_interfacepytest_generate_interface_inherit_abstracttype">test_interface.py::test_generate_interface_inherit_abstracttype</h3>
<details><summary> <pre>test_interface.py::test_generate_interface_inherit_abstracttype</pre></summary><pre>
def test_generate_interface_inherit_abstracttype():
        class MyAbstractType:
            field1 = MyScalar()

>       class MyInterface(Interface, MyAbstractType):

graphene/types/tests/test_interface.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/interface.py:50: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_interface.MyScalar object at 0x7fe41c4e9010>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_interfacepytest_generate_interface_inherit_interface">test_interface.py::test_generate_interface_inherit_interface</h3>
<details><summary> <pre>test_interface.py::test_generate_interface_inherit_interface</pre></summary><pre>
def test_generate_interface_inherit_interface():
>       class MyBaseInterface(Interface):

graphene/types/tests/test_interface.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/interface.py:50: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_interface.MyScalar object at 0x7fe41c5fc810>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_interfacepytest_generate_interface_inherit_abstracttype_reversed">test_interface.py::test_generate_interface_inherit_abstracttype_reversed</h3>
<details><summary> <pre>test_interface.py::test_generate_interface_inherit_abstracttype_reversed</pre></summary><pre>
def test_generate_interface_inherit_abstracttype_reversed():
        class MyAbstractType:
            field1 = MyScalar()

>       class MyInterface(MyAbstractType, Interface):

graphene/types/tests/test_interface.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/interface.py:50: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_interface.MyScalar object at 0x7fe41c67e8d0>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_interfacepytest_resolve_type_default">test_interface.py::test_resolve_type_default</h3>
<details><summary> <pre>test_interface.py::test_resolve_type_default</pre></summary><pre>
def test_resolve_type_default():
        class MyInterface(Interface):
            field2 = String()

        class MyTestType(ObjectType):
            class Meta:
                interfaces = (MyInterface,)

        class Query(ObjectType):
            test = Field(MyInterface)

            def resolve_test(_, info):
                return MyTestType()

>       schema = Schema(query=Query, types=[MyTestType])

graphene/types/tests/test_interface.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<MyTestType meta=<ObjectTypeOptions name='MyTestType'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_interfacepytest_resolve_type_custom">test_interface.py::test_resolve_type_custom</h3>
<details><summary> <pre>test_interface.py::test_resolve_type_custom</pre></summary><pre>
def test_resolve_type_custom():
        class MyInterface(Interface):
            field2 = String()

            @classmethod
            def resolve_type(cls, instance, info):
                if instance["type"] == 1:
                    return MyTestType1
                return MyTestType2

        class MyTestType1(ObjectType):
            class Meta:
                interfaces = (MyInterface,)

        class MyTestType2(ObjectType):
            class Meta:
                interfaces = (MyInterface,)

        class Query(ObjectType):
            test = Field(MyInterface)

            def resolve_test(_, info):
                return {"type": 1}

>       schema = Schema(query=Query, types=[MyTestType1, MyTestType2])

graphene/types/tests/test_interface.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<MyTestType1 meta=<ObjectTypeOptions name='MyTestType1'>>, <MyTestType2 meta=<ObjectTypeOptions name='MyTestType2'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_interfacepytest_resolve_type_custom_interferes">test_interface.py::test_resolve_type_custom_interferes</h3>
<details><summary> <pre>test_interface.py::test_resolve_type_custom_interferes</pre></summary><pre>
def test_resolve_type_custom_interferes():
        class MyInterface(Interface):
            field2 = String()
            type_ = String(name="type")

            def resolve_type_(_, info):
                return "foo"

        class MyTestType1(ObjectType):
            class Meta:
                interfaces = (MyInterface,)

        class MyTestType2(ObjectType):
            class Meta:
                interfaces = (MyInterface,)

        class Query(ObjectType):
            test = Field(MyInterface)

            def resolve_test(_, info):
                return MyTestType1()

>       schema = Schema(query=Query, types=[MyTestType1, MyTestType2])

graphene/types/tests/test_interface.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<MyTestType1 meta=<ObjectTypeOptions name='MyTestType1'>>, <MyTestType2 meta=<ObjectTypeOptions name='MyTestType2'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_mountedtypepytest_mounted_type">test_mountedtype.py::test_mounted_type</h3>
<details><summary> <pre>test_mountedtype.py::test_mounted_type</pre></summary><pre>
def test_mounted_type():
        unmounted = String()
        mounted = Field.mounted(unmounted)
>       assert isinstance(mounted, Field)
E       assert False
E        +  where False = isinstance(None, Field)

graphene/types/tests/test_mountedtype.py:14: AssertionError
</pre>
</details>
<h3 id="test_mountedtypepytest_mounted_type_custom">test_mountedtype.py::test_mounted_type_custom</h3>
<details><summary> <pre>test_mountedtype.py::test_mounted_type_custom</pre></summary><pre>
def test_mounted_type_custom():
        unmounted = String(metadata={"hey": "yo!"})
        mounted = CustomField.mounted(unmounted)
>       assert isinstance(mounted, CustomField)
E       assert False
E        +  where False = isinstance(None, CustomField)

graphene/types/tests/test_mountedtype.py:21: AssertionError
</pre>
</details>
<h3 id="test_mutationpytest_generate_mutation_no_args">test_mutation.py::test_generate_mutation_no_args</h3>
<details><summary> <pre>test_mutation.py::test_generate_mutation_no_args</pre></summary><pre>
def test_generate_mutation_no_args():
        class MyMutation(Mutation):
            """Documentation"""

            def mutate(self, info, **args):
                return args

        assert issubclass(MyMutation, ObjectType)
        assert MyMutation._meta.name == "MyMutation"
        assert MyMutation._meta.description == "Documentation"
>       resolved = MyMutation.Field().resolver(None, None, name="Peter")
E       AttributeError: 'NoneType' object has no attribute 'resolver'

graphene/types/tests/test_mutation.py:27: AttributeError
</pre>
</details>
<h3 id="test_mutationpytest_generate_mutation_with_meta">test_mutation.py::test_generate_mutation_with_meta</h3>
<details><summary> <pre>test_mutation.py::test_generate_mutation_with_meta</pre></summary><pre>
def test_generate_mutation_with_meta():
        class MyMutation(Mutation):
            class Meta:
                name = "MyOtherMutation"
                description = "Documentation"
                interfaces = (MyType,)

            def mutate(self, info, **args):
                return args

        assert MyMutation._meta.name == "MyOtherMutation"
        assert MyMutation._meta.description == "Documentation"
        assert MyMutation._meta.interfaces == (MyType,)
>       resolved = MyMutation.Field().resolver(None, None, name="Peter")
E       AttributeError: 'NoneType' object has no attribute 'resolver'

graphene/types/tests/test_mutation.py:44: AttributeError
</pre>
</details>
<h3 id="test_mutationpytest_mutation_custom_output_type">test_mutation.py::test_mutation_custom_output_type</h3>
<details><summary> <pre>test_mutation.py::test_mutation_custom_output_type</pre></summary><pre>
def test_mutation_custom_output_type():
        class User(ObjectType):
            name = String()

        class CreateUser(Mutation):
            class Arguments:
                name = String()

            Output = User

            def mutate(self, info, name):
                return User(name=name)

        field = CreateUser.Field()
>       assert field.type == User
E       AttributeError: 'NoneType' object has no attribute 'type'

graphene/types/tests/test_mutation.py:71: AttributeError
</pre>
</details>
<h3 id="test_mutationpytest_mutation_execution">test_mutation.py::test_mutation_execution</h3>
<details><summary> <pre>test_mutation.py::test_mutation_execution</pre></summary><pre>
def test_mutation_execution():
        class CreateUser(Mutation):
            class Arguments:
                name = String()
                dynamic = Dynamic(lambda: String())
                dynamic_none = Dynamic(lambda: None)

            name = String()
            dynamic = Dynamic(lambda: String())

            def mutate(self, info, name, dynamic):
                return CreateUser(name=name, dynamic=dynamic)

        class Query(ObjectType):
            a = String()

        class MyMutation(ObjectType):
            create_user = CreateUser.Field()

>       schema = Schema(query=Query, mutation=MyMutation)

graphene/types/tests/test_mutation.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = <MyMutation meta=<ObjectTypeOptions name='MyMutation'>>
subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_mutationpytest_mutation_no_fields_output">test_mutation.py::test_mutation_no_fields_output</h3>
<details><summary> <pre>test_mutation.py::test_mutation_no_fields_output</pre></summary><pre>
def test_mutation_no_fields_output():
        class CreateUser(Mutation):
            name = String()

            def mutate(self, info):
                return CreateUser()

        class Query(ObjectType):
            a = String()

        class MyMutation(ObjectType):
            create_user = CreateUser.Field()

>       schema = Schema(query=Query, mutation=MyMutation)

graphene/types/tests/test_mutation.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = <MyMutation meta=<ObjectTypeOptions name='MyMutation'>>
subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_mutationpytest_mutation_allow_to_have_custom_args">test_mutation.py::test_mutation_allow_to_have_custom_args</h3>
<details><summary> <pre>test_mutation.py::test_mutation_allow_to_have_custom_args</pre></summary><pre>
def test_mutation_allow_to_have_custom_args():
        class CreateUser(Mutation):
            class Arguments:
                name = String()

            name = String()

            def mutate(self, info, name):
                return CreateUser(name=name)

        class MyMutation(ObjectType):
            create_user = CreateUser.Field(
                name="createUser",
                description="Create a user",
                deprecation_reason="Is deprecated",
                required=True,
            )

>       field = MyMutation._meta.fields["create_user"]
E       KeyError: 'create_user'

graphene/types/tests/test_mutation.py:155: KeyError
</pre>
</details>
<h3 id="test_mutationpytest_mutation_default_args_output">test_mutation.py::test_mutation_default_args_output</h3>
<details><summary> <pre>test_mutation.py::test_mutation_default_args_output</pre></summary><pre>
def test_mutation_default_args_output():
        class CreateUser(Mutation):
            """Description."""

            class Arguments:
                name = String()

            name = String()

            def mutate(self, info, name):
                return CreateUser(name=name)

        class MyMutation(ObjectType):
            create_user = CreateUser.Field()

>       field = MyMutation._meta.fields["create_user"]
E       KeyError: 'create_user'

graphene/types/tests/test_mutation.py:177: KeyError
</pre>
</details>
<h3 id="test_mutationpytest_mutation_as_subclass">test_mutation.py::test_mutation_as_subclass</h3>
<details><summary> <pre>test_mutation.py::test_mutation_as_subclass</pre></summary><pre>
def test_mutation_as_subclass():
        class BaseCreateUser(Mutation):
            class Arguments:
                name = String()

            name = String()

            def mutate(self, info, **args):
                return args

        class CreateUserWithPlanet(BaseCreateUser):
            class Arguments(BaseCreateUser.Arguments):
                planet = String()

            planet = String()

            def mutate(self, info, **args):
                return CreateUserWithPlanet(**args)

        class MyMutation(ObjectType):
            create_user_with_planet = CreateUserWithPlanet.Field()

        class Query(ObjectType):
            a = String()

>       schema = Schema(query=Query, mutation=MyMutation)

graphene/types/tests/test_mutation.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = <MyMutation meta=<ObjectTypeOptions name='MyMutation'>>
subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_objecttypepytest_generate_lazy_objecttype">test_objecttype.py::test_generate_lazy_objecttype</h3>
<details><summary> <pre>test_objecttype.py::test_generate_lazy_objecttype</pre></summary><pre>
def test_generate_lazy_objecttype():
        class MyObjectType(ObjectType):
            example = Field(lambda: InnerObjectType, required=True)

        class InnerObjectType(ObjectType):
            field = Field(MyType)

        assert MyObjectType._meta.name == "MyObjectType"
        example_field = MyObjectType._meta.fields["example"]
>       assert isinstance(example_field.type, NonNull)
E       AttributeError: 'Field' object has no attribute 'type'

graphene/types/tests/test_objecttype.py:73: AttributeError
</pre>
</details>
<h3 id="test_objecttypepytest_ordered_fields_in_objecttype">test_objecttype.py::test_ordered_fields_in_objecttype</h3>
<details><summary> <pre>test_objecttype.py::test_ordered_fields_in_objecttype</pre></summary><pre>
def test_ordered_fields_in_objecttype():
>       class MyObjectType(ObjectType):

graphene/types/tests/test_objecttype.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_objecttype.MyScalar object at 0x7fe41c82f0d0>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_objecttypepytest_generate_objecttype_inherit_abstracttype">test_objecttype.py::test_generate_objecttype_inherit_abstracttype</h3>
<details><summary> <pre>test_objecttype.py::test_generate_objecttype_inherit_abstracttype</pre></summary><pre>
def test_generate_objecttype_inherit_abstracttype():
        class MyAbstractType:
            field1 = MyScalar()

>       class MyObjectType(ObjectType, MyAbstractType):

graphene/types/tests/test_objecttype.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_objecttype.MyScalar object at 0x7fe41c44e850>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_objecttypepytest_generate_objecttype_inherit_abstracttype_reversed">test_objecttype.py::test_generate_objecttype_inherit_abstracttype_reversed</h3>
<details><summary> <pre>test_objecttype.py::test_generate_objecttype_inherit_abstracttype_reversed</pre></summary><pre>
def test_generate_objecttype_inherit_abstracttype_reversed():
        class MyAbstractType:
            field1 = MyScalar()

>       class MyObjectType(MyAbstractType, ObjectType):

graphene/types/tests/test_objecttype.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_objecttype.MyScalar object at 0x7fe41c5ca110>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_objecttypepytest_generate_objecttype_unmountedtype">test_objecttype.py::test_generate_objecttype_unmountedtype</h3>
<details><summary> <pre>test_objecttype.py::test_generate_objecttype_unmountedtype</pre></summary><pre>
def test_generate_objecttype_unmountedtype():
>       class MyObjectType(ObjectType):

graphene/types/tests/test_objecttype.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = <graphene.types.tests.test_objecttype.MyScalar object at 0x7fe41c6a2210>
_as = <class 'graphene.types.field.Field'>

    def get_field_as(value, _as=None):
        """
        Get type mounted
        """
        if isinstance(value, MountedType):
            return value
        elif isinstance(value, UnmountedType):
>           return value.mount(_as)
E           AttributeError: 'MyScalar' object has no attribute 'mount'

graphene/types/utils.py:32: AttributeError
</pre>
</details>
<h3 id="test_objecttypepytest_objecttype_no_fields_output">test_objecttype.py::test_objecttype_no_fields_output</h3>
<details><summary> <pre>test_objecttype.py::test_objecttype_no_fields_output</pre></summary><pre>
def test_objecttype_no_fields_output():
        class User(ObjectType):
            name = String()

        class Query(ObjectType):
            user = Field(User)

            def resolve_user(self, info):
                return User()

>       schema = Schema(query=Query)

graphene/types/tests/test_objecttype.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_objecttypepytest_objecttype_meta_with_annotations">test_objecttype.py::test_objecttype_meta_with_annotations</h3>
<details><summary> <pre>test_objecttype.py::test_objecttype_meta_with_annotations</pre></summary><pre>
def test_objecttype_meta_with_annotations():
        class Query(ObjectType):
            class Meta:
                name: str = "oops"

            hello = String()

            def resolve_hello(self, info):
                return "Hello"

>       schema = Schema(query=Query)

graphene/types/tests/test_objecttype.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='oops'>>, mutation = None
subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_query">test_query.py::test_query</h3>
<details><summary> <pre>test_query.py::test_query</pre></summary><pre>
def test_query():
        class Query(ObjectType):
            hello = String(resolver=lambda *_: "World")

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_query_source">test_query.py::test_query_source</h3>
<details><summary> <pre>test_query.py::test_query_source</pre></summary><pre>
def test_query_source():
        class Root:
            _hello = "World"

            def hello(self):
                return self._hello

>       class Query(ObjectType):

graphene/types/tests/test_query.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
graphene/types/utils.py:32: in get_field_as
    return value.mount(_as)
graphene/types/scalars.py:69: in mount
    return Field(self.get_type(), *self.args, **self.kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.types.field.Field object at 0x7fe41c0e50d0>
type_ = <String meta=<ScalarOptions name='String'>>, args = None
resolver = None, source = 'hello', deprecation_reason = None, name = None
description = None, required = False, _creation_counter = None
default_value = None, extra_args = {}

    def __init__(self, type_, args=None, resolver=None, source=None, deprecation_reason=None, name=None, description=None, required=False, _creation_counter=None, default_value=None, **extra_args):
        super(Field, self).__init__(_creation_counter=_creation_counter)
        assert not args or isinstance(args, Mapping), f'Arguments in a field have to be a mapping, received "{args}".'
        assert not (source and resolver), 'A Field cannot have a source and a resolver in at the same time.'
        assert not callable(default_value), f'The default value can not be a function but received "{base_type(default_value)}".'
        if required:
            type_ = NonNull(type_)
        if isinstance(name, (Argument, UnmountedType)):
            extra_args['name'] = name
            name = None
        if isinstance(source, (Argument, UnmountedType)):
            extra_args['source'] = source
            source = None
        self.name = name
        self._type = type_
        self.args = to_arguments(args or {}, extra_args)
        if source:
>           resolver = partial(source_resolver, source)
E           NameError: name 'source_resolver' is not defined

graphene/types/field.py:73: NameError
</pre>
</details>
<h3 id="test_querypytest_query_union">test_query.py::test_query_union</h3>
<details><summary> <pre>test_query.py::test_query_union</pre></summary><pre>
def test_query_union():
        class one_object:
            pass

        class two_object:
            pass

        class One(ObjectType):
            one = String()

            @classmethod
            def is_type_of(cls, root, info):
                return isinstance(root, one_object)

        class Two(ObjectType):
            two = String()

            @classmethod
            def is_type_of(cls, root, info):
                return isinstance(root, two_object)

        class MyUnion(Union):
            class Meta:
                types = (One, Two)

>       class Query(ObjectType):

graphene/types/tests/test_query.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
graphene/types/utils.py:32: in get_field_as
    return value.mount(_as)
graphene/types/structures.py:28: in mount
    return Field(self.get_type(), *self.args, **self.kwargs)
graphene/types/structures.py:23: in get_type
    return get_type(self._of_type)
graphene/types/utils.py:22: in get_type
    return get_type(type_())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

type_ = <graphene.types.tests.test_query.test_query_union.<locals>.MyUnion object at 0x7fe41be6a950>

    def get_type(type_):
        """
        Returns the type for the given type. It can be:
        - A MountedType (which will be returned as is)
        - A UnmountedType (which will be mounted)
        - A Type string (which will be imported and mounted)
        - A callable (which will be called and mounted)
        """
        if isinstance(type_, MountedType):
            return type_
        elif isinstance(type_, UnmountedType):
>           return type_.mount()
E           AttributeError: 'MyUnion' object has no attribute 'mount'

graphene/types/utils.py:18: AttributeError
</pre>
</details>
<h3 id="test_querypytest_query_interface">test_query.py::test_query_interface</h3>
<details><summary> <pre>test_query.py::test_query_interface</pre></summary><pre>
def test_query_interface():
        class one_object:
            pass

        class two_object:
            pass

        class MyInterface(Interface):
            base = String()

        class One(ObjectType):
            class Meta:
                interfaces = (MyInterface,)

            one = String()

            @classmethod
            def is_type_of(cls, root, info):
                return isinstance(root, one_object)

        class Two(ObjectType):
            class Meta:
                interfaces = (MyInterface,)

            two = String()

            @classmethod
            def is_type_of(cls, root, info):
                return isinstance(root, two_object)

>       class Query(ObjectType):

graphene/types/tests/test_query.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/objecttype.py:23: in __new__
    base_cls = super().__new__(cls, name_, (InterObjectType,) + bases, namespace, **options)
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/objecttype.py:113: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=Field))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
graphene/types/utils.py:32: in get_field_as
    return value.mount(_as)
graphene/types/structures.py:28: in mount
    return Field(self.get_type(), *self.args, **self.kwargs)
graphene/types/structures.py:23: in get_type
    return get_type(self._of_type)
graphene/types/utils.py:22: in get_type
    return get_type(type_())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.types.tests.test_query.test_query_interface.<locals>.MyInterface object at 0x7fe41c0e7310>
args = (), kwargs = {}

    def __init__(self, *args, **kwargs):
>       raise Exception('An Interface cannot be initialized')
E       Exception: An Interface cannot be initialized

graphene/types/interface.py:60: Exception
</pre>
</details>
<h3 id="test_querypytest_query_dynamic">test_query.py::test_query_dynamic</h3>
<details><summary> <pre>test_query.py::test_query_dynamic</pre></summary><pre>
def test_query_dynamic():
        class Query(ObjectType):
            hello = Dynamic(lambda: String(resolver=lambda *_: "World"))
            hellos = Dynamic(lambda: List(String, resolver=lambda *_: ["Worlds"]))
            hello_field = Dynamic(lambda: Field(String, resolver=lambda *_: "Field World"))

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_query_default_value">test_query.py::test_query_default_value</h3>
<details><summary> <pre>test_query.py::test_query_default_value</pre></summary><pre>
def test_query_default_value():
        class MyType(ObjectType):
            field = String()

        class Query(ObjectType):
            hello = Field(MyType, default_value=MyType(field="something else!"))

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_query_wrong_default_value">test_query.py::test_query_wrong_default_value</h3>
<details><summary> <pre>test_query.py::test_query_wrong_default_value</pre></summary><pre>
def test_query_wrong_default_value():
        class MyType(ObjectType):
            field = String()

            @classmethod
            def is_type_of(cls, root, info):
                return isinstance(root, MyType)

        class Query(ObjectType):
            hello = Field(MyType, default_value="hello")

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_query_default_value_ignored_by_resolver">test_query.py::test_query_default_value_ignored_by_resolver</h3>
<details><summary> <pre>test_query.py::test_query_default_value_ignored_by_resolver</pre></summary><pre>
def test_query_default_value_ignored_by_resolver():
        class MyType(ObjectType):
            field = String()

        class Query(ObjectType):
            hello = Field(
                MyType,
                default_value="hello",
                resolver=lambda *_: MyType(field="no default."),
            )

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_query_resolve_function">test_query.py::test_query_resolve_function</h3>
<details><summary> <pre>test_query.py::test_query_resolve_function</pre></summary><pre>
def test_query_resolve_function():
        class Query(ObjectType):
            hello = String()

            def resolve_hello(self, info):
                return "World"

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_query_arguments">test_query.py::test_query_arguments</h3>
<details><summary> <pre>test_query.py::test_query_arguments</pre></summary><pre>
def test_query_arguments():
        class Query(ObjectType):
            test = String(a_str=String(), a_int=Int())

            def resolve_test(self, info, **args):
                return json.dumps([self, args], separators=(",", ":"))

>       test_schema = Schema(Query)

graphene/types/tests/test_query.py:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_query_input_field">test_query.py::test_query_input_field</h3>
<details><summary> <pre>test_query.py::test_query_input_field</pre></summary><pre>
def test_query_input_field():
        class Input(InputObjectType):
            a_field = String()
            recursive_field = InputField(lambda: Input)

        class Query(ObjectType):
            test = String(a_input=Input())

            def resolve_test(self, info, **args):
                return json.dumps([self, args], separators=(",", ":"))

>       test_schema = Schema(Query)

graphene/types/tests/test_query.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_query_middlewares">test_query.py::test_query_middlewares</h3>
<details><summary> <pre>test_query.py::test_query_middlewares</pre></summary><pre>
def test_query_middlewares():
        class Query(ObjectType):
            hello = String()
            other = String()

            def resolve_hello(self, info):
                return "World"

            def resolve_other(self, info):
                return "other"

        def reversed_middleware(next, *args, **kwargs):
            return next(*args, **kwargs)[::-1]

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_objecttype_on_instances">test_query.py::test_objecttype_on_instances</h3>
<details><summary> <pre>test_query.py::test_objecttype_on_instances</pre></summary><pre>
def test_objecttype_on_instances():
        class Ship:
            def __init__(self, name):
                self.name = name

        class ShipType(ObjectType):
            name = String(description="Ship name", required=True)

            def resolve_name(self, info):
                # Here self will be the Ship instance returned in resolve_ship
                return self.name

        class Query(ObjectType):
            ship = Field(ShipType)

            def resolve_ship(self, info):
                return Ship(name="xwing")

>       schema = Schema(query=Query)

graphene/types/tests/test_query.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_big_list_query_benchmark">test_query.py::test_big_list_query_benchmark</h3>
<details><summary> <pre>test_query.py::test_big_list_query_benchmark</pre></summary><pre>
benchmark = <pytest_benchmark.fixture.BenchmarkFixture object at 0x7fe41c4ea6d0>

    def test_big_list_query_benchmark(benchmark):
        big_list = range(10000)

        class Query(ObjectType):
            all_ints = List(Int)

            def resolve_all_ints(self, info):
                return big_list

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_big_list_query_compiled_query_benchmark">test_query.py::test_big_list_query_compiled_query_benchmark</h3>
<details><summary> <pre>test_query.py::test_big_list_query_compiled_query_benchmark</pre></summary><pre>
benchmark = <pytest_benchmark.fixture.BenchmarkFixture object at 0x7fe41c41da50>

    def test_big_list_query_compiled_query_benchmark(benchmark):
        big_list = range(100000)

        class Query(ObjectType):
            all_ints = List(Int)

            def resolve_all_ints(self, info):
                return big_list

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:349: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_big_list_of_containers_query_benchmark">test_query.py::test_big_list_of_containers_query_benchmark</h3>
<details><summary> <pre>test_query.py::test_big_list_of_containers_query_benchmark</pre></summary><pre>
benchmark = <pytest_benchmark.fixture.BenchmarkFixture object at 0x7fe41c5c8c50>

    def test_big_list_of_containers_query_benchmark(benchmark):
        class Container(ObjectType):
            x = Int()

        big_container_list = [Container(x=x) for x in range(1000)]

        class Query(ObjectType):
            all_containers = List(Container)

            def resolve_all_containers(self, info):
                return big_container_list

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:372: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_big_list_of_containers_multiple_fields_query_benchmark">test_query.py::test_big_list_of_containers_multiple_fields_query_benchmark</h3>
<details><summary> <pre>test_query.py::test_big_list_of_containers_multiple_fields_query_benchmark</pre></summary><pre>
benchmark = <pytest_benchmark.fixture.BenchmarkFixture object at 0x7fe41c5fc750>

    def test_big_list_of_containers_multiple_fields_query_benchmark(benchmark):
        class Container(ObjectType):
            x = Int()
            y = Int()
            z = Int()
            o = Int()

        big_container_list = [Container(x=x, y=x, z=x, o=x) for x in range(1000)]

        class Query(ObjectType):
            all_containers = List(Container)

            def resolve_all_containers(self, info):
                return big_container_list

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:395: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_big_list_of_containers_multiple_fields_custom_resolvers_query_benchmark">test_query.py::test_big_list_of_containers_multiple_fields_custom_resolvers_query_benchmark</h3>
<details><summary> <pre>test_query.py::test_big_list_of_containers_multiple_fields_custom_resolvers_query_benchmark</pre></summary><pre>
benchmark = <pytest_benchmark.fixture.BenchmarkFixture object at 0x7fe41be88f10>

    def test_big_list_of_containers_multiple_fields_custom_resolvers_query_benchmark(
        benchmark,
    ):
        class Container(ObjectType):
            x = Int()
            y = Int()
            z = Int()
            o = Int()

            def resolve_x(self, info):
                return self.x

            def resolve_y(self, info):
                return self.y

            def resolve_z(self, info):
                return self.z

            def resolve_o(self, info):
                return self.o

        big_container_list = [Container(x=x, y=x, z=x, o=x) for x in range(1000)]

        class Query(ObjectType):
            all_containers = List(Container)

            def resolve_all_containers(self, info):
                return big_container_list

>       hello_schema = Schema(Query)

graphene/types/tests/test_query.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_query_annotated_resolvers">test_query.py::test_query_annotated_resolvers</h3>
<details><summary> <pre>test_query.py::test_query_annotated_resolvers</pre></summary><pre>
def test_query_annotated_resolvers():
        context = Context(key="context")

        class Query(ObjectType):
            annotated = String(id=String())
            context = String()
            info = String()

            def resolve_annotated(self, info, id):
                return f"{self}-{id}"

            def resolve_context(self, info):
                assert isinstance(info.context, Context)
                return f"{self}-{info.context.key}"

            def resolve_info(self, info):
                assert isinstance(info, ResolveInfo)
                return f"{self}-{info.field_name}"

>       test_schema = Schema(Query)

graphene/types/tests/test_query.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_querypytest_default_as_kwarg_to_nonnull">test_query.py::test_default_as_kwarg_to_NonNull</h3>
<details><summary> <pre>test_query.py::test_default_as_kwarg_to_NonNull</pre></summary><pre>
def test_default_as_kwarg_to_NonNull():
        # Related to https://github.com/graphql-python/graphene/issues/702
        class User(ObjectType):
            name = String()
            is_admin = NonNull(Boolean, default_value=False)

        class Query(ObjectType):
            user = Field(User)

            def resolve_user(self, *args, **kwargs):
                return User(name="foo")

>       schema = Schema(query=Query)

graphene/types/tests/test_query.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_scalars_serializationpytest_serializes_output_int">test_scalars_serialization.py::test_serializes_output_int</h3>
<details><summary> <pre>test_scalars_serialization.py::test_serializes_output_int</pre></summary><pre>
def test_serializes_output_int():
        assert Int.serialize(1) == 1
        assert Int.serialize(0) == 0
        assert Int.serialize(-1) == -1
        assert Int.serialize(0.1) == 0
        assert Int.serialize(1.1) == 1
        assert Int.serialize(-1.1) == -1
        assert Int.serialize(1e5) == 100000
>       assert Int.serialize(9876504321) is Undefined
E       assert None is Undefined
E        +  where None = <function coerce_int at 0x7fe41cb10860>(9876504321)
E        +    where <function coerce_int at 0x7fe41cb10860> = Int.serialize

graphene/types/tests/test_scalars_serialization.py:13: AssertionError
</pre>
</details>
<h3 id="test_scalars_serializationpytest_serializes_output_float">test_scalars_serialization.py::test_serializes_output_float</h3>
<details><summary> <pre>test_scalars_serialization.py::test_serializes_output_float</pre></summary><pre>
def test_serializes_output_float():
        assert Float.serialize(1) == 1.0
        assert Float.serialize(0) == 0.0
        assert Float.serialize(-1) == -1.0
        assert Float.serialize(0.1) == 0.1
        assert Float.serialize(1.1) == 1.1
        assert Float.serialize(-1.1) == -1.1
        assert Float.serialize("-1.1") == -1.1
>       assert Float.serialize("one") is Undefined
E       AssertionError: assert None is Undefined
E        +  where None = <function coerce_float at 0x7fe41c900720>('one')
E        +    where <function coerce_float at 0x7fe41c900720> = Float.serialize

graphene/types/tests/test_scalars_serialization.py:31: AssertionError
</pre>
</details>
<h3 id="test_scalars_serializationpytest_serializes_output_string">test_scalars_serialization.py::test_serializes_output_string</h3>
<details><summary> <pre>test_scalars_serialization.py::test_serializes_output_string</pre></summary><pre>
def test_serializes_output_string():
        assert String.serialize("string") == "string"
        assert String.serialize(1) == "1"
        assert String.serialize(-1.1) == "-1.1"
>       assert String.serialize(True) == "true"
E       AssertionError: assert 'True' == 'true'
E         
E         - true
E         ? ^
E         + True
E         ? ^

graphene/types/tests/test_scalars_serialization.py:40: AssertionError
</pre>
</details>
<h3 id="test_schemapytest_schema">test_schema.py::test_schema</h3>
<details><summary> <pre>test_schema.py::test_schema</pre></summary><pre>
def test_schema():
>       schema = Schema(Query)

graphene/types/tests/test_schema.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_schemapytest_schema_get_type">test_schema.py::test_schema_get_type</h3>
<details><summary> <pre>test_schema.py::test_schema_get_type</pre></summary><pre>
def test_schema_get_type():
>       schema = Schema(Query)

graphene/types/tests/test_schema.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_schemapytest_schema_get_type_error">test_schema.py::test_schema_get_type_error</h3>
<details><summary> <pre>test_schema.py::test_schema_get_type_error</pre></summary><pre>
def test_schema_get_type_error():
>       schema = Schema(Query)

graphene/types/tests/test_schema.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_schemapytest_schema_str">test_schema.py::test_schema_str</h3>
<details><summary> <pre>test_schema.py::test_schema_str</pre></summary><pre>
def test_schema_str():
>       schema = Schema(Query)

graphene/types/tests/test_schema.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_schemapytest_schema_introspect">test_schema.py::test_schema_introspect</h3>
<details><summary> <pre>test_schema.py::test_schema_introspect</pre></summary><pre>
def test_schema_introspect():
>       schema = Schema(Query)

graphene/types/tests/test_schema.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_schemapytest_schema_requires_query_type">test_schema.py::test_schema_requires_query_type</h3>
<details><summary> <pre>test_schema.py::test_schema_requires_query_type</pre></summary><pre>
def test_schema_requires_query_type():
>       schema = Schema()

graphene/types/tests/test_schema.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = None, mutation = None, subscription = None, types = []
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_list">test_structures.py::test_list</h3>
<details><summary> <pre>test_structures.py::test_list</pre></summary><pre>
def test_list():
        _list = List(String)
>       assert _list.of_type == String
E       AttributeError: 'List' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:12: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_list_with_lazy_type">test_structures.py::test_list_with_lazy_type</h3>
<details><summary> <pre>test_structures.py::test_list_with_lazy_type</pre></summary><pre>
def test_list_with_lazy_type():
        MyType = object()
        field = List(lambda: MyType)
>       assert field.of_type == MyType
E       AttributeError: 'List' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:29: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_list_with_lazy_partial_type">test_structures.py::test_list_with_lazy_partial_type</h3>
<details><summary> <pre>test_structures.py::test_list_with_lazy_partial_type</pre></summary><pre>
def test_list_with_lazy_partial_type():
        MyType = object()
        field = List(partial(lambda: MyType))
>       assert field.of_type == MyType
E       AttributeError: 'List' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:35: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_list_with_string_type">test_structures.py::test_list_with_string_type</h3>
<details><summary> <pre>test_structures.py::test_list_with_string_type</pre></summary><pre>
def test_list_with_string_type():
        field = List("graphene.types.tests.utils.MyLazyType")
>       assert field.of_type == MyLazyType
E       AttributeError: 'List' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:40: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_list_inherited_works_list">test_structures.py::test_list_inherited_works_list</h3>
<details><summary> <pre>test_structures.py::test_list_inherited_works_list</pre></summary><pre>
def test_list_inherited_works_list():
        _list = List(List(String))
>       assert isinstance(_list.of_type, List)
E       AttributeError: 'List' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:45: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_list_inherited_works_nonnull">test_structures.py::test_list_inherited_works_nonnull</h3>
<details><summary> <pre>test_structures.py::test_list_inherited_works_nonnull</pre></summary><pre>
def test_list_inherited_works_nonnull():
        _list = List(NonNull(String))
>       assert isinstance(_list.of_type, NonNull)
E       AttributeError: 'List' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:51: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_nonnull">test_structures.py::test_nonnull</h3>
<details><summary> <pre>test_structures.py::test_nonnull</pre></summary><pre>
def test_nonnull():
        nonnull = NonNull(String)
>       assert nonnull.of_type == String
E       AttributeError: 'NonNull' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:57: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_nonnull_with_lazy_type">test_structures.py::test_nonnull_with_lazy_type</h3>
<details><summary> <pre>test_structures.py::test_nonnull_with_lazy_type</pre></summary><pre>
def test_nonnull_with_lazy_type():
        MyType = object()
        field = NonNull(lambda: MyType)
>       assert field.of_type == MyType
E       AttributeError: 'NonNull' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:64: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_nonnull_with_lazy_partial_type">test_structures.py::test_nonnull_with_lazy_partial_type</h3>
<details><summary> <pre>test_structures.py::test_nonnull_with_lazy_partial_type</pre></summary><pre>
def test_nonnull_with_lazy_partial_type():
        MyType = object()
        field = NonNull(partial(lambda: MyType))
>       assert field.of_type == MyType
E       AttributeError: 'NonNull' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:70: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_nonnull_with_string_type">test_structures.py::test_nonnull_with_string_type</h3>
<details><summary> <pre>test_structures.py::test_nonnull_with_string_type</pre></summary><pre>
def test_nonnull_with_string_type():
        field = NonNull("graphene.types.tests.utils.MyLazyType")
>       assert field.of_type == MyLazyType
E       AttributeError: 'NonNull' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:75: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_nonnull_inherited_works_list">test_structures.py::test_nonnull_inherited_works_list</h3>
<details><summary> <pre>test_structures.py::test_nonnull_inherited_works_list</pre></summary><pre>
def test_nonnull_inherited_works_list():
        _list = NonNull(List(String))
>       assert isinstance(_list.of_type, List)
E       AttributeError: 'NonNull' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:80: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_nonnull_inherited_dont_work_nonnull">test_structures.py::test_nonnull_inherited_dont_work_nonnull</h3>
<details><summary> <pre>test_structures.py::test_nonnull_inherited_dont_work_nonnull</pre></summary><pre>
def test_nonnull_inherited_dont_work_nonnull():
        with raises(Exception) as exc_info:
            NonNull(NonNull(String))

>       assert (
            str(exc_info.value)
            == "Can only create NonNull of a Nullable GraphQLType but got: String!."
        )
E       assert "'NonNull' ob...ute 'of_type'" == 'Can only cre...got: String!.'
E         
E         - Can only create NonNull of a Nullable GraphQLType but got: String!.
E         + 'NonNull' object has no attribute 'of_type'

graphene/types/tests/test_structures.py:88: AssertionError
</pre>
</details>
<h3 id="test_structurespytest_list_comparasion">test_structures.py::test_list_comparasion</h3>
<details><summary> <pre>test_structures.py::test_list_comparasion</pre></summary><pre>
def test_list_comparasion():
        list1 = List(String)
        list2 = List(String)
        list3 = List(None)

        list1_argskwargs = List(String, None, b=True)
        list2_argskwargs = List(String, None, b=True)

>       assert list1 == list2

graphene/types/tests/test_structures.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.types.structures.List object at 0x7fe41be8a590>
other = <graphene.types.structures.List object at 0x7fe41be89d50>

    def __eq__(self, other):
>       return isinstance(other, List) and (self.of_type == other.of_type and self.args == other.args and (self.kwargs == other.kwargs))
E       AttributeError: 'List' object has no attribute 'of_type'

graphene/types/structures.py:51: AttributeError
</pre>
</details>
<h3 id="test_structurespytest_nonnull_comparasion">test_structures.py::test_nonnull_comparasion</h3>
<details><summary> <pre>test_structures.py::test_nonnull_comparasion</pre></summary><pre>
def test_nonnull_comparasion():
        nonnull1 = NonNull(String)
        nonnull2 = NonNull(String)
        nonnull3 = NonNull(None)

        nonnull1_argskwargs = NonNull(String, None, b=True)
        nonnull2_argskwargs = NonNull(String, None, b=True)

>       assert nonnull1 == nonnull2

graphene/types/tests/test_structures.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.types.structures.NonNull object at 0x7fe41c82c390>
other = <graphene.types.structures.NonNull object at 0x7fe41cd5ca50>

    def __eq__(self, other):
>       return isinstance(other, NonNull) and (self.of_type == other.of_type and self.args == other.args and (self.kwargs == other.kwargs))
E       AttributeError: 'NonNull' object has no attribute 'of_type'

graphene/types/structures.py:84: AttributeError
</pre>
</details>
<h3 id="test_type_mappytest_enum">test_type_map.py::test_enum</h3>
<details><summary> <pre>test_type_map.py::test_enum</pre></summary><pre>
def test_enum():
        class MyEnum(Enum):
            """Description"""

            foo = 1
            bar = 2

            @property
            def description(self):
                return f"Description {self.name}={self.value}"

            @property
            def deprecation_reason(self):
                if self == MyEnum.foo:
                    return "Is deprecated"

>       type_map = create_type_map([MyEnum])

graphene/types/tests/test_type_map.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/tests/test_type_map.py:29: in create_type_map
    schema = Schema(query, types=types, auto_camelcase=auto_camelcase)
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<MyEnum meta=<EnumOptions name='MyEnum'>>], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_type_mappytest_objecttype">test_type_map.py::test_objecttype</h3>
<details><summary> <pre>test_type_map.py::test_objecttype</pre></summary><pre>
def test_objecttype():
        class MyObjectType(ObjectType):
            """Description"""

            foo = String(
                bar=String(description="Argument description", default_value="x"),
                description="Field description",
            )
            bar = String(name="gizmo")

            def resolve_foo(self, bar):
                return bar

>       type_map = create_type_map([MyObjectType])

graphene/types/tests/test_type_map.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/tests/test_type_map.py:29: in create_type_map
    schema = Schema(query, types=types, auto_camelcase=auto_camelcase)
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<MyObjectType meta=<ObjectTypeOptions name='MyObjectType'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_type_mappytest_required_argument_with_default_value">test_type_map.py::test_required_argument_with_default_value</h3>
<details><summary> <pre>test_type_map.py::test_required_argument_with_default_value</pre></summary><pre>
def test_required_argument_with_default_value():
        class MyObjectType(ObjectType):
            foo = String(bar=String(required=True, default_value="x"))

>       type_map = create_type_map([MyObjectType])

graphene/types/tests/test_type_map.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/tests/test_type_map.py:29: in create_type_map
    schema = Schema(query, types=types, auto_camelcase=auto_camelcase)
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<MyObjectType meta=<ObjectTypeOptions name='MyObjectType'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_type_mappytest_dynamic_objecttype">test_type_map.py::test_dynamic_objecttype</h3>
<details><summary> <pre>test_type_map.py::test_dynamic_objecttype</pre></summary><pre>
def test_dynamic_objecttype():
        class MyObjectType(ObjectType):
            """Description"""

            bar = Dynamic(lambda: Field(String))
            own = Field(lambda: MyObjectType)

>       type_map = create_type_map([MyObjectType])

graphene/types/tests/test_type_map.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/tests/test_type_map.py:29: in create_type_map
    schema = Schema(query, types=types, auto_camelcase=auto_camelcase)
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<MyObjectType meta=<ObjectTypeOptions name='MyObjectType'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_type_mappytest_interface">test_type_map.py::test_interface</h3>
<details><summary> <pre>test_type_map.py::test_interface</pre></summary><pre>
def test_interface():
        class MyInterface(Interface):
            """Description"""

            foo = String(
                bar=String(description="Argument description", default_value="x"),
                description="Field description",
            )
            bar = String(name="gizmo", first_arg=String(), other_arg=String(name="oth_arg"))
            own = Field(lambda: MyInterface)

            def resolve_foo(self, args, info):
                return args.get("bar")

>       type_map = create_type_map([MyInterface])

graphene/types/tests/test_type_map.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/tests/test_type_map.py:29: in create_type_map
    schema = Schema(query, types=types, auto_camelcase=auto_camelcase)
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<MyInterface meta=<InterfaceOptions name='MyInterface'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_type_mappytest_inputobject">test_type_map.py::test_inputobject</h3>
<details><summary> <pre>test_type_map.py::test_inputobject</pre></summary><pre>
def test_inputobject():
        class OtherObjectType(InputObjectType):
            thingy = NonNull(Int)

>       class MyInnerObjectType(InputObjectType):

graphene/types/tests/test_type_map.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/subclass_with_meta.py:37: in __init_subclass__
    super_class.__init_subclass_with_meta__(**options)
graphene/types/inputobjecttype.py:80: in __init_subclass_with_meta__
    fields.update(yank_fields_from_attrs(base.__dict__, _as=InputField))
graphene/types/utils.py:43: in yank_fields_from_attrs
    fields.append((key, get_field_as(value, _as)))
graphene/types/utils.py:32: in get_field_as
    return value.mount(_as)
graphene/types/structures.py:28: in mount
    return Field(self.get_type(), *self.args, **self.kwargs)
graphene/types/structures.py:23: in get_type
    return get_type(self._of_type)
graphene/types/utils.py:22: in get_type
    return get_type(type_())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

type_ = <graphene.types.tests.test_type_map.test_inputobject.<locals>.OtherObjectType object at 0x7fe41be9b410>

    def get_type(type_):
        """
        Returns the type for the given type. It can be:
        - A MountedType (which will be returned as is)
        - A UnmountedType (which will be mounted)
        - A Type string (which will be imported and mounted)
        - A callable (which will be called and mounted)
        """
        if isinstance(type_, MountedType):
            return type_
        elif isinstance(type_, UnmountedType):
>           return type_.mount()
E           AttributeError: 'OtherObjectType' object has no attribute 'mount'

graphene/types/utils.py:18: AttributeError
</pre>
</details>
<h3 id="test_type_mappytest_inputobject_undefined">test_type_map.py::test_inputobject_undefined</h3>
<details><summary> <pre>test_type_map.py::test_inputobject_undefined</pre></summary><pre>
set_default_input_object_type_to_undefined = None

    def test_inputobject_undefined(set_default_input_object_type_to_undefined):
        class OtherObjectType(InputObjectType):
            optional_field = String()

>       type_map = create_type_map([OtherObjectType])

graphene/types/tests/test_type_map.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/tests/test_type_map.py:29: in create_type_map
    schema = Schema(query, types=types, auto_camelcase=auto_camelcase)
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<OtherObjectType meta=<InputObjectTypeOptions name='OtherObjectType'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_type_mappytest_objecttype_camelcase">test_type_map.py::test_objecttype_camelcase</h3>
<details><summary> <pre>test_type_map.py::test_objecttype_camelcase</pre></summary><pre>
def test_objecttype_camelcase():
        class MyObjectType(ObjectType):
            """Description"""

            foo_bar = String(bar_foo=String())

>       type_map = create_type_map([MyObjectType])

graphene/types/tests/test_type_map.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/tests/test_type_map.py:29: in create_type_map
    schema = Schema(query, types=types, auto_camelcase=auto_camelcase)
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<MyObjectType meta=<ObjectTypeOptions name='MyObjectType'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_type_mappytest_objecttype_camelcase_disabled">test_type_map.py::test_objecttype_camelcase_disabled</h3>
<details><summary> <pre>test_type_map.py::test_objecttype_camelcase_disabled</pre></summary><pre>
def test_objecttype_camelcase_disabled():
        class MyObjectType(ObjectType):
            """Description"""

            foo_bar = String(bar_foo=String())

>       type_map = create_type_map([MyObjectType], auto_camelcase=False)

graphene/types/tests/test_type_map.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/tests/test_type_map.py:29: in create_type_map
    schema = Schema(query, types=types, auto_camelcase=auto_camelcase)
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<MyObjectType meta=<ObjectTypeOptions name='MyObjectType'>>]
auto_camelcase = False

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_type_mappytest_objecttype_with_possible_types">test_type_map.py::test_objecttype_with_possible_types</h3>
<details><summary> <pre>test_type_map.py::test_objecttype_with_possible_types</pre></summary><pre>
def test_objecttype_with_possible_types():
        class MyObjectType(ObjectType):
            """Description"""

            class Meta:
                possible_types = (dict,)

            foo_bar = String()

>       type_map = create_type_map([MyObjectType])

graphene/types/tests/test_type_map.py:299: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/tests/test_type_map.py:29: in create_type_map
    schema = Schema(query, types=types, auto_camelcase=auto_camelcase)
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<MyObjectType meta=<ObjectTypeOptions name='MyObjectType'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_type_mappytest_interface_with_interfaces">test_type_map.py::test_interface_with_interfaces</h3>
<details><summary> <pre>test_type_map.py::test_interface_with_interfaces</pre></summary><pre>
def test_interface_with_interfaces():
        class FooInterface(Interface):
            foo = String()

        class BarInterface(Interface):
            class Meta:
                interfaces = [FooInterface]

            foo = String()
            bar = String()

>       type_map = create_type_map([FooInterface, BarInterface])

graphene/types/tests/test_type_map.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/tests/test_type_map.py:29: in create_type_map
    schema = Schema(query, types=types, auto_camelcase=auto_camelcase)
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None
types = [<FooInterface meta=<InterfaceOptions name='FooInterface'>>, <BarInterface meta=<InterfaceOptions name='BarInterface'>>]
auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_unionpytest_union_can_be_mounted">test_union.py::test_union_can_be_mounted</h3>
<details><summary> <pre>test_union.py::test_union_can_be_mounted</pre></summary><pre>
def test_union_can_be_mounted():
        class MyUnion(Union):
            class Meta:
                types = (MyObjectType1, MyObjectType2)

        my_union_instance = MyUnion()
        assert isinstance(my_union_instance, UnmountedType)
>       my_union_field = my_union_instance.mount_as(Field)
E       AttributeError: 'MyUnion' object has no attribute 'mount_as'

graphene/types/tests/test_union.py:56: AttributeError
</pre>
</details>
<h3 id="test_crunchpytest_crunchsingle-item-array-uncrunched4-crunched4">test_crunch.py::test_crunch[single-item array-uncrunched4-crunched4]</h3>
<details><summary> <pre>test_crunch.py::test_crunch[single-item array-uncrunched4-crunched4]</pre></summary><pre>
description = 'single-item array', uncrunched = [None], crunched = [None, [0]]

    @mark.parametrize(
        "description,uncrunched,crunched",
        [
            ["number primitive", 0, [0]],
            ["boolean primitive", True, [True]],
            ["string primitive", "string", ["string"]],
            ["empty array", [], [[]]],
            ["single-item array", [None], [None, [0]]],
            [
                "multi-primitive all distinct array",
                [None, 0, True, "string"],
                [None, 0, True, "string", [0, 1, 2, 3]],
            ],
            [
                "multi-primitive repeated array",
                [True, True, True, True],
                [True, [0, 0, 0, 0]],
            ],
            ["one-level nested array", [[1, 2, 3]], [1, 2, 3, [0, 1, 2], [3]]],
            ["two-level nested array", [[[1, 2, 3]]], [1, 2, 3, [0, 1, 2], [3], [4]]],
            ["empty object", {}, [{}]],
            ["single-item object", {"a": None}, [None, {"a": 0}]],
            [
                "multi-item all distinct object",
                {"a": None, "b": 0, "c": True, "d": "string"},
                [None, 0, True, "string", {"a": 0, "b": 1, "c": 2, "d": 3}],
            ],
            [
                "multi-item repeated object",
                {"a": True, "b": True, "c": True, "d": True},
                [True, {"a": 0, "b": 0, "c": 0, "d": 0}],
            ],
            [
                "complex array",
                [{"a": True, "b": [1, 2, 3]}, [1, 2, 3]],
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, [5, 4]],
            ],
            [
                "complex object",
                {"a": True, "b": [1, 2, 3], "c": {"a": True, "b": [1, 2, 3]}},
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, {"a": 0, "b": 4, "c": 5}],
            ],
        ],
    )
    def test_crunch(description, uncrunched, crunched):
>       assert crunch(uncrunched) == crunched
E       AssertionError: assert [None, '[0]'] == [None, [0]]
E         
E         At index 1 diff: '[0]' != [0]
E         Use -v to get more diff

graphene/utils/tests/test_crunch.py:51: AssertionError
</pre>
</details>
<h3 id="test_crunchpytest_crunchmulti-primitive-all-distinct-array-uncrunched5-crunched5">test_crunch.py::test_crunch[multi-primitive all distinct array-uncrunched5-crunched5]</h3>
<details><summary> <pre>test_crunch.py::test_crunch[multi-primitive all distinct array-uncrunched5-crunched5]</pre></summary><pre>
description = 'multi-primitive all distinct array'
uncrunched = [None, 0, True, 'string']
crunched = [None, 0, True, 'string', [0, 1, 2, 3]]

    @mark.parametrize(
        "description,uncrunched,crunched",
        [
            ["number primitive", 0, [0]],
            ["boolean primitive", True, [True]],
            ["string primitive", "string", ["string"]],
            ["empty array", [], [[]]],
            ["single-item array", [None], [None, [0]]],
            [
                "multi-primitive all distinct array",
                [None, 0, True, "string"],
                [None, 0, True, "string", [0, 1, 2, 3]],
            ],
            [
                "multi-primitive repeated array",
                [True, True, True, True],
                [True, [0, 0, 0, 0]],
            ],
            ["one-level nested array", [[1, 2, 3]], [1, 2, 3, [0, 1, 2], [3]]],
            ["two-level nested array", [[[1, 2, 3]]], [1, 2, 3, [0, 1, 2], [3], [4]]],
            ["empty object", {}, [{}]],
            ["single-item object", {"a": None}, [None, {"a": 0}]],
            [
                "multi-item all distinct object",
                {"a": None, "b": 0, "c": True, "d": "string"},
                [None, 0, True, "string", {"a": 0, "b": 1, "c": 2, "d": 3}],
            ],
            [
                "multi-item repeated object",
                {"a": True, "b": True, "c": True, "d": True},
                [True, {"a": 0, "b": 0, "c": 0, "d": 0}],
            ],
            [
                "complex array",
                [{"a": True, "b": [1, 2, 3]}, [1, 2, 3]],
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, [5, 4]],
            ],
            [
                "complex object",
                {"a": True, "b": [1, 2, 3], "c": {"a": True, "b": [1, 2, 3]}},
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, {"a": 0, "b": 4, "c": 5}],
            ],
        ],
    )
    def test_crunch(description, uncrunched, crunched):
>       assert crunch(uncrunched) == crunched
E       AssertionError: assert [None, 0, Tru...[0, 1, 2, 3]'] == [None, 0, Tru... [0, 1, 2, 3]]
E         
E         At index 4 diff: '[0, 1, 2, 3]' != [0, 1, 2, 3]
E         Use -v to get more diff

graphene/utils/tests/test_crunch.py:51: AssertionError
</pre>
</details>
<h3 id="test_crunchpytest_crunchmulti-primitive-repeated-array-uncrunched6-crunched6">test_crunch.py::test_crunch[multi-primitive repeated array-uncrunched6-crunched6]</h3>
<details><summary> <pre>test_crunch.py::test_crunch[multi-primitive repeated array-uncrunched6-crunched6]</pre></summary><pre>
description = 'multi-primitive repeated array'
uncrunched = [True, True, True, True], crunched = [True, [0, 0, 0, 0]]

    @mark.parametrize(
        "description,uncrunched,crunched",
        [
            ["number primitive", 0, [0]],
            ["boolean primitive", True, [True]],
            ["string primitive", "string", ["string"]],
            ["empty array", [], [[]]],
            ["single-item array", [None], [None, [0]]],
            [
                "multi-primitive all distinct array",
                [None, 0, True, "string"],
                [None, 0, True, "string", [0, 1, 2, 3]],
            ],
            [
                "multi-primitive repeated array",
                [True, True, True, True],
                [True, [0, 0, 0, 0]],
            ],
            ["one-level nested array", [[1, 2, 3]], [1, 2, 3, [0, 1, 2], [3]]],
            ["two-level nested array", [[[1, 2, 3]]], [1, 2, 3, [0, 1, 2], [3], [4]]],
            ["empty object", {}, [{}]],
            ["single-item object", {"a": None}, [None, {"a": 0}]],
            [
                "multi-item all distinct object",
                {"a": None, "b": 0, "c": True, "d": "string"},
                [None, 0, True, "string", {"a": 0, "b": 1, "c": 2, "d": 3}],
            ],
            [
                "multi-item repeated object",
                {"a": True, "b": True, "c": True, "d": True},
                [True, {"a": 0, "b": 0, "c": 0, "d": 0}],
            ],
            [
                "complex array",
                [{"a": True, "b": [1, 2, 3]}, [1, 2, 3]],
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, [5, 4]],
            ],
            [
                "complex object",
                {"a": True, "b": [1, 2, 3], "c": {"a": True, "b": [1, 2, 3]}},
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, {"a": 0, "b": 4, "c": 5}],
            ],
        ],
    )
    def test_crunch(description, uncrunched, crunched):
>       assert crunch(uncrunched) == crunched
E       AssertionError: assert [True, '[0, 0, 0, 0]'] == [True, [0, 0, 0, 0]]
E         
E         At index 1 diff: '[0, 0, 0, 0]' != [0, 0, 0, 0]
E         Use -v to get more diff

graphene/utils/tests/test_crunch.py:51: AssertionError
</pre>
</details>
<h3 id="test_crunchpytest_crunchone-level-nested-array-uncrunched7-crunched7">test_crunch.py::test_crunch[one-level nested array-uncrunched7-crunched7]</h3>
<details><summary> <pre>test_crunch.py::test_crunch[one-level nested array-uncrunched7-crunched7]</pre></summary><pre>
description = 'one-level nested array', uncrunched = [[1, 2, 3]]
crunched = [1, 2, 3, [0, 1, 2], [3]]

    @mark.parametrize(
        "description,uncrunched,crunched",
        [
            ["number primitive", 0, [0]],
            ["boolean primitive", True, [True]],
            ["string primitive", "string", ["string"]],
            ["empty array", [], [[]]],
            ["single-item array", [None], [None, [0]]],
            [
                "multi-primitive all distinct array",
                [None, 0, True, "string"],
                [None, 0, True, "string", [0, 1, 2, 3]],
            ],
            [
                "multi-primitive repeated array",
                [True, True, True, True],
                [True, [0, 0, 0, 0]],
            ],
            ["one-level nested array", [[1, 2, 3]], [1, 2, 3, [0, 1, 2], [3]]],
            ["two-level nested array", [[[1, 2, 3]]], [1, 2, 3, [0, 1, 2], [3], [4]]],
            ["empty object", {}, [{}]],
            ["single-item object", {"a": None}, [None, {"a": 0}]],
            [
                "multi-item all distinct object",
                {"a": None, "b": 0, "c": True, "d": "string"},
                [None, 0, True, "string", {"a": 0, "b": 1, "c": 2, "d": 3}],
            ],
            [
                "multi-item repeated object",
                {"a": True, "b": True, "c": True, "d": True},
                [True, {"a": 0, "b": 0, "c": 0, "d": 0}],
            ],
            [
                "complex array",
                [{"a": True, "b": [1, 2, 3]}, [1, 2, 3]],
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, [5, 4]],
            ],
            [
                "complex object",
                {"a": True, "b": [1, 2, 3], "c": {"a": True, "b": [1, 2, 3]}},
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, {"a": 0, "b": 4, "c": 5}],
            ],
        ],
    )
    def test_crunch(description, uncrunched, crunched):
>       assert crunch(uncrunched) == crunched
E       assert [1, 2, 3, '[0... 2]"]', '[4]'] == [1, 2, 3, [0, 1, 2], [3]]
E         
E         At index 3 diff: '[0, 1, 2]' != [0, 1, 2]
E         Left contains one more item: '[4]'
E         Use -v to get more diff

graphene/utils/tests/test_crunch.py:51: AssertionError
</pre>
</details>
<h3 id="test_crunchpytest_crunchtwo-level-nested-array-uncrunched8-crunched8">test_crunch.py::test_crunch[two-level nested array-uncrunched8-crunched8]</h3>
<details><summary> <pre>test_crunch.py::test_crunch[two-level nested array-uncrunched8-crunched8]</pre></summary><pre>
description = 'two-level nested array', uncrunched = [[[1, 2, 3]]]
crunched = [1, 2, 3, [0, 1, 2], [3], [4]]

    @mark.parametrize(
        "description,uncrunched,crunched",
        [
            ["number primitive", 0, [0]],
            ["boolean primitive", True, [True]],
            ["string primitive", "string", ["string"]],
            ["empty array", [], [[]]],
            ["single-item array", [None], [None, [0]]],
            [
                "multi-primitive all distinct array",
                [None, 0, True, "string"],
                [None, 0, True, "string", [0, 1, 2, 3]],
            ],
            [
                "multi-primitive repeated array",
                [True, True, True, True],
                [True, [0, 0, 0, 0]],
            ],
            ["one-level nested array", [[1, 2, 3]], [1, 2, 3, [0, 1, 2], [3]]],
            ["two-level nested array", [[[1, 2, 3]]], [1, 2, 3, [0, 1, 2], [3], [4]]],
            ["empty object", {}, [{}]],
            ["single-item object", {"a": None}, [None, {"a": 0}]],
            [
                "multi-item all distinct object",
                {"a": None, "b": 0, "c": True, "d": "string"},
                [None, 0, True, "string", {"a": 0, "b": 1, "c": 2, "d": 3}],
            ],
            [
                "multi-item repeated object",
                {"a": True, "b": True, "c": True, "d": True},
                [True, {"a": 0, "b": 0, "c": 0, "d": 0}],
            ],
            [
                "complex array",
                [{"a": True, "b": [1, 2, 3]}, [1, 2, 3]],
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, [5, 4]],
            ],
            [
                "complex object",
                {"a": True, "b": [1, 2, 3], "c": {"a": True, "b": [1, 2, 3]}},
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, {"a": 0, "b": 4, "c": 5}],
            ],
        ],
    )
    def test_crunch(description, uncrunched, crunched):
>       assert crunch(uncrunched) == crunched
E       assert [1, 2, 3, '[0...', '[4]', ...] == [1, 2, 3, [0, 1, 2], [3], [4]]
E         
E         At index 3 diff: '[0, 1, 2]' != [0, 1, 2]
E         Left contains 2 more items, first extra item: '[1, 2, 3, "[0, 1, 2]", "[1, 2, 3, \\"[0, 1, 2]\\"]", "[4]"]'
E         Use -v to get more diff

graphene/utils/tests/test_crunch.py:51: AssertionError
</pre>
</details>
<h3 id="test_crunchpytest_crunchsingle-item-object-uncrunched10-crunched10">test_crunch.py::test_crunch[single-item object-uncrunched10-crunched10]</h3>
<details><summary> <pre>test_crunch.py::test_crunch[single-item object-uncrunched10-crunched10]</pre></summary><pre>
description = 'single-item object', uncrunched = {'a': None}
crunched = [None, {'a': 0}]

    @mark.parametrize(
        "description,uncrunched,crunched",
        [
            ["number primitive", 0, [0]],
            ["boolean primitive", True, [True]],
            ["string primitive", "string", ["string"]],
            ["empty array", [], [[]]],
            ["single-item array", [None], [None, [0]]],
            [
                "multi-primitive all distinct array",
                [None, 0, True, "string"],
                [None, 0, True, "string", [0, 1, 2, 3]],
            ],
            [
                "multi-primitive repeated array",
                [True, True, True, True],
                [True, [0, 0, 0, 0]],
            ],
            ["one-level nested array", [[1, 2, 3]], [1, 2, 3, [0, 1, 2], [3]]],
            ["two-level nested array", [[[1, 2, 3]]], [1, 2, 3, [0, 1, 2], [3], [4]]],
            ["empty object", {}, [{}]],
            ["single-item object", {"a": None}, [None, {"a": 0}]],
            [
                "multi-item all distinct object",
                {"a": None, "b": 0, "c": True, "d": "string"},
                [None, 0, True, "string", {"a": 0, "b": 1, "c": 2, "d": 3}],
            ],
            [
                "multi-item repeated object",
                {"a": True, "b": True, "c": True, "d": True},
                [True, {"a": 0, "b": 0, "c": 0, "d": 0}],
            ],
            [
                "complex array",
                [{"a": True, "b": [1, 2, 3]}, [1, 2, 3]],
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, [5, 4]],
            ],
            [
                "complex object",
                {"a": True, "b": [1, 2, 3], "c": {"a": True, "b": [1, 2, 3]}},
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, {"a": 0, "b": 4, "c": 5}],
            ],
        ],
    )
    def test_crunch(description, uncrunched, crunched):
>       assert crunch(uncrunched) == crunched
E       assert [None, '{"a": 0}'] == [None, {'a': 0}]
E         
E         At index 1 diff: '{"a": 0}' != {'a': 0}
E         Use -v to get more diff

graphene/utils/tests/test_crunch.py:51: AssertionError
</pre>
</details>
<h3 id="test_crunchpytest_crunchmulti-item-all-distinct-object-uncrunched11-crunched11">test_crunch.py::test_crunch[multi-item all distinct object-uncrunched11-crunched11]</h3>
<details><summary> <pre>test_crunch.py::test_crunch[multi-item all distinct object-uncrunched11-crunched11]</pre></summary><pre>
description = 'multi-item all distinct object'
uncrunched = {'a': None, 'b': 0, 'c': True, 'd': 'string'}
crunched = [None, 0, True, 'string', {'a': 0, 'b': 1, 'c': 2, 'd': 3}]

    @mark.parametrize(
        "description,uncrunched,crunched",
        [
            ["number primitive", 0, [0]],
            ["boolean primitive", True, [True]],
            ["string primitive", "string", ["string"]],
            ["empty array", [], [[]]],
            ["single-item array", [None], [None, [0]]],
            [
                "multi-primitive all distinct array",
                [None, 0, True, "string"],
                [None, 0, True, "string", [0, 1, 2, 3]],
            ],
            [
                "multi-primitive repeated array",
                [True, True, True, True],
                [True, [0, 0, 0, 0]],
            ],
            ["one-level nested array", [[1, 2, 3]], [1, 2, 3, [0, 1, 2], [3]]],
            ["two-level nested array", [[[1, 2, 3]]], [1, 2, 3, [0, 1, 2], [3], [4]]],
            ["empty object", {}, [{}]],
            ["single-item object", {"a": None}, [None, {"a": 0}]],
            [
                "multi-item all distinct object",
                {"a": None, "b": 0, "c": True, "d": "string"},
                [None, 0, True, "string", {"a": 0, "b": 1, "c": 2, "d": 3}],
            ],
            [
                "multi-item repeated object",
                {"a": True, "b": True, "c": True, "d": True},
                [True, {"a": 0, "b": 0, "c": 0, "d": 0}],
            ],
            [
                "complex array",
                [{"a": True, "b": [1, 2, 3]}, [1, 2, 3]],
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, [5, 4]],
            ],
            [
                "complex object",
                {"a": True, "b": [1, 2, 3], "c": {"a": True, "b": [1, 2, 3]}},
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, {"a": 0, "b": 4, "c": 5}],
            ],
        ],
    )
    def test_crunch(description, uncrunched, crunched):
>       assert crunch(uncrunched) == crunched
E       assert [None, 0, Tru...: 2, "d": 3}'] == [None, 0, Tru...': 2, 'd': 3}]
E         
E         At index 4 diff: '{"a": 0, "b": 1, "c": 2, "d": 3}' != {'a': 0, 'b': 1, 'c': 2, 'd': 3}
E         Use -v to get more diff

graphene/utils/tests/test_crunch.py:51: AssertionError
</pre>
</details>
<h3 id="test_crunchpytest_crunchmulti-item-repeated-object-uncrunched12-crunched12">test_crunch.py::test_crunch[multi-item repeated object-uncrunched12-crunched12]</h3>
<details><summary> <pre>test_crunch.py::test_crunch[multi-item repeated object-uncrunched12-crunched12]</pre></summary><pre>
description = 'multi-item repeated object'
uncrunched = {'a': True, 'b': True, 'c': True, 'd': True}
crunched = [True, {'a': 0, 'b': 0, 'c': 0, 'd': 0}]

    @mark.parametrize(
        "description,uncrunched,crunched",
        [
            ["number primitive", 0, [0]],
            ["boolean primitive", True, [True]],
            ["string primitive", "string", ["string"]],
            ["empty array", [], [[]]],
            ["single-item array", [None], [None, [0]]],
            [
                "multi-primitive all distinct array",
                [None, 0, True, "string"],
                [None, 0, True, "string", [0, 1, 2, 3]],
            ],
            [
                "multi-primitive repeated array",
                [True, True, True, True],
                [True, [0, 0, 0, 0]],
            ],
            ["one-level nested array", [[1, 2, 3]], [1, 2, 3, [0, 1, 2], [3]]],
            ["two-level nested array", [[[1, 2, 3]]], [1, 2, 3, [0, 1, 2], [3], [4]]],
            ["empty object", {}, [{}]],
            ["single-item object", {"a": None}, [None, {"a": 0}]],
            [
                "multi-item all distinct object",
                {"a": None, "b": 0, "c": True, "d": "string"},
                [None, 0, True, "string", {"a": 0, "b": 1, "c": 2, "d": 3}],
            ],
            [
                "multi-item repeated object",
                {"a": True, "b": True, "c": True, "d": True},
                [True, {"a": 0, "b": 0, "c": 0, "d": 0}],
            ],
            [
                "complex array",
                [{"a": True, "b": [1, 2, 3]}, [1, 2, 3]],
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, [5, 4]],
            ],
            [
                "complex object",
                {"a": True, "b": [1, 2, 3], "c": {"a": True, "b": [1, 2, 3]}},
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, {"a": 0, "b": 4, "c": 5}],
            ],
        ],
    )
    def test_crunch(description, uncrunched, crunched):
>       assert crunch(uncrunched) == crunched
E       assert [True, '{"a":...: 0, "d": 0}'] == [True, {'a': ...': 0, 'd': 0}]
E         
E         At index 1 diff: '{"a": 0, "b": 0, "c": 0, "d": 0}' != {'a': 0, 'b': 0, 'c': 0, 'd': 0}
E         Use -v to get more diff

graphene/utils/tests/test_crunch.py:51: AssertionError
</pre>
</details>
<h3 id="test_crunchpytest_crunchcomplex-array-uncrunched13-crunched13">test_crunch.py::test_crunch[complex array-uncrunched13-crunched13]</h3>
<details><summary> <pre>test_crunch.py::test_crunch[complex array-uncrunched13-crunched13]</pre></summary><pre>
description = 'complex array'
uncrunched = [{'a': True, 'b': [1, 2, 3]}, [1, 2, 3]]
crunched = [True, 1, 2, 3, [1, 2, 3], {'a': 0, 'b': 4}, ...]

    @mark.parametrize(
        "description,uncrunched,crunched",
        [
            ["number primitive", 0, [0]],
            ["boolean primitive", True, [True]],
            ["string primitive", "string", ["string"]],
            ["empty array", [], [[]]],
            ["single-item array", [None], [None, [0]]],
            [
                "multi-primitive all distinct array",
                [None, 0, True, "string"],
                [None, 0, True, "string", [0, 1, 2, 3]],
            ],
            [
                "multi-primitive repeated array",
                [True, True, True, True],
                [True, [0, 0, 0, 0]],
            ],
            ["one-level nested array", [[1, 2, 3]], [1, 2, 3, [0, 1, 2], [3]]],
            ["two-level nested array", [[[1, 2, 3]]], [1, 2, 3, [0, 1, 2], [3], [4]]],
            ["empty object", {}, [{}]],
            ["single-item object", {"a": None}, [None, {"a": 0}]],
            [
                "multi-item all distinct object",
                {"a": None, "b": 0, "c": True, "d": "string"},
                [None, 0, True, "string", {"a": 0, "b": 1, "c": 2, "d": 3}],
            ],
            [
                "multi-item repeated object",
                {"a": True, "b": True, "c": True, "d": True},
                [True, {"a": 0, "b": 0, "c": 0, "d": 0}],
            ],
            [
                "complex array",
                [{"a": True, "b": [1, 2, 3]}, [1, 2, 3]],
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, [5, 4]],
            ],
            [
                "complex object",
                {"a": True, "b": [1, 2, 3], "c": {"a": True, "b": [1, 2, 3]}},
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, {"a": 0, "b": 4, "c": 5}],
            ],
        ],
    )
    def test_crunch(description, uncrunched, crunched):
>       assert crunch(uncrunched) == crunched
E       assert [True, 2, 3, ..."b": 4}', ...] == [True, 1, 2, ... 'b': 4}, ...]
E         
E         At index 1 diff: 2 != 1
E         Left contains 2 more items, first extra item: '[true, 2, 3, [0, 1, 2]]'
E         Use -v to get more diff

graphene/utils/tests/test_crunch.py:51: AssertionError
</pre>
</details>
<h3 id="test_crunchpytest_crunchcomplex-object-uncrunched14-crunched14">test_crunch.py::test_crunch[complex object-uncrunched14-crunched14]</h3>
<details><summary> <pre>test_crunch.py::test_crunch[complex object-uncrunched14-crunched14]</pre></summary><pre>
description = 'complex object'
uncrunched = {'a': True, 'b': [1, 2, 3], 'c': {'a': True, 'b': [1, 2, 3]}}
crunched = [True, 1, 2, 3, [1, 2, 3], {'a': 0, 'b': 4}, ...]

    @mark.parametrize(
        "description,uncrunched,crunched",
        [
            ["number primitive", 0, [0]],
            ["boolean primitive", True, [True]],
            ["string primitive", "string", ["string"]],
            ["empty array", [], [[]]],
            ["single-item array", [None], [None, [0]]],
            [
                "multi-primitive all distinct array",
                [None, 0, True, "string"],
                [None, 0, True, "string", [0, 1, 2, 3]],
            ],
            [
                "multi-primitive repeated array",
                [True, True, True, True],
                [True, [0, 0, 0, 0]],
            ],
            ["one-level nested array", [[1, 2, 3]], [1, 2, 3, [0, 1, 2], [3]]],
            ["two-level nested array", [[[1, 2, 3]]], [1, 2, 3, [0, 1, 2], [3], [4]]],
            ["empty object", {}, [{}]],
            ["single-item object", {"a": None}, [None, {"a": 0}]],
            [
                "multi-item all distinct object",
                {"a": None, "b": 0, "c": True, "d": "string"},
                [None, 0, True, "string", {"a": 0, "b": 1, "c": 2, "d": 3}],
            ],
            [
                "multi-item repeated object",
                {"a": True, "b": True, "c": True, "d": True},
                [True, {"a": 0, "b": 0, "c": 0, "d": 0}],
            ],
            [
                "complex array",
                [{"a": True, "b": [1, 2, 3]}, [1, 2, 3]],
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, [5, 4]],
            ],
            [
                "complex object",
                {"a": True, "b": [1, 2, 3], "c": {"a": True, "b": [1, 2, 3]}},
                [True, 1, 2, 3, [1, 2, 3], {"a": 0, "b": 4}, {"a": 0, "b": 4, "c": 5}],
            ],
        ],
    )
    def test_crunch(description, uncrunched, crunched):
>       assert crunch(uncrunched) == crunched
E       assert [True, 2, 3, ... 1, 2]]', ...] == [True, 1, 2, ... 'b': 4}, ...]
E         
E         At index 1 diff: 2 != 1
E         Left contains 2 more items, first extra item: '[true, 2, 3, "[0, 1, 2]", "[true, 2, 3, \\"[0, 1, 2]\\"]", "[true, 2, 3, [0, 1, 2]]", "{\\"a\\": 0, \\"b\\": 5}"]'
E         Use -v to get more diff

graphene/utils/tests/test_crunch.py:51: AssertionError
</pre>
</details>
<h3 id="test_dataloaderpytest_basic_dataloader">test_dataloader.py::test_basic_dataloader</h3>
<details><summary> <pre>test_dataloader.py::test_basic_dataloader</pre></summary><pre>
@mark.asyncio
    async def test_basic_dataloader():
>       schema = Schema(query=Query)

graphene/utils/tests/test_dataloader.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/types/schema.py:90: in __init__
    type_map = TypeMap(query, mutation, subscription, types, auto_camelcase=auto_camelcase)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {}, query = <Query meta=<ObjectTypeOptions name='Query'>>
mutation = None, subscription = None, types = [], auto_camelcase = True

    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
        assert_valid_root_type(query)
        assert_valid_root_type(mutation)
        assert_valid_root_type(subscription)
        if types is None:
            types = []
        for type_ in types:
            assert is_graphene_type(type_)
        self.auto_camelcase = auto_camelcase
>       create_graphql_type = self.add_type
E       AttributeError: 'TypeMap' object has no attribute 'add_type'

graphene/types/schema.py:50: AttributeError
</pre>
</details>
<h3 id="test_dataloaderpytest_build_a_simple_data_loader">test_dataloader.py::test_build_a_simple_data_loader</h3>
<details><summary> <pre>test_dataloader.py::test_build_a_simple_data_loader</pre></summary><pre>
@mark.asyncio
    async def test_build_a_simple_data_loader():
        async def call_fn(keys):
            return keys

>       identity_loader = DataLoader(call_fn)

graphene/utils/tests/test_dataloader.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41c5f7b50>
batch_load_fn = <function test_build_a_simple_data_loader.<locals>.call_fn at 0x7fe41c754040>
batch = None, max_batch_size = None, cache = None, get_cache_key = None
cache_map = None, loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_can_build_a_data_loader_from_a_partial">test_dataloader.py::test_can_build_a_data_loader_from_a_partial</h3>
<details><summary> <pre>test_dataloader.py::test_can_build_a_data_loader_from_a_partial</pre></summary><pre>
@mark.asyncio
    async def test_can_build_a_data_loader_from_a_partial():
        value_map = {1: "one"}

        async def call_fn(context, keys):
            return [context.get(key) for key in keys]

        partial_fn = partial(call_fn, value_map)
>       identity_loader = DataLoader(partial_fn)

graphene/utils/tests/test_dataloader.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41be52110>
batch_load_fn = functools.partial(<function test_can_build_a_data_loader_from_a_partial.<locals>.call_fn at 0x7fe41c6b51c0>, {1: 'one'})
batch = None, max_batch_size = None, cache = None, get_cache_key = None
cache_map = None, loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_supports_loading_multiple_keys_in_one_call">test_dataloader.py::test_supports_loading_multiple_keys_in_one_call</h3>
<details><summary> <pre>test_dataloader.py::test_supports_loading_multiple_keys_in_one_call</pre></summary><pre>
@mark.asyncio
    async def test_supports_loading_multiple_keys_in_one_call():
        async def call_fn(keys):
            return keys

>       identity_loader = DataLoader(call_fn)

graphene/utils/tests/test_dataloader.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41c895490>
batch_load_fn = <function test_supports_loading_multiple_keys_in_one_call.<locals>.call_fn at 0x7fe41c6b7380>
batch = None, max_batch_size = None, cache = None, get_cache_key = None
cache_map = None, loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_batches_multiple_requests">test_dataloader.py::test_batches_multiple_requests</h3>
<details><summary> <pre>test_dataloader.py::test_batches_multiple_requests</pre></summary><pre>
@mark.asyncio
    async def test_batches_multiple_requests():
>       identity_loader, load_calls = id_loader()

graphene/utils/tests/test_dataloader.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41c85fcd0>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c756c00>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_batches_multiple_requests_with_max_batch_sizes">test_dataloader.py::test_batches_multiple_requests_with_max_batch_sizes</h3>
<details><summary> <pre>test_dataloader.py::test_batches_multiple_requests_with_max_batch_sizes</pre></summary><pre>
@mark.asyncio
    async def test_batches_multiple_requests_with_max_batch_sizes():
>       identity_loader, load_calls = id_loader(max_batch_size=2)

graphene/utils/tests/test_dataloader.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41c4631d0>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c5860c0>, batch = None
max_batch_size = 2, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_coalesces_identical_requests">test_dataloader.py::test_coalesces_identical_requests</h3>
<details><summary> <pre>test_dataloader.py::test_coalesces_identical_requests</pre></summary><pre>
@mark.asyncio
    async def test_coalesces_identical_requests():
>       identity_loader, load_calls = id_loader()

graphene/utils/tests/test_dataloader.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41c407810>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c756c00>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_caches_repeated_requests">test_dataloader.py::test_caches_repeated_requests</h3>
<details><summary> <pre>test_dataloader.py::test_caches_repeated_requests</pre></summary><pre>
@mark.asyncio
    async def test_caches_repeated_requests():
>       identity_loader, load_calls = id_loader()

graphene/utils/tests/test_dataloader.py:203: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41c4e9fd0>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c585760>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_clears_single_value_in_loader">test_dataloader.py::test_clears_single_value_in_loader</h3>
<details><summary> <pre>test_dataloader.py::test_clears_single_value_in_loader</pre></summary><pre>
@mark.asyncio
    async def test_clears_single_value_in_loader():
>       identity_loader, load_calls = id_loader()

graphene/utils/tests/test_dataloader.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41c676f90>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c585260>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_clears_all_values_in_loader">test_dataloader.py::test_clears_all_values_in_loader</h3>
<details><summary> <pre>test_dataloader.py::test_clears_all_values_in_loader</pre></summary><pre>
@mark.asyncio
    async def test_clears_all_values_in_loader():
>       identity_loader, load_calls = id_loader()

graphene/utils/tests/test_dataloader.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41bef6990>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c4f1440>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_allows_priming_the_cache">test_dataloader.py::test_allows_priming_the_cache</h3>
<details><summary> <pre>test_dataloader.py::test_allows_priming_the_cache</pre></summary><pre>
@mark.asyncio
    async def test_allows_priming_the_cache():
>       identity_loader, load_calls = id_loader()

graphene/utils/tests/test_dataloader.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41c40b110>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c617ce0>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_does_not_prime_keys_that_already_exist">test_dataloader.py::test_does_not_prime_keys_that_already_exist</h3>
<details><summary> <pre>test_dataloader.py::test_does_not_prime_keys_that_already_exist</pre></summary><pre>
@mark.asyncio
    async def test_does_not_prime_keys_that_already_exist():
>       identity_loader, load_calls = id_loader()

graphene/utils/tests/test_dataloader.py:288: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41c4092d0>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c3f8860>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_resolves_to_error_to_indicate_failure">test_dataloader.py::test_resolves_to_error_to_indicate_failure</h3>
<details><summary> <pre>test_dataloader.py::test_resolves_to_error_to_indicate_failure</pre></summary><pre>
@mark.asyncio
    async def test_resolves_to_error_to_indicate_failure():
        async def resolve(keys):
            mapped_keys = [
                key if key % 2 == 0 else Exception("Odd: {}".format(key)) for key in keys
            ]
            return mapped_keys

>       even_loader, load_calls = id_loader(resolve=resolve)

graphene/utils/tests/test_dataloader.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41bef6650>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c3f9620>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_can_represent_failures_and_successes_simultaneously">test_dataloader.py::test_can_represent_failures_and_successes_simultaneously</h3>
<details><summary> <pre>test_dataloader.py::test_can_represent_failures_and_successes_simultaneously</pre></summary><pre>
@mark.asyncio
    async def test_can_represent_failures_and_successes_simultaneously():
        async def resolve(keys):
            mapped_keys = [
                key if key % 2 == 0 else Exception("Odd: {}".format(key)) for key in keys
            ]
            return mapped_keys

>       even_loader, load_calls = id_loader(resolve=resolve)

graphene/utils/tests/test_dataloader.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41bef3f10>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c3f99e0>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_caches_failed_fetches">test_dataloader.py::test_caches_failed_fetches</h3>
<details><summary> <pre>test_dataloader.py::test_caches_failed_fetches</pre></summary><pre>
@mark.asyncio
    async def test_caches_failed_fetches():
        async def resolve(keys):
            mapped_keys = [Exception("Error: {}".format(key)) for key in keys]
            return mapped_keys

>       error_loader, load_calls = id_loader(resolve=resolve)

graphene/utils/tests/test_dataloader.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41beaf710>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c3fa340>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_caches_failed_fetches_2">test_dataloader.py::test_caches_failed_fetches_2</h3>
<details><summary> <pre>test_dataloader.py::test_caches_failed_fetches_2</pre></summary><pre>
@mark.asyncio
    async def test_caches_failed_fetches_2():
>       identity_loader, load_calls = id_loader()

graphene/utils/tests/test_dataloader.py:376: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41beb9c90>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c3f8540>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_batches_loads_occuring_within_promises">test_dataloader.py::test_batches_loads_occuring_within_promises</h3>
<details><summary> <pre>test_dataloader.py::test_batches_loads_occuring_within_promises</pre></summary><pre>
@mark.asyncio
    async def test_batches_loads_occuring_within_promises():
>       identity_loader, load_calls = id_loader()

graphene/utils/tests/test_dataloader.py:389: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41beae850>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c3fb420>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_catches_error_if_loader_resolver_fails">test_dataloader.py::test_catches_error_if_loader_resolver_fails</h3>
<details><summary> <pre>test_dataloader.py::test_catches_error_if_loader_resolver_fails</pre></summary><pre>
@mark.asyncio
    async def test_catches_error_if_loader_resolver_fails():
        exc = Exception("AOH!")

        def do_resolve(x):
            raise exc

>       a_loader, a_load_calls = id_loader(resolve=do_resolve)

graphene/utils/tests/test_dataloader.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41bd401d0>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c3f93a0>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_can_call_a_loader_from_a_loader">test_dataloader.py::test_can_call_a_loader_from_a_loader</h3>
<details><summary> <pre>test_dataloader.py::test_can_call_a_loader_from_a_loader</pre></summary><pre>
@mark.asyncio
    async def test_can_call_a_loader_from_a_loader():
>       deep_loader, deep_load_calls = id_loader()

graphene/utils/tests/test_dataloader.py:421: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41be75310>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c3faac0>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_dataloaderpytest_dataloader_clear_with_missing_key_works">test_dataloader.py::test_dataloader_clear_with_missing_key_works</h3>
<details><summary> <pre>test_dataloader.py::test_dataloader_clear_with_missing_key_works</pre></summary><pre>
@mark.asyncio
    async def test_dataloader_clear_with_missing_key_works():
        async def do_resolve(x):
            return x

>       a_loader, a_load_calls = id_loader(resolve=do_resolve)

graphene/utils/tests/test_dataloader.py:451: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graphene/utils/tests/test_dataloader.py:96: in id_loader
    identity_loader = DataLoader(fn, **options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graphene.utils.dataloader.DataLoader object at 0x7fe41c7dec50>
batch_load_fn = <function id_loader.<locals>.fn at 0x7fe41c757420>, batch = None
max_batch_size = None, cache = None, get_cache_key = None, cache_map = None
loop = None

    def __init__(self, batch_load_fn=None, batch=None, max_batch_size=None, cache=None, get_cache_key=None, cache_map=None, loop=None):
        self._loop = loop
        if batch_load_fn is not None:
            self.batch_load_fn = batch_load_fn
>       assert iscoroutinefunctionorpartial(self.batch_load_fn), 'batch_load_fn must be coroutine. Received: {}'.format(self.batch_load_fn)
E       NameError: name 'iscoroutinefunctionorpartial' is not defined

graphene/utils/dataloader.py:17: NameError
</pre>
</details>
<h3 id="test_deprecatedpytest_warn_deprecation">test_deprecated.py::test_warn_deprecation</h3>
<details><summary> <pre>test_deprecated.py::test_warn_deprecation</pre></summary><pre>
self = <MagicMock name='warn' id='140617697500624'>, args = ('OH!',)
kwargs = {'category': <class 'DeprecationWarning'>, 'stacklevel': 2}
expected = call('OH!', stacklevel=2, category=<class 'DeprecationWarning'>)
actual = call('OH!', <class 'DeprecationWarning'>, stacklevel=2)
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe41c585760>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: warn('OH!', stacklevel=2, category=<class 'DeprecationWarning'>)
E             Actual: warn('OH!', <class 'DeprecationWarning'>, stacklevel=2)

/root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/unittest/mock.py:939: AssertionError

During handling of the above exception, another exception occurred:

mocker = <pytest_mock.plugin.MockerFixture object at 0x7fe41be6bfd0>

    def test_warn_deprecation(mocker):
        mocker.patch.object(deprecated.warnings, "warn")

        warn_deprecation("OH!")
>       deprecated.warnings.warn.assert_called_with(
            "OH!", stacklevel=2, category=DeprecationWarning
        )
E       AssertionError: expected call not found.
E       Expected: warn('OH!', stacklevel=2, category=<class 'DeprecationWarning'>)
E         Actual: warn('OH!', <class 'DeprecationWarning'>, stacklevel=2)
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('OH!', <clas...tionWarning'>) == ('OH!',)
E         
E         Left contains one more item: <class 'DeprecationWarning'>
E         Use -v to get more diff
E       Kwargs:
E       assert {'stacklevel': 2} == {'category': ...tacklevel': 2}
E         
E         Omitting 1 identical items, use -vv to show
E         Right contains 1 more item:
E         {'category': <class 'DeprecationWarning'>}
E         Use -v to get more diff

graphene/utils/tests/test_deprecated.py:12: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_deprecated_decorator">test_deprecated.py::test_deprecated_decorator</h3>
<details><summary> <pre>test_deprecated.py::test_deprecated_decorator</pre></summary><pre>
self = <MagicMock name='warn_deprecation' id='140617705105168'>
args = ('Call to deprecated function my_func.',), kwargs = {}
expected = call('Call to deprecated function my_func.')
actual = call('my_func is deprecated.')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe41c756b60>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: warn_deprecation('Call to deprecated function my_func.')
E             Actual: warn_deprecation('my_func is deprecated.')

/root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/unittest/mock.py:939: AssertionError

During handling of the above exception, another exception occurred:

mocker = <pytest_mock.plugin.MockerFixture object at 0x7fe41c5cadd0>

    def test_deprecated_decorator(mocker):
        mocker.patch.object(deprecated, "warn_deprecation")

        @deprecated_decorator
        def my_func():
            return True

        result = my_func()
        assert result
>       deprecated.warn_deprecation.assert_called_with(
            "Call to deprecated function my_func."
        )
E       AssertionError: expected call not found.
E       Expected: warn_deprecation('Call to deprecated function my_func.')
E         Actual: warn_deprecation('my_func is deprecated.')
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('my_func is deprecated.',) == ('Call to dep...on my_func.',)
E         
E         At index 0 diff: 'my_func is deprecated.' != 'Call to deprecated function my_func.'
E         Use -v to get more diff

graphene/utils/tests/test_deprecated.py:26: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_deprecated_class">test_deprecated.py::test_deprecated_class</h3>
<details><summary> <pre>test_deprecated.py::test_deprecated_class</pre></summary><pre>
self = <MagicMock name='warn_deprecation' id='140617697274512'>
args = ('Call to deprecated class X.',), kwargs = {}
expected = call('Call to deprecated class X.')
actual = call('X is deprecated.')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe41c70ec00>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: warn_deprecation('Call to deprecated class X.')
E             Actual: warn_deprecation('X is deprecated.')

/root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/unittest/mock.py:939: AssertionError

During handling of the above exception, another exception occurred:

mocker = <pytest_mock.plugin.MockerFixture object at 0x7fe41c6a2210>

    def test_deprecated_class(mocker):
        mocker.patch.object(deprecated, "warn_deprecation")

        @deprecated_decorator
        class X:
            pass

        result = X()
        assert result
>       deprecated.warn_deprecation.assert_called_with("Call to deprecated class X.")
E       AssertionError: expected call not found.
E       Expected: warn_deprecation('Call to deprecated class X.')
E         Actual: warn_deprecation('X is deprecated.')
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('X is deprecated.',) == ('Call to dep...ed class X.',)
E         
E         At index 0 diff: 'X is deprecated.' != 'Call to deprecated class X.'
E         Use -v to get more diff

graphene/utils/tests/test_deprecated.py:40: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_deprecated_decorator_text">test_deprecated.py::test_deprecated_decorator_text</h3>
<details><summary> <pre>test_deprecated.py::test_deprecated_decorator_text</pre></summary><pre>
self = <MagicMock name='warn_deprecation' id='140617704044688'>
args = ('Call to deprecated function my_func (Deprecation text).',), kwargs = {}
expected = call('Call to deprecated function my_func (Deprecation text).')
actual = call('my_func function is deprecated. Deprecation text')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe41c6b6200>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: warn_deprecation('Call to deprecated function my_func (Deprecation text).')
E             Actual: warn_deprecation('my_func function is deprecated. Deprecation text')

/root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/unittest/mock.py:939: AssertionError

During handling of the above exception, another exception occurred:

mocker = <pytest_mock.plugin.MockerFixture object at 0x7fe41c6a9250>

    def test_deprecated_decorator_text(mocker):
        mocker.patch.object(deprecated, "warn_deprecation")

        @deprecated_decorator("Deprecation text")
        def my_func():
            return True

        result = my_func()
        assert result
>       deprecated.warn_deprecation.assert_called_with(
            "Call to deprecated function my_func (Deprecation text)."
        )
E       AssertionError: expected call not found.
E       Expected: warn_deprecation('Call to deprecated function my_func (Deprecation text).')
E         Actual: warn_deprecation('my_func function is deprecated. Deprecation text')
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('my_func fun...cation text',) == ('Call to dep...tion text).',)
E         
E         At index 0 diff: 'my_func function is deprecated. Deprecation text' != 'Call to deprecated function my_func (Deprecation text).'
E         Use -v to get more diff

graphene/utils/tests/test_deprecated.py:52: AssertionError
</pre>
</details>
<h3 id="test_deprecatedpytest_deprecated_class_text">test_deprecated.py::test_deprecated_class_text</h3>
<details><summary> <pre>test_deprecated.py::test_deprecated_class_text</pre></summary><pre>
self = <MagicMock name='warn_deprecation' id='140617707366800'>
args = ('Call to deprecated class X (Deprecation text).',), kwargs = {}
expected = call('Call to deprecated class X (Deprecation text).')
actual = call('X class is deprecated. Deprecation text')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe41c70fa60>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: warn_deprecation('Call to deprecated class X (Deprecation text).')
E             Actual: warn_deprecation('X class is deprecated. Deprecation text')

/root/.local/share/uv/python/cpython-3.11.10-linux-x86_64-gnu/lib/python3.11/unittest/mock.py:939: AssertionError

During handling of the above exception, another exception occurred:

mocker = <pytest_mock.plugin.MockerFixture object at 0x7fe41c7f3650>

    def test_deprecated_class_text(mocker):
        mocker.patch.object(deprecated, "warn_deprecation")

        @deprecated_decorator("Deprecation text")
        class X:
            pass

        result = X()
        assert result
>       deprecated.warn_deprecation.assert_called_with(
            "Call to deprecated class X (Deprecation text)."
        )
E       AssertionError: expected call not found.
E       Expected: warn_deprecation('Call to deprecated class X (Deprecation text).')
E         Actual: warn_deprecation('X class is deprecated. Deprecation text')
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('X class is ...cation text',) == ('Call to dep...tion text).',)
E         
E         At index 0 diff: 'X class is deprecated. Deprecation text' != 'Call to deprecated class X (Deprecation text).'
E         Use -v to get more diff

graphene/utils/tests/test_deprecated.py:66: AssertionError
</pre>
</details>
<h3 id="test_module_loadingpytest_import_string_attributes">test_module_loading.py::test_import_string_attributes</h3>
<details><summary> <pre>test_module_loading.py::test_import_string_attributes</pre></summary><pre>
def test_import_string_attributes():
        with raises(Exception) as exc_info:
            import_string("graphene.String", "length")

>       assert (
            str(exc_info.value)
            == 'Module "graphene" does not define a "length" attribute inside attribute/class '
            '"String"'
        )
E       assert 'Object "Stri...bute "length"' == 'Module "grap...lass "String"'
E         
E         - Module "graphene" does not define a "length" attribute inside attribute/class "String"
E         + Object "String" does not have attribute "length"

graphene/utils/tests/test_module_loading.py:37: AssertionError
</pre>
</details>
<h3 id="test_orderedtypepytest_orderedtype_resetcounter">test_orderedtype.py::test_orderedtype_resetcounter</h3>
<details><summary> <pre>test_orderedtype.py::test_orderedtype_resetcounter</pre></summary><pre>
def test_orderedtype_resetcounter():
        one = OrderedType()
        two = OrderedType()
>       one.reset_counter()
E       AttributeError: 'OrderedType' object has no attribute 'reset_counter'

graphene/utils/tests/test_orderedtype.py:31: AttributeError
</pre>
</details>
<h3 id="test_str_converterspytest_snake_case">test_str_converters.py::test_snake_case</h3>
<details><summary> <pre>test_str_converters.py::test_snake_case</pre></summary><pre>
def test_snake_case():
        assert to_snake_case("snakesOnAPlane") == "snakes_on_a_plane"
        assert to_snake_case("SnakesOnAPlane") == "snakes_on_a_plane"
>       assert to_snake_case("SnakesOnA_Plane") == "snakes_on_a__plane"
E       AssertionError: assert 'snakes_on_a_plane' == 'snakes_on_a__plane'
E         
E         - snakes_on_a__plane
E         ?             -
E         + snakes_on_a_plane

graphene/utils/tests/test_str_converters.py:8: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/graphene/relay/connection.py b/graphene/relay/connection.py</span>
<span class="gh">index 230c1a7..347a68b 100644</span>
<span class="gd">--- a/graphene/relay/connection.py</span>
<span class="gi">+++ b/graphene/relay/connection.py</span>
<span class="gu">@@ -18,9 +18,26 @@ class PageInfo(ObjectType):</span>
<span class="w"> </span>    start_cursor = String(name=&#39;startCursor&#39;, description=&#39;When paginating backwards, the cursor to continue.&#39;)
<span class="w"> </span>    end_cursor = String(name=&#39;endCursor&#39;, description=&#39;When paginating forwards, the cursor to continue.&#39;)

<span class="gi">+def get_edge_class(connection_class, node_class, base_name, strict_types=False):</span>
<span class="gi">+    &quot;&quot;&quot;Create an Edge class for a Connection.&quot;&quot;&quot;</span>
<span class="gi">+    class EdgeBase(ObjectType):</span>
<span class="gi">+        class Meta:</span>
<span class="gi">+            name = f&#39;{base_name}Edge&#39;</span>
<span class="gi">+            description = &#39;A Relay edge containing a `{base_name}` and its cursor.&#39;</span>
<span class="gi">+</span>
<span class="gi">+        node = Field(NonNull(node_class) if strict_types else node_class, description=&#39;The item at the end of the edge.&#39;)</span>
<span class="gi">+        cursor = String(required=True, description=&#39;A cursor for use in pagination.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return type(EdgeBase.__name__, (EdgeBase,), {})</span>
<span class="gi">+</span>
<span class="w"> </span>def page_info_adapter(startCursor, endCursor, hasPreviousPage, hasNextPage):
<span class="w"> </span>    &quot;&quot;&quot;Adapter for creating PageInfo instances&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return PageInfo(</span>
<span class="gi">+        start_cursor=startCursor,</span>
<span class="gi">+        end_cursor=endCursor,</span>
<span class="gi">+        has_previous_page=hasPreviousPage,</span>
<span class="gi">+        has_next_page=hasNextPage</span>
<span class="gi">+    )</span>

<span class="w"> </span>class ConnectionOptions(ObjectTypeOptions):
<span class="w"> </span>    node = None
<span class="gu">@@ -53,7 +70,7 @@ class Connection(ObjectType):</span>

<span class="w"> </span>def connection_adapter(cls, edges, pageInfo):
<span class="w"> </span>    &quot;&quot;&quot;Adapter for creating Connection instances&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return cls(edges=edges, page_info=pageInfo)</span>

<span class="w"> </span>class IterableConnectionField(Field):

<span class="gh">diff --git a/graphene/relay/node.py b/graphene/relay/node.py</span>
<span class="gh">index ed065ff..64b732b 100644</span>
<span class="gd">--- a/graphene/relay/node.py</span>
<span class="gi">+++ b/graphene/relay/node.py</span>
<span class="gu">@@ -9,7 +9,11 @@ def is_node(objecttype):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if the given objecttype has Node as an interface
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isclass(objecttype):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if not issubclass(objecttype, ObjectType):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return Node in objecttype._meta.interfaces</span>

<span class="w"> </span>class GlobalID(Field):

<span class="gu">@@ -41,4 +45,9 @@ class AbstractNode(Interface):</span>
<span class="w"> </span>        super(AbstractNode, cls).__init_subclass_with_meta__(_meta=_meta, **options)

<span class="w"> </span>class Node(AbstractNode):
<span class="gd">-    &quot;&quot;&quot;An object with an ID&quot;&quot;&quot;</span>
\ No newline at end of file
<span class="gi">+    &quot;&quot;&quot;An object with an ID&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def Field(cls, *args, **kwargs):</span>
<span class="gi">+        &quot;&quot;&quot;Create a NodeField for this Node class.&quot;&quot;&quot;</span>
<span class="gi">+        return NodeField(cls, *args, **kwargs)</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/types/argument.py b/graphene/types/argument.py</span>
<span class="gh">index 3d5d873..7da0431 100644</span>
<span class="gd">--- a/graphene/types/argument.py</span>
<span class="gi">+++ b/graphene/types/argument.py</span>
<span class="gu">@@ -5,6 +5,28 @@ from .mountedtype import MountedType</span>
<span class="w"> </span>from .structures import NonNull
<span class="w"> </span>from .utils import get_type

<span class="gi">+def to_arguments(args, extra_args=None):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Convert arguments to a list of Argument instances.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    from .unmountedtype import UnmountedType</span>
<span class="gi">+</span>
<span class="gi">+    extra_args = extra_args or {}</span>
<span class="gi">+    arguments = []</span>
<span class="gi">+</span>
<span class="gi">+    for name, value in chain(args.items(), extra_args.items()):</span>
<span class="gi">+        if isinstance(value, Argument):</span>
<span class="gi">+            argument = value</span>
<span class="gi">+            if argument.name is None:</span>
<span class="gi">+                argument.name = name</span>
<span class="gi">+        elif isinstance(value, (UnmountedType, Dynamic)):</span>
<span class="gi">+            argument = Argument(value, name=name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&#39;Unknown argument &quot;{name}&quot; of type {type(value)}&#39;)</span>
<span class="gi">+        arguments.append(argument)</span>
<span class="gi">+</span>
<span class="gi">+    return sorted(arguments, key=lambda x: x.creation_counter)</span>
<span class="gi">+</span>
<span class="w"> </span>class Argument(MountedType):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Makes an Argument available on a Field in the GraphQL schema.
<span class="gh">diff --git a/graphene/types/base.py b/graphene/types/base.py</span>
<span class="gh">index 03c7007..5c5dc69 100644</span>
<span class="gd">--- a/graphene/types/base.py</span>
<span class="gi">+++ b/graphene/types/base.py</span>
<span class="gu">@@ -18,6 +18,11 @@ class BaseOptions:</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return f&#39;&lt;{self.__class__.__name__} name={repr(self.name)}&gt;&#39;
<span class="gi">+</span>
<span class="gi">+    def freeze(self):</span>
<span class="gi">+        &quot;&quot;&quot;Freeze the options to prevent further modifications.&quot;&quot;&quot;</span>
<span class="gi">+        self._frozen = True</span>
<span class="gi">+</span>
<span class="w"> </span>BaseTypeMeta = SubclassWithMeta_Meta

<span class="w"> </span>class BaseType(SubclassWithMeta):
<span class="gh">diff --git a/graphene/types/enum.py b/graphene/types/enum.py</span>
<span class="gh">index ff69925..97d833d 100644</span>
<span class="gd">--- a/graphene/types/enum.py</span>
<span class="gi">+++ b/graphene/types/enum.py</span>
<span class="gu">@@ -4,6 +4,16 @@ from .base import BaseOptions, BaseType</span>
<span class="w"> </span>from .unmountedtype import UnmountedType
<span class="w"> </span>EnumType = type(PyEnum)

<span class="gi">+def eq_enum(self, other):</span>
<span class="gi">+    &quot;&quot;&quot;Compare two enum values for equality.&quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(other, self.__class__):</span>
<span class="gi">+        return self.value == other.value</span>
<span class="gi">+    return self.value == other</span>
<span class="gi">+</span>
<span class="gi">+def hash_enum(self):</span>
<span class="gi">+    &quot;&quot;&quot;Hash an enum value.&quot;&quot;&quot;</span>
<span class="gi">+    return hash(self.value)</span>
<span class="gi">+</span>
<span class="w"> </span>class EnumOptions(BaseOptions):
<span class="w"> </span>    enum = None
<span class="w"> </span>    deprecation_reason = None
<span class="gu">@@ -75,4 +85,15 @@ class Enum(UnmountedType, BaseType, metaclass=EnumMeta):</span>
<span class="w"> </span>        This function is called when the unmounted type (Enum instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
\ No newline at end of file
<span class="gi">+        return cls</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_enum(cls, enum, description=None, deprecation_reason=None):</span>
<span class="gi">+        &quot;&quot;&quot;Create a Graphene Enum from a Python enum.py Enum.&quot;&quot;&quot;</span>
<span class="gi">+        meta_dict = {</span>
<span class="gi">+            &#39;enum&#39;: enum,</span>
<span class="gi">+            &#39;description&#39;: description,</span>
<span class="gi">+            &#39;deprecation_reason&#39;: deprecation_reason</span>
<span class="gi">+        }</span>
<span class="gi">+        meta_class = type(&#39;Meta&#39;, (object,), meta_dict)</span>
<span class="gi">+        return type(meta_class.enum.__name__, (cls,), {&#39;Meta&#39;: meta_class})</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/types/generic.py b/graphene/types/generic.py</span>
<span class="gh">index 601d6c7..8d1d283 100644</span>
<span class="gd">--- a/graphene/types/generic.py</span>
<span class="gi">+++ b/graphene/types/generic.py</span>
<span class="gu">@@ -3,6 +3,10 @@ from graphql.language.ast import BooleanValueNode, FloatValueNode, IntValueNode,</span>
<span class="w"> </span>from graphene.types.scalars import MAX_INT, MIN_INT
<span class="w"> </span>from .scalars import Scalar

<span class="gi">+def identity(value):</span>
<span class="gi">+    &quot;&quot;&quot;Return the value unchanged.&quot;&quot;&quot;</span>
<span class="gi">+    return value</span>
<span class="gi">+</span>
<span class="w"> </span>class GenericScalar(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The `GenericScalar` scalar type represents a generic
<span class="gh">diff --git a/graphene/types/resolver.py b/graphene/types/resolver.py</span>
<span class="gh">index aed4dfb..150d851 100644</span>
<span class="gd">--- a/graphene/types/resolver.py</span>
<span class="gi">+++ b/graphene/types/resolver.py</span>
<span class="gu">@@ -1 +1,16 @@</span>
<span class="gd">-default_resolver = dict_or_attr_resolver</span>
\ No newline at end of file
<span class="gi">+def dict_or_attr_resolver(attname, default_value, root, info, **args):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Default resolver that tries to get the value from:</span>
<span class="gi">+    1. The root dict (if root is a dict)</span>
<span class="gi">+    2. An attribute of root</span>
<span class="gi">+    3. Default value if nothing is found</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(root, dict):</span>
<span class="gi">+        return root.get(attname, default_value)</span>
<span class="gi">+    return getattr(root, attname, default_value)</span>
<span class="gi">+</span>
<span class="gi">+default_resolver = dict_or_attr_resolver</span>
<span class="gi">+</span>
<span class="gi">+def get_default_resolver():</span>
<span class="gi">+    &quot;&quot;&quot;Get the default resolver function.&quot;&quot;&quot;</span>
<span class="gi">+    return default_resolver</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/types/scalars.py b/graphene/types/scalars.py</span>
<span class="gh">index d42a1ab..51180d5 100644</span>
<span class="gd">--- a/graphene/types/scalars.py</span>
<span class="gi">+++ b/graphene/types/scalars.py</span>
<span class="gu">@@ -1,11 +1,42 @@</span>
<span class="gd">-from typing import Any</span>
<span class="gi">+from typing import Any, Optional, Union</span>
<span class="w"> </span>from graphql import Undefined
<span class="w"> </span>from graphql.language.ast import BooleanValueNode, FloatValueNode, IntValueNode, StringValueNode
<span class="w"> </span>from .base import BaseOptions, BaseType
<span class="w"> </span>from .unmountedtype import UnmountedType

<span class="gi">+MAX_INT = 2147483647</span>
<span class="gi">+MIN_INT = -2147483648</span>
<span class="gi">+</span>
<span class="gi">+def coerce_int(value: Any) -&gt; Optional[int]:</span>
<span class="gi">+    &quot;&quot;&quot;Convert a value to an integer if possible.&quot;&quot;&quot;</span>
<span class="gi">+    if value is None or value is Undefined:</span>
<span class="gi">+        return None</span>
<span class="gi">+    try:</span>
<span class="gi">+        num = int(value)</span>
<span class="gi">+        if num &gt; MAX_INT or num &lt; MIN_INT:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return num</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+def coerce_float(value: Any) -&gt; Optional[float]:</span>
<span class="gi">+    &quot;&quot;&quot;Convert a value to a float if possible.&quot;&quot;&quot;</span>
<span class="gi">+    if value is None or value is Undefined:</span>
<span class="gi">+        return None</span>
<span class="gi">+    try:</span>
<span class="gi">+        return float(value)</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+def coerce_string(value: Any) -&gt; Optional[str]:</span>
<span class="gi">+    &quot;&quot;&quot;Convert a value to a string if possible.&quot;&quot;&quot;</span>
<span class="gi">+    if value is None or value is Undefined:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return str(value)</span>
<span class="gi">+</span>
<span class="w"> </span>class ScalarOptions(BaseOptions):
<span class="gd">-    pass</span>
<span class="gi">+    def freeze(self):</span>
<span class="gi">+        self._frozen = True</span>

<span class="w"> </span>class Scalar(UnmountedType, BaseType):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -30,9 +61,12 @@ class Scalar(UnmountedType, BaseType):</span>
<span class="w"> </span>        This function is called when the unmounted type (Scalar instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-MAX_INT = 2147483647</span>
<span class="gd">-MIN_INT = -2147483648</span>
<span class="gi">+        return cls</span>
<span class="gi">+</span>
<span class="gi">+    def mount(self, _as=None):</span>
<span class="gi">+        &quot;&quot;&quot;Mount the scalar type as a Field.&quot;&quot;&quot;</span>
<span class="gi">+        from .field import Field</span>
<span class="gi">+        return Field(self.get_type(), *self.args, **self.kwargs)</span>

<span class="w"> </span>class Int(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -44,6 +78,12 @@ class Int(Scalar):</span>
<span class="w"> </span>    serialize = coerce_int
<span class="w"> </span>    parse_value = coerce_int

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast):</span>
<span class="gi">+        if isinstance(ast, IntValueNode):</span>
<span class="gi">+            return coerce_int(ast.value)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="w"> </span>class BigInt(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The `BigInt` scalar type represents non-fractional whole numeric values.
<span class="gu">@@ -53,6 +93,12 @@ class BigInt(Scalar):</span>
<span class="w"> </span>    serialize = coerce_int
<span class="w"> </span>    parse_value = coerce_int

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast):</span>
<span class="gi">+        if isinstance(ast, IntValueNode):</span>
<span class="gi">+            return coerce_int(ast.value)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="w"> </span>class Float(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The `Float` scalar type represents signed double-precision fractional
<span class="gu">@@ -62,6 +108,12 @@ class Float(Scalar):</span>
<span class="w"> </span>    serialize = coerce_float
<span class="w"> </span>    parse_value = coerce_float

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast):</span>
<span class="gi">+        if isinstance(ast, (IntValueNode, FloatValueNode)):</span>
<span class="gi">+            return coerce_float(ast.value)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="w"> </span>class String(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The `String` scalar type represents textual data, represented as UTF-8
<span class="gu">@@ -71,6 +123,12 @@ class String(Scalar):</span>
<span class="w"> </span>    serialize = coerce_string
<span class="w"> </span>    parse_value = coerce_string

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast):</span>
<span class="gi">+        if isinstance(ast, StringValueNode):</span>
<span class="gi">+            return ast.value</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="w"> </span>class Boolean(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The `Boolean` scalar type represents `true` or `false`.
<span class="gu">@@ -78,6 +136,12 @@ class Boolean(Scalar):</span>
<span class="w"> </span>    serialize = bool
<span class="w"> </span>    parse_value = bool

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast):</span>
<span class="gi">+        if isinstance(ast, BooleanValueNode):</span>
<span class="gi">+            return ast.value</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="w"> </span>class ID(Scalar):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The `ID` scalar type represents a unique identifier, often used to
<span class="gu">@@ -87,4 +151,10 @@ class ID(Scalar):</span>
<span class="w"> </span>    (such as `4`) input value will be accepted as an ID.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    serialize = str
<span class="gd">-    parse_value = str</span>
\ No newline at end of file
<span class="gi">+    parse_value = str</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def parse_literal(ast):</span>
<span class="gi">+        if isinstance(ast, (StringValueNode, IntValueNode)):</span>
<span class="gi">+            return str(ast.value)</span>
<span class="gi">+        return None</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/types/schema.py b/graphene/types/schema.py</span>
<span class="gh">index ed0c560..1d38b1e 100644</span>
<span class="gd">--- a/graphene/types/schema.py</span>
<span class="gi">+++ b/graphene/types/schema.py</span>
<span class="gu">@@ -16,9 +16,26 @@ from .scalars import ID, Boolean, Float, Int, Scalar, String</span>
<span class="w"> </span>from .structures import List, NonNull
<span class="w"> </span>from .union import Union
<span class="w"> </span>from .utils import get_field_as
<span class="gi">+</span>
<span class="w"> </span>introspection_query = get_introspection_query()
<span class="w"> </span>IntrospectionSchema = introspection_types[&#39;__Schema&#39;]

<span class="gi">+def is_graphene_type(type_):</span>
<span class="gi">+    &quot;&quot;&quot;Check if the given type is a Graphene type.&quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(type_, (GrapheneGraphQLType, str)):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if inspect.isclass(type_) and issubclass(type_, (ObjectType, InputObjectType, Scalar, Interface, Union, Enum)):</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+def assert_valid_root_type(type_):</span>
<span class="gi">+    &quot;&quot;&quot;Assert that the given type is a valid root type.&quot;&quot;&quot;</span>
<span class="gi">+    if type_ is None:</span>
<span class="gi">+        return</span>
<span class="gi">+    is_valid = inspect.isclass(type_) and issubclass(type_, ObjectType)</span>
<span class="gi">+    if not is_valid:</span>
<span class="gi">+        raise Exception(f&#39;Type &quot;{type_}&quot; is not a valid root type. Expected a subclass of ObjectType.&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>class TypeMap(dict):

<span class="w"> </span>    def __init__(self, query=None, mutation=None, subscription=None, types=None, auto_camelcase=True):
<span class="gu">@@ -38,7 +55,12 @@ class TypeMap(dict):</span>

<span class="w"> </span>    def get_function_for_type(self, graphene_type, func_name, name, default_value):
<span class="w"> </span>        &quot;&quot;&quot;Gets a resolve or subscribe function for a given ObjectType&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not hasattr(graphene_type, func_name):</span>
<span class="gi">+            return default_value</span>
<span class="gi">+        func = getattr(graphene_type, func_name)</span>
<span class="gi">+        if func is None:</span>
<span class="gi">+            return default_value</span>
<span class="gi">+        return func</span>

<span class="w"> </span>class Schema:
<span class="w"> </span>    &quot;&quot;&quot;Schema Definition.
<span class="gu">@@ -108,18 +130,27 @@ class Schema:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            :obj:`ExecutionResult` containing any data and errors for the operation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = normalize_execute_kwargs(kwargs)</span>
<span class="gi">+        return graphql_sync(self.graphql_schema, *args, **kwargs)</span>

<span class="w"> </span>    async def execute_async(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Execute a GraphQL query on the schema asynchronously.
<span class="w"> </span>        Same as `execute`, but uses `graphql` instead of `graphql_sync`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = normalize_execute_kwargs(kwargs)</span>
<span class="gi">+        return await graphql(self.graphql_schema, *args, **kwargs)</span>

<span class="w"> </span>    async def subscribe(self, query, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Execute a GraphQL subscription on the schema asynchronously.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs = normalize_execute_kwargs(kwargs)</span>
<span class="gi">+        return await subscribe(self.graphql_schema, query, *args, **kwargs)</span>

<span class="w"> </span>def normalize_execute_kwargs(kwargs):
<span class="w"> </span>    &quot;&quot;&quot;Replace alias names in keyword arguments for graphql()&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if kwargs.get(&#39;root&#39;) is not None and not kwargs.get(&#39;root_value&#39;):</span>
<span class="gi">+        kwargs[&#39;root_value&#39;] = kwargs.pop(&#39;root&#39;)</span>
<span class="gi">+    if kwargs.get(&#39;context&#39;) is not None and not kwargs.get(&#39;context_value&#39;):</span>
<span class="gi">+        kwargs[&#39;context_value&#39;] = kwargs.pop(&#39;context&#39;)</span>
<span class="gi">+    if kwargs.get(&#39;variables&#39;) is not None and not kwargs.get(&#39;variable_values&#39;):</span>
<span class="gi">+        kwargs[&#39;variable_values&#39;] = kwargs.pop(&#39;variables&#39;)</span>
<span class="gi">+    return kwargs</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/types/structures.py b/graphene/types/structures.py</span>
<span class="gh">index fa4a743..07dcab1 100644</span>
<span class="gd">--- a/graphene/types/structures.py</span>
<span class="gi">+++ b/graphene/types/structures.py</span>
<span class="gu">@@ -20,7 +20,12 @@ class Structure(UnmountedType):</span>
<span class="w"> </span>        This function is called when the unmounted type (List or NonNull instance)
<span class="w"> </span>        is mounted (as a Field, InputField or Argument)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return get_type(self._of_type)</span>
<span class="gi">+</span>
<span class="gi">+    def mount(self, _as=None):</span>
<span class="gi">+        &quot;&quot;&quot;Mount the structure type as a Field.&quot;&quot;&quot;</span>
<span class="gi">+        from .field import Field</span>
<span class="gi">+        return Field(self.get_type(), *self.args, **self.kwargs)</span>

<span class="w"> </span>class List(Structure):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gh">diff --git a/graphene/types/utils.py b/graphene/types/utils.py</span>
<span class="gh">index 9c05994..e7bc059 100644</span>
<span class="gd">--- a/graphene/types/utils.py</span>
<span class="gi">+++ b/graphene/types/utils.py</span>
<span class="gu">@@ -4,19 +4,49 @@ from ..utils.module_loading import import_string</span>
<span class="w"> </span>from .mountedtype import MountedType
<span class="w"> </span>from .unmountedtype import UnmountedType

<span class="gi">+def get_type(type_):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Returns the type for the given type. It can be:</span>
<span class="gi">+    - A MountedType (which will be returned as is)</span>
<span class="gi">+    - A UnmountedType (which will be mounted)</span>
<span class="gi">+    - A Type string (which will be imported and mounted)</span>
<span class="gi">+    - A callable (which will be called and mounted)</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(type_, MountedType):</span>
<span class="gi">+        return type_</span>
<span class="gi">+    elif isinstance(type_, UnmountedType):</span>
<span class="gi">+        return type_.mount()</span>
<span class="gi">+    elif isinstance(type_, str):</span>
<span class="gi">+        return import_string(type_)</span>
<span class="gi">+    elif callable(type_):</span>
<span class="gi">+        return get_type(type_())</span>
<span class="gi">+    return type_</span>
<span class="gi">+</span>
<span class="w"> </span>def get_field_as(value, _as=None):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get type mounted
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, MountedType):</span>
<span class="gi">+        return value</span>
<span class="gi">+    elif isinstance(value, UnmountedType):</span>
<span class="gi">+        return value.mount(_as)</span>
<span class="gi">+    return value</span>

<span class="w"> </span>def yank_fields_from_attrs(attrs, _as=None, sort=True):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Extract all the fields in given attributes (dict)
<span class="w"> </span>    and return them ordered
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fields = []</span>
<span class="gi">+    for key, value in attrs.items():</span>
<span class="gi">+        if isinstance(value, (MountedType, UnmountedType)):</span>
<span class="gi">+            fields.append((key, get_field_as(value, _as)))</span>
<span class="gi">+    if sort:</span>
<span class="gi">+        fields = sorted(fields, key=lambda f: f[1].creation_counter)</span>
<span class="gi">+    return fields</span>

<span class="w"> </span>def get_underlying_type(_type):
<span class="w"> </span>    &quot;&quot;&quot;Get the underlying type even if it is wrapped in structures like NonNull&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    while hasattr(_type, &#39;of_type&#39;):</span>
<span class="gi">+        _type = _type.of_type</span>
<span class="gi">+    return _type</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/utils/crunch.py b/graphene/utils/crunch.py</span>
<span class="gh">index 0ff4a3a..d97f292 100644</span>
<span class="gd">--- a/graphene/utils/crunch.py</span>
<span class="gi">+++ b/graphene/utils/crunch.py</span>
<span class="gu">@@ -1,2 +1,69 @@</span>
<span class="w"> </span>import json
<span class="gd">-from collections.abc import Mapping</span>
\ No newline at end of file
<span class="gi">+from collections.abc import Mapping</span>
<span class="gi">+</span>
<span class="gi">+def crunch(data):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Transforms data structures into a more compact form by:</span>
<span class="gi">+    - Converting primitives into single-item lists</span>
<span class="gi">+    - Converting arrays into a list of values followed by indices</span>
<span class="gi">+    - Converting objects into a list of values followed by a key-index mapping</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    values = []</span>
<span class="gi">+    value_to_index = {}</span>
<span class="gi">+</span>
<span class="gi">+    def get_index(value):</span>
<span class="gi">+        if not isinstance(value, (bool, int, float, str, type(None))):</span>
<span class="gi">+            value = json.dumps(value, sort_keys=True)</span>
<span class="gi">+        if value not in value_to_index:</span>
<span class="gi">+            value_to_index[value] = len(values)</span>
<span class="gi">+            values.append(value)</span>
<span class="gi">+        return value_to_index[value]</span>
<span class="gi">+</span>
<span class="gi">+    def process(obj):</span>
<span class="gi">+        if isinstance(obj, (bool, int, float, str, type(None))):</span>
<span class="gi">+            return [obj]</span>
<span class="gi">+        elif isinstance(obj, list):</span>
<span class="gi">+            if not obj:</span>
<span class="gi">+                return [[]]</span>
<span class="gi">+            indices = []</span>
<span class="gi">+            for item in obj:</span>
<span class="gi">+                processed = process(item)</span>
<span class="gi">+                if len(processed) &gt; 1:</span>
<span class="gi">+                    indices.append(get_index(processed))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    indices.append(get_index(processed[0]))</span>
<span class="gi">+            result = []</span>
<span class="gi">+            for i in range(len(values)):</span>
<span class="gi">+                if isinstance(values[i], str) and values[i].startswith(&#39;[&#39;):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        array = json.loads(values[i])</span>
<span class="gi">+                        if array == indices:</span>
<span class="gi">+                            return values[:i] + [indices]</span>
<span class="gi">+                    except:</span>
<span class="gi">+                        pass</span>
<span class="gi">+            values.append(json.dumps(indices))</span>
<span class="gi">+            return values</span>
<span class="gi">+        elif isinstance(obj, Mapping):</span>
<span class="gi">+            if not obj:</span>
<span class="gi">+                return [{}]</span>
<span class="gi">+            obj_indices = {}</span>
<span class="gi">+            for key, value in sorted(obj.items()):</span>
<span class="gi">+                processed = process(value)</span>
<span class="gi">+                if len(processed) &gt; 1:</span>
<span class="gi">+                    obj_indices[key] = get_index(processed)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    obj_indices[key] = get_index(processed[0])</span>
<span class="gi">+            result = []</span>
<span class="gi">+            for i in range(len(values)):</span>
<span class="gi">+                if isinstance(values[i], str) and values[i].startswith(&#39;{&#39;):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        mapping = json.loads(values[i])</span>
<span class="gi">+                        if mapping == obj_indices:</span>
<span class="gi">+                            return values[:i] + [obj_indices]</span>
<span class="gi">+                    except:</span>
<span class="gi">+                        pass</span>
<span class="gi">+            values.append(json.dumps(obj_indices))</span>
<span class="gi">+            return values</span>
<span class="gi">+        return [obj]</span>
<span class="gi">+</span>
<span class="gi">+    return process(data)</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/utils/deprecated.py b/graphene/utils/deprecated.py</span>
<span class="gh">index a3e7408..71b0164 100644</span>
<span class="gd">--- a/graphene/utils/deprecated.py</span>
<span class="gi">+++ b/graphene/utils/deprecated.py</span>
<span class="gu">@@ -3,10 +3,38 @@ import inspect</span>
<span class="w"> </span>import warnings
<span class="w"> </span>string_types = (type(b&#39;&#39;), type(&#39;&#39;))

<span class="gi">+def warn_deprecation(message):</span>
<span class="gi">+    warnings.warn(message, DeprecationWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="w"> </span>def deprecated(reason):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This is a decorator which can be used to mark functions
<span class="w"> </span>    as deprecated. It will result in a warning being emitted
<span class="w"> </span>    when the function is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if isinstance(reason, string_types):</span>
<span class="gi">+        def decorator(func):</span>
<span class="gi">+            if inspect.isclass(func):</span>
<span class="gi">+                fmt = &quot;{name} class is deprecated. {reason}&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                fmt = &quot;{name} function is deprecated. {reason}&quot;</span>
<span class="gi">+</span>
<span class="gi">+            msg = fmt.format(name=func.__name__, reason=reason)</span>
<span class="gi">+</span>
<span class="gi">+            @functools.wraps(func)</span>
<span class="gi">+            def wrapper(*args, **kwargs):</span>
<span class="gi">+                warn_deprecation(msg)</span>
<span class="gi">+                return func(*args, **kwargs)</span>
<span class="gi">+            return wrapper</span>
<span class="gi">+        return decorator</span>
<span class="gi">+    elif inspect.isclass(reason) or inspect.isfunction(reason):</span>
<span class="gi">+        func = reason</span>
<span class="gi">+        msg = &quot;{} is deprecated.&quot;.format(func.__name__)</span>
<span class="gi">+</span>
<span class="gi">+        @functools.wraps(func)</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            warn_deprecation(msg)</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(repr(type(reason)))</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/utils/get_unbound_function.py b/graphene/utils/get_unbound_function.py</span>
<span class="gh">index e69de29..4e0b838 100644</span>
<span class="gd">--- a/graphene/utils/get_unbound_function.py</span>
<span class="gi">+++ b/graphene/utils/get_unbound_function.py</span>
<span class="gu">@@ -0,0 +1,9 @@</span>
<span class="gi">+def get_unbound_function(func):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Get the unbound function from a bound method or function.</span>
<span class="gi">+    This is useful when we want to get the original function from a method</span>
<span class="gi">+    that has been bound to a class instance.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if hasattr(func, &quot;__func__&quot;):</span>
<span class="gi">+        return func.__func__</span>
<span class="gi">+    return func</span>
<span class="gh">diff --git a/graphene/utils/module_loading.py b/graphene/utils/module_loading.py</span>
<span class="gh">index fd365ca..89e734c 100644</span>
<span class="gd">--- a/graphene/utils/module_loading.py</span>
<span class="gi">+++ b/graphene/utils/module_loading.py</span>
<span class="gu">@@ -9,4 +9,33 @@ def import_string(dotted_path, dotted_attributes=None):</span>
<span class="w"> </span>    the first step, and return the corresponding value designated by the
<span class="w"> </span>    attribute path. Raise ImportError if the import failed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    try:</span>
<span class="gi">+        module_path, class_name = dotted_path.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+    except ValueError as err:</span>
<span class="gi">+        raise ImportError(&quot;%s doesn&#39;t look like a module path&quot; % dotted_path) from err</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        module = import_module(module_path)</span>
<span class="gi">+    except ImportError as err:</span>
<span class="gi">+        raise ImportError(&#39;Module &quot;%s&quot; does not exist&#39; % module_path) from err</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        attribute = getattr(module, class_name)</span>
<span class="gi">+    except AttributeError as err:</span>
<span class="gi">+        raise ImportError(&#39;Module &quot;%s&quot; does not define a &quot;%s&quot; attribute/class&#39; % (module_path, class_name)) from err</span>
<span class="gi">+</span>
<span class="gi">+    if dotted_attributes:</span>
<span class="gi">+        try:</span>
<span class="gi">+            for attr in dotted_attributes.split(&#39;.&#39;):</span>
<span class="gi">+                attribute = getattr(attribute, attr)</span>
<span class="gi">+        except AttributeError as err:</span>
<span class="gi">+            raise ImportError(&#39;Object &quot;%s&quot; does not have attribute &quot;%s&quot;&#39; % (attribute, dotted_attributes)) from err</span>
<span class="gi">+</span>
<span class="gi">+    return attribute</span>
<span class="gi">+</span>
<span class="gi">+def lazy_import(dotted_path, dotted_attributes=None):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Lazy version of import_string that returns a proxy object that imports the module</span>
<span class="gi">+    only when needed.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    return partial(import_string, dotted_path, dotted_attributes)</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/utils/orderedtype.py b/graphene/utils/orderedtype.py</span>
<span class="gh">index 6776272..76666e0 100644</span>
<span class="gd">--- a/graphene/utils/orderedtype.py</span>
<span class="gi">+++ b/graphene/utils/orderedtype.py</span>
<span class="gu">@@ -7,6 +7,13 @@ class OrderedType:</span>
<span class="w"> </span>    def __init__(self, _creation_counter=None):
<span class="w"> </span>        self.creation_counter = _creation_counter or self.gen_counter()

<span class="gi">+    @classmethod</span>
<span class="gi">+    def gen_counter(cls):</span>
<span class="gi">+        &quot;&quot;&quot;Generate a new counter value.&quot;&quot;&quot;</span>
<span class="gi">+        counter = cls.creation_counter</span>
<span class="gi">+        cls.creation_counter += 1</span>
<span class="gi">+        return counter</span>
<span class="gi">+</span>
<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if isinstance(self, type(other)):
<span class="w"> </span>            return self.creation_counter == other.creation_counter
<span class="gh">diff --git a/graphene/utils/props.py b/graphene/utils/props.py</span>
<span class="gh">index ec56be0..c44e9ed 100644</span>
<span class="gd">--- a/graphene/utils/props.py</span>
<span class="gi">+++ b/graphene/utils/props.py</span>
<span class="gu">@@ -3,4 +3,22 @@ class _OldClass:</span>

<span class="w"> </span>class _NewClass:
<span class="w"> </span>    pass
<span class="gd">-_all_vars = set(dir(_OldClass) + dir(_NewClass))</span>
\ No newline at end of file
<span class="gi">+_all_vars = set(dir(_OldClass) + dir(_NewClass))</span>
<span class="gi">+</span>
<span class="gi">+def props(obj):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Extract all properties from a class or instance.</span>
<span class="gi">+    Properties are attributes that are not in the base class.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(obj, type):</span>
<span class="gi">+        # If obj is a class, get its attributes</span>
<span class="gi">+        attrs = obj.__dict__</span>
<span class="gi">+    else:</span>
<span class="gi">+        # If obj is an instance, get its class&#39;s attributes</span>
<span class="gi">+        attrs = obj.__class__.__dict__</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        key: value</span>
<span class="gi">+        for key, value in attrs.items()</span>
<span class="gi">+        if key not in _all_vars and not key.startswith(&#39;_&#39;)</span>
<span class="gi">+    }</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/utils/resolve_only_args.py b/graphene/utils/resolve_only_args.py</span>
<span class="gh">index 202d774..1133f4a 100644</span>
<span class="gd">--- a/graphene/utils/resolve_only_args.py</span>
<span class="gi">+++ b/graphene/utils/resolve_only_args.py</span>
<span class="gu">@@ -1,2 +1,13 @@</span>
<span class="w"> </span>from functools import wraps
<span class="gd">-from .deprecated import deprecated</span>
\ No newline at end of file
<span class="gi">+from .deprecated import deprecated</span>
<span class="gi">+</span>
<span class="gi">+@deprecated(&#39;resolve_only_args decorator is deprecated. Use normal resolver function instead.&#39;)</span>
<span class="gi">+def resolve_only_args(resolver):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    This function wraps a resolver to only pass root and args,</span>
<span class="gi">+    disregarding info and context (info=None).</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    @wraps(resolver)</span>
<span class="gi">+    def wrapped_resolver(root, info, **args):</span>
<span class="gi">+        return resolver(root, **args)</span>
<span class="gi">+    return wrapped_resolver</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/utils/str_converters.py b/graphene/utils/str_converters.py</span>
<span class="gh">index 7d0e67b..9b581b7 100644</span>
<span class="gd">--- a/graphene/utils/str_converters.py</span>
<span class="gi">+++ b/graphene/utils/str_converters.py</span>
<span class="gu">@@ -1 +1,15 @@</span>
<span class="gd">-import re</span>
\ No newline at end of file
<span class="gi">+import re</span>
<span class="gi">+</span>
<span class="gi">+def to_camel_case(snake_str):</span>
<span class="gi">+    &quot;&quot;&quot;Convert a snake_case string to camelCase.&quot;&quot;&quot;</span>
<span class="gi">+    components = snake_str.split(&#39;_&#39;)</span>
<span class="gi">+    # We capitalize the first letter of each component except the first one</span>
<span class="gi">+    # with the &#39;capitalize&#39; method and join them together.</span>
<span class="gi">+    return components[0] + &#39;&#39;.join(x.capitalize() if x else &#39;_&#39; for x in components[1:])</span>
<span class="gi">+</span>
<span class="gi">+def to_snake_case(camel_str):</span>
<span class="gi">+    &quot;&quot;&quot;Convert a camelCase string to snake_case.&quot;&quot;&quot;</span>
<span class="gi">+    pattern = re.compile(r&#39;(?&lt;!^)(?&lt;!_)([A-Z])&#39;)</span>
<span class="gi">+    # Insert underscore before capital letters (except at start or after underscore)</span>
<span class="gi">+    # and convert to lowercase</span>
<span class="gi">+    return pattern.sub(r&#39;_\1&#39;, camel_str).lower()</span>
\ No newline at end of file
<span class="gh">diff --git a/graphene/utils/subclass_with_meta.py b/graphene/utils/subclass_with_meta.py</span>
<span class="gh">index bde17f5..b08c0d0 100644</span>
<span class="gd">--- a/graphene/utils/subclass_with_meta.py</span>
<span class="gi">+++ b/graphene/utils/subclass_with_meta.py</span>
<span class="gu">@@ -30,7 +30,7 @@ class SubclassWithMeta(metaclass=SubclassWithMeta_Meta):</span>
<span class="w"> </span>        options = dict(meta_options, **_meta_props)
<span class="w"> </span>        abstract = options.pop(&#39;abstract&#39;, False)
<span class="w"> </span>        if abstract:
<span class="gd">-            assert not options, f&#39;Abstract types can only contain the abstract attribute. Received: abstract, {&#39;, &#39;.join(options)}&#39;</span>
<span class="gi">+            assert not options, &#39;Abstract types can only contain the abstract attribute. Received: abstract, &#39; + &#39;, &#39;.join(options)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            super_class = super(cls, cls)
<span class="w"> </span>            if hasattr(super_class, &#39;__init_subclass_with_meta__&#39;):
<span class="gh">diff --git a/graphene/utils/trim_docstring.py b/graphene/utils/trim_docstring.py</span>
<span class="gh">index ea6a197..59591c7 100644</span>
<span class="gd">--- a/graphene/utils/trim_docstring.py</span>
<span class="gi">+++ b/graphene/utils/trim_docstring.py</span>
<span class="gu">@@ -1 +1,30 @@</span>
<span class="gd">-import inspect</span>
\ No newline at end of file
<span class="gi">+import inspect</span>
<span class="gi">+</span>
<span class="gi">+def trim_docstring(docstring):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Trim and clean up docstring indentation and whitespace.</span>
<span class="gi">+    Based on PEP 257&#39;s trim function.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if not docstring:</span>
<span class="gi">+        return None</span>
<span class="gi">+    # Convert tabs to spaces (following the normal Python rules)</span>
<span class="gi">+    # and split into a list of lines:</span>
<span class="gi">+    lines = docstring.expandtabs().splitlines()</span>
<span class="gi">+    # Determine minimum indentation (first line doesn&#39;t count):</span>
<span class="gi">+    indent = float(&#39;inf&#39;)</span>
<span class="gi">+    for line in lines[1:]:</span>
<span class="gi">+        stripped = line.lstrip()</span>
<span class="gi">+        if stripped:</span>
<span class="gi">+            indent = min(indent, len(line) - len(stripped))</span>
<span class="gi">+    # Remove indentation (first line is special):</span>
<span class="gi">+    trimmed = [lines[0].strip()]</span>
<span class="gi">+    if indent &lt; float(&#39;inf&#39;):</span>
<span class="gi">+        for line in lines[1:]:</span>
<span class="gi">+            trimmed.append(line[indent:].rstrip())</span>
<span class="gi">+    # Strip off trailing and leading blank lines:</span>
<span class="gi">+    while trimmed and not trimmed[-1]:</span>
<span class="gi">+        trimmed.pop()</span>
<span class="gi">+    while trimmed and not trimmed[0]:</span>
<span class="gi">+        trimmed.pop(0)</span>
<span class="gi">+    # Return a single string:</span>
<span class="gi">+    return &#39;\n&#39;.join(trimmed)</span>
\ No newline at end of file
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>