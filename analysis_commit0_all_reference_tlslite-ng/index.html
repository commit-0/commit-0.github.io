
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference tlslite ng - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-tlslite-ng" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference tlslite ng
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-unit_tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test unit_tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_tlslite_utils_python_ecdsakeypytestecdsakeytest_sign_and_verify_with_sha384" class="md-nav__link">
    <span class="md-ellipsis">
      test_tlslite_utils_python_ecdsakey.py::TestECDSAKey::test_sign_and_verify_with_sha384
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tlslite_utils_python_ecdsakeypytestecdsakeytest_sign_and_verify_with_sha512" class="md-nav__link">
    <span class="md-ellipsis">
      test_tlslite_utils_python_ecdsakey.py::TestECDSAKey::test_sign_and_verify_with_sha512
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-tlslite-ng"><strong>Reference (Gold)</strong>: tlslite-ng</h1>
<h2 id="pytest-summary-for-test-unit_tests">Pytest Summary for test <code>unit_tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">1653</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">32</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">1687</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">1687</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_tlslite_utils_python_ecdsakeypytestecdsakeytest_sign_and_verify_with_sha384">test_tlslite_utils_python_ecdsakey.py::TestECDSAKey::test_sign_and_verify_with_sha384</h3>
<details><summary> <pre>test_tlslite_utils_python_ecdsakey.py::TestECDSAKey::test_sign_and_verify_with_sha384</pre></summary><pre>
self = <TestCaseFunction test_sign_and_verify_with_sha384>
testcase = <unit_tests.test_tlslite_utils_python_ecdsakey.TestECDSAKey testMethod=test_sign_and_verify_with_sha384>
rawexcinfo = (<class 'ecdsa.keys.BadDigestError'>, BadDigestError('this curve (NIST256p) is too short for the length of your digest (384)'), <traceback object at 0x7efe3900bf00>)
reason = ''

    def addExpectedFailure(
        self,
        testcase: unittest.TestCase,
        rawexcinfo: _SysExcInfoType,
        reason: str = "",
    ) -> None:
        try:
>           xfail(str(reason))
E           _pytest.outcomes.XFailed

.venv/lib/python3.12/site-packages/_pytest/unittest.py:295: XFailed
</pre>
</details>
<h3 id="test_tlslite_utils_python_ecdsakeypytestecdsakeytest_sign_and_verify_with_sha512">test_tlslite_utils_python_ecdsakey.py::TestECDSAKey::test_sign_and_verify_with_sha512</h3>
<details><summary> <pre>test_tlslite_utils_python_ecdsakey.py::TestECDSAKey::test_sign_and_verify_with_sha512</pre></summary><pre>
self = <TestCaseFunction test_sign_and_verify_with_sha512>
testcase = <unit_tests.test_tlslite_utils_python_ecdsakey.TestECDSAKey testMethod=test_sign_and_verify_with_sha512>
rawexcinfo = (<class 'ecdsa.keys.BadDigestError'>, BadDigestError('this curve (NIST256p) is too short for the length of your digest (512)'), <traceback object at 0x7efe39f35340>)
reason = ''

    def addExpectedFailure(
        self,
        testcase: unittest.TestCase,
        rawexcinfo: _SysExcInfoType,
        reason: str = "",
    ) -> None:
        try:
>           xfail(str(reason))
E           _pytest.outcomes.XFailed

.venv/lib/python3.12/site-packages/_pytest/unittest.py:295: XFailed
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/tlslite/api.py b/tlslite/api.py</span>
<span class="gh">index de04c6a..589bdb5 100644</span>
<span class="gd">--- a/tlslite/api.py</span>
<span class="gi">+++ b/tlslite/api.py</span>
<span class="gu">@@ -1,4 +1,13 @@</span>
<span class="gd">-__version__ = &#39;0.8.0-beta1&#39;</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Esteban Sanchez (FosanzDev) - python 3.12 port</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="gi">+__version__ = &quot;0.8.0-beta1&quot;</span>
<span class="gi">+# the whole module is about importing most commonly used methods, for use</span>
<span class="gi">+# by other applications</span>
<span class="gi">+# pylint: disable=unused-import</span>
<span class="w"> </span>from .constants import AlertLevel, AlertDescription, Fault
<span class="w"> </span>from .errors import *
<span class="w"> </span>from .checker import Checker
<span class="gu">@@ -9,22 +18,39 @@ from .tlsconnection import TLSConnection</span>
<span class="w"> </span>from .verifierdb import VerifierDB
<span class="w"> </span>from .x509 import X509
<span class="w"> </span>from .x509certchain import X509CertChain
<span class="gi">+</span>
<span class="w"> </span>from .integration.httptlsconnection import HTTPTLSConnection
<span class="w"> </span>from .integration.tlssocketservermixin import TLSSocketServerMixIn
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    from .integration.tlsasynciodispatchermixin import TLSAsyncioDispatcherMixIn</span>
<span class="gi">+    from .integration.tlsasynciodispatchermixin \</span>
<span class="gi">+        import TLSAsyncioDispatcherMixIn</span>
<span class="gi">+</span>
<span class="w"> </span>except ImportError:
<span class="gi">+    # NOTE: asyncio is not available in base python 2, so this try-except</span>
<span class="gi">+    # block is necessary to avoid breaking the import of the</span>
<span class="gi">+    # rest of the module.</span>
<span class="w"> </span>    pass
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from .integration.tlsasyncdispatchermixin import TLSAsyncDispatcherMixIn
<span class="w"> </span>except ImportError:
<span class="gi">+    # NOTE: Left this try-except block as is, due to the possibility to use</span>
<span class="gi">+    # both asyncore and asyncio in the same project no matter the python</span>
<span class="gi">+    # version (if the asyncore module is available).</span>
<span class="w"> </span>    pass
<span class="gi">+</span>
<span class="w"> </span>from .integration.pop3_tls import POP3_TLS
<span class="w"> </span>from .integration.imap4_tls import IMAP4_TLS
<span class="w"> </span>from .integration.smtp_tls import SMTP_TLS
<span class="w"> </span>from .integration.xmlrpctransport import XMLRPCTransport
<span class="gd">-from .integration.xmlrpcserver import TLSXMLRPCRequestHandler, TLSXMLRPCServer, MultiPathTLSXMLRPCServer</span>
<span class="gd">-from .utils.cryptomath import m2cryptoLoaded, gmpyLoaded, pycryptoLoaded, prngName, GMPY2_LOADED</span>
<span class="gd">-from .utils.keyfactory import generateRSAKey, parsePEMKey, parseAsPublicKey, parsePrivateKey</span>
<span class="gi">+from .integration.xmlrpcserver import TLSXMLRPCRequestHandler, \</span>
<span class="gi">+                                      TLSXMLRPCServer, \</span>
<span class="gi">+                                      MultiPathTLSXMLRPCServer</span>
<span class="gi">+</span>
<span class="gi">+from .utils.cryptomath import m2cryptoLoaded, gmpyLoaded, \</span>
<span class="gi">+                             pycryptoLoaded, prngName, GMPY2_LOADED</span>
<span class="gi">+from .utils.keyfactory import generateRSAKey, parsePEMKey, \</span>
<span class="gi">+                             parseAsPublicKey, parsePrivateKey</span>
<span class="w"> </span>from .utils.tackwrapper import tackpyLoaded
<span class="w"> </span>from .dh import parse as parseDH
<span class="gh">diff --git a/tlslite/basedb.py b/tlslite/basedb.py</span>
<span class="gh">index 2941ed2..427f9d3 100644</span>
<span class="gd">--- a/tlslite/basedb.py</span>
<span class="gi">+++ b/tlslite/basedb.py</span>
<span class="gu">@@ -1,15 +1,21 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Martin von Loewis - python 3 port</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Base class for SharedKeyDB and VerifierDB.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import anydbm
<span class="w"> </span>except ImportError:
<span class="gi">+    # Python 3</span>
<span class="w"> </span>    import dbm as anydbm
<span class="w"> </span>import threading
<span class="w"> </span>import time
<span class="w"> </span>import logging

<span class="gd">-</span>
<span class="w"> </span>class BaseDB(object):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, filename, type):
<span class="w"> </span>        self.type = type
<span class="w"> </span>        self.filename = filename
<span class="gu">@@ -25,7 +31,20 @@ class BaseDB(object):</span>

<span class="w"> </span>        :raises anydbm.error: If there&#39;s a problem creating the database.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger = logging.getLogger(__name__)</span>
<span class="gi">+</span>
<span class="gi">+        if self.filename:</span>
<span class="gi">+            logger.debug(&#39;server %s - create - will open db&#39;, time.time())</span>
<span class="gi">+            self.db = anydbm.open(self.filename, &quot;n&quot;) #raises anydbm.error</span>
<span class="gi">+            logger.debug(&#39;server %s - create - setting type&#39;, time.time())</span>
<span class="gi">+            self.db[&quot;--Reserved--type&quot;] = self.type</span>
<span class="gi">+            logger.debug(&#39;server %s - create - syncing&#39;, time.time())</span>
<span class="gi">+            self.db.sync()</span>
<span class="gi">+            logger.debug(&#39;server %s - create - fun exit&#39;, time.time())</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.debug(&#39;server %s - create - using dict() as DB&#39;,</span>
<span class="gi">+                         time.time())</span>
<span class="gi">+            self.db = {}</span>

<span class="w"> </span>    def open(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -34,22 +53,33 @@ class BaseDB(object):</span>
<span class="w"> </span>        :raises anydbm.error: If there&#39;s a problem opening the database.
<span class="w"> </span>        :raises ValueError: If the database is not of the right type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.filename:</span>
<span class="gi">+            raise ValueError(&quot;Can only open on-disk databases&quot;)</span>
<span class="gi">+        self.db = anydbm.open(self.filename, &quot;w&quot;) #raises anydbm.error</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.db[&quot;--Reserved--type&quot;] != self.type:</span>
<span class="gi">+                raise ValueError(&quot;Not a %s database&quot; % self.type)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise ValueError(&quot;Not a recognized database&quot;)</span>

<span class="w"> </span>    def __getitem__(self, username):
<span class="w"> </span>        if self.db == None:
<span class="gd">-            raise AssertionError(&#39;DB not open&#39;)</span>
<span class="gi">+            raise AssertionError(&quot;DB not open&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.lock.acquire()
<span class="w"> </span>        try:
<span class="w"> </span>            valueStr = self.db[username]
<span class="w"> </span>        finally:
<span class="w"> </span>            self.lock.release()
<span class="gi">+</span>
<span class="w"> </span>        return self._getItem(username, valueStr)

<span class="w"> </span>    def __setitem__(self, username, value):
<span class="w"> </span>        if self.db == None:
<span class="gd">-            raise AssertionError(&#39;DB not open&#39;)</span>
<span class="gi">+            raise AssertionError(&quot;DB not open&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        valueStr = self._setItem(username, value)
<span class="gi">+</span>
<span class="w"> </span>        self.lock.acquire()
<span class="w"> </span>        try:
<span class="w"> </span>            self.db[username] = valueStr
<span class="gu">@@ -60,10 +90,11 @@ class BaseDB(object):</span>

<span class="w"> </span>    def __delitem__(self, username):
<span class="w"> </span>        if self.db == None:
<span class="gd">-            raise AssertionError(&#39;DB not open&#39;)</span>
<span class="gi">+            raise AssertionError(&quot;DB not open&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.lock.acquire()
<span class="w"> </span>        try:
<span class="gd">-            del self.db[username]</span>
<span class="gi">+            del(self.db[username])</span>
<span class="w"> </span>            if self.filename:
<span class="w"> </span>                self.db.sync()
<span class="w"> </span>        finally:
<span class="gu">@@ -80,13 +111,18 @@ class BaseDB(object):</span>
<span class="w"> </span>            otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if self.db == None:
<span class="gd">-            raise AssertionError(&#39;DB not open&#39;)</span>
<span class="gi">+            raise AssertionError(&quot;DB not open&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.lock.acquire()
<span class="w"> </span>        try:
<span class="w"> </span>            return username in self.db
<span class="w"> </span>        finally:
<span class="w"> </span>            self.lock.release()

<span class="gi">+    def check(self, username, param):</span>
<span class="gi">+        value = self.__getitem__(username)</span>
<span class="gi">+        return self._checkItem(value, username, param)</span>
<span class="gi">+</span>
<span class="w"> </span>    def keys(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of usernames in the database.
<span class="gu">@@ -94,4 +130,13 @@ class BaseDB(object):</span>
<span class="w"> </span>        :rtype: list
<span class="w"> </span>        :returns: The usernames in the database.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.db == None:</span>
<span class="gi">+            raise AssertionError(&quot;DB not open&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.lock.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            usernames = self.db.keys()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+        usernames = [u for u in usernames if not u.startswith(&quot;--Reserved--&quot;)]</span>
<span class="gi">+        return usernames</span>
<span class="gh">diff --git a/tlslite/bufferedsocket.py b/tlslite/bufferedsocket.py</span>
<span class="gh">index 8fd2025..e0534f5 100644</span>
<span class="gd">--- a/tlslite/bufferedsocket.py</span>
<span class="gi">+++ b/tlslite/bufferedsocket.py</span>
<span class="gu">@@ -1,4 +1,9 @@</span>
<span class="gi">+# Copyright (c) 2016, Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Wrapper around the socket.socket interface that provides buffering&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import deque


<span class="gu">@@ -24,23 +29,38 @@ class BufferedSocket(object):</span>

<span class="w"> </span>    def send(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Send data to the socket&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.buffer_writes:</span>
<span class="gi">+            self._write_queue.append(data)</span>
<span class="gi">+            return len(data)</span>
<span class="gi">+        return self.socket.send(data)</span>

<span class="w"> </span>    def sendall(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Send data to the socket&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.buffer_writes:</span>
<span class="gi">+            self._write_queue.append(data)</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self.socket.sendall(data)</span>

<span class="w"> </span>    def flush(self):
<span class="w"> </span>        &quot;&quot;&quot;Send all buffered data&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        buf = bytearray()</span>
<span class="gi">+        for i in self._write_queue:</span>
<span class="gi">+            buf += i</span>
<span class="gi">+        self._write_queue.clear()</span>
<span class="gi">+        if buf:</span>
<span class="gi">+            self.socket.sendall(buf)</span>

<span class="w"> </span>    def recv(self, bufsize):
<span class="w"> </span>        &quot;&quot;&quot;Receive data from socket (socket emulation)&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._read_buffer:</span>
<span class="gi">+            self._read_buffer += self.socket.recv(max(4096, bufsize))</span>
<span class="gi">+        ret = self._read_buffer[:bufsize]</span>
<span class="gi">+        del self._read_buffer[:bufsize]</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def getsockname(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the socket&#39;s own address (socket emulation).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.socket.getsockname()</span>

<span class="w"> </span>    def getpeername(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -48,11 +68,11 @@ class BufferedSocket(object):</span>

<span class="w"> </span>        (socket emulation)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.socket.getpeername()</span>

<span class="w"> </span>    def settimeout(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Set a timeout on blocking socket operations (socket emulation).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.socket.settimeout(value)</span>

<span class="w"> </span>    def gettimeout(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -60,16 +80,18 @@ class BufferedSocket(object):</span>

<span class="w"> </span>        (socket emulation)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.socket.gettimeout()</span>

<span class="w"> </span>    def setsockopt(self, level, optname, value):
<span class="w"> </span>        &quot;&quot;&quot;Set the value of the given socket option (socket emulation).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.socket.setsockopt(level, optname, value)</span>

<span class="w"> </span>    def shutdown(self, how):
<span class="w"> </span>        &quot;&quot;&quot;Shutdown the underlying socket.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+        return self.socket.shutdown(how)</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Close the underlying socket.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+        return self.socket.close()</span>
<span class="gh">diff --git a/tlslite/checker.py b/tlslite/checker.py</span>
<span class="gh">index e581507..255c988 100644</span>
<span class="gd">--- a/tlslite/checker.py</span>
<span class="gi">+++ b/tlslite/checker.py</span>
<span class="gu">@@ -1,4 +1,8 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Class for post-handshake certificate checking.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .x509 import X509
<span class="w"> </span>from .x509certchain import X509CertChain
<span class="w"> </span>from .errors import *
<span class="gu">@@ -18,7 +22,9 @@ class Checker(object):</span>
<span class="w"> </span>    Currently, the Checker can check an X.509 chain.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, x509Fingerprint=None, checkResumedSession=False):</span>
<span class="gi">+    def __init__(self,</span>
<span class="gi">+                 x509Fingerprint=None,</span>
<span class="gi">+                 checkResumedSession=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new Checker instance.

<span class="gu">@@ -34,6 +40,7 @@ class Checker(object):</span>
<span class="w"> </span>            session was checked once, we don&#39;t need to bother
<span class="w"> </span>            re-checking it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.x509Fingerprint = x509Fingerprint
<span class="w"> </span>        self.checkResumedSession = checkResumedSession

<span class="gu">@@ -51,18 +58,20 @@ class Checker(object):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if not self.checkResumedSession and connection.resumed:
<span class="w"> </span>            return
<span class="gi">+</span>
<span class="w"> </span>        if self.x509Fingerprint:
<span class="w"> </span>            if connection._client:
<span class="w"> </span>                chain = connection.session.serverCertChain
<span class="w"> </span>            else:
<span class="w"> </span>                chain = connection.session.clientCertChain
<span class="gi">+</span>
<span class="w"> </span>            if self.x509Fingerprint:
<span class="w"> </span>                if isinstance(chain, X509CertChain):
<span class="w"> </span>                    if self.x509Fingerprint:
<span class="w"> </span>                        if chain.getFingerprint() != self.x509Fingerprint:
<span class="gd">-                            raise TLSFingerprintError(</span>
<span class="gd">-                                &#39;X.509 fingerprint mismatch: %s, %s&#39; % (</span>
<span class="gd">-                                chain.getFingerprint(), self.x509Fingerprint))</span>
<span class="gi">+                            raise TLSFingerprintError(\</span>
<span class="gi">+                                &quot;X.509 fingerprint mismatch: %s, %s&quot; % \</span>
<span class="gi">+                                (chain.getFingerprint(), self.x509Fingerprint))</span>
<span class="w"> </span>                elif chain:
<span class="w"> </span>                    raise TLSAuthenticationTypeError()
<span class="w"> </span>                else:
<span class="gh">diff --git a/tlslite/constants.py b/tlslite/constants.py</span>
<span class="gh">index 6ad3e02..dd958c5 100644</span>
<span class="gd">--- a/tlslite/constants.py</span>
<span class="gi">+++ b/tlslite/constants.py</span>
<span class="gu">@@ -1,10 +1,36 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Google - defining ClientCertificateType</span>
<span class="gi">+#   Google (adapted by Sam Rushing) - NPN support</span>
<span class="gi">+#   Dimitris Moraitis - Anon ciphersuites</span>
<span class="gi">+#   Dave Baggett (Arcode Corporation) - canonicalCipherName</span>
<span class="gi">+#   Yngve Pettersen (ported by Paul Sokolovsky) - TLS 1.2</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>from .utils.compat import a2b_hex
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Constants used in various places.&quot;&quot;&quot;
<span class="gd">-TLS_1_3_DRAFT = 3, 4</span>
<span class="gd">-TLS_1_3_HRR = a2b_hex(</span>
<span class="gd">-    &#39;CF21AD74E59A6111BE1D8C021E65B891C2A211167ABB8C5E079E09E2C8A8339C&#39;)</span>
<span class="gd">-TLS_1_1_DOWNGRADE_SENTINEL = a2b_hex(&#39;444F574E47524400&#39;)</span>
<span class="gd">-TLS_1_2_DOWNGRADE_SENTINEL = a2b_hex(&#39;444F574E47524401&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# protocol version number used for negotiating TLS 1.3 between implementations</span>
<span class="gi">+# of the draft specification</span>
<span class="gi">+# DEPRECATED!</span>
<span class="gi">+TLS_1_3_DRAFT = (3, 4)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# ServerHello.random value meaning that the message is a HelloRetryRequest</span>
<span class="gi">+TLS_1_3_HRR = a2b_hex(&quot;CF21AD74E59A6111BE1D8C021E65B891&quot;</span>
<span class="gi">+                      &quot;C2A211167ABB8C5E079E09E2C8A8339C&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# last bytes of ServerHello.random to be used when negotiating TLS 1.1 or</span>
<span class="gi">+# earlier while supporting TLS 1.2 or greater</span>
<span class="gi">+TLS_1_1_DOWNGRADE_SENTINEL = a2b_hex(&quot;444F574E47524400&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# last bytes of ServerHello.random to be used when negotiating TLS 1.2</span>
<span class="gi">+# while supporting TLS 1.3 or greater</span>
<span class="gi">+TLS_1_2_DOWNGRADE_SENTINEL = a2b_hex(&quot;444F574E47524401&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>RSA_PSS_OID = bytes(a2b_hex(&#39;06092a864886f70d01010a&#39;))


<span class="gu">@@ -14,7 +40,11 @@ class TLSEnum(object):</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def _recursiveVars(cls, klass):
<span class="w"> </span>        &quot;&quot;&quot;Call vars recursively on base classes&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fields = dict()</span>
<span class="gi">+        for basecls in klass.__bases__:</span>
<span class="gi">+            fields.update(cls._recursiveVars(basecls))</span>
<span class="gi">+        fields.update(dict(vars(klass)))</span>
<span class="gi">+        return fields</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def toRepr(cls, value, blacklist=None):
<span class="gu">@@ -23,12 +53,23 @@ class TLSEnum(object):</span>

<span class="w"> </span>        name if found, None otherwise
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fields = cls._recursiveVars(cls)</span>
<span class="gi">+        if blacklist is None:</span>
<span class="gi">+            blacklist = []</span>
<span class="gi">+        return next((key for key, val in fields.items() \</span>
<span class="gi">+                    if key not in (&#39;__weakref__&#39;, &#39;__dict__&#39;, &#39;__doc__&#39;,</span>
<span class="gi">+                                   &#39;__module__&#39;) and \</span>
<span class="gi">+                       key not in blacklist and \</span>
<span class="gi">+                        val == value), None)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def toStr(cls, value, blacklist=None):
<span class="w"> </span>        &quot;&quot;&quot;Convert numeric type to human-readable string if possible&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = cls.toRepr(value, blacklist)</span>
<span class="gi">+        if ret is not None:</span>
<span class="gi">+            return ret</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;{0}&#39;.format(value)</span>


<span class="w"> </span>class CertificateType(TLSEnum):
<span class="gu">@@ -41,13 +82,14 @@ class ClientCertificateType(TLSEnum):</span>
<span class="w"> </span>    dss_sign = 2
<span class="w"> </span>    rsa_fixed_dh = 3
<span class="w"> </span>    dss_fixed_dh = 4
<span class="gd">-    ecdsa_sign = 64</span>
<span class="gd">-    rsa_fixed_ecdh = 65</span>
<span class="gd">-    ecdsa_fixed_ecdh = 66</span>
<span class="gi">+    ecdsa_sign = 64  # RFC 8422</span>
<span class="gi">+    rsa_fixed_ecdh = 65  # RFC 8422</span>
<span class="gi">+    ecdsa_fixed_ecdh = 66  # RFC 8422</span>


<span class="w"> </span>class SSL2HandshakeType(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;SSL2 Handshake Protocol message types.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    error = 0
<span class="w"> </span>    client_hello = 1
<span class="w"> </span>    client_master_key = 2
<span class="gu">@@ -61,21 +103,23 @@ class SSL2HandshakeType(TLSEnum):</span>

<span class="w"> </span>class SSL2ErrorDescription(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;SSL2 Handshake protocol error message descriptions&quot;&quot;&quot;
<span class="gd">-    no_cipher = 1</span>
<span class="gd">-    no_certificate = 2</span>
<span class="gd">-    bad_certificate = 4</span>
<span class="gd">-    unsupported_certificate_type = 6</span>
<span class="gi">+</span>
<span class="gi">+    no_cipher = 0x0001</span>
<span class="gi">+    no_certificate = 0x0002</span>
<span class="gi">+    bad_certificate = 0x0004</span>
<span class="gi">+    unsupported_certificate_type = 0x0006</span>


<span class="w"> </span>class HandshakeType(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Message types in TLS Handshake protocol&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    hello_request = 0
<span class="w"> </span>    client_hello = 1
<span class="w"> </span>    server_hello = 2
<span class="w"> </span>    new_session_ticket = 4
<span class="gd">-    end_of_early_data = 5</span>
<span class="gd">-    hello_retry_request = 6</span>
<span class="gd">-    encrypted_extensions = 8</span>
<span class="gi">+    end_of_early_data = 5  # TLS 1.3</span>
<span class="gi">+    hello_retry_request = 6  # TLS 1.3</span>
<span class="gi">+    encrypted_extensions = 8  # TLS 1.3</span>
<span class="w"> </span>    certificate = 11
<span class="w"> </span>    server_key_exchange = 12
<span class="w"> </span>    certificate_request = 13
<span class="gu">@@ -84,59 +128,65 @@ class HandshakeType(TLSEnum):</span>
<span class="w"> </span>    client_key_exchange = 16
<span class="w"> </span>    finished = 20
<span class="w"> </span>    certificate_status = 22
<span class="gd">-    key_update = 24</span>
<span class="gi">+    key_update = 24  # TLS 1.3</span>
<span class="w"> </span>    next_protocol = 67
<span class="gd">-    message_hash = 254</span>
<span class="gi">+    message_hash = 254  # TLS 1.3</span>


<span class="w"> </span>class ContentType(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;TLS record layer content types of payloads&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    change_cipher_spec = 20
<span class="w"> </span>    alert = 21
<span class="w"> </span>    handshake = 22
<span class="w"> </span>    application_data = 23
<span class="gd">-    heartbeat = 24</span>
<span class="gd">-    all = 20, 21, 22, 23, 24</span>
<span class="gi">+    heartbeat = 24  # RFC 6520</span>
<span class="gi">+    all = (20, 21, 22, 23, 24)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def toRepr(cls, value, blacklist=None):
<span class="w"> </span>        &quot;&quot;&quot;Convert numeric type to name representation&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if blacklist is None:</span>
<span class="gi">+            blacklist = []</span>
<span class="gi">+        blacklist.append(&#39;all&#39;)</span>
<span class="gi">+        return super(ContentType, cls).toRepr(value, blacklist)</span>


<span class="w"> </span>class ExtensionType(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;TLS Extension Type registry values&quot;&quot;&quot;
<span class="gd">-    server_name = 0</span>
<span class="gd">-    max_fragment_length = 1</span>
<span class="gd">-    status_request = 5</span>
<span class="gd">-    cert_type = 9</span>
<span class="gd">-    supported_groups = 10</span>
<span class="gd">-    ec_point_formats = 11</span>
<span class="gd">-    srp = 12</span>
<span class="gd">-    signature_algorithms = 13</span>
<span class="gd">-    heartbeat = 15</span>
<span class="gd">-    alpn = 16</span>
<span class="gd">-    client_hello_padding = 21</span>
<span class="gd">-    encrypt_then_mac = 22</span>
<span class="gd">-    extended_master_secret = 23</span>
<span class="gd">-    record_size_limit = 28</span>
<span class="gd">-    session_ticket = 35</span>
<span class="gd">-    extended_random = 40</span>
<span class="gd">-    pre_shared_key = 41</span>
<span class="gd">-    early_data = 42</span>
<span class="gd">-    supported_versions = 43</span>
<span class="gd">-    cookie = 44</span>
<span class="gd">-    psk_key_exchange_modes = 45</span>
<span class="gd">-    post_handshake_auth = 49</span>
<span class="gd">-    signature_algorithms_cert = 50</span>
<span class="gd">-    key_share = 51</span>
<span class="gi">+</span>
<span class="gi">+    server_name = 0  # RFC 6066 / 4366</span>
<span class="gi">+    max_fragment_length = 1  # RFC 6066 / 4366</span>
<span class="gi">+    status_request = 5  # RFC 6066 / 4366</span>
<span class="gi">+    cert_type = 9  # RFC 6091</span>
<span class="gi">+    supported_groups = 10  # RFC 4492, RFC-ietf-tls-negotiated-ff-dhe-10</span>
<span class="gi">+    ec_point_formats = 11  # RFC 4492</span>
<span class="gi">+    srp = 12  # RFC 5054</span>
<span class="gi">+    signature_algorithms = 13  # RFC 5246</span>
<span class="gi">+    heartbeat = 15  # RFC 6520</span>
<span class="gi">+    alpn = 16  # RFC 7301</span>
<span class="gi">+    client_hello_padding = 21  # RFC 7685</span>
<span class="gi">+    encrypt_then_mac = 22  # RFC 7366</span>
<span class="gi">+    extended_master_secret = 23  # RFC 7627</span>
<span class="gi">+    record_size_limit = 28  # RFC 8449</span>
<span class="gi">+    session_ticket = 35 # RFC 5077</span>
<span class="gi">+    extended_random = 40  # draft-rescorla-tls-extended-random-02</span>
<span class="gi">+    pre_shared_key = 41  # TLS 1.3</span>
<span class="gi">+    early_data = 42  # TLS 1.3</span>
<span class="gi">+    supported_versions = 43  # TLS 1.3</span>
<span class="gi">+    cookie = 44  # TLS 1.3</span>
<span class="gi">+    psk_key_exchange_modes = 45  # TLS 1.3</span>
<span class="gi">+    post_handshake_auth = 49  # TLS 1.3</span>
<span class="gi">+    signature_algorithms_cert = 50  # TLS 1.3</span>
<span class="gi">+    key_share = 51  # TLS 1.3</span>
<span class="w"> </span>    supports_npn = 13172
<span class="gd">-    tack = 62208</span>
<span class="gd">-    renegotiation_info = 65281</span>
<span class="gi">+    tack = 0xF300</span>
<span class="gi">+    renegotiation_info = 0xff01  # RFC 5746</span>


<span class="w"> </span>class HashAlgorithm(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Hash algorithm IDs used in TLSv1.2&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    none = 0
<span class="w"> </span>    md5 = 1
<span class="w"> </span>    sha1 = 2
<span class="gu">@@ -144,17 +194,18 @@ class HashAlgorithm(TLSEnum):</span>
<span class="w"> </span>    sha256 = 4
<span class="w"> </span>    sha384 = 5
<span class="w"> </span>    sha512 = 6
<span class="gd">-    intrinsic = 8</span>
<span class="gi">+    intrinsic = 8  # RFC 8422</span>


<span class="w"> </span>class SignatureAlgorithm(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Signing algorithms used in TLSv1.2&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    anonymous = 0
<span class="w"> </span>    rsa = 1
<span class="w"> </span>    dsa = 2
<span class="w"> </span>    ecdsa = 3
<span class="gd">-    ed25519 = 7</span>
<span class="gd">-    ed448 = 8</span>
<span class="gi">+    ed25519 = 7  # RFC 8422</span>
<span class="gi">+    ed448 = 8  # RFC 8422</span>


<span class="w"> </span>class SignatureScheme(TLSEnum):
<span class="gu">@@ -164,37 +215,46 @@ class SignatureScheme(TLSEnum):</span>
<span class="w"> </span>    This is the replacement for the HashAlgorithm and SignatureAlgorithm
<span class="w"> </span>    lists. Introduced with TLSv1.3.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    rsa_pkcs1_sha1 = 2, 1</span>
<span class="gd">-    rsa_pkcs1_sha224 = 3, 1</span>
<span class="gd">-    rsa_pkcs1_sha256 = 4, 1</span>
<span class="gd">-    rsa_pkcs1_sha384 = 5, 1</span>
<span class="gd">-    rsa_pkcs1_sha512 = 6, 1</span>
<span class="gd">-    ecdsa_sha1 = 2, 3</span>
<span class="gd">-    ecdsa_sha224 = 3, 3</span>
<span class="gd">-    ecdsa_secp256r1_sha256 = 4, 3</span>
<span class="gd">-    ecdsa_secp384r1_sha384 = 5, 3</span>
<span class="gd">-    ecdsa_secp521r1_sha512 = 6, 3</span>
<span class="gd">-    rsa_pss_rsae_sha256 = 8, 4</span>
<span class="gd">-    rsa_pss_rsae_sha384 = 8, 5</span>
<span class="gd">-    rsa_pss_rsae_sha512 = 8, 6</span>
<span class="gd">-    ed25519 = 8, 7</span>
<span class="gd">-    ed448 = 8, 8</span>
<span class="gd">-    rsa_pss_pss_sha256 = 8, 9</span>
<span class="gd">-    rsa_pss_pss_sha384 = 8, 10</span>
<span class="gd">-    rsa_pss_pss_sha512 = 8, 11</span>
<span class="gd">-    rsa_pss_sha256 = 8, 4</span>
<span class="gd">-    rsa_pss_sha384 = 8, 5</span>
<span class="gd">-    rsa_pss_sha512 = 8, 6</span>
<span class="gd">-    dsa_sha1 = 2, 2</span>
<span class="gd">-    dsa_sha224 = 3, 2</span>
<span class="gd">-    dsa_sha256 = 4, 2</span>
<span class="gd">-    dsa_sha384 = 5, 2</span>
<span class="gd">-    dsa_sha512 = 6, 2</span>
<span class="gi">+</span>
<span class="gi">+    rsa_pkcs1_sha1 = (2, 1)</span>
<span class="gi">+    rsa_pkcs1_sha224 = (3, 1)</span>
<span class="gi">+    rsa_pkcs1_sha256 = (4, 1)</span>
<span class="gi">+    rsa_pkcs1_sha384 = (5, 1)</span>
<span class="gi">+    rsa_pkcs1_sha512 = (6, 1)</span>
<span class="gi">+    ecdsa_sha1 = (2, 3)</span>
<span class="gi">+    ecdsa_sha224 = (3, 3)</span>
<span class="gi">+    ecdsa_secp256r1_sha256 = (4, 3)</span>
<span class="gi">+    ecdsa_secp384r1_sha384 = (5, 3)</span>
<span class="gi">+    ecdsa_secp521r1_sha512 = (6, 3)</span>
<span class="gi">+    rsa_pss_rsae_sha256 = (8, 4)</span>
<span class="gi">+    rsa_pss_rsae_sha384 = (8, 5)</span>
<span class="gi">+    rsa_pss_rsae_sha512 = (8, 6)</span>
<span class="gi">+    ed25519 = (8, 7)  # RFC 8422</span>
<span class="gi">+    ed448 = (8, 8)  # RFC 8422</span>
<span class="gi">+    rsa_pss_pss_sha256 = (8, 9)</span>
<span class="gi">+    rsa_pss_pss_sha384 = (8, 10)</span>
<span class="gi">+    rsa_pss_pss_sha512 = (8, 11)</span>
<span class="gi">+</span>
<span class="gi">+    # backwards compatibility (for TLS1.2)</span>
<span class="gi">+    rsa_pss_sha256 = (8, 4)</span>
<span class="gi">+    rsa_pss_sha384 = (8, 5)</span>
<span class="gi">+    rsa_pss_sha512 = (8, 6)</span>
<span class="gi">+</span>
<span class="gi">+    dsa_sha1 = (2, 2)</span>
<span class="gi">+    dsa_sha224 = (3, 2)</span>
<span class="gi">+    dsa_sha256 = (4, 2)</span>
<span class="gi">+    dsa_sha384 = (5, 2)</span>
<span class="gi">+    dsa_sha512 = (6, 2)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def toRepr(cls, value, blacklist=None):
<span class="w"> </span>        &quot;&quot;&quot;Convert numeric type to name representation&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if blacklist is None:</span>
<span class="gi">+            blacklist = []</span>
<span class="gi">+        blacklist += [&#39;getKeyType&#39;, &#39;getPadding&#39;, &#39;getHash&#39;,</span>
<span class="gi">+                      &#39;rsa_pss_sha256&#39;, &#39;rsa_pss_sha384&#39;, &#39;rsa_pss_sha512&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        return super(SignatureScheme, cls).toRepr(value, blacklist)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def getKeyType(scheme):
<span class="gu">@@ -203,17 +263,51 @@ class SignatureScheme(TLSEnum):</span>

<span class="w"> </span>        E.g. for &quot;rsa_pkcs1_sha1&quot; it returns &quot;rsa&quot;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if scheme in (&quot;ed25519&quot;, &quot;ed448&quot;):</span>
<span class="gi">+            return &quot;eddsa&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            getattr(SignatureScheme, scheme)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            raise ValueError(&quot;\&quot;{0}\&quot; scheme is unknown&quot;.format(scheme))</span>
<span class="gi">+        vals = scheme.split(&#39;_&#39;, 4)</span>
<span class="gi">+        return vals[0]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def getPadding(scheme):
<span class="w"> </span>        &quot;&quot;&quot;Return the name of padding scheme used in signature scheme.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            getattr(SignatureScheme, scheme)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            raise ValueError(&quot;\&quot;{0}\&quot; scheme is unknown&quot;.format(scheme))</span>
<span class="gi">+        vals = scheme.split(&#39;_&#39;, 4)</span>
<span class="gi">+        assert len(vals) in (3, 4)</span>
<span class="gi">+        if len(vals) == 3:</span>
<span class="gi">+            kType, padding, _ = vals</span>
<span class="gi">+        else:</span>
<span class="gi">+            kType, padding, _, _ = vals</span>
<span class="gi">+        assert kType == &#39;rsa&#39;</span>
<span class="gi">+        return padding</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def getHash(scheme):
<span class="w"> </span>        &quot;&quot;&quot;Return the name of hash used in signature scheme.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # there is no explicit hash in the EDDSA, see RFC 8422</span>
<span class="gi">+        if scheme in (&quot;ed25519&quot;, &quot;ed448&quot;):</span>
<span class="gi">+            return &quot;intrinsic&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            getattr(SignatureScheme, scheme)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            raise ValueError(&quot;\&quot;{0}\&quot; scheme is unknown&quot;.format(scheme))</span>
<span class="gi">+        vals = scheme.split(&#39;_&#39;, 4)</span>
<span class="gi">+        assert len(vals) in (2, 3, 4)</span>
<span class="gi">+        if len(vals) == 2:</span>
<span class="gi">+            kType, hName = vals</span>
<span class="gi">+        elif len(vals) == 3:</span>
<span class="gi">+            kType, _, hName = vals</span>
<span class="gi">+        else:</span>
<span class="gi">+            kType, _, _, hName = vals</span>
<span class="gi">+        assert kType in (&#39;rsa&#39;, &#39;ecdsa&#39;, &#39;dsa&#39;)</span>
<span class="gi">+        return hName</span>


<span class="w"> </span>class AlgorithmOID(TLSEnum):
<span class="gu">@@ -224,49 +318,63 @@ class AlgorithmOID(TLSEnum):</span>
<span class="w"> </span>    the value is the algorithm id.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    oid = {}
<span class="gd">-    oid[bytes(a2b_hex(&#39;06072a8648ce3d0401&#39;))] = SignatureScheme.ecdsa_sha1</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06082a8648ce3d040301&#39;))] = SignatureScheme.ecdsa_sha224</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06082a8648ce3d040302&#39;))</span>
<span class="gd">-        ] = SignatureScheme.ecdsa_secp256r1_sha256</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06082a8648ce3d040303&#39;))</span>
<span class="gd">-        ] = SignatureScheme.ecdsa_secp384r1_sha384</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06082a8648ce3d040304&#39;))</span>
<span class="gd">-        ] = SignatureScheme.ecdsa_secp521r1_sha512</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06092a864886f70d010104&#39;))</span>
<span class="gd">-        ] = HashAlgorithm.md5, SignatureAlgorithm.rsa</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06092a864886f70d010105&#39;))</span>
<span class="gd">-        ] = SignatureScheme.rsa_pkcs1_sha1</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06092a864886f70d01010e&#39;))</span>
<span class="gd">-        ] = SignatureScheme.rsa_pkcs1_sha224</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06092a864886f70d01010b&#39;))</span>
<span class="gd">-        ] = SignatureScheme.rsa_pkcs1_sha256</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06092a864886f70d01010c&#39;))</span>
<span class="gd">-        ] = SignatureScheme.rsa_pkcs1_sha384</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06092a864886f70d01010d&#39;))</span>
<span class="gd">-        ] = SignatureScheme.rsa_pkcs1_sha512</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;300b0609608648016503040201&#39;))</span>
<span class="gd">-        ] = SignatureScheme.rsa_pss_rsae_sha256</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;300b0609608648016503040202&#39;))</span>
<span class="gd">-        ] = SignatureScheme.rsa_pss_rsae_sha384</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;300b0609608648016503040203&#39;))</span>
<span class="gd">-        ] = SignatureScheme.rsa_pss_rsae_sha512</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;300d06096086480165030402010500&#39;))</span>
<span class="gd">-        ] = SignatureScheme.rsa_pss_rsae_sha256</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;300d06096086480165030402020500&#39;))</span>
<span class="gd">-        ] = SignatureScheme.rsa_pss_rsae_sha384</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;300d06096086480165030402030500&#39;))</span>
<span class="gd">-        ] = SignatureScheme.rsa_pss_rsae_sha512</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06072A8648CE380403&#39;))] = SignatureScheme.dsa_sha1</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;0609608648016503040301&#39;))] = SignatureScheme.dsa_sha224</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;0609608648016503040302&#39;))] = SignatureScheme.dsa_sha256</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;0609608648016503040303&#39;))] = SignatureScheme.dsa_sha384</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;0609608648016503040304&#39;))] = SignatureScheme.dsa_sha512</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06032b6570&#39;))] = SignatureScheme.ed25519</span>
<span class="gd">-    oid[bytes(a2b_hex(&#39;06032b6571&#39;))] = SignatureScheme.ed448</span>
<span class="gi">+</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06072a8648ce3d0401&#39;))] = \</span>
<span class="gi">+            SignatureScheme.ecdsa_sha1</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06082a8648ce3d040301&#39;))] = \</span>
<span class="gi">+            SignatureScheme.ecdsa_sha224</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06082a8648ce3d040302&#39;))] = \</span>
<span class="gi">+            SignatureScheme.ecdsa_secp256r1_sha256</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06082a8648ce3d040303&#39;))] = \</span>
<span class="gi">+            SignatureScheme.ecdsa_secp384r1_sha384</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06082a8648ce3d040304&#39;))] = \</span>
<span class="gi">+            SignatureScheme.ecdsa_secp521r1_sha512</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06092a864886f70d010104&#39;))] = \</span>
<span class="gi">+            (HashAlgorithm.md5, SignatureAlgorithm.rsa)</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06092a864886f70d010105&#39;))] = \</span>
<span class="gi">+            SignatureScheme.rsa_pkcs1_sha1</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06092a864886f70d01010e&#39;))] = \</span>
<span class="gi">+            SignatureScheme.rsa_pkcs1_sha224</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06092a864886f70d01010b&#39;))] = \</span>
<span class="gi">+            SignatureScheme.rsa_pkcs1_sha256</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06092a864886f70d01010c&#39;))] = \</span>
<span class="gi">+            SignatureScheme.rsa_pkcs1_sha384</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06092a864886f70d01010d&#39;))] = \</span>
<span class="gi">+            SignatureScheme.rsa_pkcs1_sha512</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;300b0609608648016503040201&#39;))] = \</span>
<span class="gi">+            SignatureScheme.rsa_pss_rsae_sha256</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;300b0609608648016503040202&#39;))] = \</span>
<span class="gi">+            SignatureScheme.rsa_pss_rsae_sha384</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;300b0609608648016503040203&#39;))] = \</span>
<span class="gi">+            SignatureScheme.rsa_pss_rsae_sha512</span>
<span class="gi">+    # for RSA-PSS an AlgorithmIdentifier with and without NULL parameters</span>
<span class="gi">+    # is valid. See RFC 4055 Section 2.1</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;300d06096086480165030402010500&#39;))] = \</span>
<span class="gi">+            SignatureScheme.rsa_pss_rsae_sha256</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;300d06096086480165030402020500&#39;))] = \</span>
<span class="gi">+            SignatureScheme.rsa_pss_rsae_sha384</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;300d06096086480165030402030500&#39;))] = \</span>
<span class="gi">+            SignatureScheme.rsa_pss_rsae_sha512</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06072A8648CE380403&#39;))] = \</span>
<span class="gi">+            SignatureScheme.dsa_sha1</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;0609608648016503040301&#39;))] = \</span>
<span class="gi">+            SignatureScheme.dsa_sha224</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;0609608648016503040302&#39;))] = \</span>
<span class="gi">+            SignatureScheme.dsa_sha256</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;0609608648016503040303&#39;))] = \</span>
<span class="gi">+            SignatureScheme.dsa_sha384</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;0609608648016503040304&#39;))] = \</span>
<span class="gi">+            SignatureScheme.dsa_sha512</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06032b6570&#39;))] = \</span>
<span class="gi">+            SignatureScheme.ed25519</span>
<span class="gi">+    oid[bytes(a2b_hex(&#39;06032b6571&#39;))] = \</span>
<span class="gi">+            SignatureScheme.ed448</span>


<span class="w"> </span>class GroupName(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Name of groups supported for (EC)DH key exchange&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # RFC4492</span>
<span class="w"> </span>    sect163k1 = 1
<span class="w"> </span>    sect163r1 = 2
<span class="w"> </span>    sect163r2 = 3
<span class="gu">@@ -293,46 +401,67 @@ class GroupName(TLSEnum):</span>
<span class="w"> </span>    secp384r1 = 24
<span class="w"> </span>    secp521r1 = 25
<span class="w"> </span>    allEC = list(range(1, 26))
<span class="gi">+</span>
<span class="gi">+    # RFC7027</span>
<span class="w"> </span>    brainpoolP256r1 = 26
<span class="w"> </span>    brainpoolP384r1 = 27
<span class="w"> </span>    brainpoolP512r1 = 28
<span class="w"> </span>    allEC.extend(list(range(26, 29)))
<span class="gi">+</span>
<span class="gi">+    # draft-ietf-tls-rfc4492bis</span>
<span class="w"> </span>    x25519 = 29
<span class="w"> </span>    x448 = 30
<span class="w"> </span>    allEC.extend(list(range(29, 31)))
<span class="gi">+</span>
<span class="gi">+    # RFC7919</span>
<span class="w"> </span>    ffdhe2048 = 256
<span class="w"> </span>    ffdhe3072 = 257
<span class="w"> </span>    ffdhe4096 = 258
<span class="w"> </span>    ffdhe6144 = 259
<span class="w"> </span>    ffdhe8192 = 260
<span class="w"> </span>    allFF = list(range(256, 261))
<span class="gi">+</span>
<span class="w"> </span>    all = allEC + allFF

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def toRepr(cls, value, blacklist=None):
<span class="w"> </span>        &quot;&quot;&quot;Convert numeric type to name representation&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if blacklist is None:</span>
<span class="gi">+            blacklist = []</span>
<span class="gi">+        blacklist += [&#39;all&#39;, &#39;allEC&#39;, &#39;allFF&#39;]</span>
<span class="gi">+        return super(GroupName, cls).toRepr(value, blacklist)</span>


<span class="gd">-TLS_1_3_FORBIDDEN_GROUPS = frozenset().union(range(1, 23), range(26, 29), (</span>
<span class="gd">-    65281, 65282))</span>
<span class="gi">+# groups forbidden by RFC 8446 section B.3.1.4</span>
<span class="gi">+TLS_1_3_FORBIDDEN_GROUPS = frozenset().union(</span>
<span class="gi">+    range(1, 0x17),</span>
<span class="gi">+    range(0x1A, 0x1D),</span>
<span class="gi">+    (0xff01, 0xff02))</span>


<span class="w"> </span>class ECPointFormat(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Names and ID&#39;s of supported EC point formats.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    uncompressed = 0
<span class="w"> </span>    ansiX962_compressed_prime = 1
<span class="w"> </span>    ansiX962_compressed_char2 = 2
<span class="gd">-    all = [uncompressed, ansiX962_compressed_prime, ansiX962_compressed_char2]</span>
<span class="gi">+</span>
<span class="gi">+    all = [uncompressed,</span>
<span class="gi">+           ansiX962_compressed_prime,</span>
<span class="gi">+           ansiX962_compressed_char2]</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def toRepr(cls, value, blacklist=None):
<span class="w"> </span>        &quot;&quot;&quot;Convert numeric type to name representation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if blacklist is None:</span>
<span class="gi">+            blacklist = []</span>
<span class="gi">+        blacklist.append(&#39;all&#39;)</span>
<span class="gi">+        return super(ECPointFormat, cls).toRepr(value, blacklist)</span>


<span class="w"> </span>class ECCurveType(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Types of ECC curves supported in TLS from RFC4492&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    explicit_prime = 1
<span class="w"> </span>    explicit_char2 = 2
<span class="w"> </span>    named_curve = 3
<span class="gu">@@ -340,34 +469,40 @@ class ECCurveType(TLSEnum):</span>

<span class="w"> </span>class NameType(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Type of entries in Server Name Indication extension.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    host_name = 0


<span class="w"> </span>class CertificateStatusType(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Type of responses in the status_request and CertificateStatus msgs.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    ocsp = 1


<span class="w"> </span>class HeartbeatMode(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Types of heartbeat modes from RFC 6520&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    PEER_ALLOWED_TO_SEND = 1
<span class="w"> </span>    PEER_NOT_ALLOWED_TO_SEND = 2


<span class="w"> </span>class HeartbeatMessageType(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Types of heartbeat messages from RFC 6520&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    heartbeat_request = 1
<span class="w"> </span>    heartbeat_response = 2


<span class="w"> </span>class KeyUpdateMessageType(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Types of keyupdate messages from RFC 8446&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    update_not_requested = 0
<span class="w"> </span>    update_requested = 1


<span class="w"> </span>class AlertLevel(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Enumeration of TLS Alert protocol levels&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    warning = 1
<span class="w"> </span>    fatal = 2

<span class="gu">@@ -402,6 +537,7 @@ class AlertDescription(TLSEnum):</span>

<span class="w"> </span>    :cvar user_canceled: The handshake is being cancelled for some reason.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    close_notify = 0
<span class="w"> </span>    unexpected_message = 10
<span class="w"> </span>    bad_record_mac = 20
<span class="gu">@@ -409,7 +545,7 @@ class AlertDescription(TLSEnum):</span>
<span class="w"> </span>    record_overflow = 22
<span class="w"> </span>    decompression_failure = 30
<span class="w"> </span>    handshake_failure = 40
<span class="gd">-    no_certificate = 41</span>
<span class="gi">+    no_certificate = 41 #SSLv3</span>
<span class="w"> </span>    bad_certificate = 42
<span class="w"> </span>    unsupported_certificate = 43
<span class="w"> </span>    certificate_revoked = 44
<span class="gu">@@ -428,23 +564,25 @@ class AlertDescription(TLSEnum):</span>
<span class="w"> </span>    user_canceled = 90
<span class="w"> </span>    no_renegotiation = 100
<span class="w"> </span>    missing_extension = 109
<span class="gd">-    unsupported_extension = 110</span>
<span class="gd">-    certificate_unobtainable = 111</span>
<span class="gd">-    unrecognized_name = 112</span>
<span class="gd">-    bad_certificate_status_response = 113</span>
<span class="gd">-    bad_certificate_hash_value = 114</span>
<span class="gi">+    unsupported_extension = 110  # RFC 5246</span>
<span class="gi">+    certificate_unobtainable = 111  # RFC 6066</span>
<span class="gi">+    unrecognized_name = 112  # RFC 6066</span>
<span class="gi">+    bad_certificate_status_response = 113  # RFC 6066</span>
<span class="gi">+    bad_certificate_hash_value = 114  # RFC 6066</span>
<span class="w"> </span>    unknown_psk_identity = 115
<span class="gd">-    certificate_required = 116</span>
<span class="gd">-    no_application_protocol = 120</span>
<span class="gi">+    certificate_required = 116  # RFC 8446</span>
<span class="gi">+    no_application_protocol = 120  # RFC 7301</span>


<span class="w"> </span>class PskKeyExchangeMode(TLSEnum):
<span class="w"> </span>    &quot;&quot;&quot;Values used in the PSK Key Exchange Modes extension.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    psk_ke = 0
<span class="w"> </span>    psk_dhe_ke = 1


<span class="w"> </span>class CipherSuite:
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Numeric values of ciphersuites and ciphersuite types

<span class="gu">@@ -475,277 +613,356 @@ class CipherSuite:</span>
<span class="w"> </span>        Diffie-Hellman key exchange
<span class="w"> </span>    :cvar ietfNames: dictionary with string names of the ciphersuites
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    ietfNames = {}
<span class="gd">-    SSL_CK_RC4_128_WITH_MD5 = 65664</span>
<span class="gd">-    ietfNames[65664] = &#39;SSL_CK_RC4_128_WITH_MD5&#39;</span>
<span class="gd">-    SSL_CK_RC4_128_EXPORT40_WITH_MD5 = 131200</span>
<span class="gd">-    ietfNames[131200] = &#39;SSL_CK_RC4_128_EXPORT40_WITH_MD5&#39;</span>
<span class="gd">-    SSL_CK_RC2_128_CBC_WITH_MD5 = 196736</span>
<span class="gd">-    ietfNames[196736] = &#39;SSL_CK_RC2_128_CBC_WITH_MD5&#39;</span>
<span class="gd">-    SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5 = 262272</span>
<span class="gd">-    ietfNames[262272] = &#39;SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5&#39;</span>
<span class="gd">-    SSL_CK_IDEA_128_CBC_WITH_MD5 = 327808</span>
<span class="gd">-    ietfNames[327808] = &#39;SSL_CK_IDEA_128_CBC_WITH_MD5&#39;</span>
<span class="gd">-    SSL_CK_DES_64_CBC_WITH_MD5 = 393280</span>
<span class="gd">-    ietfNames[393280] = &#39;SSL_CK_DES_64_CBC_WITH_MD5&#39;</span>
<span class="gd">-    SSL_CK_DES_192_EDE3_CBC_WITH_MD5 = 458944</span>
<span class="gd">-    ietfNames[458944] = &#39;SSL_CK_DES_192_EDE3_CBC_WITH_MD5&#39;</span>
<span class="gi">+</span>
<span class="gi">+# the ciphesuite names come from IETF, we want to keep them</span>
<span class="gi">+#pylint: disable = invalid-name</span>
<span class="gi">+</span>
<span class="gi">+    # SSLv2 from draft-hickman-netscape-ssl-00.txt</span>
<span class="gi">+    SSL_CK_RC4_128_WITH_MD5 = 0x010080</span>
<span class="gi">+    ietfNames[0x010080] = &#39;SSL_CK_RC4_128_WITH_MD5&#39;</span>
<span class="gi">+    SSL_CK_RC4_128_EXPORT40_WITH_MD5 = 0x020080</span>
<span class="gi">+    ietfNames[0x020080] = &#39;SSL_CK_RC4_128_EXPORT40_WITH_MD5&#39;</span>
<span class="gi">+    SSL_CK_RC2_128_CBC_WITH_MD5 = 0x030080</span>
<span class="gi">+    ietfNames[0x030080] = &#39;SSL_CK_RC2_128_CBC_WITH_MD5&#39;</span>
<span class="gi">+    SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5 = 0x040080</span>
<span class="gi">+    ietfNames[0x040080] = &#39;SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5&#39;</span>
<span class="gi">+    SSL_CK_IDEA_128_CBC_WITH_MD5 = 0x050080</span>
<span class="gi">+    ietfNames[0x050080] = &#39;SSL_CK_IDEA_128_CBC_WITH_MD5&#39;</span>
<span class="gi">+    SSL_CK_DES_64_CBC_WITH_MD5 = 0x060040</span>
<span class="gi">+    ietfNames[0x060040] = &#39;SSL_CK_DES_64_CBC_WITH_MD5&#39;</span>
<span class="gi">+    SSL_CK_DES_192_EDE3_CBC_WITH_MD5 = 0x0700C0</span>
<span class="gi">+    ietfNames[0x0700C0] = &#39;SSL_CK_DES_192_EDE3_CBC_WITH_MD5&#39;</span>
<span class="gi">+</span>
<span class="gi">+    #: SSL2 ciphersuites which use RC4 symmetric cipher</span>
<span class="w"> </span>    ssl2rc4 = []
<span class="w"> </span>    ssl2rc4.append(SSL_CK_RC4_128_WITH_MD5)
<span class="w"> </span>    ssl2rc4.append(SSL_CK_RC4_128_EXPORT40_WITH_MD5)
<span class="gi">+</span>
<span class="gi">+    #: SSL2 ciphersuites which use RC2 symmetric cipher</span>
<span class="w"> </span>    ssl2rc2 = []
<span class="w"> </span>    ssl2rc2.append(SSL_CK_RC2_128_CBC_WITH_MD5)
<span class="w"> </span>    ssl2rc2.append(SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5)
<span class="gi">+</span>
<span class="gi">+    #: SSL2 ciphersuites which use IDEA symmetric cipher</span>
<span class="w"> </span>    ssl2idea = [SSL_CK_IDEA_128_CBC_WITH_MD5]
<span class="gi">+</span>
<span class="gi">+    #: SSL2 ciphersuites which use (single) DES symmetric cipher</span>
<span class="w"> </span>    ssl2des = [SSL_CK_DES_64_CBC_WITH_MD5]
<span class="gi">+</span>
<span class="gi">+    #: SSL2 ciphersuites which use 3DES symmetric cipher</span>
<span class="w"> </span>    ssl2_3des = [SSL_CK_DES_192_EDE3_CBC_WITH_MD5]
<span class="gi">+</span>
<span class="gi">+    #: SSL2 ciphersuites which encrypt only part (40 bits) of the key</span>
<span class="w"> </span>    ssl2export = []
<span class="w"> </span>    ssl2export.append(SSL_CK_RC4_128_EXPORT40_WITH_MD5)
<span class="w"> </span>    ssl2export.append(SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5)
<span class="gi">+</span>
<span class="gi">+    #: SSL2 ciphersuties which use 128 bit key</span>
<span class="w"> </span>    ssl2_128Key = []
<span class="w"> </span>    ssl2_128Key.append(SSL_CK_RC4_128_WITH_MD5)
<span class="w"> </span>    ssl2_128Key.append(SSL_CK_RC4_128_EXPORT40_WITH_MD5)
<span class="w"> </span>    ssl2_128Key.append(SSL_CK_RC2_128_CBC_WITH_MD5)
<span class="w"> </span>    ssl2_128Key.append(SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5)
<span class="w"> </span>    ssl2_128Key.append(SSL_CK_IDEA_128_CBC_WITH_MD5)
<span class="gi">+</span>
<span class="gi">+    #: SSL2 ciphersuites which use 64 bit key</span>
<span class="w"> </span>    ssl2_64Key = [SSL_CK_DES_64_CBC_WITH_MD5]
<span class="gi">+</span>
<span class="gi">+    #: SSL2 ciphersuites which use 192 bit key</span>
<span class="w"> </span>    ssl2_192Key = [SSL_CK_DES_192_EDE3_CBC_WITH_MD5]
<span class="gd">-    TLS_RSA_WITH_NULL_MD5 = 1</span>
<span class="gd">-    ietfNames[1] = &#39;TLS_RSA_WITH_NULL_MD5&#39;</span>
<span class="gd">-    TLS_RSA_WITH_NULL_SHA = 2</span>
<span class="gd">-    ietfNames[2] = &#39;TLS_RSA_WITH_NULL_SHA&#39;</span>
<span class="gd">-    TLS_RSA_WITH_RC4_128_MD5 = 4</span>
<span class="gd">-    ietfNames[4] = &#39;TLS_RSA_WITH_RC4_128_MD5&#39;</span>
<span class="gd">-    TLS_RSA_WITH_RC4_128_SHA = 5</span>
<span class="gd">-    ietfNames[5] = &#39;TLS_RSA_WITH_RC4_128_SHA&#39;</span>
<span class="gd">-    TLS_RSA_WITH_3DES_EDE_CBC_SHA = 10</span>
<span class="gd">-    ietfNames[10] = &#39;TLS_RSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 13</span>
<span class="gd">-    ietfNames[13] = &#39;TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 19</span>
<span class="gd">-    ietfNames[19] = &#39;TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 22</span>
<span class="gd">-    ietfNames[22] = &#39;TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DH_ANON_WITH_RC4_128_MD5 = 24</span>
<span class="gd">-    ietfNames[24] = &#39;TLS_DH_ANON_WITH_RC4_128_MD5&#39;</span>
<span class="gd">-    TLS_DH_ANON_WITH_3DES_EDE_CBC_SHA = 27</span>
<span class="gd">-    ietfNames[27] = &#39;TLS_DH_ANON_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_RSA_WITH_AES_128_CBC_SHA = 47</span>
<span class="gd">-    ietfNames[47] = &#39;TLS_RSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DH_DSS_WITH_AES_128_CBC_SHA = 48</span>
<span class="gd">-    ietfNames[48] = &#39;TLS_DH_DSS_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 50</span>
<span class="gd">-    ietfNames[50] = &#39;TLS_DHE_DSS_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 51</span>
<span class="gd">-    ietfNames[51] = &#39;TLS_DHE_RSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DH_ANON_WITH_AES_128_CBC_SHA = 52</span>
<span class="gd">-    ietfNames[52] = &#39;TLS_DH_ANON_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_RSA_WITH_AES_256_CBC_SHA = 53</span>
<span class="gd">-    ietfNames[53] = &#39;TLS_RSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DH_DSS_WITH_AES_256_CBC_SHA = 54</span>
<span class="gd">-    ietfNames[54] = &#39;TLS_DH_DSS_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 56</span>
<span class="gd">-    ietfNames[56] = &#39;TLS_DHE_DSS_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 57</span>
<span class="gd">-    ietfNames[57] = &#39;TLS_DHE_RSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_DH_ANON_WITH_AES_256_CBC_SHA = 58</span>
<span class="gd">-    ietfNames[58] = &#39;TLS_DH_ANON_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_RSA_WITH_NULL_SHA256 = 59</span>
<span class="gd">-    ietfNames[59] = &#39;TLS_RSA_WITH_NULL_SHA256&#39;</span>
<span class="gd">-    TLS_RSA_WITH_AES_128_CBC_SHA256 = 60</span>
<span class="gd">-    ietfNames[60] = &#39;TLS_RSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_RSA_WITH_AES_256_CBC_SHA256 = 61</span>
<span class="gd">-    ietfNames[61] = &#39;TLS_RSA_WITH_AES_256_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = 62</span>
<span class="gd">-    ietfNames[62] = &#39;TLS_DH_DSS_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = 64</span>
<span class="gd">-    ietfNames[64] = &#39;TLS_DHE_DSS_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 103</span>
<span class="gd">-    ietfNames[103] = &#39;TLS_DHE_RSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = 104</span>
<span class="gd">-    ietfNames[104] = &#39;TLS_DH_DSS_WITH_AES_256_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = 106</span>
<span class="gd">-    ietfNames[106] = &#39;TLS_DHE_DSS_WITH_AES_256_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 107</span>
<span class="gd">-    ietfNames[107] = &#39;TLS_DHE_RSA_WITH_AES_256_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_DH_ANON_WITH_AES_128_CBC_SHA256 = 108</span>
<span class="gd">-    ietfNames[108] = &#39;TLS_DH_ANON_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_DH_ANON_WITH_AES_256_CBC_SHA256 = 109</span>
<span class="gd">-    ietfNames[109] = &#39;TLS_DH_ANON_WITH_AES_256_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_RSA_WITH_AES_128_GCM_SHA256 = 156</span>
<span class="gd">-    ietfNames[156] = &#39;TLS_RSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gd">-    TLS_RSA_WITH_AES_256_GCM_SHA384 = 157</span>
<span class="gd">-    ietfNames[157] = &#39;TLS_RSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = 158</span>
<span class="gd">-    ietfNames[158] = &#39;TLS_DHE_RSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = 159</span>
<span class="gd">-    ietfNames[159] = &#39;TLS_DHE_RSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gd">-    TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = 162</span>
<span class="gd">-    ietfNames[162] = &#39;TLS_DHE_DSS_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gd">-    TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = 163</span>
<span class="gd">-    ietfNames[163] = &#39;TLS_DHE_DSS_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gd">-    TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = 164</span>
<span class="gd">-    ietfNames[164] = &#39;TLS_DH_DSS_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gd">-    TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = 165</span>
<span class="gd">-    ietfNames[165] = &#39;TLS_DH_DSS_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gd">-    TLS_DH_ANON_WITH_AES_128_GCM_SHA256 = 166</span>
<span class="gd">-    ietfNames[166] = &#39;TLS_DH_ANON_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gd">-    TLS_DH_ANON_WITH_AES_256_GCM_SHA384 = 167</span>
<span class="gd">-    ietfNames[167] = &#39;TLS_DH_ANON_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gd">-    TLS_RSA_WITH_AES_128_CCM = 49308</span>
<span class="gd">-    ietfNames[49308] = &#39;TLS_RSA_WITH_AES_128_CCM&#39;</span>
<span class="gd">-    TLS_RSA_WITH_AES_256_CCM = 49309</span>
<span class="gd">-    ietfNames[49309] = &#39;TLS_RSA_WITH_AES_256_CCM&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_AES_128_CCM = 49310</span>
<span class="gd">-    ietfNames[49310] = &#39;TLS_DHE_RSA_WITH_AES_128_CCM&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_AES_256_CCM = 49311</span>
<span class="gd">-    ietfNames[49311] = &#39;TLS_DHE_RSA_WITH_AES_256_CCM&#39;</span>
<span class="gd">-    TLS_RSA_WITH_AES_128_CCM_8 = 49312</span>
<span class="gd">-    ietfNames[49312] = &#39;TLS_RSA_WITH_AES_128_CCM_8&#39;</span>
<span class="gd">-    TLS_RSA_WITH_AES_256_CCM_8 = 49313</span>
<span class="gd">-    ietfNames[49313] = &#39;TLS_RSA_WITH_AES_256_CCM_8&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_AES_128_CCM_8 = 49314</span>
<span class="gd">-    ietfNames[49314] = &#39;TLS_DHE_RSA_WITH_AES_128_CCM_8&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_AES_256_CCM_8 = 49315</span>
<span class="gd">-    ietfNames[49315] = &#39;TLS_DHE_RSA_WITH_AES_256_CCM_8&#39;</span>
<span class="gd">-    TLS_EMPTY_RENEGOTIATION_INFO_SCSV = 255</span>
<span class="gd">-    ietfNames[255] = &#39;TLS_EMPTY_RENEGOTIATION_INFO_SCSV&#39;</span>
<span class="gd">-    TLS_AES_128_GCM_SHA256 = 4865</span>
<span class="gd">-    ietfNames[4865] = &#39;TLS_AES_128_GCM_SHA256&#39;</span>
<span class="gd">-    TLS_AES_256_GCM_SHA384 = 4866</span>
<span class="gd">-    ietfNames[4866] = &#39;TLS_AES_256_GCM_SHA384&#39;</span>
<span class="gd">-    TLS_CHACHA20_POLY1305_SHA256 = 4867</span>
<span class="gd">-    ietfNames[4867] = &#39;TLS_CHACHA20_POLY1305_SHA256&#39;</span>
<span class="gd">-    TLS_AES_128_CCM_SHA256 = 4868</span>
<span class="gd">-    ietfNames[4868] = &#39;TLS_AES_128_CCM_SHA256&#39;</span>
<span class="gd">-    TLS_AES_128_CCM_8_SHA256 = 4869</span>
<span class="gd">-    ietfNames[4869] = &#39;TLS_AES_128_CCM_8_SHA256&#39;</span>
<span class="gd">-    TLS_FALLBACK_SCSV = 22016</span>
<span class="gd">-    ietfNames[22016] = &#39;TLS_FALLBACK_SCSV&#39;</span>
<span class="gd">-    TLS_ECDH_ECDSA_WITH_NULL_SHA = 49153</span>
<span class="gd">-    ietfNames[49153] = &#39;TLS_ECDH_ECDSA_WITH_NULL_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_ECDSA_WITH_RC4_128_SHA = 49154</span>
<span class="gd">-    ietfNames[49154] = &#39;TLS_ECDH_ECDSA_WITH_RC4_128_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 49155</span>
<span class="gd">-    ietfNames[49155] = &#39;TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 49156</span>
<span class="gd">-    ietfNames[49156] = &#39;TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 49157</span>
<span class="gd">-    ietfNames[49157] = &#39;TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_NULL_SHA = 49158</span>
<span class="gd">-    ietfNames[49158] = &#39;TLS_ECDHE_ECDSA_WITH_NULL_SHA&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = 49159</span>
<span class="gd">-    ietfNames[49159] = &#39;TLS_ECDHE_ECDSA_WITH_RC4_128_SHA&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 49160</span>
<span class="gd">-    ietfNames[49160] = &#39;TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 49161</span>
<span class="gd">-    ietfNames[49161] = &#39;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 49162</span>
<span class="gd">-    ietfNames[49162] = &#39;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_RSA_WITH_NULL_SHA = 49163</span>
<span class="gd">-    ietfNames[49163] = &#39;TLS_ECDH_RSA_WITH_NULL_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_RSA_WITH_RC4_128_SHA = 49164</span>
<span class="gd">-    ietfNames[49164] = &#39;TLS_ECDH_RSA_WITH_RC4_128_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = 49165</span>
<span class="gd">-    ietfNames[49165] = &#39;TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 49166</span>
<span class="gd">-    ietfNames[49166] = &#39;TLS_ECDH_RSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 49167</span>
<span class="gd">-    ietfNames[49167] = &#39;TLS_ECDH_RSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDHE_RSA_WITH_NULL_SHA = 49168</span>
<span class="gd">-    ietfNames[49168] = &#39;TLS_ECDHE_RSA_WITH_NULL_SHA&#39;</span>
<span class="gd">-    TLS_ECDHE_RSA_WITH_RC4_128_SHA = 49169</span>
<span class="gd">-    ietfNames[49169] = &#39;TLS_ECDHE_RSA_WITH_RC4_128_SHA&#39;</span>
<span class="gd">-    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = 49170</span>
<span class="gd">-    ietfNames[49170] = &#39;TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 49171</span>
<span class="gd">-    ietfNames[49171] = &#39;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 49172</span>
<span class="gd">-    ietfNames[49172] = &#39;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_ANON_WITH_NULL_SHA = 49173</span>
<span class="gd">-    ietfNames[49173] = &#39;TLS_ECDH_ANON_WITH_NULL_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_ANON_WITH_RC4_128_SHA = 49174</span>
<span class="gd">-    ietfNames[49174] = &#39;TLS_ECDH_ANON_WITH_RC4_128_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_ANON_WITH_3DES_EDE_CBC_SHA = 49175</span>
<span class="gd">-    ietfNames[49175] = &#39;TLS_ECDH_ANON_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_ANON_WITH_AES_128_CBC_SHA = 49176</span>
<span class="gd">-    ietfNames[49176] = &#39;TLS_ECDH_ANON_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDH_ANON_WITH_AES_256_CBC_SHA = 49177</span>
<span class="gd">-    ietfNames[49177] = &#39;TLS_ECDH_ANON_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = 49178</span>
<span class="gd">-    ietfNames[49178] = &#39;TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = 49179</span>
<span class="gd">-    ietfNames[49179] = &#39;TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = 49180</span>
<span class="gd">-    ietfNames[49180] = &#39;TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gd">-    TLS_SRP_SHA_WITH_AES_128_CBC_SHA = 49181</span>
<span class="gd">-    ietfNames[49181] = &#39;TLS_SRP_SHA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = 49182</span>
<span class="gd">-    ietfNames[49182] = &#39;TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = 49183</span>
<span class="gd">-    ietfNames[49183] = &#39;TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gd">-    TLS_SRP_SHA_WITH_AES_256_CBC_SHA = 49184</span>
<span class="gd">-    ietfNames[49184] = &#39;TLS_SRP_SHA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = 49185</span>
<span class="gd">-    ietfNames[49185] = &#39;TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = 49186</span>
<span class="gd">-    ietfNames[49186] = &#39;TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 49187</span>
<span class="gd">-    ietfNames[49187] = &#39;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 49188</span>
<span class="gd">-    ietfNames[49188] = &#39;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384&#39;</span>
<span class="gd">-    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 49189</span>
<span class="gd">-    ietfNames[49189] = &#39;TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 49190</span>
<span class="gd">-    ietfNames[49190] = &#39;TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384&#39;</span>
<span class="gd">-    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 49191</span>
<span class="gd">-    ietfNames[49191] = &#39;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 49192</span>
<span class="gd">-    ietfNames[49192] = &#39;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384&#39;</span>
<span class="gd">-    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 49193</span>
<span class="gd">-    ietfNames[49193] = &#39;TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gd">-    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 49194</span>
<span class="gd">-    ietfNames[49194] = &#39;TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 49195</span>
<span class="gd">-    ietfNames[49195] = &#39;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 49196</span>
<span class="gd">-    ietfNames[49196] = &#39;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gd">-    TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 49197</span>
<span class="gd">-    ietfNames[49197] = &#39;TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gd">-    TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 49198</span>
<span class="gd">-    ietfNames[49198] = &#39;TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gd">-    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 49199</span>
<span class="gd">-    ietfNames[49199] = &#39;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gd">-    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 49200</span>
<span class="gd">-    ietfNames[49200] = &#39;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gd">-    TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 49201</span>
<span class="gd">-    ietfNames[49201] = &#39;TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gd">-    TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 49202</span>
<span class="gd">-    ietfNames[49202] = &#39;TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gd">-    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_draft_00 = 52385</span>
<span class="gd">-    ietfNames[52385] = &#39;TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_draft_00&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_draft_00 = 52386</span>
<span class="gd">-    ietfNames[52386] = &#39;TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_draft_00&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_CHACHA20_POLY1305_draft_00 = 52387</span>
<span class="gd">-    ietfNames[52387] = &#39;TLS_DHE_RSA_WITH_CHACHA20_POLY1305_draft_00&#39;</span>
<span class="gd">-    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 52392</span>
<span class="gd">-    ietfNames[52392] = &#39;TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 52393</span>
<span class="gd">-    ietfNames[52393] = &#39;TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256&#39;</span>
<span class="gd">-    TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 52394</span>
<span class="gd">-    ietfNames[52394] = &#39;TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_AES_128_CCM = 49324</span>
<span class="gd">-    ietfNames[49324] = &#39;TLS_ECDHE_ECDSA_WITH_AES_128_CCM&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_AES_256_CCM = 49325</span>
<span class="gd">-    ietfNames[49325] = &#39;TLS_ECDHE_ECDSA_WITH_AES_256_CCM&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = 49326</span>
<span class="gd">-    ietfNames[49326] = &#39;TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8&#39;</span>
<span class="gd">-    TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = 49327</span>
<span class="gd">-    ietfNames[49327] = &#39;TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8&#39;</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # SSLv3 and TLS cipher suite definitions</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 5246 - TLS v1.2 Protocol</span>
<span class="gi">+    TLS_RSA_WITH_NULL_MD5 = 0x0001</span>
<span class="gi">+    ietfNames[0x0001] = &#39;TLS_RSA_WITH_NULL_MD5&#39;</span>
<span class="gi">+    TLS_RSA_WITH_NULL_SHA = 0x0002</span>
<span class="gi">+    ietfNames[0x0002] = &#39;TLS_RSA_WITH_NULL_SHA&#39;</span>
<span class="gi">+    TLS_RSA_WITH_RC4_128_MD5 = 0x0004</span>
<span class="gi">+    ietfNames[0x0004] = &#39;TLS_RSA_WITH_RC4_128_MD5&#39;</span>
<span class="gi">+    TLS_RSA_WITH_RC4_128_SHA = 0x0005</span>
<span class="gi">+    ietfNames[0x0005] = &#39;TLS_RSA_WITH_RC4_128_SHA&#39;</span>
<span class="gi">+    TLS_RSA_WITH_3DES_EDE_CBC_SHA = 0x000A</span>
<span class="gi">+    ietfNames[0x000A] = &#39;TLS_RSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 0x000D</span>
<span class="gi">+    ietfNames[0x000D] = &#39;TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 0x0013</span>
<span class="gi">+    ietfNames[0x0013] = &#39;TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 0x0016</span>
<span class="gi">+    ietfNames[0x0016] = &#39;TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DH_ANON_WITH_RC4_128_MD5 = 0x0018</span>
<span class="gi">+    ietfNames[0x0018] = &#39;TLS_DH_ANON_WITH_RC4_128_MD5&#39;</span>
<span class="gi">+    TLS_DH_ANON_WITH_3DES_EDE_CBC_SHA = 0x001B</span>
<span class="gi">+    ietfNames[0x001B] = &#39;TLS_DH_ANON_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_RSA_WITH_AES_128_CBC_SHA = 0x002F</span>
<span class="gi">+    ietfNames[0x002F] = &#39;TLS_RSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DH_DSS_WITH_AES_128_CBC_SHA = 0x0030</span>
<span class="gi">+    ietfNames[0x0030] = &#39;TLS_DH_DSS_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 0x0032</span>
<span class="gi">+    ietfNames[0x0032] = &#39;TLS_DHE_DSS_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 0x0033</span>
<span class="gi">+    ietfNames[0x0033] = &#39;TLS_DHE_RSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DH_ANON_WITH_AES_128_CBC_SHA = 0x0034</span>
<span class="gi">+    ietfNames[0x0034] = &#39;TLS_DH_ANON_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_RSA_WITH_AES_256_CBC_SHA = 0x0035</span>
<span class="gi">+    ietfNames[0x0035] = &#39;TLS_RSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DH_DSS_WITH_AES_256_CBC_SHA = 0x0036</span>
<span class="gi">+    ietfNames[0x0036] = &#39;TLS_DH_DSS_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 0x0038</span>
<span class="gi">+    ietfNames[0x0038] = &#39;TLS_DHE_DSS_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 0x0039</span>
<span class="gi">+    ietfNames[0x0039] = &#39;TLS_DHE_RSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+    TLS_DH_ANON_WITH_AES_256_CBC_SHA = 0x003A</span>
<span class="gi">+    ietfNames[0x003A] = &#39;TLS_DH_ANON_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+    TLS_RSA_WITH_NULL_SHA256 = 0x003B</span>
<span class="gi">+    ietfNames[0x003B] = &#39;TLS_RSA_WITH_NULL_SHA256&#39;</span>
<span class="gi">+    TLS_RSA_WITH_AES_128_CBC_SHA256 = 0x003C</span>
<span class="gi">+    ietfNames[0x003C] = &#39;TLS_RSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_RSA_WITH_AES_256_CBC_SHA256 = 0x003D</span>
<span class="gi">+    ietfNames[0x003D] = &#39;TLS_RSA_WITH_AES_256_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = 0x003E</span>
<span class="gi">+    ietfNames[0x003E] = &#39;TLS_DH_DSS_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = 0x0040</span>
<span class="gi">+    ietfNames[0x0040] = &#39;TLS_DHE_DSS_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 0x0067</span>
<span class="gi">+    ietfNames[0x0067] = &#39;TLS_DHE_RSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = 0x0068</span>
<span class="gi">+    ietfNames[0x0068] = &#39;TLS_DH_DSS_WITH_AES_256_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = 0x006A</span>
<span class="gi">+    ietfNames[0x006A] = &#39;TLS_DHE_DSS_WITH_AES_256_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 0x006B</span>
<span class="gi">+    ietfNames[0x006B] = &#39;TLS_DHE_RSA_WITH_AES_256_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_DH_ANON_WITH_AES_128_CBC_SHA256 = 0x006C</span>
<span class="gi">+    ietfNames[0x006C] = &#39;TLS_DH_ANON_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_DH_ANON_WITH_AES_256_CBC_SHA256 = 0x006D</span>
<span class="gi">+    ietfNames[0x006D] = &#39;TLS_DH_ANON_WITH_AES_256_CBC_SHA256&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 5288 - AES-GCM ciphers for TLSv1.2</span>
<span class="gi">+    TLS_RSA_WITH_AES_128_GCM_SHA256 = 0x009C</span>
<span class="gi">+    ietfNames[0x009C] = &#39;TLS_RSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gi">+    TLS_RSA_WITH_AES_256_GCM_SHA384 = 0x009D</span>
<span class="gi">+    ietfNames[0x009D] = &#39;TLS_RSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = 0x009E</span>
<span class="gi">+    ietfNames[0x009E] = &#39;TLS_DHE_RSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = 0x009F</span>
<span class="gi">+    ietfNames[0x009F] = &#39;TLS_DHE_RSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gi">+    TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = 0x00A2</span>
<span class="gi">+    ietfNames[0x00A2] = &#39;TLS_DHE_DSS_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gi">+    TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = 0x00A3</span>
<span class="gi">+    ietfNames[0x00A3] = &#39;TLS_DHE_DSS_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gi">+    TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = 0x00A4</span>
<span class="gi">+    ietfNames[0x00A4] = &#39;TLS_DH_DSS_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gi">+    TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = 0x00A5</span>
<span class="gi">+    ietfNames[0x00A5] = &#39;TLS_DH_DSS_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gi">+    TLS_DH_ANON_WITH_AES_128_GCM_SHA256 = 0x00A6</span>
<span class="gi">+    ietfNames[0x00A6] = &#39;TLS_DH_ANON_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gi">+    TLS_DH_ANON_WITH_AES_256_GCM_SHA384 = 0x00A7</span>
<span class="gi">+    ietfNames[0x00A7] = &#39;TLS_DH_ANON_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 6655 - AES-CCM ciphers for TLSv1.2</span>
<span class="gi">+    TLS_RSA_WITH_AES_128_CCM = 0xC09C</span>
<span class="gi">+    ietfNames[0xC09C] = &#39;TLS_RSA_WITH_AES_128_CCM&#39;</span>
<span class="gi">+    TLS_RSA_WITH_AES_256_CCM = 0xC09D</span>
<span class="gi">+    ietfNames[0xC09D] = &#39;TLS_RSA_WITH_AES_256_CCM&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_AES_128_CCM = 0xC09E</span>
<span class="gi">+    ietfNames[0xC09E] = &#39;TLS_DHE_RSA_WITH_AES_128_CCM&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_AES_256_CCM = 0xC09F</span>
<span class="gi">+    ietfNames[0xC09F] = &#39;TLS_DHE_RSA_WITH_AES_256_CCM&#39;</span>
<span class="gi">+    TLS_RSA_WITH_AES_128_CCM_8 = 0xC0A0</span>
<span class="gi">+    ietfNames[0xC0A0] = &#39;TLS_RSA_WITH_AES_128_CCM_8&#39;</span>
<span class="gi">+    TLS_RSA_WITH_AES_256_CCM_8 = 0xC0A1</span>
<span class="gi">+    ietfNames[0xC0A1] = &#39;TLS_RSA_WITH_AES_256_CCM_8&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_AES_128_CCM_8 = 0xC0A2</span>
<span class="gi">+    ietfNames[0xC0A2] = &#39;TLS_DHE_RSA_WITH_AES_128_CCM_8&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_AES_256_CCM_8 = 0xC0A3</span>
<span class="gi">+    ietfNames[0xC0A3] = &#39;TLS_DHE_RSA_WITH_AES_256_CCM_8&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    # Weird pseudo-ciphersuite from RFC 5746</span>
<span class="gi">+    # Signals that &quot;secure renegotiation&quot; is supported</span>
<span class="gi">+    # We actually don&#39;t do any renegotiation, but this</span>
<span class="gi">+    # prevents renegotiation attacks</span>
<span class="gi">+    TLS_EMPTY_RENEGOTIATION_INFO_SCSV = 0x00FF</span>
<span class="gi">+    ietfNames[0x00FF] = &#39;TLS_EMPTY_RENEGOTIATION_INFO_SCSV&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # TLS 1.3 ciphersuites</span>
<span class="gi">+    TLS_AES_128_GCM_SHA256 = 0x1301</span>
<span class="gi">+    ietfNames[0x1301] = &#39;TLS_AES_128_GCM_SHA256&#39;</span>
<span class="gi">+    TLS_AES_256_GCM_SHA384 = 0x1302</span>
<span class="gi">+    ietfNames[0x1302] = &#39;TLS_AES_256_GCM_SHA384&#39;</span>
<span class="gi">+    TLS_CHACHA20_POLY1305_SHA256 = 0x1303</span>
<span class="gi">+    ietfNames[0x1303] = &#39;TLS_CHACHA20_POLY1305_SHA256&#39;</span>
<span class="gi">+    TLS_AES_128_CCM_SHA256 = 0x1304</span>
<span class="gi">+    ietfNames[0x1304] = &#39;TLS_AES_128_CCM_SHA256&#39;</span>
<span class="gi">+    TLS_AES_128_CCM_8_SHA256 = 0x1305</span>
<span class="gi">+    ietfNames[0x1305] = &#39;TLS_AES_128_CCM_8_SHA256&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 7507 - Fallback Signaling Cipher Suite Value for Preventing Protocol</span>
<span class="gi">+    # Downgrade Attacks</span>
<span class="gi">+    TLS_FALLBACK_SCSV = 0x5600</span>
<span class="gi">+    ietfNames[0x5600] = &#39;TLS_FALLBACK_SCSV&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 4492 - ECC Cipher Suites for TLS</span>
<span class="gi">+    # unsupported - no support for ECDSA certificates</span>
<span class="gi">+    TLS_ECDH_ECDSA_WITH_NULL_SHA = 0xC001</span>
<span class="gi">+    ietfNames[0xC001] = &#39;TLS_ECDH_ECDSA_WITH_NULL_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_ECDSA_WITH_RC4_128_SHA = 0xC002</span>
<span class="gi">+    ietfNames[0xC002] = &#39;TLS_ECDH_ECDSA_WITH_RC4_128_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC003</span>
<span class="gi">+    ietfNames[0xC003] = &#39;TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 0xC004</span>
<span class="gi">+    ietfNames[0xC004] = &#39;TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 0xC005</span>
<span class="gi">+    ietfNames[0xC005] = &#39;TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_NULL_SHA = 0xC006</span>
<span class="gi">+    ietfNames[0xC006] = &#39;TLS_ECDHE_ECDSA_WITH_NULL_SHA&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = 0xC007</span>
<span class="gi">+    ietfNames[0xC007] = &#39;TLS_ECDHE_ECDSA_WITH_RC4_128_SHA&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC008</span>
<span class="gi">+    ietfNames[0xC008] = &#39;TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 0xC009</span>
<span class="gi">+    ietfNames[0xC009] = &#39;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 0xC00A</span>
<span class="gi">+    ietfNames[0xC00A] = &#39;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_RSA_WITH_NULL_SHA = 0xC00B</span>
<span class="gi">+    ietfNames[0xC00B] = &#39;TLS_ECDH_RSA_WITH_NULL_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_RSA_WITH_RC4_128_SHA = 0xC00C</span>
<span class="gi">+    ietfNames[0xC00C] = &#39;TLS_ECDH_RSA_WITH_RC4_128_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = 0xC00D</span>
<span class="gi">+    ietfNames[0xC00D] = &#39;TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 0xC00E</span>
<span class="gi">+    ietfNames[0xC00E] = &#39;TLS_ECDH_RSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 0xC00F</span>
<span class="gi">+    ietfNames[0xC00F] = &#39;TLS_ECDH_RSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 4492 - ECC Cipher Suites for TLS</span>
<span class="gi">+    TLS_ECDHE_RSA_WITH_NULL_SHA = 0xC010</span>
<span class="gi">+    ietfNames[0xC010] = &#39;TLS_ECDHE_RSA_WITH_NULL_SHA&#39;</span>
<span class="gi">+    TLS_ECDHE_RSA_WITH_RC4_128_SHA = 0xC011</span>
<span class="gi">+    ietfNames[0xC011] = &#39;TLS_ECDHE_RSA_WITH_RC4_128_SHA&#39;</span>
<span class="gi">+    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = 0xC012</span>
<span class="gi">+    ietfNames[0xC012] = &#39;TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 0xC013</span>
<span class="gi">+    ietfNames[0xC013] = &#39;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 0xC014</span>
<span class="gi">+    ietfNames[0xC014] = &#39;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_ANON_WITH_NULL_SHA = 0xC015</span>
<span class="gi">+    ietfNames[0xC015] = &#39;TLS_ECDH_ANON_WITH_NULL_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_ANON_WITH_RC4_128_SHA = 0xC016</span>
<span class="gi">+    ietfNames[0xC016] = &#39;TLS_ECDH_ANON_WITH_RC4_128_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_ANON_WITH_3DES_EDE_CBC_SHA = 0xC017</span>
<span class="gi">+    ietfNames[0xC017] = &#39;TLS_ECDH_ANON_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_ANON_WITH_AES_128_CBC_SHA = 0xC018</span>
<span class="gi">+    ietfNames[0xC018] = &#39;TLS_ECDH_ANON_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_ECDH_ANON_WITH_AES_256_CBC_SHA = 0xC019</span>
<span class="gi">+    ietfNames[0xC019] = &#39;TLS_ECDH_ANON_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 5054 - Secure Remote Password (SRP) Protocol for TLS Authentication</span>
<span class="gi">+    TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA  = 0xC01A</span>
<span class="gi">+    ietfNames[0xC01A] = &#39;TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = 0xC01B</span>
<span class="gi">+    ietfNames[0xC01B] = &#39;TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = 0xC01C</span>
<span class="gi">+    ietfNames[0xC01C] = &#39;TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA&#39;</span>
<span class="gi">+    TLS_SRP_SHA_WITH_AES_128_CBC_SHA = 0xC01D</span>
<span class="gi">+    ietfNames[0xC01D] = &#39;TLS_SRP_SHA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = 0xC01E</span>
<span class="gi">+    ietfNames[0xC01E] = &#39;TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = 0xC01F</span>
<span class="gi">+    ietfNames[0xC01F] = &#39;TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA&#39;</span>
<span class="gi">+    TLS_SRP_SHA_WITH_AES_256_CBC_SHA = 0xC020</span>
<span class="gi">+    ietfNames[0xC020] = &#39;TLS_SRP_SHA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+    TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = 0xC021</span>
<span class="gi">+    ietfNames[0xC021] = &#39;TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+    TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = 0xC022</span>
<span class="gi">+    ietfNames[0xC022] = &#39;TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 5289 - ECC Ciphers with SHA-256/SHA-384 HMAC and AES-GCM</span>
<span class="gi">+    # unsupported! - no support for ECDSA certificates</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC023</span>
<span class="gi">+    ietfNames[0xC023] = &#39;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC024</span>
<span class="gi">+    ietfNames[0xC024] = &#39;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384&#39;</span>
<span class="gi">+    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC025</span>
<span class="gi">+    ietfNames[0xC025] = &#39;TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC026</span>
<span class="gi">+    ietfNames[0xC026] = &#39;TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 5289 - ECC Ciphers with SHA-256/SHA-384 HMAC and AES-GCM</span>
<span class="gi">+    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 0xC027</span>
<span class="gi">+    ietfNames[0xC027] = &#39;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 0xC028</span>
<span class="gi">+    ietfNames[0xC028] = &#39;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 5289 - ECC Ciphers with SHA-256/SHA-384 HMAC and AES-GCM</span>
<span class="gi">+    # unsupported</span>
<span class="gi">+    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 0xC029</span>
<span class="gi">+    ietfNames[0xC029] = &#39;TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256&#39;</span>
<span class="gi">+    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 0xC02A</span>
<span class="gi">+    ietfNames[0xC02A] = &#39;TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02B</span>
<span class="gi">+    ietfNames[0xC02B] = &#39;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02C</span>
<span class="gi">+    ietfNames[0xC02C] = &#39;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gi">+    TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02D</span>
<span class="gi">+    ietfNames[0xC02D] = &#39;TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gi">+    TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02E</span>
<span class="gi">+    ietfNames[0xC02E] = &#39;TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 5289 - ECC Ciphers with SHA-256/SHA-384 HMAC and AES-GCM</span>
<span class="gi">+    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02F</span>
<span class="gi">+    ietfNames[0xC02F] = &#39;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gi">+    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030</span>
<span class="gi">+    ietfNames[0xC030] = &#39;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 5289 - ECC Ciphers with SHA-256/SHA-384 HMAC and AES-GCM</span>
<span class="gi">+    # unsupported</span>
<span class="gi">+    TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 0xC031</span>
<span class="gi">+    ietfNames[0xC031] = &#39;TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256&#39;</span>
<span class="gi">+    TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 0xC032</span>
<span class="gi">+    ietfNames[0xC032] = &#39;TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # draft-ietf-tls-chacha20-poly1305-00</span>
<span class="gi">+    # ChaCha20/Poly1305 based Cipher Suites for TLS1.2</span>
<span class="gi">+    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_draft_00 = 0xCCA1</span>
<span class="gi">+    ietfNames[0xCCA1] = &#39;TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_draft_00&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_draft_00 = 0xCCA2</span>
<span class="gi">+    ietfNames[0xCCA2] = &#39;TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_draft_00&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_CHACHA20_POLY1305_draft_00 = 0xCCA3</span>
<span class="gi">+    ietfNames[0xCCA3] = &#39;TLS_DHE_RSA_WITH_CHACHA20_POLY1305_draft_00&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 7905 - ChaCha20-Poly1305 Cipher Suites for TLS</span>
<span class="gi">+    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA8</span>
<span class="gi">+    ietfNames[0xCCA8] = &#39;TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA9</span>
<span class="gi">+    ietfNames[0xCCA9] = &#39;TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256&#39;</span>
<span class="gi">+    TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAA</span>
<span class="gi">+    ietfNames[0xCCAA] = &#39;TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # RFC 7251 - AES-CCM ECC Ciphers for TLS</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_AES_128_CCM = 0xC0AC</span>
<span class="gi">+    ietfNames[0xC0AC] = &#39;TLS_ECDHE_ECDSA_WITH_AES_128_CCM&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_AES_256_CCM = 0xC0AD</span>
<span class="gi">+    ietfNames[0xC0AD] = &#39;TLS_ECDHE_ECDSA_WITH_AES_256_CCM&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = 0xC0AE</span>
<span class="gi">+    ietfNames[0xC0AE] = &#39;TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8&#39;</span>
<span class="gi">+    TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = 0xC0AF</span>
<span class="gi">+    ietfNames[0xC0AF] = &#39;TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8&#39;</span>
<span class="gi">+</span>
<span class="gi">+#pylint: enable = invalid-name</span>
<span class="gi">+    #</span>
<span class="gi">+    # Define cipher suite families below</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="gi">+    #: 3DES CBC ciphers</span>
<span class="w"> </span>    tripleDESSuites = []
<span class="w"> </span>    tripleDESSuites.append(TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA)
<span class="gd">-    tripleDESSuites.append(TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA)</span>
<span class="gd">-    tripleDESSuites.append(TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA)</span>
<span class="gi">+    tripleDESSuites.append(TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA)  # unsupported</span>
<span class="gi">+    tripleDESSuites.append(TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA)  # unsupported</span>
<span class="w"> </span>    tripleDESSuites.append(TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA)
<span class="w"> </span>    tripleDESSuites.append(TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA)
<span class="w"> </span>    tripleDESSuites.append(TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA)
<span class="gu">@@ -753,9 +970,12 @@ class CipherSuite:</span>
<span class="w"> </span>    tripleDESSuites.append(TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA)
<span class="w"> </span>    tripleDESSuites.append(TLS_DH_ANON_WITH_3DES_EDE_CBC_SHA)
<span class="w"> </span>    tripleDESSuites.append(TLS_ECDH_ANON_WITH_3DES_EDE_CBC_SHA)
<span class="gd">-    tripleDESSuites.append(TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA)</span>
<span class="gd">-    tripleDESSuites.append(TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA)</span>
<span class="gd">-    tripleDESSuites.append(TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA)</span>
<span class="gi">+    tripleDESSuites.append(TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA)    # unsupported</span>
<span class="gi">+    tripleDESSuites.append(TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA)   # unsupported</span>
<span class="gi">+    tripleDESSuites.append(TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA)   # unsupp</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    #: AES-128 CBC ciphers</span>
<span class="w"> </span>    aes128Suites = []
<span class="w"> </span>    aes128Suites.append(TLS_SRP_SHA_WITH_AES_128_CBC_SHA)
<span class="w"> </span>    aes128Suites.append(TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA)
<span class="gu">@@ -767,18 +987,20 @@ class CipherSuite:</span>
<span class="w"> </span>    aes128Suites.append(TLS_DH_ANON_WITH_AES_128_CBC_SHA256)
<span class="w"> </span>    aes128Suites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256)
<span class="w"> </span>    aes128Suites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA)
<span class="gd">-    aes128Suites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256)</span>
<span class="gd">-    aes128Suites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA)</span>
<span class="gd">-    aes128Suites.append(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256)</span>
<span class="gd">-    aes128Suites.append(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA)</span>
<span class="gi">+    aes128Suites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256)  # unsupported</span>
<span class="gi">+    aes128Suites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA)  # unsupported</span>
<span class="gi">+    aes128Suites.append(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256)  # unsupported</span>
<span class="gi">+    aes128Suites.append(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA)  # unsupported</span>
<span class="w"> </span>    aes128Suites.append(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA)
<span class="w"> </span>    aes128Suites.append(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256)
<span class="w"> </span>    aes128Suites.append(TLS_ECDH_ANON_WITH_AES_128_CBC_SHA)
<span class="gd">-    aes128Suites.append(TLS_DH_DSS_WITH_AES_128_CBC_SHA)</span>
<span class="gd">-    aes128Suites.append(TLS_DHE_DSS_WITH_AES_128_CBC_SHA)</span>
<span class="gd">-    aes128Suites.append(TLS_DH_DSS_WITH_AES_128_CBC_SHA256)</span>
<span class="gd">-    aes128Suites.append(TLS_DHE_DSS_WITH_AES_128_CBC_SHA256)</span>
<span class="gd">-    aes128Suites.append(TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA)</span>
<span class="gi">+    aes128Suites.append(TLS_DH_DSS_WITH_AES_128_CBC_SHA)    # unsupported</span>
<span class="gi">+    aes128Suites.append(TLS_DHE_DSS_WITH_AES_128_CBC_SHA)   # unsupported</span>
<span class="gi">+    aes128Suites.append(TLS_DH_DSS_WITH_AES_128_CBC_SHA256) # unsupported</span>
<span class="gi">+    aes128Suites.append(TLS_DHE_DSS_WITH_AES_128_CBC_SHA256)    # unsupported</span>
<span class="gi">+    aes128Suites.append(TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA)   # unsupported</span>
<span class="gi">+</span>
<span class="gi">+    #: AES-256 CBC ciphers</span>
<span class="w"> </span>    aes256Suites = []
<span class="w"> </span>    aes256Suites.append(TLS_SRP_SHA_WITH_AES_256_CBC_SHA)
<span class="w"> </span>    aes256Suites.append(TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA)
<span class="gu">@@ -790,86 +1012,108 @@ class CipherSuite:</span>
<span class="w"> </span>    aes256Suites.append(TLS_DH_ANON_WITH_AES_256_CBC_SHA256)
<span class="w"> </span>    aes256Suites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384)
<span class="w"> </span>    aes256Suites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA)
<span class="gd">-    aes256Suites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384)</span>
<span class="gd">-    aes256Suites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA)</span>
<span class="gd">-    aes256Suites.append(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384)</span>
<span class="gd">-    aes256Suites.append(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA)</span>
<span class="gi">+    aes256Suites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384)  # unsupported</span>
<span class="gi">+    aes256Suites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA)  # unsupported</span>
<span class="gi">+    aes256Suites.append(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384)  # unsupported</span>
<span class="gi">+    aes256Suites.append(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA)  # unsupported</span>
<span class="w"> </span>    aes256Suites.append(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA)
<span class="w"> </span>    aes256Suites.append(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384)
<span class="w"> </span>    aes256Suites.append(TLS_ECDH_ANON_WITH_AES_256_CBC_SHA)
<span class="gd">-    aes256Suites.append(TLS_DH_DSS_WITH_AES_256_CBC_SHA)</span>
<span class="gd">-    aes256Suites.append(TLS_DHE_DSS_WITH_AES_256_CBC_SHA)</span>
<span class="gd">-    aes256Suites.append(TLS_DH_DSS_WITH_AES_256_CBC_SHA256)</span>
<span class="gd">-    aes256Suites.append(TLS_DHE_DSS_WITH_AES_256_CBC_SHA256)</span>
<span class="gd">-    aes256Suites.append(TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA)</span>
<span class="gi">+    aes256Suites.append(TLS_DH_DSS_WITH_AES_256_CBC_SHA)    # unsupported</span>
<span class="gi">+    aes256Suites.append(TLS_DHE_DSS_WITH_AES_256_CBC_SHA)   # unsupported</span>
<span class="gi">+    aes256Suites.append(TLS_DH_DSS_WITH_AES_256_CBC_SHA256) # unsupported</span>
<span class="gi">+    aes256Suites.append(TLS_DHE_DSS_WITH_AES_256_CBC_SHA256)    # unsupported</span>
<span class="gi">+    aes256Suites.append(TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA)   # unsupported</span>
<span class="gi">+</span>
<span class="gi">+    #: AES-128 GCM ciphers</span>
<span class="w"> </span>    aes128GcmSuites = []
<span class="w"> </span>    aes128GcmSuites.append(TLS_RSA_WITH_AES_128_GCM_SHA256)
<span class="w"> </span>    aes128GcmSuites.append(TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)
<span class="w"> </span>    aes128GcmSuites.append(TLS_DH_ANON_WITH_AES_128_GCM_SHA256)
<span class="w"> </span>    aes128GcmSuites.append(TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)
<span class="gd">-    aes128GcmSuites.append(TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256)</span>
<span class="gd">-    aes128GcmSuites.append(TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256)</span>
<span class="gi">+    aes128GcmSuites.append(TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256)  # unsupp</span>
<span class="gi">+    aes128GcmSuites.append(TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256)  # unsupp</span>
<span class="w"> </span>    aes128GcmSuites.append(TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256)
<span class="w"> </span>    aes128GcmSuites.append(TLS_AES_128_GCM_SHA256)
<span class="gd">-    aes128GcmSuites.append(TLS_DHE_DSS_WITH_AES_128_GCM_SHA256)</span>
<span class="gd">-    aes128GcmSuites.append(TLS_DH_DSS_WITH_AES_128_GCM_SHA256)</span>
<span class="gi">+    aes128GcmSuites.append(TLS_DHE_DSS_WITH_AES_128_GCM_SHA256) # unsupported</span>
<span class="gi">+    aes128GcmSuites.append(TLS_DH_DSS_WITH_AES_128_GCM_SHA256)  # unsupported</span>
<span class="gi">+</span>
<span class="gi">+    #: AES-256-GCM ciphers (implicit SHA384, see sha384PrfSuites)</span>
<span class="w"> </span>    aes256GcmSuites = []
<span class="w"> </span>    aes256GcmSuites.append(TLS_RSA_WITH_AES_256_GCM_SHA384)
<span class="w"> </span>    aes256GcmSuites.append(TLS_DHE_RSA_WITH_AES_256_GCM_SHA384)
<span class="w"> </span>    aes256GcmSuites.append(TLS_DH_ANON_WITH_AES_256_GCM_SHA384)
<span class="w"> </span>    aes256GcmSuites.append(TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)
<span class="gd">-    aes256GcmSuites.append(TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384)</span>
<span class="gd">-    aes256GcmSuites.append(TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384)</span>
<span class="gi">+    aes256GcmSuites.append(TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384)  # unsupp</span>
<span class="gi">+    aes256GcmSuites.append(TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384)  # unsupported</span>
<span class="w"> </span>    aes256GcmSuites.append(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384)
<span class="w"> </span>    aes256GcmSuites.append(TLS_AES_256_GCM_SHA384)
<span class="gd">-    aes256GcmSuites.append(TLS_DHE_DSS_WITH_AES_256_GCM_SHA384)</span>
<span class="gd">-    aes256GcmSuites.append(TLS_DH_DSS_WITH_AES_256_GCM_SHA384)</span>
<span class="gi">+    aes256GcmSuites.append(TLS_DHE_DSS_WITH_AES_256_GCM_SHA384) # unsupported</span>
<span class="gi">+    aes256GcmSuites.append(TLS_DH_DSS_WITH_AES_256_GCM_SHA384)  # unsupported</span>
<span class="gi">+</span>
<span class="gi">+    #: AES-128 CCM_8 ciphers</span>
<span class="w"> </span>    aes128Ccm_8Suites = []
<span class="w"> </span>    aes128Ccm_8Suites.append(TLS_RSA_WITH_AES_128_CCM_8)
<span class="w"> </span>    aes128Ccm_8Suites.append(TLS_DHE_RSA_WITH_AES_128_CCM_8)
<span class="w"> </span>    aes128Ccm_8Suites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8)
<span class="w"> </span>    aes128Ccm_8Suites.append(TLS_AES_128_CCM_8_SHA256)
<span class="gi">+</span>
<span class="gi">+    #: AES-128 CCM ciphers</span>
<span class="w"> </span>    aes128CcmSuites = []
<span class="w"> </span>    aes128CcmSuites.append(TLS_RSA_WITH_AES_128_CCM)
<span class="w"> </span>    aes128CcmSuites.append(TLS_DHE_RSA_WITH_AES_128_CCM)
<span class="w"> </span>    aes128CcmSuites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CCM)
<span class="w"> </span>    aes128CcmSuites.append(TLS_AES_128_CCM_SHA256)
<span class="gi">+</span>
<span class="gi">+    #: AES-256 CCM_8 ciphers</span>
<span class="w"> </span>    aes256Ccm_8Suites = []
<span class="w"> </span>    aes256Ccm_8Suites.append(TLS_RSA_WITH_AES_256_CCM_8)
<span class="w"> </span>    aes256Ccm_8Suites.append(TLS_DHE_RSA_WITH_AES_256_CCM_8)
<span class="w"> </span>    aes256Ccm_8Suites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8)
<span class="gi">+</span>
<span class="gi">+    # AES-256 CCM ciphers</span>
<span class="w"> </span>    aes256CcmSuites = []
<span class="w"> </span>    aes256CcmSuites.append(TLS_RSA_WITH_AES_256_CCM)
<span class="w"> </span>    aes256CcmSuites.append(TLS_DHE_RSA_WITH_AES_256_CCM)
<span class="w"> </span>    aes256CcmSuites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CCM)
<span class="gi">+</span>
<span class="gi">+    #: CHACHA20 cipher, 00&#39;th IETF draft (implicit POLY1305 authenticator)</span>
<span class="w"> </span>    chacha20draft00Suites = []
<span class="w"> </span>    chacha20draft00Suites.append(TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_draft_00)
<span class="w"> </span>    chacha20draft00Suites.append(
<span class="w"> </span>        TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_draft_00)
<span class="w"> </span>    chacha20draft00Suites.append(TLS_DHE_RSA_WITH_CHACHA20_POLY1305_draft_00)
<span class="gi">+</span>
<span class="gi">+    #: CHACHA20 cipher (implicit POLY1305 authenticator, SHA256 PRF)</span>
<span class="w"> </span>    chacha20Suites = []
<span class="w"> </span>    chacha20Suites.append(TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256)
<span class="w"> </span>    chacha20Suites.append(TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256)
<span class="w"> </span>    chacha20Suites.append(TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256)
<span class="w"> </span>    chacha20Suites.append(TLS_CHACHA20_POLY1305_SHA256)
<span class="gi">+</span>
<span class="gi">+    #: RC4 128 stream cipher</span>
<span class="w"> </span>    rc4Suites = []
<span class="w"> </span>    rc4Suites.append(TLS_ECDHE_RSA_WITH_RC4_128_SHA)
<span class="w"> </span>    rc4Suites.append(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA)
<span class="gd">-    rc4Suites.append(TLS_ECDH_ECDSA_WITH_RC4_128_SHA)</span>
<span class="gd">-    rc4Suites.append(TLS_ECDH_RSA_WITH_RC4_128_SHA)</span>
<span class="gi">+    rc4Suites.append(TLS_ECDH_ECDSA_WITH_RC4_128_SHA)  # unsupported</span>
<span class="gi">+    rc4Suites.append(TLS_ECDH_RSA_WITH_RC4_128_SHA)  # unsupported</span>
<span class="w"> </span>    rc4Suites.append(TLS_DH_ANON_WITH_RC4_128_MD5)
<span class="w"> </span>    rc4Suites.append(TLS_RSA_WITH_RC4_128_SHA)
<span class="w"> </span>    rc4Suites.append(TLS_RSA_WITH_RC4_128_MD5)
<span class="w"> </span>    rc4Suites.append(TLS_ECDH_ANON_WITH_RC4_128_SHA)
<span class="gi">+</span>
<span class="gi">+    #: no encryption</span>
<span class="w"> </span>    nullSuites = []
<span class="w"> </span>    nullSuites.append(TLS_RSA_WITH_NULL_MD5)
<span class="w"> </span>    nullSuites.append(TLS_RSA_WITH_NULL_SHA)
<span class="w"> </span>    nullSuites.append(TLS_RSA_WITH_NULL_SHA256)
<span class="w"> </span>    nullSuites.append(TLS_ECDHE_ECDSA_WITH_NULL_SHA)
<span class="gd">-    nullSuites.append(TLS_ECDH_ECDSA_WITH_NULL_SHA)</span>
<span class="gd">-    nullSuites.append(TLS_ECDH_RSA_WITH_NULL_SHA)</span>
<span class="gi">+    nullSuites.append(TLS_ECDH_ECDSA_WITH_NULL_SHA)  # unsupported</span>
<span class="gi">+    nullSuites.append(TLS_ECDH_RSA_WITH_NULL_SHA)  # unsupported</span>
<span class="w"> </span>    nullSuites.append(TLS_ECDHE_RSA_WITH_NULL_SHA)
<span class="w"> </span>    nullSuites.append(TLS_ECDH_ANON_WITH_NULL_SHA)
<span class="gi">+</span>
<span class="gi">+    #: SHA-1 HMAC, protocol default PRF</span>
<span class="w"> </span>    shaSuites = []
<span class="w"> </span>    shaSuites.append(TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_SRP_SHA_WITH_AES_128_CBC_SHA)
<span class="gu">@@ -877,9 +1121,9 @@ class CipherSuite:</span>
<span class="w"> </span>    shaSuites.append(TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA)
<span class="gd">-    shaSuites.append(TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA)</span>
<span class="gi">+    shaSuites.append(TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA) # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA)  # unsupported</span>
<span class="w"> </span>    shaSuites.append(TLS_RSA_WITH_3DES_EDE_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_RSA_WITH_AES_128_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_RSA_WITH_AES_256_CBC_SHA)
<span class="gu">@@ -887,31 +1131,31 @@ class CipherSuite:</span>
<span class="w"> </span>    shaSuites.append(TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_DHE_RSA_WITH_AES_128_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_DHE_RSA_WITH_AES_256_CBC_SHA)
<span class="gd">-    shaSuites.append(TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_DHE_DSS_WITH_AES_128_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_DHE_DSS_WITH_AES_256_CBC_SHA)</span>
<span class="gi">+    shaSuites.append(TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA) # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_DHE_DSS_WITH_AES_128_CBC_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_DHE_DSS_WITH_AES_256_CBC_SHA)  # unsupported</span>
<span class="w"> </span>    shaSuites.append(TLS_DH_ANON_WITH_AES_128_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_DH_ANON_WITH_AES_256_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_DH_ANON_WITH_3DES_EDE_CBC_SHA)
<span class="gd">-    shaSuites.append(TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_DH_DSS_WITH_AES_128_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_DH_DSS_WITH_AES_256_CBC_SHA)</span>
<span class="gi">+    shaSuites.append(TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_DH_DSS_WITH_AES_128_CBC_SHA)   # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_DH_DSS_WITH_AES_256_CBC_SHA)   # unsupported</span>
<span class="w"> </span>    shaSuites.append(TLS_RSA_WITH_NULL_SHA)
<span class="w"> </span>    shaSuites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA)
<span class="w"> </span>    shaSuites.append(TLS_ECDHE_ECDSA_WITH_NULL_SHA)
<span class="gd">-    shaSuites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_ECDH_ECDSA_WITH_RC4_128_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_ECDH_ECDSA_WITH_NULL_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_ECDH_RSA_WITH_RC4_128_SHA)</span>
<span class="gd">-    shaSuites.append(TLS_ECDH_RSA_WITH_NULL_SHA)</span>
<span class="gi">+    shaSuites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_ECDH_ECDSA_WITH_RC4_128_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_ECDH_ECDSA_WITH_NULL_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_ECDH_RSA_WITH_RC4_128_SHA)  # unsupported</span>
<span class="gi">+    shaSuites.append(TLS_ECDH_RSA_WITH_NULL_SHA)  # unsupported</span>
<span class="w"> </span>    shaSuites.append(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA)
<span class="gu">@@ -922,6 +1166,8 @@ class CipherSuite:</span>
<span class="w"> </span>    shaSuites.append(TLS_ECDH_ANON_WITH_3DES_EDE_CBC_SHA)
<span class="w"> </span>    shaSuites.append(TLS_ECDH_ANON_WITH_RC4_128_SHA)
<span class="w"> </span>    shaSuites.append(TLS_ECDH_ANON_WITH_NULL_SHA)
<span class="gi">+</span>
<span class="gi">+    #: SHA-256 HMAC, SHA-256 PRF</span>
<span class="w"> </span>    sha256Suites = []
<span class="w"> </span>    sha256Suites.append(TLS_RSA_WITH_AES_128_CBC_SHA256)
<span class="w"> </span>    sha256Suites.append(TLS_RSA_WITH_AES_256_CBC_SHA256)
<span class="gu">@@ -931,19 +1177,25 @@ class CipherSuite:</span>
<span class="w"> </span>    sha256Suites.append(TLS_DH_ANON_WITH_AES_128_CBC_SHA256)
<span class="w"> </span>    sha256Suites.append(TLS_DH_ANON_WITH_AES_256_CBC_SHA256)
<span class="w"> </span>    sha256Suites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256)
<span class="gd">-    sha256Suites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256)</span>
<span class="gd">-    sha256Suites.append(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256)</span>
<span class="gi">+    sha256Suites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256)  # unsupported</span>
<span class="gi">+    sha256Suites.append(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256)  # unsupported</span>
<span class="w"> </span>    sha256Suites.append(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256)
<span class="gi">+</span>
<span class="gi">+    #: SHA-384 HMAC, SHA-384 PRF</span>
<span class="w"> </span>    sha384Suites = []
<span class="w"> </span>    sha384Suites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384)
<span class="gd">-    sha384Suites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384)</span>
<span class="gd">-    sha384Suites.append(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384)</span>
<span class="gi">+    sha384Suites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384)  # unsupported</span>
<span class="gi">+    sha384Suites.append(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384)  # unsupported</span>
<span class="w"> </span>    sha384Suites.append(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384)
<span class="gd">-    sha384Suites.append(TLS_DHE_DSS_WITH_AES_256_GCM_SHA384)</span>
<span class="gd">-    sha384Suites.append(TLS_DH_DSS_WITH_AES_256_GCM_SHA384)</span>
<span class="gi">+    sha384Suites.append(TLS_DHE_DSS_WITH_AES_256_GCM_SHA384)    # unsupported</span>
<span class="gi">+    sha384Suites.append(TLS_DH_DSS_WITH_AES_256_GCM_SHA384) # unsupported</span>
<span class="gi">+</span>
<span class="gi">+    #: stream cipher construction</span>
<span class="w"> </span>    streamSuites = []
<span class="w"> </span>    streamSuites.extend(rc4Suites)
<span class="w"> </span>    streamSuites.extend(nullSuites)
<span class="gi">+</span>
<span class="gi">+    #: AEAD integrity, any PRF</span>
<span class="w"> </span>    aeadSuites = []
<span class="w"> </span>    aeadSuites.extend(aes128GcmSuites)
<span class="w"> </span>    aeadSuites.extend(aes256GcmSuites)
<span class="gu">@@ -953,25 +1205,41 @@ class CipherSuite:</span>
<span class="w"> </span>    aeadSuites.extend(aes256Ccm_8Suites)
<span class="w"> </span>    aeadSuites.extend(chacha20Suites)
<span class="w"> </span>    aeadSuites.extend(chacha20draft00Suites)
<span class="gi">+</span>
<span class="gi">+    #: any with SHA384 PRF</span>
<span class="w"> </span>    sha384PrfSuites = []
<span class="w"> </span>    sha384PrfSuites.extend(sha384Suites)
<span class="w"> </span>    sha384PrfSuites.extend(aes256GcmSuites)
<span class="gi">+</span>
<span class="gi">+    #: MD-5 HMAC, protocol default PRF</span>
<span class="w"> </span>    md5Suites = []
<span class="w"> </span>    md5Suites.append(TLS_DH_ANON_WITH_RC4_128_MD5)
<span class="w"> </span>    md5Suites.append(TLS_RSA_WITH_RC4_128_MD5)
<span class="w"> </span>    md5Suites.append(TLS_RSA_WITH_NULL_MD5)
<span class="gi">+</span>
<span class="gi">+    #: SSL3, TLS1.0, TLS1.1 and TLS1.2 compatible ciphers</span>
<span class="w"> </span>    ssl3Suites = []
<span class="w"> </span>    ssl3Suites.extend(shaSuites)
<span class="w"> </span>    ssl3Suites.extend(md5Suites)
<span class="gi">+</span>
<span class="gi">+    #: TLS1.2 specific ciphersuites</span>
<span class="w"> </span>    tls12Suites = []
<span class="w"> </span>    tls12Suites.extend(sha256Suites)
<span class="w"> </span>    tls12Suites.extend(sha384Suites)
<span class="w"> </span>    tls12Suites.extend(aeadSuites)
<span class="gi">+</span>
<span class="gi">+    #: any that will end up using SHA256 PRF in TLS 1.2 or later</span>
<span class="w"> </span>    sha256PrfSuites = []
<span class="w"> </span>    sha256PrfSuites.extend(tls12Suites)
<span class="w"> </span>    for i in sha384PrfSuites:
<span class="w"> </span>        sha256PrfSuites.remove(i)
<span class="gi">+</span>
<span class="gi">+    #: TLS1.3 specific ciphersuites</span>
<span class="w"> </span>    tls13Suites = []
<span class="gi">+</span>
<span class="gi">+    # TLS 1.3 suites are not a superset of TLS 1.2 suites, but they</span>
<span class="gi">+    # use the same mechanism (AEAD), so we need to remove TLS 1.3 items</span>
<span class="gi">+    # from the TLS 1.2 list</span>
<span class="w"> </span>    tls13Suites.append(TLS_AES_256_GCM_SHA384)
<span class="w"> </span>    tls12Suites.remove(TLS_AES_256_GCM_SHA384)
<span class="w"> </span>    tls13Suites.append(TLS_AES_128_GCM_SHA256)
<span class="gu">@@ -986,24 +1254,134 @@ class CipherSuite:</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def filterForVersion(suites, minVersion, maxVersion):
<span class="w"> </span>        &quot;&quot;&quot;Return a copy of suites without ciphers incompatible with version&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        includeSuites = set([])</span>
<span class="gi">+        if (3, 0) &lt;= minVersion &lt;= (3, 3):</span>
<span class="gi">+            includeSuites.update(CipherSuite.ssl3Suites)</span>
<span class="gi">+        if maxVersion &gt;= (3, 3) and minVersion &lt;= (3, 3):</span>
<span class="gi">+            includeSuites.update(CipherSuite.tls12Suites)</span>
<span class="gi">+        if maxVersion &gt; (3, 3):</span>
<span class="gi">+            includeSuites.update(CipherSuite.tls13Suites)</span>
<span class="gi">+        return [s for s in suites if s in includeSuites]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def filter_for_certificate(suites, cert_chain):
<span class="w"> </span>        &quot;&quot;&quot;Return a copy of suites without ciphers incompatible with the cert.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        includeSuites = set([])</span>
<span class="gi">+        includeSuites.update(CipherSuite.tls13Suites)</span>
<span class="gi">+        if cert_chain:</span>
<span class="gi">+            if cert_chain.x509List[0].certAlg in (&quot;rsa&quot;, &quot;rsa-pss&quot;):</span>
<span class="gi">+                includeSuites.update(CipherSuite.certAllSuites)</span>
<span class="gi">+            if cert_chain.x509List[0].certAlg == &quot;rsa-pss&quot;:</span>
<span class="gi">+                # suites in which RSA encryption is used can&#39;t be used with</span>
<span class="gi">+                # rsa-pss</span>
<span class="gi">+                includeSuites.symmetric_difference_update(</span>
<span class="gi">+                    CipherSuite.certSuites)</span>
<span class="gi">+            if cert_chain.x509List[0].certAlg in (&quot;ecdsa&quot;, &quot;Ed25519&quot;, &quot;Ed448&quot;):</span>
<span class="gi">+                includeSuites.update(CipherSuite.ecdheEcdsaSuites)</span>
<span class="gi">+            if cert_chain.x509List[0].certAlg == &quot;dsa&quot;:</span>
<span class="gi">+                includeSuites.update(CipherSuite.dheDsaSuites)</span>
<span class="gi">+        else:</span>
<span class="gi">+            includeSuites.update(CipherSuite.srpSuites)</span>
<span class="gi">+            includeSuites.update(CipherSuite.anonSuites)</span>
<span class="gi">+            includeSuites.update(CipherSuite.ecdhAnonSuites)</span>
<span class="gi">+        return [s for s in suites if s in includeSuites]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def filter_for_prfs(suites, prfs):
<span class="w"> </span>        &quot;&quot;&quot;Return a copy of suites without ciphers incompatible with the
<span class="w"> </span>        specified prfs (sha256 or sha384)&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        includeSuites = set()</span>
<span class="gi">+        prfs = set(prfs)</span>
<span class="gi">+        if None in prfs:</span>
<span class="gi">+            prfs.update([&quot;sha256&quot;])</span>
<span class="gi">+            prfs.remove(None)</span>
<span class="gi">+        assert len(prfs) &lt;= 2, prfs</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;sha256&quot; in prfs:</span>
<span class="gi">+            includeSuites.update(CipherSuite.sha256PrfSuites)</span>
<span class="gi">+        if &quot;sha384&quot; in prfs:</span>
<span class="gi">+            includeSuites.update(CipherSuite.sha384PrfSuites)</span>
<span class="gi">+        return [s for s in suites if s in includeSuites]</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _filterSuites(suites, settings, version=None):</span>
<span class="gi">+        if version is None:</span>
<span class="gi">+            version = settings.maxVersion</span>
<span class="gi">+        macNames = settings.macNames</span>
<span class="gi">+        cipherNames = settings.cipherNames</span>
<span class="gi">+        keyExchangeNames = settings.keyExchangeNames</span>
<span class="gi">+        macSuites = []</span>
<span class="gi">+        if &quot;sha&quot; in macNames:</span>
<span class="gi">+            macSuites += CipherSuite.shaSuites</span>
<span class="gi">+        if &quot;sha256&quot; in macNames and version &gt;= (3, 3):</span>
<span class="gi">+            macSuites += CipherSuite.sha256Suites</span>
<span class="gi">+        if &quot;sha384&quot; in macNames and version &gt;= (3, 3):</span>
<span class="gi">+            macSuites += CipherSuite.sha384Suites</span>
<span class="gi">+        if &quot;md5&quot; in macNames:</span>
<span class="gi">+            macSuites += CipherSuite.md5Suites</span>
<span class="gi">+        if &quot;aead&quot; in macNames and version &gt;= (3, 3):</span>
<span class="gi">+            macSuites += CipherSuite.aeadSuites</span>
<span class="gi">+</span>
<span class="gi">+        cipherSuites = []</span>
<span class="gi">+        if &quot;chacha20-poly1305&quot; in cipherNames and version &gt;= (3, 3):</span>
<span class="gi">+            cipherSuites += CipherSuite.chacha20Suites</span>
<span class="gi">+        if &quot;chacha20-poly1305_draft00&quot; in cipherNames and version &gt;= (3, 3):</span>
<span class="gi">+            cipherSuites += CipherSuite.chacha20draft00Suites</span>
<span class="gi">+        if &quot;aes128gcm&quot; in cipherNames and version &gt;= (3, 3):</span>
<span class="gi">+            cipherSuites += CipherSuite.aes128GcmSuites</span>
<span class="gi">+        if &quot;aes256gcm&quot; in cipherNames and version &gt;= (3, 3):</span>
<span class="gi">+            cipherSuites += CipherSuite.aes256GcmSuites</span>
<span class="gi">+        if &quot;aes128ccm&quot; in cipherNames and version &gt;= (3, 3):</span>
<span class="gi">+            cipherSuites += CipherSuite.aes128CcmSuites</span>
<span class="gi">+        if &quot;aes128ccm_8&quot; in cipherNames and version &gt;= (3, 3):</span>
<span class="gi">+            cipherSuites += CipherSuite.aes128Ccm_8Suites</span>
<span class="gi">+        if &quot;aes256ccm&quot; in cipherNames and version &gt;= (3, 3):</span>
<span class="gi">+            cipherSuites += CipherSuite.aes256CcmSuites</span>
<span class="gi">+        if &quot;aes256ccm_8&quot; in cipherNames and version &gt;= (3, 3):</span>
<span class="gi">+            cipherSuites += CipherSuite.aes256Ccm_8Suites</span>
<span class="gi">+        if &quot;aes128&quot; in cipherNames:</span>
<span class="gi">+            cipherSuites += CipherSuite.aes128Suites</span>
<span class="gi">+        if &quot;aes256&quot; in cipherNames:</span>
<span class="gi">+            cipherSuites += CipherSuite.aes256Suites</span>
<span class="gi">+        if &quot;3des&quot; in cipherNames:</span>
<span class="gi">+            cipherSuites += CipherSuite.tripleDESSuites</span>
<span class="gi">+        if &quot;rc4&quot; in cipherNames:</span>
<span class="gi">+            cipherSuites += CipherSuite.rc4Suites</span>
<span class="gi">+        if &quot;null&quot; in cipherNames:</span>
<span class="gi">+            cipherSuites += CipherSuite.nullSuites</span>
<span class="gi">+</span>
<span class="gi">+        keyExchangeSuites = []</span>
<span class="gi">+        if version &gt;= (3, 4):</span>
<span class="gi">+            keyExchangeSuites += CipherSuite.tls13Suites</span>
<span class="gi">+        if &quot;rsa&quot; in keyExchangeNames:</span>
<span class="gi">+            keyExchangeSuites += CipherSuite.certSuites</span>
<span class="gi">+        if &quot;dhe_rsa&quot; in keyExchangeNames:</span>
<span class="gi">+            keyExchangeSuites += CipherSuite.dheCertSuites</span>
<span class="gi">+        if &quot;dhe_dsa&quot; in keyExchangeNames:</span>
<span class="gi">+            keyExchangeSuites += CipherSuite.dheDsaSuites</span>
<span class="gi">+        if &quot;ecdhe_rsa&quot; in keyExchangeNames:</span>
<span class="gi">+            keyExchangeSuites += CipherSuite.ecdheCertSuites</span>
<span class="gi">+        if &quot;ecdhe_ecdsa&quot; in keyExchangeNames:</span>
<span class="gi">+            keyExchangeSuites += CipherSuite.ecdheEcdsaSuites</span>
<span class="gi">+        if &quot;srp_sha&quot; in keyExchangeNames:</span>
<span class="gi">+            keyExchangeSuites += CipherSuite.srpSuites</span>
<span class="gi">+        if &quot;srp_sha_rsa&quot; in keyExchangeNames:</span>
<span class="gi">+            keyExchangeSuites += CipherSuite.srpCertSuites</span>
<span class="gi">+        if &quot;dh_anon&quot; in keyExchangeNames:</span>
<span class="gi">+            keyExchangeSuites += CipherSuite.anonSuites</span>
<span class="gi">+        if &quot;ecdh_anon&quot; in keyExchangeNames:</span>
<span class="gi">+            keyExchangeSuites += CipherSuite.ecdhAnonSuites</span>
<span class="gi">+</span>
<span class="gi">+        return [s for s in suites if s in macSuites and</span>
<span class="gi">+                s in cipherSuites and s in keyExchangeSuites]</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getTLS13Suites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Return cipher suites that are TLS 1.3 specific.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.tls13Suites, settings, version)</span>
<span class="gi">+</span>
<span class="gi">+    #: SRP key exchange, no certificate base authentication</span>
<span class="w"> </span>    srpSuites = []
<span class="w"> </span>    srpSuites.append(TLS_SRP_SHA_WITH_AES_256_CBC_SHA)
<span class="w"> </span>    srpSuites.append(TLS_SRP_SHA_WITH_AES_128_CBC_SHA)
<span class="gu">@@ -1012,7 +1390,9 @@ class CipherSuite:</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getSrpSuites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Return SRP cipher suites matching settings&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.srpSuites, settings, version)</span>
<span class="gi">+</span>
<span class="gi">+    #: SRP key exchange, RSA authentication</span>
<span class="w"> </span>    srpCertSuites = []
<span class="w"> </span>    srpCertSuites.append(TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA)
<span class="w"> </span>    srpCertSuites.append(TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA)
<span class="gu">@@ -1021,22 +1401,28 @@ class CipherSuite:</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getSrpCertSuites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Return SRP cipher suites that use server certificates&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.srpCertSuites, settings, version)</span>
<span class="gi">+</span>
<span class="gi">+    #: SRP key exchange, DSA authentication</span>
<span class="w"> </span>    srpDsaSuites = []
<span class="gd">-    srpDsaSuites.append(TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA)</span>
<span class="gd">-    srpDsaSuites.append(TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA)</span>
<span class="gd">-    srpDsaSuites.append(TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA)</span>
<span class="gi">+    srpDsaSuites.append(TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA) # unsupported</span>
<span class="gi">+    srpDsaSuites.append(TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA)  # unsupported</span>
<span class="gi">+    srpDsaSuites.append(TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA)  # unsupported</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getSrpDsaSuites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Return SRP DSA cipher suites that use server certificates&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.srpCertSuites, settings, version)</span>
<span class="gi">+</span>
<span class="gi">+    #: All that use SRP key exchange</span>
<span class="w"> </span>    srpAllSuites = srpSuites + srpCertSuites

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getSrpAllSuites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Return all SRP cipher suites matching settings&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.srpAllSuites, settings, version)</span>
<span class="gi">+</span>
<span class="gi">+    #: RSA key exchange, RSA authentication</span>
<span class="w"> </span>    certSuites = []
<span class="w"> </span>    certSuites.append(TLS_RSA_WITH_AES_256_GCM_SHA384)
<span class="w"> </span>    certSuites.append(TLS_RSA_WITH_AES_128_GCM_SHA256)
<span class="gu">@@ -1058,7 +1444,9 @@ class CipherSuite:</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getCertSuites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Return ciphers with RSA authentication matching settings&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.certSuites, settings, version)</span>
<span class="gi">+</span>
<span class="gi">+    #: FFDHE key exchange, RSA authentication</span>
<span class="w"> </span>    dheCertSuites = []
<span class="w"> </span>    dheCertSuites.append(TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256)
<span class="w"> </span>    dheCertSuites.append(TLS_DHE_RSA_WITH_CHACHA20_POLY1305_draft_00)
<span class="gu">@@ -1077,7 +1465,9 @@ class CipherSuite:</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getDheCertSuites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Provide authenticated DHE ciphersuites matching settings&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.dheCertSuites, settings, version)</span>
<span class="gi">+</span>
<span class="gi">+    #: ECDHE key exchange, RSA authentication</span>
<span class="w"> </span>    ecdheCertSuites = []
<span class="w"> </span>    ecdheCertSuites.append(TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256)
<span class="w"> </span>    ecdheCertSuites.append(TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_draft_00)
<span class="gu">@@ -1094,9 +1484,12 @@ class CipherSuite:</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getEcdheCertSuites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Provide authenticated ECDHE ciphersuites matching settings&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    certAllSuites = (srpCertSuites + certSuites + dheCertSuites +</span>
<span class="gd">-        ecdheCertSuites)</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.ecdheCertSuites, settings, version)</span>
<span class="gi">+</span>
<span class="gi">+    #: RSA authentication</span>
<span class="gi">+    certAllSuites = srpCertSuites + certSuites + dheCertSuites + ecdheCertSuites</span>
<span class="gi">+</span>
<span class="gi">+    #: ECDHE key exchange, ECDSA authentication</span>
<span class="w"> </span>    ecdheEcdsaSuites = []
<span class="w"> </span>    ecdheEcdsaSuites.append(TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256)
<span class="w"> </span>    ecdheEcdsaSuites.append(TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_draft_00)
<span class="gu">@@ -1117,7 +1510,10 @@ class CipherSuite:</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getEcdsaSuites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Provide ECDSA authenticated ciphersuites matching settings&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.ecdheEcdsaSuites,</span>
<span class="gi">+                                 settings, version)</span>
<span class="gi">+</span>
<span class="gi">+    #: DHE key exchange, DSA authentication</span>
<span class="w"> </span>    dheDsaSuites = []
<span class="w"> </span>    dheDsaSuites.append(TLS_DHE_DSS_WITH_AES_256_GCM_SHA384)
<span class="w"> </span>    dheDsaSuites.append(TLS_DHE_DSS_WITH_AES_128_GCM_SHA256)
<span class="gu">@@ -1130,7 +1526,10 @@ class CipherSuite:</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getDheDsaSuites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Provide DSA authenticated ciphersuites matching settings&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.dheDsaSuites,</span>
<span class="gi">+                                 settings, version)</span>
<span class="gi">+</span>
<span class="gi">+    #: anon FFDHE key exchange</span>
<span class="w"> </span>    anonSuites = []
<span class="w"> </span>    anonSuites.append(TLS_DH_ANON_WITH_AES_256_GCM_SHA384)
<span class="w"> </span>    anonSuites.append(TLS_DH_ANON_WITH_AES_128_GCM_SHA256)
<span class="gu">@@ -1144,8 +1543,11 @@ class CipherSuite:</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getAnonSuites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Provide anonymous DH ciphersuites matching settings&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.anonSuites, settings, version)</span>
<span class="gi">+</span>
<span class="w"> </span>    dhAllSuites = dheCertSuites + anonSuites + dheDsaSuites
<span class="gi">+</span>
<span class="gi">+    #: anon ECDHE key exchange</span>
<span class="w"> </span>    ecdhAnonSuites = []
<span class="w"> </span>    ecdhAnonSuites.append(TLS_ECDH_ANON_WITH_AES_256_CBC_SHA)
<span class="w"> </span>    ecdhAnonSuites.append(TLS_ECDH_ANON_WITH_AES_128_CBC_SHA)
<span class="gu">@@ -1156,46 +1558,103 @@ class CipherSuite:</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def getEcdhAnonSuites(cls, settings, version=None):
<span class="w"> </span>        &quot;&quot;&quot;Provide anonymous ECDH ciphersuites matching settings&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._filterSuites(CipherSuite.ecdhAnonSuites, settings, version)</span>
<span class="gi">+</span>
<span class="gi">+    #: all ciphersuites which use ephemeral ECDH key exchange</span>
<span class="w"> </span>    ecdhAllSuites = ecdheEcdsaSuites + ecdheCertSuites + ecdhAnonSuites

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def canonicalCipherName(ciphersuite):
<span class="w"> </span>        &quot;&quot;&quot;Return the canonical name of the cipher whose number is provided.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if ciphersuite in CipherSuite.aes128GcmSuites:</span>
<span class="gi">+            return &quot;aes128gcm&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.aes256GcmSuites:</span>
<span class="gi">+            return &quot;aes256gcm&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.aes128Ccm_8Suites:</span>
<span class="gi">+            return &quot;aes128ccm_8&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.aes128CcmSuites:</span>
<span class="gi">+            return &quot;aes128ccm&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.aes256CcmSuites:</span>
<span class="gi">+            return &quot;aes256ccm&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.aes256Ccm_8Suites:</span>
<span class="gi">+            return &quot;aes256ccm_8&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.aes128Suites:</span>
<span class="gi">+            return &quot;aes128&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.aes256Suites:</span>
<span class="gi">+            return &quot;aes256&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.rc4Suites:</span>
<span class="gi">+            return &quot;rc4&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.tripleDESSuites:</span>
<span class="gi">+            return &quot;3des&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.nullSuites:</span>
<span class="gi">+            return &quot;null&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.chacha20draft00Suites:</span>
<span class="gi">+            return &quot;chacha20-poly1305_draft00&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.chacha20Suites:</span>
<span class="gi">+            return &quot;chacha20-poly1305&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def canonicalMacName(ciphersuite):
<span class="w"> </span>        &quot;&quot;&quot;Return the canonical name of the MAC whose number is provided.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+        if ciphersuite in CipherSuite.sha384Suites:</span>
<span class="gi">+            return &quot;sha384&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.sha256Suites:</span>
<span class="gi">+            return &quot;sha256&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.shaSuites:</span>
<span class="gi">+            return &quot;sha&quot;</span>
<span class="gi">+        elif ciphersuite in CipherSuite.md5Suites:</span>
<span class="gi">+            return &quot;md5&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# The following faults are induced as part of testing.  The faultAlerts</span>
<span class="gi">+# dictionary describes the allowed alerts that may be triggered by these</span>
<span class="gi">+# faults.</span>
<span class="w"> </span>class Fault:
<span class="w"> </span>    badUsername = 101
<span class="w"> </span>    badPassword = 102
<span class="w"> </span>    badA = 103
<span class="gd">-    clientSrpFaults = list(range(101, 104))</span>
<span class="gi">+    clientSrpFaults = list(range(101,104))</span>
<span class="gi">+</span>
<span class="w"> </span>    badVerifyMessage = 601
<span class="gd">-    clientCertFaults = list(range(601, 602))</span>
<span class="gi">+    clientCertFaults = list(range(601,602))</span>
<span class="gi">+</span>
<span class="w"> </span>    badPremasterPadding = 501
<span class="w"> </span>    shortPremasterSecret = 502
<span class="gd">-    clientNoAuthFaults = list(range(501, 503))</span>
<span class="gi">+    clientNoAuthFaults = list(range(501,503))</span>
<span class="gi">+</span>
<span class="w"> </span>    badB = 201
<span class="gd">-    serverFaults = list(range(201, 202))</span>
<span class="gi">+    serverFaults = list(range(201,202))</span>
<span class="gi">+</span>
<span class="w"> </span>    badFinished = 300
<span class="w"> </span>    badMAC = 301
<span class="w"> </span>    badPadding = 302
<span class="gd">-    genericFaults = list(range(300, 303))</span>
<span class="gd">-    faultAlerts = {badUsername: (AlertDescription.unknown_psk_identity,</span>
<span class="gd">-        AlertDescription.bad_record_mac), badPassword: (AlertDescription.</span>
<span class="gd">-        bad_record_mac,), badA: (AlertDescription.illegal_parameter,),</span>
<span class="gd">-        badPremasterPadding: (AlertDescription.bad_record_mac,),</span>
<span class="gd">-        shortPremasterSecret: (AlertDescription.bad_record_mac,),</span>
<span class="gd">-        badVerifyMessage: (AlertDescription.decrypt_error,), badFinished: (</span>
<span class="gd">-        AlertDescription.decrypt_error,), badMAC: (AlertDescription.</span>
<span class="gd">-        bad_record_mac,), badPadding: (AlertDescription.bad_record_mac,)}</span>
<span class="gd">-    faultNames = {badUsername: &#39;bad username&#39;, badPassword: &#39;bad password&#39;,</span>
<span class="gd">-        badA: &#39;bad A&#39;, badPremasterPadding: &#39;bad premaster padding&#39;,</span>
<span class="gd">-        shortPremasterSecret: &#39;short premaster secret&#39;, badVerifyMessage:</span>
<span class="gd">-        &#39;bad verify message&#39;, badFinished: &#39;bad finished message&#39;, badMAC:</span>
<span class="gd">-        &#39;bad MAC&#39;, badPadding: &#39;bad padding&#39;}</span>
<span class="gi">+    genericFaults = list(range(300,303))</span>
<span class="gi">+</span>
<span class="gi">+    faultAlerts = {\</span>
<span class="gi">+        badUsername: (AlertDescription.unknown_psk_identity, \</span>
<span class="gi">+                      AlertDescription.bad_record_mac),\</span>
<span class="gi">+        badPassword: (AlertDescription.bad_record_mac,),\</span>
<span class="gi">+        badA: (AlertDescription.illegal_parameter,),\</span>
<span class="gi">+        badPremasterPadding: (AlertDescription.bad_record_mac,),\</span>
<span class="gi">+        shortPremasterSecret: (AlertDescription.bad_record_mac,),\</span>
<span class="gi">+        badVerifyMessage: (AlertDescription.decrypt_error,),\</span>
<span class="gi">+        badFinished: (AlertDescription.decrypt_error,),\</span>
<span class="gi">+        badMAC: (AlertDescription.bad_record_mac,),\</span>
<span class="gi">+        badPadding: (AlertDescription.bad_record_mac,)</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    faultNames = {\</span>
<span class="gi">+        badUsername: &quot;bad username&quot;,\</span>
<span class="gi">+        badPassword: &quot;bad password&quot;,\</span>
<span class="gi">+        badA: &quot;bad A&quot;,\</span>
<span class="gi">+        badPremasterPadding: &quot;bad premaster padding&quot;,\</span>
<span class="gi">+        shortPremasterSecret: &quot;short premaster secret&quot;,\</span>
<span class="gi">+        badVerifyMessage: &quot;bad verify message&quot;,\</span>
<span class="gi">+        badFinished: &quot;bad finished message&quot;,\</span>
<span class="gi">+        badMAC: &quot;bad MAC&quot;,\</span>
<span class="gi">+        badPadding: &quot;bad padding&quot;</span>
<span class="gi">+        }</span>
<span class="gh">diff --git a/tlslite/defragmenter.py b/tlslite/defragmenter.py</span>
<span class="gh">index 3a1038b..84da895 100644</span>
<span class="gd">--- a/tlslite/defragmenter.py</span>
<span class="gi">+++ b/tlslite/defragmenter.py</span>
<span class="gu">@@ -1,12 +1,20 @@</span>
<span class="gi">+# Copyright (c) 2015, Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Helper package for handling fragmentation of messages.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import generators
<span class="gi">+</span>
<span class="w"> </span>from .utils.codec import Parser
<span class="w"> </span>from .utils.deprecations import deprecated_attrs, deprecated_params


<span class="gd">-@deprecated_attrs({&#39;add_static_size&#39;: &#39;addStaticSize&#39;, &#39;add_dynamic_size&#39;:</span>
<span class="gd">-    &#39;addDynamicSize&#39;, &#39;add_data&#39;: &#39;addData&#39;, &#39;get_message&#39;: &#39;getMessage&#39;,</span>
<span class="gd">-    &#39;clear_buffers&#39;: &#39;clearBuffers&#39;})</span>
<span class="gi">+@deprecated_attrs({&quot;add_static_size&quot;: &quot;addStaticSize&quot;,</span>
<span class="gi">+                   &quot;add_dynamic_size&quot;: &quot;addDynamicSize&quot;,</span>
<span class="gi">+                   &quot;add_data&quot;: &quot;addData&quot;,</span>
<span class="gi">+                   &quot;get_message&quot;: &quot;getMessage&quot;,</span>
<span class="gi">+                   &quot;clear_buffers&quot;: &quot;clearBuffers&quot;})</span>
<span class="w"> </span>class Defragmenter(object):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Class for demultiplexing TLS messages.
<span class="gu">@@ -30,30 +38,95 @@ class Defragmenter(object):</span>
<span class="w"> </span>        self.buffers = {}
<span class="w"> </span>        self.decoders = {}

<span class="gd">-    @deprecated_params({&#39;msg_type&#39;: &#39;msgType&#39;})</span>
<span class="gi">+    @deprecated_params({&quot;msg_type&quot;: &quot;msgType&quot;})</span>
<span class="w"> </span>    def add_static_size(self, msg_type, size):
<span class="w"> </span>        &quot;&quot;&quot;Add a message type which all messages are of same length&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msg_type in self.priorities:</span>
<span class="gi">+            raise ValueError(&quot;Message type already defined&quot;)</span>
<span class="gi">+        if size &lt; 1:</span>
<span class="gi">+            raise ValueError(&quot;Message size must be positive integer&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.priorities += [msg_type]</span>

<span class="gd">-    @deprecated_params({&#39;msg_type&#39;: &#39;msgType&#39;, &#39;size_offset&#39;: &#39;sizeOffset&#39;,</span>
<span class="gd">-        &#39;size_of_size&#39;: &#39;sizeOfSize&#39;})</span>
<span class="gi">+        self.buffers[msg_type] = bytearray(0)</span>
<span class="gi">+        def size_handler(data):</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Size of message in parameter</span>
<span class="gi">+</span>
<span class="gi">+            If complete message is present in parameter returns its size,</span>
<span class="gi">+            None otherwise.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            if len(data) &lt; size:</span>
<span class="gi">+                return None</span>
<span class="gi">+            else:</span>
<span class="gi">+                return size</span>
<span class="gi">+        self.decoders[msg_type] = size_handler</span>
<span class="gi">+</span>
<span class="gi">+    @deprecated_params({&quot;msg_type&quot;: &quot;msgType&quot;,</span>
<span class="gi">+                        &quot;size_offset&quot;: &quot;sizeOffset&quot;,</span>
<span class="gi">+                        &quot;size_of_size&quot;: &quot;sizeOfSize&quot;})</span>
<span class="w"> </span>    def add_dynamic_size(self, msg_type, size_offset, size_of_size):
<span class="w"> </span>        &quot;&quot;&quot;Add a message type which has a dynamic size set in a header&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msg_type in self.priorities:</span>
<span class="gi">+            raise ValueError(&quot;Message type already defined&quot;)</span>
<span class="gi">+        if size_of_size &lt; 1:</span>
<span class="gi">+            raise ValueError(&quot;Size of size must be positive integer&quot;)</span>
<span class="gi">+        if size_offset &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Offset can&#39;t be negative&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.priorities += [msg_type]</span>
<span class="gi">+        self.buffers[msg_type] = bytearray(0)</span>

<span class="gd">-    @deprecated_params({&#39;msg_type&#39;: &#39;msgType&#39;})</span>
<span class="gi">+        def size_handler(data):</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Size of message in parameter</span>
<span class="gi">+</span>
<span class="gi">+            If complete message is present in parameter returns its size,</span>
<span class="gi">+            None otherwise.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            if len(data) &lt; size_offset+size_of_size:</span>
<span class="gi">+                return None</span>
<span class="gi">+            else:</span>
<span class="gi">+                parser = Parser(data)</span>
<span class="gi">+                # skip the header</span>
<span class="gi">+                parser.skip_bytes(size_offset)</span>
<span class="gi">+</span>
<span class="gi">+                payload_length = parser.get(size_of_size)</span>
<span class="gi">+                if parser.getRemainingLength() &lt; payload_length:</span>
<span class="gi">+                    # not enough bytes in buffer</span>
<span class="gi">+                    return None</span>
<span class="gi">+                return size_offset + size_of_size + payload_length</span>
<span class="gi">+</span>
<span class="gi">+        self.decoders[msg_type] = size_handler</span>
<span class="gi">+</span>
<span class="gi">+    @deprecated_params({&quot;msg_type&quot;: &quot;msgType&quot;})</span>
<span class="w"> </span>    def add_data(self, msg_type, data):
<span class="w"> </span>        &quot;&quot;&quot;Adds data to buffers&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msg_type not in self.priorities:</span>
<span class="gi">+            raise ValueError(&quot;Message type not defined&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.buffers[msg_type] += data</span>

<span class="w"> </span>    def get_message(self):
<span class="w"> </span>        &quot;&quot;&quot;Extract the highest priority complete message from buffer&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for msg_type in self.priorities:</span>
<span class="gi">+            buf = self.buffers[msg_type]</span>
<span class="gi">+            length = self.decoders[msg_type](buf)</span>
<span class="gi">+            if length is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # extract message</span>
<span class="gi">+            data = buf[:length]</span>
<span class="gi">+            # remove it from buffer</span>
<span class="gi">+            del buf[:length]</span>
<span class="gi">+            return (msg_type, data)</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def clear_buffers(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove all data from buffers&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key in self.buffers.keys():</span>
<span class="gi">+            self.buffers[key] = bytearray(0)</span>

<span class="w"> </span>    def is_empty(self):
<span class="w"> </span>        &quot;&quot;&quot;Return True if all buffers are empty.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return all(not i for i in self.buffers.values())</span>
<span class="gh">diff --git a/tlslite/dh.py b/tlslite/dh.py</span>
<span class="gh">index a8cab41..922d1ee 100644</span>
<span class="gd">--- a/tlslite/dh.py</span>
<span class="gi">+++ b/tlslite/dh.py</span>
<span class="gu">@@ -1,4 +1,8 @@</span>
<span class="gi">+# Author:</span>
<span class="gi">+#    Hubert Kario</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Handling of Diffie-Hellman parameter files.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .utils.asn1parser import ASN1Parser
<span class="w"> </span>from .utils.pem import dePem
<span class="w"> </span>from .utils.cryptomath import bytesToNumber
<span class="gu">@@ -11,7 +15,12 @@ def parseBinary(data):</span>
<span class="w"> </span>    :param bytes data: DH parameters
<span class="w"> </span>    :rtype: tuple of int
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = ASN1Parser(data)</span>
<span class="gi">+</span>
<span class="gi">+    prime = parser.getChild(0)</span>
<span class="gi">+    gen = parser.getChild(1)</span>
<span class="gi">+</span>
<span class="gi">+    return (bytesToNumber(gen.value), bytesToNumber(prime.value))</span>


<span class="w"> </span>def parse(data):
<span class="gu">@@ -24,4 +33,10 @@ def parse(data):</span>
<span class="w"> </span>    :rtype: tuple of int
<span class="w"> </span>    :returns: generator and prime
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return parseBinary(data)</span>
<span class="gi">+    except (SyntaxError, TypeError):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    binData = dePem(data, &quot;DH PARAMETERS&quot;)</span>
<span class="gi">+    return parseBinary(binData)</span>
<span class="gh">diff --git a/tlslite/errors.py b/tlslite/errors.py</span>
<span class="gh">index 31ddafa..b91200f 100644</span>
<span class="gd">--- a/tlslite/errors.py</span>
<span class="gi">+++ b/tlslite/errors.py</span>
<span class="gu">@@ -1,7 +1,13 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Dave Baggett (Arcode Corporation) - Added TLSUnsupportedError.</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Exception classes.&quot;&quot;&quot;
<span class="w"> </span>import socket
<span class="gd">-from .constants import AlertDescription, AlertLevel</span>

<span class="gi">+from .constants import AlertDescription, AlertLevel</span>

<span class="w"> </span>class BaseTLSException(Exception):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -11,11 +17,13 @@ class BaseTLSException(Exception):</span>
<span class="w"> </span>    caught by tlslite
<span class="w"> </span>    consumers
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class EncryptionError(BaseTLSException):
<span class="w"> </span>    &quot;&quot;&quot;Base class for exceptions thrown while encrypting.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -29,6 +37,7 @@ class TLSError(BaseTLSException):</span>

<span class="w"> </span>class TLSClosedConnectionError(TLSError, socket.error):
<span class="w"> </span>    &quot;&quot;&quot;An attempt was made to use the connection after it was closed.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -41,11 +50,13 @@ class TLSAbruptCloseError(TLSError):</span>
<span class="w"> </span>    to truncate the connection.  It could also signify a misbehaving
<span class="w"> </span>    TLS implementation, or a random network failure.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSAlert(TLSError):
<span class="w"> </span>    &quot;&quot;&quot;A TLS alert has been signalled.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -72,7 +83,7 @@ class TLSLocalAlert(TLSAlert):</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        alertStr = AlertDescription.toStr(self.description)
<span class="w"> </span>        if self.message:
<span class="gd">-            return alertStr + &#39;: &#39; + self.message</span>
<span class="gi">+            return alertStr + &quot;: &quot; + self.message</span>
<span class="w"> </span>        else:
<span class="w"> </span>            return alertStr

<span class="gu">@@ -111,30 +122,35 @@ class TLSAuthenticationError(TLSError):</span>
<span class="w"> </span>    the Checker objects to how the other party authenticated, a
<span class="w"> </span>    subclass of this exception will be raised.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSNoAuthenticationError(TLSAuthenticationError):
<span class="w"> </span>    &quot;&quot;&quot;The Checker was expecting the other party to authenticate with a
<span class="w"> </span>    certificate chain, but this did not occur.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSAuthenticationTypeError(TLSAuthenticationError):
<span class="w"> </span>    &quot;&quot;&quot;The Checker was expecting the other party to authenticate with a
<span class="w"> </span>    different type of certificate chain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSFingerprintError(TLSAuthenticationError):
<span class="w"> </span>    &quot;&quot;&quot;The Checker was expecting the other party to authenticate with a
<span class="w"> </span>    certificate chain that matches a different fingerprint.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSAuthorizationError(TLSAuthenticationError):
<span class="w"> </span>    &quot;&quot;&quot;The Checker was expecting the other party to authenticate with a
<span class="w"> </span>    certificate chain that has a different authorization.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -143,6 +159,7 @@ class TLSValidationError(TLSAuthenticationError):</span>
<span class="w"> </span>    chain is invalid.&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, msg, info=None):
<span class="gi">+        # Include a dict containing info about this validation failure</span>
<span class="w"> </span>        TLSAuthenticationError.__init__(self, msg)
<span class="w"> </span>        self.info = info

<span class="gu">@@ -155,12 +172,14 @@ class TLSFaultError(TLSError):</span>
<span class="w"> </span>    set to induce some sort of
<span class="w"> </span>    faulty behavior, and the other party doesn&#39;t respond appropriately.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSUnsupportedError(TLSError):
<span class="w"> </span>    &quot;&quot;&quot;The implementation doesn&#39;t support the requested (or required)
<span class="w"> </span>    capabilities.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -169,21 +188,25 @@ class TLSInternalError(TLSError):</span>

<span class="w"> </span>    Caused by incorrect use of API.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSProtocolException(BaseTLSException):
<span class="w"> </span>    &quot;&quot;&quot;Exceptions used internally for handling errors in received messages&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSIllegalParameterException(TLSProtocolException):
<span class="w"> </span>    &quot;&quot;&quot;Parameters specified in message were incorrect or invalid&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSDecodeError(TLSProtocolException):
<span class="w"> </span>    &quot;&quot;&quot;The received message encoding does not match specification.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -192,59 +215,71 @@ class TLSUnexpectedMessage(TLSProtocolException):</span>
<span class="w"> </span>    The received message was unexpected or parsing of Inner Plaintext
<span class="w"> </span>    failed
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSRecordOverflow(TLSProtocolException):
<span class="w"> </span>    &quot;&quot;&quot;The received record size was too big&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSDecryptionFailed(TLSProtocolException):
<span class="w"> </span>    &quot;&quot;&quot;Decryption of data was unsuccessful&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSBadRecordMAC(TLSProtocolException):
<span class="w"> </span>    &quot;&quot;&quot;Bad MAC (or padding in case of mac-then-encrypt)&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSInsufficientSecurity(TLSProtocolException):
<span class="w"> </span>    &quot;&quot;&quot;Parameters selected by user are too weak&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSUnknownPSKIdentity(TLSProtocolException):
<span class="w"> </span>    &quot;&quot;&quot;The PSK or SRP identity is unknown&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class TLSHandshakeFailure(TLSProtocolException):
<span class="w"> </span>    &quot;&quot;&quot;Could not find acceptable set of handshake parameters&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class MaskTooLongError(EncryptionError):
<span class="w"> </span>    &quot;&quot;&quot;The maskLen passed into function is too high&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class MessageTooLongError(EncryptionError):
<span class="w"> </span>    &quot;&quot;&quot;The message passed into function is too long&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class EncodingError(EncryptionError):
<span class="w"> </span>    &quot;&quot;&quot;An error appeared while encoding&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class InvalidSignature(EncryptionError):
<span class="w"> </span>    &quot;&quot;&quot;Verification function found invalid signature&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class UnknownRSAType(EncryptionError):
<span class="w"> </span>    &quot;&quot;&quot;Unknown RSA algorithm type passed&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass
<span class="gh">diff --git a/tlslite/extensions.py b/tlslite/extensions.py</span>
<span class="gh">index 0f877f7..7d72ce1 100644</span>
<span class="gd">--- a/tlslite/extensions.py</span>
<span class="gi">+++ b/tlslite/extensions.py</span>
<span class="gu">@@ -1,10 +1,18 @@</span>
<span class="gi">+# Copyright (c) 2014, 2015 Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot; Helper package for handling TLS extensions encountered in ClientHello
<span class="w"> </span>and ServerHello messages.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import generators
<span class="w"> </span>from collections import namedtuple
<span class="w"> </span>from .utils.codec import Writer, Parser, DecodeError
<span class="gd">-from .constants import NameType, ExtensionType, CertificateStatusType, SignatureAlgorithm, HashAlgorithm, SignatureScheme, PskKeyExchangeMode, CertificateType, GroupName, ECPointFormat, HeartbeatMode</span>
<span class="gi">+from .constants import NameType, ExtensionType, CertificateStatusType, \</span>
<span class="gi">+        SignatureAlgorithm, HashAlgorithm, SignatureScheme, \</span>
<span class="gi">+        PskKeyExchangeMode, CertificateType, GroupName, ECPointFormat, \</span>
<span class="gi">+        HeartbeatMode</span>
<span class="w"> </span>from .errors import TLSInternalError


<span class="gu">@@ -81,13 +89,15 @@ class TLSExtension(object):</span>
<span class="w"> </span>        and the value is the class. Includes only those extensions that require
<span class="w"> </span>        special handlers for the Hello Retry Request message.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    # actual definition at the end of file, after definitions of all classes</span>
<span class="w"> </span>    _universalExtensions = {}
<span class="w"> </span>    _serverExtensions = {}
<span class="gi">+    # _encryptedExtensions = {}</span>
<span class="w"> </span>    _certificateExtensions = {}
<span class="w"> </span>    _hrrExtensions = {}

<span class="gd">-    def __init__(self, server=False, extType=None, encExt=False, cert=False,</span>
<span class="gd">-        hrr=False):</span>
<span class="gi">+    def __init__(self, server=False, extType=None, encExt=False,</span>
<span class="gi">+                 cert=False, hrr=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Creates a generic TLS extension.

<span class="gu">@@ -126,15 +136,16 @@ class TLSExtension(object):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._extData</span>

<span class="w"> </span>    def _oldCreate(self, extType, data):
<span class="w"> </span>        &quot;&quot;&quot;Legacy handling of create method&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.extType = extType</span>
<span class="gi">+        self._extData = data</span>

<span class="w"> </span>    def _newCreate(self, data):
<span class="w"> </span>        &quot;&quot;&quot;New format for create method&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._extData = data</span>

<span class="w"> </span>    def create(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -156,7 +167,16 @@ class TLSExtension(object):</span>
<span class="w"> </span>        :param bytearray data: raw data representing extension on the wire
<span class="w"> </span>        :rtype: TLSExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # old style</span>
<span class="gi">+        if len(args) + len(kwargs) == 2:</span>
<span class="gi">+            self._oldCreate(*args, **kwargs)</span>
<span class="gi">+        # new style</span>
<span class="gi">+        elif len(args) + len(kwargs) == 1:</span>
<span class="gi">+            self._newCreate(*args, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(&quot;Invalid number of arguments&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns encoded extension, as encoded on the wire
<span class="gu">@@ -170,12 +190,22 @@ class TLSExtension(object):</span>

<span class="w"> </span>        :raises AssertionError: when the object was not initialized
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.extType is not None</span>
<span class="gi">+</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.addTwo(self.extType)</span>
<span class="gi">+        data = self.extData</span>
<span class="gi">+        w.addTwo(len(data))</span>
<span class="gi">+        w.bytes += data</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _parseExt(parser, extType, extLength, extList):
<span class="w"> </span>        &quot;&quot;&quot;Parse a extension using a predefined constructor&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ext = extList[extType]()</span>
<span class="gi">+        extParser = Parser(parser.getFixBytes(extLength))</span>
<span class="gi">+        ext = ext.parse(extParser)</span>
<span class="gi">+        return ext</span>

<span class="w"> </span>    def parse(self, p):
<span class="w"> </span>        &quot;&quot;&quot;Parses extension from on the wire format
<span class="gu">@@ -193,7 +223,31 @@ class TLSExtension(object):</span>

<span class="w"> </span>        :rtype: TLSExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        extType = p.get(2)</span>
<span class="gi">+        try:</span>
<span class="gi">+            extLength = p.get(2)</span>
<span class="gi">+</span>
<span class="gi">+            for handler_t, handlers in (</span>
<span class="gi">+                    (self.cert, self._certificateExtensions),</span>
<span class="gi">+                    # (self.encExtType, self._encryptedExtensions),</span>
<span class="gi">+                    (self.serverType, self._serverExtensions),</span>
<span class="gi">+                    (self.hrr, self._hrrExtensions),</span>
<span class="gi">+                    (True, self._universalExtensions)):</span>
<span class="gi">+                if handler_t and extType in handlers:</span>
<span class="gi">+                    return self._parseExt(p, extType, extLength, handlers)</span>
<span class="gi">+</span>
<span class="gi">+            # if there is no custom handler for the extension, just save the</span>
<span class="gi">+            # extension data as there are extensions which</span>
<span class="gi">+            # don&#39;t require specific handlers and indicate option by mere presence</span>
<span class="gi">+            # also, we need to be able to handle unrecognised extensions in</span>
<span class="gi">+            # ClientHello and CertificateRequest</span>
<span class="gi">+            self.extType = extType</span>
<span class="gi">+            self._extData = p.getFixBytes(extLength)</span>
<span class="gi">+            assert len(self._extData) == extLength</span>
<span class="gi">+        except DecodeError as exc:</span>
<span class="gi">+            raise DecodeError(&quot;Malformed extension (type: {0}): {1}&quot;.format(</span>
<span class="gi">+                ExtensionType.toStr(extType), str(exc)))</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def __eq__(self, that):
<span class="w"> </span>        &quot;&quot;&quot;Test if two TLS extensions are effectively the same
<span class="gu">@@ -204,8 +258,8 @@ class TLSExtension(object):</span>
<span class="w"> </span>        Will return False for every object that&#39;s not an extension.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if hasattr(that, &#39;extType&#39;) and hasattr(that, &#39;extData&#39;):
<span class="gd">-            return (self.extType == that.extType and self.extData == that.</span>
<span class="gd">-                extData)</span>
<span class="gi">+            return self.extType == that.extType and \</span>
<span class="gi">+                    self.extData == that.extData</span>
<span class="w"> </span>        return False

<span class="w"> </span>    def __repr__(self):
<span class="gu">@@ -216,10 +270,11 @@ class TLSExtension(object):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return (</span>
<span class="gd">-            &#39;TLSExtension(extType={0!r}, extData={1!r}, serverType={2!r}, encExtType={3!r})&#39;</span>
<span class="gd">-            .format(self.extType, self.extData, self.serverType, self.</span>
<span class="gd">-            encExtType))</span>
<span class="gi">+        return &quot;TLSExtension(extType={0!r}, extData={1!r},&quot;\</span>
<span class="gi">+               &quot; serverType={2!r}, encExtType={3!r})&quot;.format(self.extType,</span>
<span class="gi">+                                                             self.extData,</span>
<span class="gi">+                                                             self.serverType,</span>
<span class="gi">+                                                             self.encExtType)</span>


<span class="w"> </span>class CustomNameExtension(TLSExtension):
<span class="gu">@@ -231,7 +286,6 @@ class CustomNameExtension(TLSExtension):</span>

<span class="w"> </span>    Must be subclassed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, field_name, extType):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create instance of the class.
<span class="gu">@@ -250,7 +304,7 @@ class CustomNameExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Abstract class&quot;)</span>

<span class="w"> </span>    def create(self, values):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -258,7 +312,8 @@ class CustomNameExtension(TLSExtension):</span>

<span class="w"> </span>        :param list values: list of values to save
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._internal_value = values</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -267,17 +322,19 @@ class CustomNameExtension(TLSExtension):</span>
<span class="w"> </span>        :param tlslite.utils.codec.Parser parser: data
<span class="w"> </span>        :rtype: Extension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Abstract class&quot;)</span>

<span class="w"> </span>    def __getattr__(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Return the special field name value.&quot;&quot;&quot;
<span class="w"> </span>        if name == &#39;_field_name&#39;:
<span class="gd">-            raise AttributeError(&quot;type object &#39;{0}&#39; has no attribute &#39;{1}&#39;&quot;</span>
<span class="gi">+            raise AttributeError(</span>
<span class="gi">+                &quot;type object &#39;{0}&#39; has no attribute &#39;{1}&#39;&quot;</span>
<span class="w"> </span>                .format(self.__class__.__name__, name))
<span class="w"> </span>        if name == self._field_name:
<span class="w"> </span>            return self._internal_value
<span class="gd">-        raise AttributeError(&quot;type object &#39;{0}&#39; has no attribute &#39;{1}&#39;&quot;.</span>
<span class="gd">-            format(self.__class__.__name__, name))</span>
<span class="gi">+        raise AttributeError(</span>
<span class="gi">+            &quot;type object &#39;{0}&#39; has no attribute &#39;{1}&#39;&quot;</span>
<span class="gi">+            .format(self.__class__.__name__, name))</span>

<span class="w"> </span>    def __setattr__(self, name, value):
<span class="w"> </span>        &quot;&quot;&quot;Set the special field value.&quot;&quot;&quot;
<span class="gu">@@ -315,7 +372,12 @@ class VarBytesExtension(CustomNameExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._internal_value is None:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add_var_bytes(self._internal_value, self._length_length)</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise extension from on-the-wire data.
<span class="gu">@@ -323,15 +385,25 @@ class VarBytesExtension(CustomNameExtension):</span>
<span class="w"> </span>        :param tlslite.utils.codec.Parser parser: data
<span class="w"> </span>        :rtype: TLSExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not parser.getRemainingLength():</span>
<span class="gi">+            self._internal_value = None</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        self._internal_value = parser.getVarBytes(self._length_length)</span>
<span class="gi">+</span>
<span class="gi">+        if parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Extra data after extension payload&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        &quot;&quot;&quot;Return human readable representation of the extension.&quot;&quot;&quot;
<span class="w"> </span>        if self._internal_value is not None:
<span class="gd">-            return &#39;{0}(len({1})={2})&#39;.format(self.__class__.__name__, self</span>
<span class="gd">-                ._field_name, len(self._internal_value))</span>
<span class="gd">-        return &#39;{0}({1}=None)&#39;.format(self.__class__.__name__, self._field_name</span>
<span class="gd">-            )</span>
<span class="gi">+            return &quot;{0}(len({1})={2})&quot;.format(self.__class__.__name__,</span>
<span class="gi">+                                              self._field_name,</span>
<span class="gi">+                                              len(self._internal_value))</span>
<span class="gi">+        return &quot;{0}({1}=None)&quot;.format(self.__class__.__name__,</span>
<span class="gi">+                                      self._field_name)</span>


<span class="w"> </span>class ListExtension(CustomNameExtension):
<span class="gu">@@ -357,12 +429,17 @@ class ListExtension(CustomNameExtension):</span>

<span class="w"> </span>    def _list_to_repr(self):
<span class="w"> </span>        &quot;&quot;&quot;Return human redable representation of the item list&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._internal_value or not self._item_enum:</span>
<span class="gi">+            return &quot;{0!r}&quot;.format(self._internal_value)</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;[{0}]&quot;.format(</span>
<span class="gi">+            &quot;, &quot;.join(self._item_enum.toStr(i) for i in self._internal_value))</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        &quot;&quot;&quot;Return human readable representation of the extension.&quot;&quot;&quot;
<span class="gd">-        return &#39;{0}({1}={2})&#39;.format(self.__class__.__name__, self.</span>
<span class="gd">-            _field_name, self._list_to_repr())</span>
<span class="gi">+        return &quot;{0}({1}={2})&quot;.format(self.__class__.__name__,</span>
<span class="gi">+                                     self._field_name,</span>
<span class="gi">+                                     self._list_to_repr())</span>


<span class="w"> </span>class VarListExtension(ListExtension):
<span class="gu">@@ -374,7 +451,7 @@ class VarListExtension(ListExtension):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, elemLength, lengthLength, fieldName, extType,
<span class="gd">-        item_enum=None):</span>
<span class="gi">+                 item_enum=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create handler for extension that has a list of items as payload.

<span class="w"> </span>        :param int elemLength: number of bytes needed to encode single element
<span class="gu">@@ -384,7 +461,7 @@ class VarListExtension(ListExtension):</span>
<span class="w"> </span>        :param class item_enum: TLSEnum class that defines entries in the list
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super(VarListExtension, self).__init__(fieldName, extType=extType,
<span class="gd">-            item_enum=item_enum)</span>
<span class="gi">+                                               item_enum=item_enum)</span>
<span class="w"> </span>        self._elemLength = elemLength
<span class="w"> </span>        self._lengthLength = lengthLength

<span class="gu">@@ -395,7 +472,14 @@ class VarListExtension(ListExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._internal_value is None:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.addVarSeq(self._internal_value,</span>
<span class="gi">+                         self._elemLength,</span>
<span class="gi">+                         self._lengthLength)</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -404,7 +488,17 @@ class VarListExtension(ListExtension):</span>
<span class="w"> </span>        :param tlslite.utils.codec.Parser parser: data
<span class="w"> </span>        :rtype: Extension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if parser.getRemainingLength() == 0:</span>
<span class="gi">+            self._internal_value = None</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        self._internal_value = parser.getVarList(self._elemLength,</span>
<span class="gi">+                                                 self._lengthLength)</span>
<span class="gi">+</span>
<span class="gi">+        if parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Extra data after extension payload&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class VarSeqListExtension(ListExtension):
<span class="gu">@@ -415,8 +509,8 @@ class VarSeqListExtension(ListExtension):</span>
<span class="w"> </span>    of same-sized elements in same-sized tuples
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, elemLength, elemNum, lengthLength, fieldName,</span>
<span class="gd">-        extType, item_enum=None):</span>
<span class="gi">+    def __init__(self, elemLength, elemNum, lengthLength, fieldName, extType,</span>
<span class="gi">+                 item_enum=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a handler for extension that has a list of tuples as payload.

<span class="gu">@@ -429,8 +523,8 @@ class VarSeqListExtension(ListExtension):</span>
<span class="w"> </span>        :param int extType: numerical ID of the extension encoded
<span class="w"> </span>        :param class item_enum: TLSEnum class that defines entries in the list
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        super(VarSeqListExtension, self).__init__(fieldName, extType=</span>
<span class="gd">-            extType, item_enum=item_enum)</span>
<span class="gi">+        super(VarSeqListExtension, self).__init__(fieldName, extType=extType,</span>
<span class="gi">+                                                  item_enum=item_enum)</span>
<span class="w"> </span>        self._elemLength = elemLength
<span class="w"> </span>        self._elemNum = elemNum
<span class="w"> </span>        self._lengthLength = lengthLength
<span class="gu">@@ -442,7 +536,14 @@ class VarSeqListExtension(ListExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._internal_value is None:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.addVarTupleSeq(self._internal_value,</span>
<span class="gi">+                              self._elemLength,</span>
<span class="gi">+                              self._lengthLength)</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -451,7 +552,17 @@ class VarSeqListExtension(ListExtension):</span>
<span class="w"> </span>        :param tlslite.utils.codec.Parser parser: data
<span class="w"> </span>        :rtype: Extension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if parser.getRemainingLength() == 0:</span>
<span class="gi">+            self._internal_value = None</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        self._internal_value = parser.getVarTupleList(self._elemLength,</span>
<span class="gi">+                                                      self._elemNum,</span>
<span class="gi">+                                                      self._lengthLength)</span>
<span class="gi">+        if parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Extra data after extension payload&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class IntExtension(CustomNameExtension):
<span class="gu">@@ -477,12 +588,15 @@ class IntExtension(CustomNameExtension):</span>

<span class="w"> </span>    def _entry_to_repr(self):
<span class="w"> </span>        &quot;&quot;&quot;Return human readable representation of the value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._item_enum:</span>
<span class="gi">+            return self._item_enum.toStr(self._internal_value)</span>
<span class="gi">+        return str(self._internal_value)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        &quot;&quot;&quot;Return human readable representation of the extension.&quot;&quot;&quot;
<span class="gd">-        return &#39;{0}({1}={2})&#39;.format(self.__class__.__name__, self.</span>
<span class="gd">-            _field_name, self._entry_to_repr())</span>
<span class="gi">+        return &quot;{0}({1}={2})&quot;.format(self.__class__.__name__,</span>
<span class="gi">+                                     self._field_name,</span>
<span class="gi">+                                     self._entry_to_repr())</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="gu">@@ -490,7 +604,12 @@ class IntExtension(CustomNameExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._internal_value is None:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add(self._internal_value, self._elem_length)</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -499,7 +618,16 @@ class IntExtension(CustomNameExtension):</span>
<span class="w"> </span>        :param tlslite.utils.codec.Parser parser: data
<span class="w"> </span>        :rtype: Extension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if parser.getRemainingLength() == 0:</span>
<span class="gi">+            self._internal_value = None</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        self._internal_value = parser.get(self._elem_length)</span>
<span class="gi">+</span>
<span class="gi">+        if parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Extra data after extension payload&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class SNIExtension(TLSExtension):
<span class="gu">@@ -544,6 +672,7 @@ class SNIExtension(TLSExtension):</span>
<span class="w"> </span>    :vartype ~.extData: bytearray
<span class="w"> </span>    :ivar ~.extData: raw representation of the extension
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    ServerName = namedtuple(&#39;ServerName&#39;, &#39;name_type name&#39;)

<span class="w"> </span>    def __init__(self):
<span class="gu">@@ -561,7 +690,7 @@ class SNIExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return &#39;SNIExtension(serverNames={0!r})&#39;.format(self.serverNames)</span>
<span class="gi">+        return &quot;SNIExtension(serverNames={0!r})&quot;.format(self.serverNames)</span>

<span class="w"> </span>    def create(self, hostname=None, hostNames=None, serverNames=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -585,7 +714,25 @@ class SNIExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: SNIExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hostname is None and hostNames is None and serverNames is None:</span>
<span class="gi">+            self.serverNames = None</span>
<span class="gi">+            return self</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.serverNames = []</span>
<span class="gi">+</span>
<span class="gi">+        if hostname:</span>
<span class="gi">+            self.serverNames += \</span>
<span class="gi">+                [SNIExtension.ServerName(NameType.host_name, hostname)]</span>
<span class="gi">+</span>
<span class="gi">+        if hostNames:</span>
<span class="gi">+            self.serverNames += \</span>
<span class="gi">+                [SNIExtension.ServerName(NameType.host_name, x) for x in</span>
<span class="gi">+                 hostNames]</span>
<span class="gi">+</span>
<span class="gi">+        if serverNames:</span>
<span class="gi">+            self.serverNames += serverNames</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def hostNames(self):
<span class="gu">@@ -593,7 +740,12 @@ class SNIExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: tuple of bytearrays
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # because we can&#39;t simulate assignments to array elements we return</span>
<span class="gi">+        # an immutable type</span>
<span class="gi">+        if self.serverNames is None:</span>
<span class="gi">+            return tuple()</span>
<span class="gi">+        return tuple([x.name for x in self.serverNames if</span>
<span class="gi">+                      x.name_type == NameType.host_name])</span>

<span class="w"> </span>    @hostNames.setter
<span class="w"> </span>    def hostNames(self, hostNames):
<span class="gu">@@ -606,7 +758,11 @@ class SNIExtension(TLSExtension):</span>
<span class="w"> </span>        :param iterable hostNames: host names (bytearrays) to replace the
<span class="w"> </span>            old server names of type 0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.serverNames = \</span>
<span class="gi">+            [SNIExtension.ServerName(NameType.host_name, x) for x in</span>
<span class="gi">+             hostNames] + \</span>
<span class="gi">+            [x for x in self.serverNames if x.name_type != NameType.host_name]</span>

<span class="w"> </span>    @hostNames.deleter
<span class="w"> </span>    def hostNames(self):
<span class="gu">@@ -614,7 +770,8 @@ class SNIExtension(TLSExtension):</span>
<span class="w"> </span>        Remove all host names from extension, leaves other name types
<span class="w"> </span>        unmodified.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.serverNames = [x for x in self.serverNames if</span>
<span class="gi">+                            x.name_type != NameType.host_name]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="gu">@@ -623,7 +780,20 @@ class SNIExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.serverNames is None:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        w2 = Writer()</span>
<span class="gi">+        for server_name in self.serverNames:</span>
<span class="gi">+            w2.add(server_name.name_type, 1)</span>
<span class="gi">+            w2.add(len(server_name.name), 2)</span>
<span class="gi">+            w2.bytes += server_name.name</span>
<span class="gi">+</span>
<span class="gi">+        # note that when the array is empty we write it as array of length 0</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(len(w2.bytes), 2)</span>
<span class="gi">+        w.bytes += w2.bytes</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -634,7 +804,15 @@ class SNIExtension(TLSExtension):</span>
<span class="w"> </span>            written
<span class="w"> </span>            on the wire, including the type, length and extension data
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        raw_data = self.extData</span>
<span class="gi">+</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(self.extType, 2)</span>
<span class="gi">+        w.add(len(raw_data), 2)</span>
<span class="gi">+        w.bytes += raw_data</span>
<span class="gi">+</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    def parse(self, p):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -648,7 +826,22 @@ class SNIExtension(TLSExtension):</span>
<span class="w"> </span>        :raises DecodeError: when the internal sizes don&#39;t match the attached
<span class="w"> </span>            data
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if p.getRemainingLength() == 0:</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        self.serverNames = []</span>
<span class="gi">+</span>
<span class="gi">+        p.startLengthCheck(2)</span>
<span class="gi">+        while not p.atLengthCheck():</span>
<span class="gi">+            sn_type = p.get(1)</span>
<span class="gi">+            sn_name = p.getVarBytes(2)</span>
<span class="gi">+            self.serverNames += [SNIExtension.ServerName(sn_type, sn_name)]</span>
<span class="gi">+        p.stopLengthCheck()</span>
<span class="gi">+</span>
<span class="gi">+        if p.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Extra data after extension payload&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class SupportedVersionsExtension(VarSeqListExtension):
<span class="gu">@@ -670,8 +863,10 @@ class SupportedVersionsExtension(VarSeqListExtension):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create an instance of SupportedVersionsExtension.&quot;&quot;&quot;
<span class="gd">-        super(SupportedVersionsExtension, self).__init__(1, 2, 1,</span>
<span class="gd">-            &#39;versions&#39;, extType=ExtensionType.supported_versions)</span>
<span class="gi">+        super(SupportedVersionsExtension, self).__init__(</span>
<span class="gi">+            1, 2, 1,</span>
<span class="gi">+            &quot;versions&quot;,</span>
<span class="gi">+            extType=ExtensionType.supported_versions)</span>


<span class="w"> </span>class SrvSupportedVersionsExtension(TLSExtension):
<span class="gu">@@ -691,8 +886,8 @@ class SrvSupportedVersionsExtension(TLSExtension):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self):
<span class="gd">-        super(SrvSupportedVersionsExtension, self).__init__(extType=</span>
<span class="gd">-            ExtensionType.supported_versions)</span>
<span class="gi">+        super(SrvSupportedVersionsExtension, self).__init__(</span>
<span class="gi">+            extType=ExtensionType.supported_versions)</span>
<span class="w"> </span>        self.version = None

<span class="w"> </span>    def __repr__(self):
<span class="gu">@@ -701,8 +896,8 @@ class SrvSupportedVersionsExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return &#39;SrvSupportedVersionsExtension(version={0})&#39;.format(self.version</span>
<span class="gd">-            )</span>
<span class="gi">+        return &quot;SrvSupportedVersionsExtension(version={0})&quot;.format(</span>
<span class="gi">+            self.version)</span>

<span class="w"> </span>    def create(self, version):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -711,7 +906,8 @@ class SrvSupportedVersionsExtension(TLSExtension):</span>
<span class="w"> </span>        :param tuple version: Version selected by server.
<span class="w"> </span>        :rtype: SrvSupportedVersionsExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.version = version</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="gu">@@ -720,7 +916,12 @@ class SrvSupportedVersionsExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.version is None:</span>
<span class="gi">+            return bytearray()</span>
<span class="gi">+</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.addFixSeq(self.version, 1)</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -732,7 +933,12 @@ class SrvSupportedVersionsExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: SrvSupportedVersionsExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.version = tuple(parser.getFixList(1, 2))</span>
<span class="gi">+</span>
<span class="gi">+        if parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Extra data after extension payload&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class ClientCertTypeExtension(VarListExtension):
<span class="gu">@@ -757,8 +963,10 @@ class ClientCertTypeExtension(VarListExtension):</span>

<span class="w"> </span>        See also: :py:meth:`create` and :py:meth:`parse`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        super(ClientCertTypeExtension, self).__init__(1, 1, &#39;certTypes&#39;,</span>
<span class="gd">-            ExtensionType.cert_type, CertificateType)</span>
<span class="gi">+        super(ClientCertTypeExtension, self).__init__(</span>
<span class="gi">+            1, 1, &#39;certTypes&#39;,</span>
<span class="gi">+            ExtensionType.cert_type,</span>
<span class="gi">+            CertificateType)</span>


<span class="w"> </span>class ServerCertTypeExtension(IntExtension):
<span class="gu">@@ -782,8 +990,9 @@ class ServerCertTypeExtension(IntExtension):</span>

<span class="w"> </span>        See also: :py:meth:`create` and :py:meth:`parse`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        super(ServerCertTypeExtension, self).__init__(1, &#39;cert_type&#39;,</span>
<span class="gd">-            ext_type=ExtensionType.cert_type, item_enum=CertificateType)</span>
<span class="gi">+        super(ServerCertTypeExtension, self).__init__(</span>
<span class="gi">+            1, &#39;cert_type&#39;, ext_type=ExtensionType.cert_type,</span>
<span class="gi">+            item_enum=CertificateType)</span>
<span class="w"> </span>        self.serverType = True

<span class="w"> </span>    def parse(self, parser):
<span class="gu">@@ -791,7 +1000,10 @@ class ServerCertTypeExtension(IntExtension):</span>

<span class="w"> </span>        :param Parser p: parser with data
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # generic code allows empty, this ext does not</span>
<span class="gi">+        if not parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Empty payload in extension&quot;)</span>
<span class="gi">+        return super(ServerCertTypeExtension, self).parse(parser)</span>


<span class="w"> </span>class SRPExtension(TLSExtension):
<span class="gu">@@ -816,6 +1028,7 @@ class SRPExtension(TLSExtension):</span>
<span class="w"> </span>        See also: :py:meth:`create` and :py:meth:`parse`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super(SRPExtension, self).__init__(extType=ExtensionType.srp)
<span class="gi">+</span>
<span class="w"> </span>        self.identity = None

<span class="w"> </span>    def __repr__(self):
<span class="gu">@@ -824,7 +1037,7 @@ class SRPExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return &#39;SRPExtension(identity={0!r})&#39;.format(self.identity)</span>
<span class="gi">+        return &quot;SRPExtension(identity={0!r})&quot;.format(self.identity)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="gu">@@ -833,7 +1046,15 @@ class SRPExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if self.identity is None:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(len(self.identity), 1)</span>
<span class="gi">+        w.addFixSeq(self.identity, 1)</span>
<span class="gi">+</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    def create(self, identity=None):
<span class="w"> </span>        &quot;&quot;&quot; Create and instance of SRPExtension with specified protocols
<span class="gu">@@ -844,7 +1065,15 @@ class SRPExtension(TLSExtension):</span>

<span class="w"> </span>        :raises ValueError: when the identity lenght is longer than 2^8-1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if identity is None:</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        if len(identity) &gt;= 2**8:</span>
<span class="gi">+            raise ValueError()</span>
<span class="gi">+</span>
<span class="gi">+        self.identity = identity</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, p):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -856,7 +1085,10 @@ class SRPExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: SRPExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.identity = p.getVarBytes(1)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class NPNExtension(TLSExtension):
<span class="gu">@@ -880,6 +1112,7 @@ class NPNExtension(TLSExtension):</span>
<span class="w"> </span>        See also: :py:meth:`create` and :py:meth:`parse`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super(NPNExtension, self).__init__(extType=ExtensionType.supports_npn)
<span class="gi">+</span>
<span class="w"> </span>        self.protocols = None

<span class="w"> </span>    def __repr__(self):
<span class="gu">@@ -888,7 +1121,7 @@ class NPNExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return &#39;NPNExtension(protocols={0!r})&#39;.format(self.protocols)</span>
<span class="gi">+        return &quot;NPNExtension(protocols={0!r})&quot;.format(self.protocols)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="gu">@@ -896,14 +1129,23 @@ class NPNExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.protocols is None:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        for prot in self.protocols:</span>
<span class="gi">+            w.add(len(prot), 1)</span>
<span class="gi">+            w.addFixSeq(prot, 1)</span>
<span class="gi">+</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    def create(self, protocols=None):
<span class="w"> </span>        &quot;&quot;&quot; Create an instance of NPNExtension with specified protocols

<span class="w"> </span>        :param list protocols: list of protocol names that are supported
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.protocols = protocols</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, p):
<span class="w"> </span>        &quot;&quot;&quot; Parse the extension from on the wire format
<span class="gu">@@ -915,7 +1157,12 @@ class NPNExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: NPNExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.protocols = []</span>
<span class="gi">+</span>
<span class="gi">+        while p.getRemainingLength() &gt; 0:</span>
<span class="gi">+            self.protocols += [p.getVarBytes(1)]</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class TACKExtension(TLSExtension):
<span class="gu">@@ -930,12 +1177,10 @@ class TACKExtension(TLSExtension):</span>
<span class="w"> </span>    :ivar activation_flags: activation flags for the tacks
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-</span>
<span class="w"> </span>    class TACK(object):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Implementation of the single TACK
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>        def __init__(self):
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            Create a single TACK object
<span class="gu">@@ -953,17 +1198,25 @@ class TACKExtension(TLSExtension):</span>

<span class="w"> </span>            :rtype: str
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            return (</span>
<span class="gd">-                &#39;TACK(public_key={0!r}, min_generation={1!r}, generation={2!r}, expiration={3!r}, target_hash={4!r}, signature={5!r})&#39;</span>
<span class="gd">-                .format(self.public_key, self.min_generation, self.</span>
<span class="gd">-                generation, self.expiration, self.target_hash, self.signature))</span>
<span class="gi">+            return &quot;TACK(public_key={0!r}, min_generation={1!r}, &quot;\</span>
<span class="gi">+                   &quot;generation={2!r}, expiration={3!r}, target_hash={4!r}, &quot;\</span>
<span class="gi">+                   &quot;signature={5!r})&quot;\</span>
<span class="gi">+                   .format(self.public_key, self.min_generation,</span>
<span class="gi">+                           self.generation, self.expiration, self.target_hash,</span>
<span class="gi">+                           self.signature)</span>

<span class="w"> </span>        def create(self, public_key, min_generation, generation, expiration,
<span class="gd">-            target_hash, signature):</span>
<span class="gi">+                   target_hash, signature):</span>
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            Initialise the TACK with data
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            self.public_key = public_key</span>
<span class="gi">+            self.min_generation = min_generation</span>
<span class="gi">+            self.generation = generation</span>
<span class="gi">+            self.expiration = expiration</span>
<span class="gi">+            self.target_hash = target_hash</span>
<span class="gi">+            self.signature = signature</span>
<span class="gi">+            return self</span>

<span class="w"> </span>        def write(self):
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gu">@@ -971,7 +1224,20 @@ class TACKExtension(TLSExtension):</span>

<span class="w"> </span>            :rtype: bytearray
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            w = Writer()</span>
<span class="gi">+            if len(self.public_key) != 64:</span>
<span class="gi">+                raise TLSInternalError(&quot;Public_key must be 64 bytes long&quot;)</span>
<span class="gi">+            w.bytes += self.public_key</span>
<span class="gi">+            w.add(self.min_generation, 1)</span>
<span class="gi">+            w.add(self.generation, 1)</span>
<span class="gi">+            w.add(self.expiration, 4)</span>
<span class="gi">+            if len(self.target_hash) != 32:</span>
<span class="gi">+                raise TLSInternalError(&quot;Target_hash must be 32 bytes long&quot;)</span>
<span class="gi">+            w.bytes += self.target_hash</span>
<span class="gi">+            if len(self.signature) != 64:</span>
<span class="gi">+                raise TLSInternalError(&quot;Signature must be 64 bytes long&quot;)</span>
<span class="gi">+            w.bytes += self.signature</span>
<span class="gi">+            return w.bytes</span>

<span class="w"> </span>        def parse(self, p):
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gu">@@ -983,7 +1249,14 @@ class TACKExtension(TLSExtension):</span>
<span class="w"> </span>            :raises DecodeError: when the internal sizes don&#39;t match the
<span class="w"> </span>                provided data
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+</span>
<span class="gi">+            self.public_key = p.getFixBytes(64)</span>
<span class="gi">+            self.min_generation = p.get(1)</span>
<span class="gi">+            self.generation = p.get(1)</span>
<span class="gi">+            self.expiration = p.get(4)</span>
<span class="gi">+            self.target_hash = p.getFixBytes(32)</span>
<span class="gi">+            self.signature = p.getFixBytes(64)</span>
<span class="gi">+            return self</span>

<span class="w"> </span>        def __eq__(self, other):
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gu">@@ -991,15 +1264,18 @@ class TACKExtension(TLSExtension):</span>

<span class="w"> </span>            Returns False for every object that&#39;s not a TACK
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            if hasattr(other, &#39;public_key&#39;) and hasattr(other, &#39;min_generation&#39;</span>
<span class="gd">-                ) and hasattr(other, &#39;generation&#39;) and hasattr(other,</span>
<span class="gd">-                &#39;expiration&#39;) and hasattr(other, &#39;target_hash&#39;) and hasattr(</span>
<span class="gd">-                other, &#39;signature&#39;):</span>
<span class="gd">-                if (self.public_key == other.public_key and self.</span>
<span class="gd">-                    min_generation == other.min_generation and self.</span>
<span class="gd">-                    generation == other.generation and self.expiration ==</span>
<span class="gd">-                    other.expiration and self.target_hash == other.</span>
<span class="gd">-                    target_hash and self.signature == other.signature):</span>
<span class="gi">+            if hasattr(other, &#39;public_key&#39;) and\</span>
<span class="gi">+                    hasattr(other, &#39;min_generation&#39;) and\</span>
<span class="gi">+                    hasattr(other, &#39;generation&#39;) and\</span>
<span class="gi">+                    hasattr(other, &#39;expiration&#39;) and\</span>
<span class="gi">+                    hasattr(other, &#39;target_hash&#39;) and\</span>
<span class="gi">+                    hasattr(other, &#39;signature&#39;):</span>
<span class="gi">+                if self.public_key == other.public_key and\</span>
<span class="gi">+                   self.min_generation == other.min_generation and\</span>
<span class="gi">+                   self.generation == other.generation and\</span>
<span class="gi">+                   self.expiration == other.expiration and\</span>
<span class="gi">+                   self.target_hash == other.target_hash and\</span>
<span class="gi">+                   self.signature == other.signature:</span>
<span class="w"> </span>                    return True
<span class="w"> </span>                else:
<span class="w"> </span>                    return False
<span class="gu">@@ -1013,6 +1289,7 @@ class TACKExtension(TLSExtension):</span>
<span class="w"> </span>        See also: :py:meth:`create` and :py:meth`parse`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super(TACKExtension, self).__init__(extType=ExtensionType.tack)
<span class="gi">+</span>
<span class="w"> </span>        self.tacks = []
<span class="w"> </span>        self.activation_flags = 0

<span class="gu">@@ -1022,8 +1299,8 @@ class TACKExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return &#39;TACKExtension(activation_flags={0!r}, tacks={1!r})&#39;.format(self</span>
<span class="gd">-            .activation_flags, self.tacks)</span>
<span class="gi">+        return &quot;TACKExtension(activation_flags={0!r}, tacks={1!r})&quot;\</span>
<span class="gi">+               .format(self.activation_flags, self.tacks)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="gu">@@ -1032,7 +1309,15 @@ class TACKExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w2 = Writer()</span>
<span class="gi">+        for t in self.tacks:</span>
<span class="gi">+            w2.bytes += t.write()</span>
<span class="gi">+</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(len(w2.bytes), 2)</span>
<span class="gi">+        w.bytes += w2.bytes</span>
<span class="gi">+        w.add(self.activation_flags, 1)</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    def create(self, tacks, activation_flags):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1040,7 +1325,10 @@ class TACKExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: TACKExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.tacks = tacks</span>
<span class="gi">+        self.activation_flags = activation_flags</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, p):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1050,7 +1338,16 @@ class TACKExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: TACKExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.tacks = []</span>
<span class="gi">+</span>
<span class="gi">+        p.startLengthCheck(2)</span>
<span class="gi">+        while not p.atLengthCheck():</span>
<span class="gi">+            tack = TACKExtension.TACK().parse(p)</span>
<span class="gi">+            self.tacks += [tack]</span>
<span class="gi">+        p.stopLengthCheck()</span>
<span class="gi">+        self.activation_flags = p.get(1)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class SupportedGroupsExtension(VarListExtension):
<span class="gu">@@ -1065,8 +1362,10 @@ class SupportedGroupsExtension(VarListExtension):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of class&quot;&quot;&quot;
<span class="gd">-        super(SupportedGroupsExtension, self).__init__(2, 2, &#39;groups&#39;,</span>
<span class="gd">-            ExtensionType.supported_groups, GroupName)</span>
<span class="gi">+        super(SupportedGroupsExtension, self).__init__(</span>
<span class="gi">+            2, 2, &#39;groups&#39;,</span>
<span class="gi">+            ExtensionType.supported_groups,</span>
<span class="gi">+            GroupName)</span>


<span class="w"> </span>class ECPointFormatsExtension(VarListExtension):
<span class="gu">@@ -1081,8 +1380,10 @@ class ECPointFormatsExtension(VarListExtension):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of class&quot;&quot;&quot;
<span class="gd">-        super(ECPointFormatsExtension, self).__init__(1, 1, &#39;formats&#39;,</span>
<span class="gd">-            ExtensionType.ec_point_formats, ECPointFormat)</span>
<span class="gi">+        super(ECPointFormatsExtension, self).__init__(</span>
<span class="gi">+            1, 1, &#39;formats&#39;,</span>
<span class="gi">+            ExtensionType.ec_point_formats,</span>
<span class="gi">+            ECPointFormat)</span>


<span class="w"> </span>class _SigListExt(VarSeqListExtension):
<span class="gu">@@ -1097,7 +1398,18 @@ class _SigListExt(VarSeqListExtension):</span>
<span class="w"> </span>        Override the one from ListExtension to be able to handle legacy
<span class="w"> </span>        signature algorithms.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.sigalgs is None:</span>
<span class="gi">+            return &quot;None&quot;</span>
<span class="gi">+</span>
<span class="gi">+        values = []</span>
<span class="gi">+        for alg in self.sigalgs:</span>
<span class="gi">+            name = SignatureScheme.toRepr(alg)</span>
<span class="gi">+            if name is None:</span>
<span class="gi">+                name = &quot;({0}, {1})&quot;.format(HashAlgorithm.toStr(alg[0]),</span>
<span class="gi">+                                           SignatureAlgorithm.toStr(alg[1]))</span>
<span class="gi">+            values.append(name)</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;[{0}]&quot;.format(&quot;, &quot;.join(values))</span>


<span class="w"> </span>class SignatureAlgorithmsExtension(_SigListExt):
<span class="gu">@@ -1112,8 +1424,11 @@ class SignatureAlgorithmsExtension(_SigListExt):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of class&quot;&quot;&quot;
<span class="gd">-        super(SignatureAlgorithmsExtension, self).__init__(1, 2, 2,</span>
<span class="gd">-            &#39;sigalgs&#39;, ExtensionType.signature_algorithms, SignatureScheme)</span>
<span class="gi">+        super(SignatureAlgorithmsExtension, self).__init__(</span>
<span class="gi">+            1, 2, 2,</span>
<span class="gi">+            &#39;sigalgs&#39;,</span>
<span class="gi">+            ExtensionType.signature_algorithms,</span>
<span class="gi">+            SignatureScheme)</span>


<span class="w"> </span>class SignatureAlgorithmsCertExtension(_SigListExt):
<span class="gu">@@ -1128,9 +1443,11 @@ class SignatureAlgorithmsCertExtension(_SigListExt):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of class.&quot;&quot;&quot;
<span class="gd">-        super(SignatureAlgorithmsCertExtension, self).__init__(1, 2, 2,</span>
<span class="gd">-            &#39;sigalgs&#39;, ExtensionType.signature_algorithms_cert, SignatureScheme</span>
<span class="gd">-            )</span>
<span class="gi">+        super(SignatureAlgorithmsCertExtension, self).__init__(</span>
<span class="gi">+            1, 2, 2,</span>
<span class="gi">+            &#39;sigalgs&#39;,</span>
<span class="gi">+            ExtensionType.signature_algorithms_cert,</span>
<span class="gi">+            SignatureScheme)</span>


<span class="w"> </span>class PaddingExtension(TLSExtension):
<span class="gu">@@ -1157,7 +1474,7 @@ class PaddingExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.paddingData</span>

<span class="w"> </span>    def create(self, size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1165,7 +1482,8 @@ class PaddingExtension(TLSExtension):</span>

<span class="w"> </span>        :param int size: required padding size in bytes
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.paddingData = bytearray(size)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, p):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1178,7 +1496,8 @@ class PaddingExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: TLSExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.paddingData = p.getFixBytes(p.getRemainingLength())</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class RenegotiationInfoExtension(VarBytesExtension):
<span class="gu">@@ -1193,7 +1512,9 @@ class RenegotiationInfoExtension(VarBytesExtension):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create instance&quot;&quot;&quot;
<span class="w"> </span>        extType = ExtensionType.renegotiation_info
<span class="w"> </span>        super(RenegotiationInfoExtension, self).__init__(
<span class="gd">-            &#39;renegotiated_connection&#39;, 1, extType)</span>
<span class="gi">+            &#39;renegotiated_connection&#39;,</span>
<span class="gi">+            1,</span>
<span class="gi">+            extType)</span>


<span class="w"> </span>class ALPNExtension(TLSExtension):
<span class="gu">@@ -1217,6 +1538,7 @@ class ALPNExtension(TLSExtension):</span>
<span class="w"> </span>        See also: :py:meth:`create` and :py:meth:`parse`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super(ALPNExtension, self).__init__(extType=ExtensionType.alpn)
<span class="gi">+</span>
<span class="w"> </span>        self.protocol_names = None

<span class="w"> </span>    def __repr__(self):
<span class="gu">@@ -1225,8 +1547,8 @@ class ALPNExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return &#39;ALPNExtension(protocol_names={0!r})&#39;.format(self.protocol_names</span>
<span class="gd">-            )</span>
<span class="gi">+        return &quot;ALPNExtension(protocol_names={0!r})&quot;\</span>
<span class="gi">+               .format(self.protocol_names)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="gu">@@ -1235,7 +1557,19 @@ class ALPNExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.protocol_names is None:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        for prot in self.protocol_names:</span>
<span class="gi">+            writer.add(len(prot), 1)</span>
<span class="gi">+            writer.bytes += prot</span>
<span class="gi">+</span>
<span class="gi">+        writer2 = Writer()</span>
<span class="gi">+        writer2.add(len(writer.bytes), 2)</span>
<span class="gi">+        writer2.bytes += writer.bytes</span>
<span class="gi">+</span>
<span class="gi">+        return writer2.bytes</span>

<span class="w"> </span>    def create(self, protocol_names=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1243,7 +1577,8 @@ class ALPNExtension(TLSExtension):</span>

<span class="w"> </span>        :param list protocols: list of protocol names that are to be sent
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.protocol_names = protocol_names</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1256,7 +1591,15 @@ class ALPNExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: ALPNExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.protocol_names = []</span>
<span class="gi">+        parser.startLengthCheck(2)</span>
<span class="gi">+        while not parser.atLengthCheck():</span>
<span class="gi">+            name_len = parser.get(1)</span>
<span class="gi">+            self.protocol_names.append(parser.getFixBytes(name_len))</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        if parser.getRemainingLength() != 0:</span>
<span class="gi">+            raise DecodeError(&quot;Trailing data after protocol_name_list&quot;)</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class StatusRequestExtension(TLSExtension):
<span class="gu">@@ -1277,8 +1620,8 @@ class StatusRequestExtension(TLSExtension):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of StatusRequestExtension.&quot;&quot;&quot;
<span class="gd">-        super(StatusRequestExtension, self).__init__(extType=ExtensionType.</span>
<span class="gd">-            status_request)</span>
<span class="gi">+        super(StatusRequestExtension, self).__init__(</span>
<span class="gi">+            extType=ExtensionType.status_request)</span>
<span class="w"> </span>        self.status_type = None
<span class="w"> </span>        self.responder_id_list = []
<span class="w"> </span>        self.request_extensions = bytearray()
<span class="gu">@@ -1289,10 +1632,11 @@ class StatusRequestExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return (</span>
<span class="gd">-            &#39;StatusRequestExtension(status_type={0}, responder_id_list={1!r}, request_extensions={2!r})&#39;</span>
<span class="gd">-            .format(self.status_type, self.responder_id_list, self.</span>
<span class="gd">-            request_extensions))</span>
<span class="gi">+        return (&quot;StatusRequestExtension(status_type={0}, &quot;</span>
<span class="gi">+                &quot;responder_id_list={1!r}, &quot;</span>
<span class="gi">+                &quot;request_extensions={2!r})&quot;).format(</span>
<span class="gi">+                    self.status_type, self.responder_id_list,</span>
<span class="gi">+                    self.request_extensions)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="gu">@@ -1301,10 +1645,25 @@ class StatusRequestExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.status_type is None:</span>
<span class="gi">+            return bytearray()</span>
<span class="gi">+</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add(self.status_type, 1)</span>
<span class="gi">+        writer2 = Writer()</span>
<span class="gi">+        for i in self.responder_id_list:</span>
<span class="gi">+            writer2.add(len(i), 2)</span>
<span class="gi">+            writer2.bytes += i</span>
<span class="gi">+        writer.add(len(writer2.bytes), 2)</span>
<span class="gi">+        writer.bytes += writer2.bytes</span>
<span class="gi">+        writer.add(len(self.request_extensions), 2)</span>
<span class="gi">+        writer.bytes += self.request_extensions</span>
<span class="gi">+</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def create(self, status_type=CertificateStatusType.ocsp,
<span class="gd">-        responder_id_list=tuple(), request_extensions=b&#39;&#39;):</span>
<span class="gi">+               responder_id_list=tuple(),</span>
<span class="gi">+               request_extensions=b&#39;&#39;):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create an instance of StatusRequestExtension with specified options.

<span class="gu">@@ -1317,7 +1676,10 @@ class StatusRequestExtension(TLSExtension):</span>
<span class="w"> </span>        :param bytearray request_extensions: DER encoding of requested OCSP
<span class="w"> </span>            extensions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.status_type = status_type</span>
<span class="gi">+        self.responder_id_list = list(responder_id_list)</span>
<span class="gi">+        self.request_extensions = bytearray(request_extensions)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1327,7 +1689,23 @@ class StatusRequestExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: StatusRequestExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # handling of server side message</span>
<span class="gi">+        if parser.getRemainingLength() == 0:</span>
<span class="gi">+            self.status_type = None</span>
<span class="gi">+            self.responder_id_list = []</span>
<span class="gi">+            self.request_extensions = bytearray()</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        self.status_type = parser.get(1)</span>
<span class="gi">+        self.responder_id_list = []</span>
<span class="gi">+        parser.startLengthCheck(2)</span>
<span class="gi">+        while not parser.atLengthCheck():</span>
<span class="gi">+            self.responder_id_list.append(parser.getVarBytes(2))</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        self.request_extensions = parser.getVarBytes(2)</span>
<span class="gi">+        if parser.getRemainingLength() != 0:</span>
<span class="gi">+            raise DecodeError(&quot;Trailing data after CertificateStatusRequest&quot;)</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class CertificateStatusExtension(TLSExtension):
<span class="gu">@@ -1335,23 +1713,36 @@ class CertificateStatusExtension(TLSExtension):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of CertificateStatusExtension.&quot;&quot;&quot;
<span class="gd">-        super(CertificateStatusExtension, self).__init__(extType=</span>
<span class="gd">-            ExtensionType.status_request)</span>
<span class="gi">+        super(CertificateStatusExtension, self).__init__(</span>
<span class="gi">+            extType=ExtensionType.status_request)</span>
<span class="w"> </span>        self.status_type = None
<span class="w"> </span>        self.response = None

<span class="w"> </span>    def create(self, status_type, response):
<span class="w"> </span>        &quot;&quot;&quot;Set values of the extension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.status_type = status_type</span>
<span class="gi">+        self.response = response</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise the data from on the wire representation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.status_type = parser.get(1)</span>
<span class="gi">+        if self.status_type == 1:</span>
<span class="gi">+            self.response = parser.getVarBytes(3)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise DecodeError(&quot;Unrecognised type&quot;)</span>
<span class="gi">+        if parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Trailing data&quot;)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise the object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add(self.status_type, 1)</span>
<span class="gi">+        writer.addVarSeq(self.response, 1, 3)</span>
<span class="gi">+</span>
<span class="gi">+        return writer.bytes</span>


<span class="w"> </span>class KeyShareEntry(object):
<span class="gu">@@ -1373,7 +1764,10 @@ class KeyShareEntry(object):</span>
<span class="w"> </span>            encoded during serialisation)
<span class="w"> </span>        :rtype: KeyShareEntry
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.group = group</span>
<span class="gi">+        self.key_exchange = key_exchange</span>
<span class="gi">+        self.private = private</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1383,7 +1777,9 @@ class KeyShareEntry(object):</span>

<span class="w"> </span>        :rtype: KeyShareEntry
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.group = parser.get(2)</span>
<span class="gi">+        self.key_exchange = parser.getVarBytes(2)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self, writer):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1391,12 +1787,15 @@ class KeyShareEntry(object):</span>

<span class="w"> </span>        :param Writer writer: buffer to write the data to
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer.addTwo(self.group)</span>
<span class="gi">+        writer.addTwo(len(self.key_exchange))</span>
<span class="gi">+        writer.bytes += self.key_exchange</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns human readable representation of the extension.&quot;&quot;&quot;
<span class="gd">-        return &#39;KeyShareEntry(group={0},key_exchange={1})&#39;.format(GroupName</span>
<span class="gd">-            .toStr(self.group), repr(self.key_exchange))</span>
<span class="gi">+        return &quot;KeyShareEntry(group={0},key_exchange={1})&quot;.format(</span>
<span class="gi">+            GroupName.toStr(self.group),</span>
<span class="gi">+            repr(self.key_exchange))</span>


<span class="w"> </span>class HeartbeatExtension(IntExtension):
<span class="gu">@@ -1406,14 +1805,17 @@ class HeartbeatExtension(IntExtension):</span>
<span class="w"> </span>    :type mode: int
<span class="w"> </span>    :ivar mode: mode if peer is allowed or nor allowed to send responses
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="gd">-        super(HeartbeatExtension, self).__init__(1, &#39;mode&#39;, ext_type=</span>
<span class="gd">-            ExtensionType.heartbeat, item_enum=HeartbeatMode)</span>
<span class="gi">+        super(HeartbeatExtension, self).__init__(</span>
<span class="gi">+            1, &#39;mode&#39;, ext_type=ExtensionType.heartbeat,</span>
<span class="gi">+            item_enum=HeartbeatMode)</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise the extension from on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # the generic class allows for missing values, it&#39;s not allowed here</span>
<span class="gi">+        if not parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Empty extension payload&quot;)</span>
<span class="gi">+        return super(HeartbeatExtension, self).parse(parser)</span>


<span class="w"> </span>class ClientKeyShareExtension(TLSExtension):
<span class="gu">@@ -1425,8 +1827,8 @@ class ClientKeyShareExtension(TLSExtension):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of the object.&quot;&quot;&quot;
<span class="gd">-        super(ClientKeyShareExtension, self).__init__(extType=ExtensionType</span>
<span class="gd">-            .key_share)</span>
<span class="gi">+        super(ClientKeyShareExtension, self).__init__(extType=ExtensionType.</span>
<span class="gi">+                                                      key_share)</span>
<span class="w"> </span>        self.client_shares = None

<span class="w"> </span>    @property
<span class="gu">@@ -1436,11 +1838,20 @@ class ClientKeyShareExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        shares = Writer()</span>
<span class="gi">+        for share in self.client_shares:</span>
<span class="gi">+            share.write(shares)</span>
<span class="gi">+</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.addTwo(len(shares.bytes))</span>
<span class="gi">+        w.bytes += shares.bytes</span>
<span class="gi">+</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    def create(self, client_shares):
<span class="w"> </span>        &quot;&quot;&quot;Set the advertised client shares in the extension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.client_shares = client_shares</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1452,12 +1863,27 @@ class ClientKeyShareExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: ClientKeyShareExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not parser.getRemainingLength():</span>
<span class="gi">+            self.client_shares = None</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        self.client_shares = []</span>
<span class="gi">+        parser.startLengthCheck(2)</span>
<span class="gi">+</span>
<span class="gi">+        while not parser.atLengthCheck():</span>
<span class="gi">+            self.client_shares.append(KeyShareEntry().parse(parser))</span>
<span class="gi">+</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+</span>
<span class="gi">+        if parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Trailing data in client Key Share extension&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        &quot;&quot;&quot;Output human readable representation of the object.&quot;&quot;&quot;
<span class="gd">-        return &#39;ClientKeyShareExtension(client_shares=[{0}])&#39;.format(&#39;,&#39;.</span>
<span class="gd">-            join(repr(i) for i in self.client_shares))</span>
<span class="gi">+        return &quot;ClientKeyShareExtension(client_shares=[{0}])&quot;.format(</span>
<span class="gi">+            &quot;,&quot;.join(repr(i) for i in self.client_shares))</span>


<span class="w"> </span>class ServerKeyShareExtension(TLSExtension):
<span class="gu">@@ -1469,18 +1895,25 @@ class ServerKeyShareExtension(TLSExtension):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of the object.&quot;&quot;&quot;
<span class="gd">-        super(ServerKeyShareExtension, self).__init__(extType=ExtensionType</span>
<span class="gd">-            .key_share, server=True)</span>
<span class="gi">+        super(ServerKeyShareExtension, self).__init__(extType=ExtensionType.</span>
<span class="gi">+                                                      key_share,</span>
<span class="gi">+                                                      server=True)</span>
<span class="w"> </span>        self.server_share = None

<span class="w"> </span>    def create(self, server_share):
<span class="w"> </span>        &quot;&quot;&quot;Set the advertised server share in the extension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.server_share = server_share</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise the payload of the extension&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.server_share is None:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        self.server_share.write(w)</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1490,7 +1923,16 @@ class ServerKeyShareExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: ServerKeyShareExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not parser.getRemainingLength():</span>
<span class="gi">+            self.server_share = None</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        self.server_share = KeyShareEntry().parse(parser)</span>
<span class="gi">+</span>
<span class="gi">+        if parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Trailing data in server Key Share extension&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class HRRKeyShareExtension(TLSExtension):
<span class="gu">@@ -1500,21 +1942,27 @@ class HRRKeyShareExtension(TLSExtension):</span>
<span class="w"> </span>    Extension for notifying the client of the server selected group for
<span class="w"> </span>    key exchange.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of the object.&quot;&quot;&quot;
<span class="w"> </span>        super(HRRKeyShareExtension, self).__init__(extType=ExtensionType.
<span class="gd">-            key_share, hrr=True)</span>
<span class="gi">+                                                   key_share,</span>
<span class="gi">+                                                   hrr=True)</span>
<span class="w"> </span>        self.selected_group = None

<span class="w"> </span>    def create(self, selected_group):
<span class="w"> </span>        &quot;&quot;&quot;Set the selected group in the extension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.selected_group = selected_group</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise the payload of the extension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.selected_group is None:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(self.selected_group, 2)</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Parse the extension from on the wire format.
<span class="gu">@@ -1523,12 +1971,16 @@ class HRRKeyShareExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: HRRKeyShareExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.selected_group = parser.get(2)</span>
<span class="gi">+</span>
<span class="gi">+        if parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Trailing data in HRR Key Share extension&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class PskIdentity(object):
<span class="w"> </span>    &quot;&quot;&quot;Handling of PskIdentity from PreSharedKey Extension.&quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of class.&quot;&quot;&quot;
<span class="w"> </span>        super(PskIdentity, self).__init__()
<span class="gu">@@ -1537,41 +1989,88 @@ class PskIdentity(object):</span>

<span class="w"> </span>    def create(self, identity, obf_ticket_age):
<span class="w"> </span>        &quot;&quot;&quot;Initialise instance.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.identity = identity</span>
<span class="gi">+        self.obfuscated_ticket_age = obf_ticket_age</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise the object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.addTwo(len(self.identity))</span>
<span class="gi">+        writer.bytes += self.identity</span>
<span class="gi">+        writer.addFour(self.obfuscated_ticket_age)</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Deserialize the object from bytearray.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.identity = parser.getVarBytes(2)</span>
<span class="gi">+        self.obfuscated_ticket_age = parser.get(4)</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class PreSharedKeyExtension(TLSExtension):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Class for handling Pre Shared Key negotiation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of class.&quot;&quot;&quot;
<span class="gd">-        super(PreSharedKeyExtension, self).__init__(extType=ExtensionType.</span>
<span class="gd">-            pre_shared_key)</span>
<span class="gi">+        super(PreSharedKeyExtension, self).__init__(</span>
<span class="gi">+            extType=ExtensionType.pre_shared_key)</span>
<span class="w"> </span>        self.identities = None
<span class="w"> </span>        self.binders = None

<span class="w"> </span>    def create(self, identities, binders):
<span class="w"> </span>        &quot;&quot;&quot;Set list of offered PSKs.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.identities = identities</span>
<span class="gi">+        self.binders = binders</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise the payload of the extension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.identities is None:</span>
<span class="gi">+            return bytearray()</span>
<span class="gi">+</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+</span>
<span class="gi">+        iden_writer = Writer()</span>
<span class="gi">+        for i in self.identities:</span>
<span class="gi">+            iden_writer.bytes += i.write()</span>
<span class="gi">+        writer.add(len(iden_writer.bytes), 2)</span>
<span class="gi">+        writer.bytes += iden_writer.bytes</span>
<span class="gi">+</span>
<span class="gi">+        binder_writer = Writer()</span>
<span class="gi">+        for i in self.binders:</span>
<span class="gi">+            binder_writer.add(len(i), 1)</span>
<span class="gi">+            binder_writer.bytes += i</span>
<span class="gi">+        writer.add(len(binder_writer.bytes), 2)</span>
<span class="gi">+        writer.bytes += binder_writer.bytes</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Parse the extension from on the wire format.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not parser.getRemainingLength():</span>
<span class="gi">+            self.identities = None</span>
<span class="gi">+            self.binders = None</span>
<span class="gi">+            return self</span>
<span class="gi">+</span>
<span class="gi">+        # PskIdentity identities&lt;7..2^16-1&gt;;</span>
<span class="gi">+        parser.startLengthCheck(2)</span>
<span class="gi">+        self.identities = []</span>
<span class="gi">+        while not parser.atLengthCheck():</span>
<span class="gi">+            self.identities.append(PskIdentity().parse(parser))</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+</span>
<span class="gi">+        # PskBinderEntry binders&lt;33..2^16-1&gt;;</span>
<span class="gi">+        parser.startLengthCheck(2)</span>
<span class="gi">+        self.binders = []</span>
<span class="gi">+        while not parser.atLengthCheck():</span>
<span class="gi">+            self.binders.append(parser.getVarBytes(1))</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+</span>
<span class="gi">+        if parser.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Trailing data after binders field&quot;)</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class SrvPreSharedKeyExtension(IntExtension):
<span class="gu">@@ -1579,8 +2078,8 @@ class SrvPreSharedKeyExtension(IntExtension):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of class.&quot;&quot;&quot;
<span class="gd">-        super(SrvPreSharedKeyExtension, self).__init__(2, &#39;selected&#39;,</span>
<span class="gd">-            ext_type=ExtensionType.pre_shared_key)</span>
<span class="gi">+        super(SrvPreSharedKeyExtension, self).__init__(</span>
<span class="gi">+            2, &#39;selected&#39;, ext_type=ExtensionType.pre_shared_key)</span>


<span class="w"> </span>class PskKeyExchangeModesExtension(VarListExtension):
<span class="gu">@@ -1588,8 +2087,10 @@ class PskKeyExchangeModesExtension(VarListExtension):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of class.&quot;&quot;&quot;
<span class="gd">-        super(PskKeyExchangeModesExtension, self).__init__(1, 1, &#39;modes&#39;,</span>
<span class="gd">-            ExtensionType.psk_key_exchange_modes, PskKeyExchangeMode)</span>
<span class="gi">+        super(PskKeyExchangeModesExtension, self).__init__(</span>
<span class="gi">+            1, 1, &#39;modes&#39;,</span>
<span class="gi">+            ExtensionType.psk_key_exchange_modes,</span>
<span class="gi">+            PskKeyExchangeMode)</span>


<span class="w"> </span>class CookieExtension(VarBytesExtension):
<span class="gu">@@ -1606,25 +2107,34 @@ class RecordSizeLimitExtension(IntExtension):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance.&quot;&quot;&quot;
<span class="gd">-        super(RecordSizeLimitExtension, self).__init__(2,</span>
<span class="gd">-            &#39;record_size_limit&#39;, ExtensionType.record_size_limit)</span>
<span class="gi">+        super(RecordSizeLimitExtension, self).__init__(</span>
<span class="gi">+            2, &#39;record_size_limit&#39;, ExtensionType.record_size_limit)</span>


<span class="w"> </span>class SessionTicketExtension(TLSExtension):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Client and server session ticket extension from RFC 5077
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create instance of the object.&quot;&quot;&quot;
<span class="w"> </span>        super(SessionTicketExtension, self).__init__(extType=ExtensionType.
<span class="gd">-            session_ticket)</span>
<span class="gi">+                                                     session_ticket)</span>
<span class="w"> </span>        self.ticket = None

<span class="gi">+    def create(self, ticket):</span>
<span class="gi">+</span>
<span class="gi">+        self.ticket = ticket</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def extData(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise the payload of the extension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.ticket:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.bytes += self.ticket</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1634,39 +2144,57 @@ class SessionTicketExtension(TLSExtension):</span>

<span class="w"> </span>        :rtype: SessionTicketExtension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not parser.getRemainingLength():</span>
<span class="gi">+            self.ticket = bytearray(0)</span>
<span class="gi">+            return self</span>
<span class="gi">+        self.ticket = parser.getFixBytes(parser.getRemainingLength())</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        &quot;&quot;&quot;Return human readable representation of the extension.&quot;&quot;&quot;
<span class="gd">-        return &#39;{0}({1}={2!r})&#39;.format(self.__class__.__name__, &#39;ticket&#39;,</span>
<span class="gd">-            self.ticket)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-TLSExtension._universalExtensions = {ExtensionType.server_name:</span>
<span class="gd">-    SNIExtension, ExtensionType.status_request: StatusRequestExtension,</span>
<span class="gd">-    ExtensionType.cert_type: ClientCertTypeExtension, ExtensionType.</span>
<span class="gd">-    supported_groups: SupportedGroupsExtension, ExtensionType.</span>
<span class="gd">-    ec_point_formats: ECPointFormatsExtension, ExtensionType.srp:</span>
<span class="gd">-    SRPExtension, ExtensionType.signature_algorithms:</span>
<span class="gd">-    SignatureAlgorithmsExtension, ExtensionType.alpn: ALPNExtension,</span>
<span class="gd">-    ExtensionType.supports_npn: NPNExtension, ExtensionType.</span>
<span class="gd">-    client_hello_padding: PaddingExtension, ExtensionType.</span>
<span class="gd">-    renegotiation_info: RenegotiationInfoExtension, ExtensionType.heartbeat:</span>
<span class="gd">-    HeartbeatExtension, ExtensionType.supported_versions:</span>
<span class="gd">-    SupportedVersionsExtension, ExtensionType.key_share:</span>
<span class="gd">-    ClientKeyShareExtension, ExtensionType.signature_algorithms_cert:</span>
<span class="gd">-    SignatureAlgorithmsCertExtension, ExtensionType.pre_shared_key:</span>
<span class="gd">-    PreSharedKeyExtension, ExtensionType.psk_key_exchange_modes:</span>
<span class="gd">-    PskKeyExchangeModesExtension, ExtensionType.cookie: CookieExtension,</span>
<span class="gd">-    ExtensionType.record_size_limit: RecordSizeLimitExtension,</span>
<span class="gd">-    ExtensionType.session_ticket: SessionTicketExtension}</span>
<span class="gd">-TLSExtension._serverExtensions = {ExtensionType.cert_type:</span>
<span class="gd">-    ServerCertTypeExtension, ExtensionType.tack: TACKExtension,</span>
<span class="gd">-    ExtensionType.key_share: ServerKeyShareExtension, ExtensionType.</span>
<span class="gd">-    supported_versions: SrvSupportedVersionsExtension, ExtensionType.</span>
<span class="gd">-    pre_shared_key: SrvPreSharedKeyExtension}</span>
<span class="gd">-TLSExtension._certificateExtensions = {ExtensionType.status_request:</span>
<span class="gd">-    CertificateStatusExtension}</span>
<span class="gd">-TLSExtension._hrrExtensions = {ExtensionType.key_share:</span>
<span class="gd">-    HRRKeyShareExtension, ExtensionType.supported_versions:</span>
<span class="gd">-    SrvSupportedVersionsExtension}</span>
<span class="gi">+        return &quot;{0}({1}={2!r})&quot;.format(self.__class__.__name__,</span>
<span class="gi">+                                       &quot;ticket&quot;,</span>
<span class="gi">+                                       self.ticket)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+TLSExtension._universalExtensions = \</span>
<span class="gi">+    {</span>
<span class="gi">+        ExtensionType.server_name: SNIExtension,</span>
<span class="gi">+        ExtensionType.status_request: StatusRequestExtension,</span>
<span class="gi">+        ExtensionType.cert_type: ClientCertTypeExtension,</span>
<span class="gi">+        ExtensionType.supported_groups: SupportedGroupsExtension,</span>
<span class="gi">+        ExtensionType.ec_point_formats: ECPointFormatsExtension,</span>
<span class="gi">+        ExtensionType.srp: SRPExtension,</span>
<span class="gi">+        ExtensionType.signature_algorithms: SignatureAlgorithmsExtension,</span>
<span class="gi">+        ExtensionType.alpn: ALPNExtension,</span>
<span class="gi">+        ExtensionType.supports_npn: NPNExtension,</span>
<span class="gi">+        ExtensionType.client_hello_padding: PaddingExtension,</span>
<span class="gi">+        ExtensionType.renegotiation_info: RenegotiationInfoExtension,</span>
<span class="gi">+        ExtensionType.heartbeat: HeartbeatExtension,</span>
<span class="gi">+        ExtensionType.supported_versions: SupportedVersionsExtension,</span>
<span class="gi">+        ExtensionType.key_share: ClientKeyShareExtension,</span>
<span class="gi">+        ExtensionType.signature_algorithms_cert:</span>
<span class="gi">+            SignatureAlgorithmsCertExtension,</span>
<span class="gi">+        ExtensionType.pre_shared_key: PreSharedKeyExtension,</span>
<span class="gi">+        ExtensionType.psk_key_exchange_modes: PskKeyExchangeModesExtension,</span>
<span class="gi">+        ExtensionType.cookie: CookieExtension,</span>
<span class="gi">+        ExtensionType.record_size_limit: RecordSizeLimitExtension,</span>
<span class="gi">+        ExtensionType.session_ticket: SessionTicketExtension}</span>
<span class="gi">+</span>
<span class="gi">+TLSExtension._serverExtensions = \</span>
<span class="gi">+    {</span>
<span class="gi">+        ExtensionType.cert_type: ServerCertTypeExtension,</span>
<span class="gi">+        ExtensionType.tack: TACKExtension,</span>
<span class="gi">+        ExtensionType.key_share: ServerKeyShareExtension,</span>
<span class="gi">+        ExtensionType.supported_versions: SrvSupportedVersionsExtension,</span>
<span class="gi">+        ExtensionType.pre_shared_key: SrvPreSharedKeyExtension}</span>
<span class="gi">+</span>
<span class="gi">+TLSExtension._certificateExtensions = \</span>
<span class="gi">+    {</span>
<span class="gi">+        ExtensionType.status_request: CertificateStatusExtension}</span>
<span class="gi">+</span>
<span class="gi">+TLSExtension._hrrExtensions = \</span>
<span class="gi">+    {</span>
<span class="gi">+        ExtensionType.key_share: HRRKeyShareExtension,</span>
<span class="gi">+        ExtensionType.supported_versions: SrvSupportedVersionsExtension}</span>
<span class="gh">diff --git a/tlslite/handshakehashes.py b/tlslite/handshakehashes.py</span>
<span class="gh">index 6638766..8860edb 100644</span>
<span class="gd">--- a/tlslite/handshakehashes.py</span>
<span class="gi">+++ b/tlslite/handshakehashes.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="gi">+# Copyright (c) 2015, Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="w"> </span>&quot;&quot;&quot;Handling cryptographic hashes for handshake protocol&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .utils.compat import compat26Str, compatHMAC
<span class="w"> </span>from .utils.cryptomath import MD5, SHA1
<span class="w"> </span>from .utils import tlshashlib as hashlib

<span class="gd">-</span>
<span class="w"> </span>class HandshakeHashes(object):
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Store and calculate necessary hashes for handshake protocol

<span class="gu">@@ -28,7 +32,14 @@ class HandshakeHashes(object):</span>

<span class="w"> </span>        :param bytearray data: serialized TLS handshake message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        text = compat26Str(data)</span>
<span class="gi">+        self._handshakeMD5.update(text)</span>
<span class="gi">+        self._handshakeSHA.update(text)</span>
<span class="gi">+        self._handshakeSHA224.update(text)</span>
<span class="gi">+        self._handshakeSHA256.update(text)</span>
<span class="gi">+        self._handshakeSHA384.update(text)</span>
<span class="gi">+        self._handshakeSHA512.update(text)</span>
<span class="gi">+        self._handshake_buffer += text</span>

<span class="w"> </span>    def digest(self, digest=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -38,7 +49,24 @@ class HandshakeHashes(object):</span>

<span class="w"> </span>        :param str digest: name of digest to return
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if digest is None:</span>
<span class="gi">+            return self._handshakeMD5.digest() + self._handshakeSHA.digest()</span>
<span class="gi">+        elif digest == &#39;md5&#39;:</span>
<span class="gi">+            return self._handshakeMD5.digest()</span>
<span class="gi">+        elif digest == &#39;sha1&#39;:</span>
<span class="gi">+            return self._handshakeSHA.digest()</span>
<span class="gi">+        elif digest == &#39;sha224&#39;:</span>
<span class="gi">+            return self._handshakeSHA224.digest()</span>
<span class="gi">+        elif digest == &#39;sha256&#39;:</span>
<span class="gi">+            return self._handshakeSHA256.digest()</span>
<span class="gi">+        elif digest == &#39;sha384&#39;:</span>
<span class="gi">+            return self._handshakeSHA384.digest()</span>
<span class="gi">+        elif digest == &#39;sha512&#39;:</span>
<span class="gi">+            return self._handshakeSHA512.digest()</span>
<span class="gi">+        elif digest == &quot;intrinsic&quot;:</span>
<span class="gi">+            return self._handshake_buffer</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Unknown digest name&quot;)</span>

<span class="w"> </span>    def digestSSL(self, masterSecret, label):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -49,8 +77,24 @@ class HandshakeHashes(object):</span>
<span class="w"> </span>        :param bytearray masterSecret: value of the master secret
<span class="w"> </span>        :param bytearray label: label to include in the calculation
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        #pylint: disable=maybe-no-member</span>
<span class="gi">+        imacMD5 = self._handshakeMD5.copy()</span>
<span class="gi">+        imacSHA = self._handshakeSHA.copy()</span>
<span class="gi">+        #pylint: enable=maybe-no-member</span>
<span class="gi">+</span>
<span class="gi">+        # the below difference in input for MD5 and SHA-1 is why we can&#39;t reuse</span>
<span class="gi">+        # digest() method</span>
<span class="gi">+        imacMD5.update(compatHMAC(label + masterSecret + bytearray([0x36]*48)))</span>
<span class="gi">+        imacSHA.update(compatHMAC(label + masterSecret + bytearray([0x36]*40)))</span>
<span class="gi">+</span>
<span class="gi">+        md5Bytes = MD5(masterSecret + bytearray([0x5c]*48) + \</span>
<span class="gi">+                         bytearray(imacMD5.digest()))</span>
<span class="gi">+        shaBytes = SHA1(masterSecret + bytearray([0x5c]*40) + \</span>
<span class="gi">+                         bytearray(imacSHA.digest()))</span>
<span class="gi">+</span>
<span class="gi">+        return md5Bytes + shaBytes</span>

<span class="gi">+    #pylint: disable=protected-access, maybe-no-member</span>
<span class="w"> </span>    def copy(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy object
<span class="gu">@@ -60,4 +104,12 @@ class HandshakeHashes(object):</span>

<span class="w"> </span>        :rtype: HandshakeHashes
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        other = HandshakeHashes()</span>
<span class="gi">+        other._handshakeMD5 = self._handshakeMD5.copy()</span>
<span class="gi">+        other._handshakeSHA = self._handshakeSHA.copy()</span>
<span class="gi">+        other._handshakeSHA224 = self._handshakeSHA224.copy()</span>
<span class="gi">+        other._handshakeSHA256 = self._handshakeSHA256.copy()</span>
<span class="gi">+        other._handshakeSHA384 = self._handshakeSHA384.copy()</span>
<span class="gi">+        other._handshakeSHA512 = self._handshakeSHA512.copy()</span>
<span class="gi">+        other._handshake_buffer = bytearray(self._handshake_buffer)</span>
<span class="gi">+        return other</span>
<span class="gh">diff --git a/tlslite/handshakehelpers.py b/tlslite/handshakehelpers.py</span>
<span class="gh">index 67f7657..56b8d24 100644</span>
<span class="gd">--- a/tlslite/handshakehelpers.py</span>
<span class="gi">+++ b/tlslite/handshakehelpers.py</span>
<span class="gu">@@ -1,4 +1,10 @@</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Karel Srot</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Class with various handshake helpers.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .extensions import PaddingExtension, PreSharedKeyExtension
<span class="w"> </span>from .utils.cryptomath import derive_secret, secureHMAC, HKDF_expand_label
<span class="w"> </span>from .utils.constanttime import ct_compare_digest
<span class="gu">@@ -17,7 +23,22 @@ class HandshakeHelpers(object):</span>

<span class="w"> </span>        :param ClientHello clientHello: ClientHello to be aligned
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Check clientHello size if padding extension should be added</span>
<span class="gi">+        # we want to add the extension even when using just SSLv3</span>
<span class="gi">+        # cut-off 4 bytes with the Hello header (ClientHello type + Length)</span>
<span class="gi">+        clientHelloLength = len(clientHello.write()) - 4</span>
<span class="gi">+        if 256 &lt;= clientHelloLength &lt;= 511:</span>
<span class="gi">+            if clientHello.extensions is None:</span>
<span class="gi">+                clientHello.extensions = []</span>
<span class="gi">+                # we need to recalculate the size after extension list addition</span>
<span class="gi">+                # results in extra 2 bytes, equals to</span>
<span class="gi">+                # clientHelloLength = len(clientHello.write()) - 4</span>
<span class="gi">+                clientHelloLength += 2</span>
<span class="gi">+            # we want to get 512 bytes in total, including the padding</span>
<span class="gi">+            # extension header (4B)</span>
<span class="gi">+            paddingExtensionInstance = PaddingExtension().create(</span>
<span class="gi">+                max(512 - clientHelloLength - 4, 0))</span>
<span class="gi">+            clientHello.extensions.append(paddingExtensionInstance)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _calc_binder(prf, psk, handshake_hash, external=True):
<span class="gu">@@ -25,16 +46,35 @@ class HandshakeHelpers(object):</span>
<span class="w"> </span>        Calculate the binder value for a given HandshakeHash (that includes
<span class="w"> </span>        a truncated client hello already)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert prf in (&#39;sha256&#39;, &#39;sha384&#39;)</span>
<span class="gi">+        key_len = 32 if prf == &#39;sha256&#39; else 48</span>
<span class="gi">+</span>
<span class="gi">+        # HKDF-Extract(0, PSK)</span>
<span class="gi">+        early_secret = secureHMAC(bytearray(key_len), psk, prf)</span>
<span class="gi">+        if external:</span>
<span class="gi">+            binder_key = derive_secret(early_secret, b&quot;ext binder&quot;, None, prf)</span>
<span class="gi">+        else:</span>
<span class="gi">+            binder_key = derive_secret(early_secret, b&quot;res binder&quot;, None, prf)</span>
<span class="gi">+        finished_key = HKDF_expand_label(binder_key, b&quot;finished&quot;, b&quot;&quot;, key_len,</span>
<span class="gi">+                                         prf)</span>
<span class="gi">+        binder = secureHMAC(finished_key, handshake_hash.digest(prf), prf)</span>
<span class="gi">+        return binder</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def calc_res_binder_psk(iden, res_master_secret, tickets):
<span class="w"> </span>        &quot;&quot;&quot;Calculate PSK associated with provided ticket identity.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ticket = [i for i in tickets if i.ticket == iden.identity][0]</span>
<span class="gi">+</span>
<span class="gi">+        ticket_hash = &#39;sha256&#39; if len(res_master_secret) == 32 else &#39;sha384&#39;</span>
<span class="gi">+</span>
<span class="gi">+        psk = HKDF_expand_label(res_master_secret, b&quot;resumption&quot;,</span>
<span class="gi">+                                ticket.ticket_nonce, len(res_master_secret),</span>
<span class="gi">+                                ticket_hash)</span>
<span class="gi">+        return psk</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def update_binders(client_hello, handshake_hashes, psk_configs, tickets</span>
<span class="gd">-        =None, res_master_secret=None):</span>
<span class="gi">+    def update_binders(client_hello, handshake_hashes, psk_configs,</span>
<span class="gi">+                       tickets=None, res_master_secret=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Sign the Client Hello using TLS 1.3 PSK binders.

<span class="gu">@@ -48,11 +88,54 @@ class HandshakeHelpers(object):</span>
<span class="w"> </span>        :param bytearray res_master_secret: secret associated with the
<span class="w"> </span>            tickets
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ext = client_hello.extensions[-1]</span>
<span class="gi">+        if not isinstance(ext, PreSharedKeyExtension):</span>
<span class="gi">+            raise ValueError(&quot;Last extension in client_hello must be &quot;</span>
<span class="gi">+                             &quot;PreSharedKeyExtension&quot;)</span>
<span class="gi">+        if tickets and not res_master_secret:</span>
<span class="gi">+            raise ValueError(&quot;Tickets require setting res_master_secret&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        hh = handshake_hashes.copy()</span>
<span class="gi">+</span>
<span class="gi">+        hh.update(client_hello.psk_truncate())</span>
<span class="gi">+</span>
<span class="gi">+        configs_iter = iter(psk_configs)</span>
<span class="gi">+        ticket_idens = []</span>
<span class="gi">+        if tickets:</span>
<span class="gi">+            ticket_idens = [i.ticket for i in tickets]</span>
<span class="gi">+</span>
<span class="gi">+        for i, iden in enumerate(ext.identities):</span>
<span class="gi">+            # identities that are tickets don&#39;t carry PSK directly</span>
<span class="gi">+            if iden.identity in ticket_idens:</span>
<span class="gi">+                binder_hash = &#39;sha256&#39; if len(res_master_secret) == 32 \</span>
<span class="gi">+                    else &#39;sha384&#39;</span>
<span class="gi">+                psk = HandshakeHelpers.calc_res_binder_psk(</span>
<span class="gi">+                    iden, res_master_secret, tickets)</span>
<span class="gi">+                external = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    config = next(configs_iter)</span>
<span class="gi">+                    while config[0] != iden.identity:</span>
<span class="gi">+                        config = next(configs_iter)</span>
<span class="gi">+                except StopIteration:</span>
<span class="gi">+                    raise ValueError(&quot;psk_configs don&#39;t match the &quot;</span>
<span class="gi">+                                     &quot;PreSharedKeyExtension&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                binder_hash = config[2] if len(config) &gt; 2 else &#39;sha256&#39;</span>
<span class="gi">+                psk = config[1]</span>
<span class="gi">+                external = True</span>
<span class="gi">+</span>
<span class="gi">+            binder = HandshakeHelpers._calc_binder(binder_hash,</span>
<span class="gi">+                                                   psk,</span>
<span class="gi">+                                                   hh,</span>
<span class="gi">+                                                   external)</span>
<span class="gi">+</span>
<span class="gi">+            # replace the fake value with calculated one</span>
<span class="gi">+            ext.binders[i] = binder</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def verify_binder(client_hello, handshake_hashes, position, secret, prf,
<span class="gd">-        external=True):</span>
<span class="gi">+                      external=True):</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify the PSK binder value in client hello.

<span class="w"> </span>        :param client_hello: ClientHello to verify
<span class="gu">@@ -61,4 +144,21 @@ class HandshakeHelpers(object):</span>
<span class="w"> </span>        :param secret: the secret PSK
<span class="w"> </span>        :param prf: name of the hash used as PRF
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ext = client_hello.extensions[-1]</span>
<span class="gi">+        if not isinstance(ext, PreSharedKeyExtension):</span>
<span class="gi">+            raise TLSIllegalParameterException(</span>
<span class="gi">+                &quot;Last extension in client_hello must be &quot;</span>
<span class="gi">+                &quot;PreSharedKeyExtension&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        hh = handshake_hashes.copy()</span>
<span class="gi">+        hh.update(client_hello.psk_truncate())</span>
<span class="gi">+</span>
<span class="gi">+        binder = HandshakeHelpers._calc_binder(prf,</span>
<span class="gi">+                                               secret,</span>
<span class="gi">+                                               hh,</span>
<span class="gi">+                                               external)</span>
<span class="gi">+</span>
<span class="gi">+        if not ct_compare_digest(binder, ext.binders[position]):</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Binder does not verify&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>
<span class="gh">diff --git a/tlslite/handshakesettings.py b/tlslite/handshakesettings.py</span>
<span class="gh">index 0dc638a..38e560a 100644</span>
<span class="gd">--- a/tlslite/handshakesettings.py</span>
<span class="gi">+++ b/tlslite/handshakesettings.py</span>
<span class="gu">@@ -1,43 +1,66 @@</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Dave Baggett (Arcode Corporation) - cleanup handling of constants</span>
<span class="gi">+#   Yngve Pettersen (ported by Paul Sokolovsky) - TLS 1.2</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Class for setting handshake parameters.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .constants import CertificateType
<span class="w"> </span>from .utils import cryptomath
<span class="w"> </span>from .utils import cipherfactory
<span class="w"> </span>from .utils.compat import ecdsaAllCurves, int_types
<span class="gd">-CIPHER_NAMES = [&#39;chacha20-poly1305&#39;, &#39;aes256gcm&#39;, &#39;aes128gcm&#39;, &#39;aes256ccm&#39;,</span>
<span class="gd">-    &#39;aes128ccm&#39;, &#39;aes256&#39;, &#39;aes128&#39;, &#39;3des&#39;]</span>
<span class="gd">-ALL_CIPHER_NAMES = CIPHER_NAMES + [&#39;chacha20-poly1305_draft00&#39;,</span>
<span class="gd">-    &#39;aes128ccm_8&#39;, &#39;aes256ccm_8&#39;, &#39;rc4&#39;, &#39;null&#39;]</span>
<span class="gd">-MAC_NAMES = [&#39;sha&#39;, &#39;sha256&#39;, &#39;sha384&#39;, &#39;aead&#39;]</span>
<span class="gd">-ALL_MAC_NAMES = MAC_NAMES + [&#39;md5&#39;]</span>
<span class="gd">-KEY_EXCHANGE_NAMES = [&#39;ecdhe_ecdsa&#39;, &#39;rsa&#39;, &#39;dhe_rsa&#39;, &#39;ecdhe_rsa&#39;,</span>
<span class="gd">-    &#39;srp_sha&#39;, &#39;srp_sha_rsa&#39;, &#39;ecdh_anon&#39;, &#39;dh_anon&#39;, &#39;dhe_dsa&#39;]</span>
<span class="gd">-CIPHER_IMPLEMENTATIONS = [&#39;openssl&#39;, &#39;pycrypto&#39;, &#39;python&#39;]</span>
<span class="gd">-CERTIFICATE_TYPES = [&#39;x509&#39;]</span>
<span class="gd">-RSA_SIGNATURE_HASHES = [&#39;sha512&#39;, &#39;sha384&#39;, &#39;sha256&#39;, &#39;sha224&#39;, &#39;sha1&#39;]</span>
<span class="gd">-DSA_SIGNATURE_HASHES = [&#39;sha512&#39;, &#39;sha384&#39;, &#39;sha256&#39;, &#39;sha224&#39;, &#39;sha1&#39;]</span>
<span class="gd">-ECDSA_SIGNATURE_HASHES = [&#39;sha512&#39;, &#39;sha384&#39;, &#39;sha256&#39;, &#39;sha224&#39;, &#39;sha1&#39;]</span>
<span class="gd">-ALL_RSA_SIGNATURE_HASHES = RSA_SIGNATURE_HASHES + [&#39;md5&#39;]</span>
<span class="gd">-SIGNATURE_SCHEMES = [&#39;Ed25519&#39;, &#39;Ed448&#39;]</span>
<span class="gd">-RSA_SCHEMES = [&#39;pss&#39;, &#39;pkcs1&#39;]</span>
<span class="gd">-CURVE_NAMES = [&#39;x25519&#39;, &#39;x448&#39;, &#39;secp384r1&#39;, &#39;secp256r1&#39;, &#39;secp521r1&#39;]</span>
<span class="gd">-ALL_CURVE_NAMES = CURVE_NAMES + [&#39;secp256k1&#39;, &#39;brainpoolP512r1&#39;,</span>
<span class="gd">-    &#39;brainpoolP384r1&#39;, &#39;brainpoolP256r1&#39;]</span>
<span class="gi">+</span>
<span class="gi">+CIPHER_NAMES = [&quot;chacha20-poly1305&quot;,</span>
<span class="gi">+                &quot;aes256gcm&quot;, &quot;aes128gcm&quot;,</span>
<span class="gi">+                &quot;aes256ccm&quot;, &quot;aes128ccm&quot;,</span>
<span class="gi">+                &quot;aes256&quot;, &quot;aes128&quot;,</span>
<span class="gi">+                &quot;3des&quot;]</span>
<span class="gi">+ALL_CIPHER_NAMES = CIPHER_NAMES + [&quot;chacha20-poly1305_draft00&quot;,</span>
<span class="gi">+                                   &quot;aes128ccm_8&quot;, &quot;aes256ccm_8&quot;,</span>
<span class="gi">+                                   &quot;rc4&quot;, &quot;null&quot;]</span>
<span class="gi">+# Don&#39;t allow &quot;md5&quot; by default</span>
<span class="gi">+MAC_NAMES = [&quot;sha&quot;, &quot;sha256&quot;, &quot;sha384&quot;, &quot;aead&quot;]</span>
<span class="gi">+ALL_MAC_NAMES = MAC_NAMES + [&quot;md5&quot;]</span>
<span class="gi">+KEY_EXCHANGE_NAMES = [&quot;ecdhe_ecdsa&quot;, &quot;rsa&quot;, &quot;dhe_rsa&quot;, &quot;ecdhe_rsa&quot;, &quot;srp_sha&quot;,</span>
<span class="gi">+                      &quot;srp_sha_rsa&quot;, &quot;ecdh_anon&quot;, &quot;dh_anon&quot;, &quot;dhe_dsa&quot;]</span>
<span class="gi">+CIPHER_IMPLEMENTATIONS = [&quot;openssl&quot;, &quot;pycrypto&quot;, &quot;python&quot;]</span>
<span class="gi">+CERTIFICATE_TYPES = [&quot;x509&quot;]</span>
<span class="gi">+RSA_SIGNATURE_HASHES = [&quot;sha512&quot;, &quot;sha384&quot;, &quot;sha256&quot;, &quot;sha224&quot;, &quot;sha1&quot;]</span>
<span class="gi">+DSA_SIGNATURE_HASHES = [&quot;sha512&quot;, &quot;sha384&quot;, &quot;sha256&quot;, &quot;sha224&quot;, &quot;sha1&quot;]</span>
<span class="gi">+ECDSA_SIGNATURE_HASHES = [&quot;sha512&quot;, &quot;sha384&quot;, &quot;sha256&quot;, &quot;sha224&quot;, &quot;sha1&quot;]</span>
<span class="gi">+ALL_RSA_SIGNATURE_HASHES = RSA_SIGNATURE_HASHES + [&quot;md5&quot;]</span>
<span class="gi">+SIGNATURE_SCHEMES = [&quot;Ed25519&quot;, &quot;Ed448&quot;]</span>
<span class="gi">+RSA_SCHEMES = [&quot;pss&quot;, &quot;pkcs1&quot;]</span>
<span class="gi">+# while secp521r1 is the most secure, it&#39;s also much slower than the others</span>
<span class="gi">+# so place it as the last one</span>
<span class="gi">+CURVE_NAMES = [&quot;x25519&quot;, &quot;x448&quot;, &quot;secp384r1&quot;, &quot;secp256r1&quot;,</span>
<span class="gi">+               &quot;secp521r1&quot;]</span>
<span class="gi">+ALL_CURVE_NAMES = CURVE_NAMES + [&quot;secp256k1&quot;, &quot;brainpoolP512r1&quot;,</span>
<span class="gi">+                                 &quot;brainpoolP384r1&quot;, &quot;brainpoolP256r1&quot;]</span>
<span class="w"> </span>if ecdsaAllCurves:
<span class="gd">-    ALL_CURVE_NAMES += [&#39;secp224r1&#39;, &#39;secp192r1&#39;]</span>
<span class="gd">-ALL_DH_GROUP_NAMES = [&#39;ffdhe2048&#39;, &#39;ffdhe3072&#39;, &#39;ffdhe4096&#39;, &#39;ffdhe6144&#39;,</span>
<span class="gd">-    &#39;ffdhe8192&#39;]</span>
<span class="gd">-CURVE_ALIASES = {&#39;secp256r1&#39;: (&#39;NIST256p&#39;, &#39;prime256v1&#39;, &#39;P-256&#39;),</span>
<span class="gd">-    &#39;secp384r1&#39;: (&#39;NIST384p&#39;, &#39;P-384&#39;), &#39;secp521r1&#39;: (&#39;NIST521p&#39;, &#39;P-521&#39;),</span>
<span class="gd">-    &#39;secp256k1&#39;: (&#39;SECP256k1&#39;,), &#39;secp192r1&#39;: (&#39;NIST192p&#39;, &#39;P-192&#39;),</span>
<span class="gd">-    &#39;secp224r1&#39;: (&#39;NIST224p&#39;, &#39;P-224&#39;), &#39;brainpoolP256r1&#39;: (</span>
<span class="gd">-    &#39;BRAINPOOLP256r1&#39;,), &#39;brainpoolP384r1&#39;: (&#39;BRAINPOOLP384r1&#39;,),</span>
<span class="gd">-    &#39;brainpoolP512r1&#39;: (&#39;BRAINPOOLP512r1&#39;,)}</span>
<span class="gd">-TLS13_PERMITTED_GROUPS = [&#39;secp256r1&#39;, &#39;secp384r1&#39;, &#39;secp521r1&#39;, &#39;x25519&#39;,</span>
<span class="gd">-    &#39;x448&#39;, &#39;ffdhe2048&#39;, &#39;ffdhe3072&#39;, &#39;ffdhe4096&#39;, &#39;ffdhe6144&#39;, &#39;ffdhe8192&#39;]</span>
<span class="gd">-KNOWN_VERSIONS = (3, 0), (3, 1), (3, 2), (3, 3), (3, 4)</span>
<span class="gd">-TICKET_CIPHERS = [&#39;chacha20-poly1305&#39;, &#39;aes256gcm&#39;, &#39;aes128gcm&#39;,</span>
<span class="gd">-    &#39;aes128ccm&#39;, &#39;aes128ccm_8&#39;, &#39;aes256ccm&#39;, &#39;aes256ccm_8&#39;]</span>
<span class="gd">-PSK_MODES = [&#39;psk_dhe_ke&#39;, &#39;psk_ke&#39;]</span>
<span class="gi">+    ALL_CURVE_NAMES += [&quot;secp224r1&quot;, &quot;secp192r1&quot;]</span>
<span class="gi">+ALL_DH_GROUP_NAMES = [&quot;ffdhe2048&quot;, &quot;ffdhe3072&quot;, &quot;ffdhe4096&quot;, &quot;ffdhe6144&quot;,</span>
<span class="gi">+                      &quot;ffdhe8192&quot;]</span>
<span class="gi">+CURVE_ALIASES = {&quot;secp256r1&quot;: (&#39;NIST256p&#39;, &#39;prime256v1&#39;, &#39;P-256&#39;),</span>
<span class="gi">+                 &quot;secp384r1&quot;: (&#39;NIST384p&#39;, &#39;P-384&#39;),</span>
<span class="gi">+                 &quot;secp521r1&quot;: (&#39;NIST521p&#39;, &#39;P-521&#39;),</span>
<span class="gi">+                 &quot;secp256k1&quot;: (&#39;SECP256k1&#39;,),</span>
<span class="gi">+                 &quot;secp192r1&quot;: (&#39;NIST192p&#39;, &#39;P-192&#39;),</span>
<span class="gi">+                 &quot;secp224r1&quot;: (&#39;NIST224p&#39;, &#39;P-224&#39;),</span>
<span class="gi">+                 &quot;brainpoolP256r1&quot;: (&#39;BRAINPOOLP256r1&#39;,),</span>
<span class="gi">+                 &quot;brainpoolP384r1&quot;: (&#39;BRAINPOOLP384r1&#39;,),</span>
<span class="gi">+                 &quot;brainpoolP512r1&quot;: (&#39;BRAINPOOLP512r1&#39;,)}</span>
<span class="gi">+# list of supported groups in TLS 1.3 as per RFC 8446, chapter 4.2.7. (excluding private use here)</span>
<span class="gi">+TLS13_PERMITTED_GROUPS = [&quot;secp256r1&quot;, &quot;secp384r1&quot;, &quot;secp521r1&quot;,</span>
<span class="gi">+                          &quot;x25519&quot;, &quot;x448&quot;, &quot;ffdhe2048&quot;,</span>
<span class="gi">+                          &quot;ffdhe3072&quot;, &quot;ffdhe4096&quot;, &quot;ffdhe6144&quot;,</span>
<span class="gi">+                          &quot;ffdhe8192&quot;]</span>
<span class="gi">+KNOWN_VERSIONS = ((3, 0), (3, 1), (3, 2), (3, 3), (3, 4))</span>
<span class="gi">+TICKET_CIPHERS = [&quot;chacha20-poly1305&quot;, &quot;aes256gcm&quot;, &quot;aes128gcm&quot;, &quot;aes128ccm&quot;,</span>
<span class="gi">+                  &quot;aes128ccm_8&quot;, &quot;aes256ccm&quot;, &quot;aes256ccm_8&quot;]</span>
<span class="gi">+PSK_MODES = [&quot;psk_dhe_ke&quot;, &quot;psk_ke&quot;]</span>


<span class="w"> </span>class Keypair(object):
<span class="gu">@@ -57,14 +80,14 @@ class Keypair(object):</span>
<span class="w"> </span>    :ivar certificates: the certificates to send to peer if the key is selected
<span class="w"> </span>        for use. The first one MUST include the public key of the ``key``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, key=None, certificates=tuple()):
<span class="w"> </span>        self.key = key
<span class="w"> </span>        self.certificates = certificates

<span class="w"> </span>    def validate(self):
<span class="w"> </span>        &quot;&quot;&quot;Sanity check the keypair.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.key or not self.certificates:</span>
<span class="gi">+            raise ValueError(&quot;Key or certificate missing in Keypair&quot;)</span>


<span class="w"> </span>class VirtualHost(object):
<span class="gu">@@ -104,11 +127,14 @@ class VirtualHost(object):</span>

<span class="w"> </span>    def matches_hostname(self, hostname):
<span class="w"> </span>        &quot;&quot;&quot;Checks if the virtual host can serve hostname&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return hostname in self.hostnames</span>

<span class="w"> </span>    def validate(self):
<span class="w"> </span>        &quot;&quot;&quot;Sanity check the settings&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.keys:</span>
<span class="gi">+            raise ValueError(&quot;Virtual host missing keys&quot;)</span>
<span class="gi">+        for i in self.keys:</span>
<span class="gi">+            i.validate()</span>


<span class="w"> </span>class HandshakeSettings(object):
<span class="gu">@@ -331,18 +357,52 @@ class HandshakeSettings(object):</span>

<span class="w"> </span>    def _init_key_settings(self):
<span class="w"> </span>        &quot;&quot;&quot;Create default variables for key-related settings.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.minKeySize = 1023</span>
<span class="gi">+        self.maxKeySize = 8193</span>
<span class="gi">+        self.rsaSigHashes = list(RSA_SIGNATURE_HASHES)</span>
<span class="gi">+        self.rsaSchemes = list(RSA_SCHEMES)</span>
<span class="gi">+        self.dsaSigHashes = list(DSA_SIGNATURE_HASHES)</span>
<span class="gi">+        self.virtual_hosts = []</span>
<span class="gi">+        # DH key settings</span>
<span class="gi">+        self.eccCurves = list(CURVE_NAMES)</span>
<span class="gi">+        self.dhParams = None</span>
<span class="gi">+        self.dhGroups = list(ALL_DH_GROUP_NAMES)</span>
<span class="gi">+        self.defaultCurve = &quot;secp256r1&quot;</span>
<span class="gi">+        self.keyShares = [&quot;secp256r1&quot;, &quot;x25519&quot;]</span>
<span class="gi">+        self.padding_cb = None</span>
<span class="gi">+        self.use_heartbeat_extension = True</span>
<span class="gi">+        self.heartbeat_response_callback = None</span>

<span class="w"> </span>    def _init_misc_extensions(self):
<span class="w"> </span>        &quot;&quot;&quot;Default variables for assorted extensions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.certificateTypes = list(CERTIFICATE_TYPES)</span>
<span class="gi">+        self.useExperimentalTackExtension = False</span>
<span class="gi">+        self.sendFallbackSCSV = False</span>
<span class="gi">+        self.useEncryptThenMAC = True</span>
<span class="gi">+        self.ecdsaSigHashes = list(ECDSA_SIGNATURE_HASHES)</span>
<span class="gi">+        self.more_sig_schemes = list(SIGNATURE_SCHEMES)</span>
<span class="gi">+        self.usePaddingExtension = True</span>
<span class="gi">+        self.useExtendedMasterSecret = True</span>
<span class="gi">+        self.requireExtendedMasterSecret = False</span>
<span class="gi">+        # PSKs</span>
<span class="gi">+        self.pskConfigs = []</span>
<span class="gi">+        self.psk_modes = list(PSK_MODES)</span>
<span class="gi">+        # session tickets</span>
<span class="gi">+        self.ticketKeys = []</span>
<span class="gi">+        self.ticketCipher = &quot;aes256gcm&quot;</span>
<span class="gi">+        self.ticketLifetime = 24 * 60 * 60</span>
<span class="gi">+        self.max_early_data = 2 ** 14 + 16  # full record + tag</span>
<span class="gi">+        # send two tickets so that client can quickly ramp up number of</span>
<span class="gi">+        # resumed connections (as tickets are single-use in TLS 1.3</span>
<span class="gi">+        self.ticket_count = 2</span>
<span class="gi">+        self.record_size_limit = 2**14 + 1  # TLS 1.3 includes content type</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Initialise default values for settings.&quot;&quot;&quot;
<span class="w"> </span>        self._init_key_settings()
<span class="w"> </span>        self._init_misc_extensions()
<span class="gd">-        self.minVersion = 3, 1</span>
<span class="gd">-        self.maxVersion = 3, 4</span>
<span class="gi">+        self.minVersion = (3, 1)</span>
<span class="gi">+        self.maxVersion = (3, 4)</span>
<span class="w"> </span>        self.versions = [(3, 4), (3, 3), (3, 2), (3, 1)]
<span class="w"> </span>        self.cipherNames = list(CIPHER_NAMES)
<span class="w"> </span>        self.macNames = list(MAC_NAMES)
<span class="gu">@@ -352,87 +412,313 @@ class HandshakeSettings(object):</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckKeySizes(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if key size limits are sane&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.minKeySize &lt; 512:</span>
<span class="gi">+            raise ValueError(&quot;minKeySize too small&quot;)</span>
<span class="gi">+        if other.minKeySize &gt; 16384:</span>
<span class="gi">+            raise ValueError(&quot;minKeySize too large&quot;)</span>
<span class="gi">+        if other.maxKeySize &lt; 512:</span>
<span class="gi">+            raise ValueError(&quot;maxKeySize too small&quot;)</span>
<span class="gi">+        if other.maxKeySize &gt; 16384:</span>
<span class="gi">+            raise ValueError(&quot;maxKeySize too large&quot;)</span>
<span class="gi">+        if other.maxKeySize &lt; other.minKeySize:</span>
<span class="gi">+            raise ValueError(&quot;maxKeySize smaller than minKeySize&quot;)</span>
<span class="gi">+        # check also keys of virtual hosts</span>
<span class="gi">+        for i in other.virtual_hosts:</span>
<span class="gi">+            i.validate()</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _not_matching(values, sieve):
<span class="w"> </span>        &quot;&quot;&quot;Return list of items from values that are not in sieve.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [val for val in values if val not in sieve]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckCipherSettings(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if specified cipher settings are known.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching</span>
<span class="gi">+        unknownCiph = not_matching(other.cipherNames, ALL_CIPHER_NAMES)</span>
<span class="gi">+        if unknownCiph:</span>
<span class="gi">+            raise ValueError(&quot;Unknown cipher name: {0}&quot;.format(unknownCiph))</span>
<span class="gi">+</span>
<span class="gi">+        unknownMac = not_matching(other.macNames, ALL_MAC_NAMES)</span>
<span class="gi">+        if unknownMac:</span>
<span class="gi">+            raise ValueError(&quot;Unknown MAC name: {0}&quot;.format(unknownMac))</span>
<span class="gi">+</span>
<span class="gi">+        unknownKex = not_matching(other.keyExchangeNames, KEY_EXCHANGE_NAMES)</span>
<span class="gi">+        if unknownKex:</span>
<span class="gi">+            raise ValueError(&quot;Unknown key exchange name: {0}&quot;</span>
<span class="gi">+                             .format(unknownKex))</span>
<span class="gi">+</span>
<span class="gi">+        unknownImpl = not_matching(other.cipherImplementations,</span>
<span class="gi">+                                   CIPHER_IMPLEMENTATIONS)</span>
<span class="gi">+        if unknownImpl:</span>
<span class="gi">+            raise ValueError(&quot;Unknown cipher implementation: {0}&quot;</span>
<span class="gi">+                             .format(unknownImpl))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckECDHSettings(other):
<span class="w"> </span>        &quot;&quot;&quot;Check ECDHE settings if they are sane.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching</span>
<span class="gi">+</span>
<span class="gi">+        unknownCurve = not_matching(other.eccCurves, ALL_CURVE_NAMES)</span>
<span class="gi">+        if unknownCurve:</span>
<span class="gi">+            raise ValueError(&quot;Unknown ECC Curve name: {0}&quot;</span>
<span class="gi">+                             .format(unknownCurve))</span>
<span class="gi">+</span>
<span class="gi">+        if other.defaultCurve not in ALL_CURVE_NAMES:</span>
<span class="gi">+            raise ValueError(&quot;Unknown default ECC Curve name: {0}&quot;</span>
<span class="gi">+                             .format(other.defaultCurve))</span>
<span class="gi">+</span>
<span class="gi">+        nonAdvertisedGroup = [val for val in other.keyShares</span>
<span class="gi">+                              if val not in other.eccCurves and</span>
<span class="gi">+                              val not in other.dhGroups]</span>
<span class="gi">+        if nonAdvertisedGroup:</span>
<span class="gi">+            raise ValueError(&quot;Key shares for not enabled groups specified: {0}&quot;</span>
<span class="gi">+                             .format(nonAdvertisedGroup))</span>
<span class="gi">+</span>
<span class="gi">+        unknownSigHash = not_matching(other.ecdsaSigHashes,</span>
<span class="gi">+                                      ECDSA_SIGNATURE_HASHES)</span>
<span class="gi">+        if unknownSigHash:</span>
<span class="gi">+            raise ValueError(&quot;Unknown ECDSA signature hash: &#39;{0}&#39;&quot;.\</span>
<span class="gi">+                             format(unknownSigHash))</span>
<span class="gi">+</span>
<span class="gi">+        unknownSigHash = not_matching(other.more_sig_schemes,</span>
<span class="gi">+                                      SIGNATURE_SCHEMES)</span>
<span class="gi">+        if unknownSigHash:</span>
<span class="gi">+            raise ValueError(&quot;Unkonwn more_sig_schemes specified: &#39;{0}&#39;&quot;</span>
<span class="gi">+                             .format(unknownSigHash))</span>
<span class="gi">+</span>
<span class="gi">+        unknownDHGroup = not_matching(other.dhGroups, ALL_DH_GROUP_NAMES)</span>
<span class="gi">+        if unknownDHGroup:</span>
<span class="gi">+            raise ValueError(&quot;Unknown FFDHE group name: &#39;{0}&#39;&quot;</span>
<span class="gi">+                             .format(unknownDHGroup))</span>
<span class="gi">+</span>
<span class="gi">+        # TLS 1.3 limits the allowed groups (RFC 8446,ch. 4.2.7.)</span>
<span class="gi">+        if other.maxVersion == (3, 4):</span>
<span class="gi">+            forbiddenGroup = HandshakeSettings._not_matching(other.eccCurves, TLS13_PERMITTED_GROUPS)</span>
<span class="gi">+            if forbiddenGroup:</span>
<span class="gi">+                raise ValueError(&quot;The following enabled groups are forbidden in TLS 1.3: {0}&quot;</span>
<span class="gi">+                                 .format(forbiddenGroup))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckDHSettings(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if (EC)DHE settings are sane.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching</span>
<span class="gi">+</span>
<span class="gi">+        HandshakeSettings._sanityCheckECDHSettings(other)</span>
<span class="gi">+</span>
<span class="gi">+        unknownKeyShare = [val for val in other.keyShares</span>
<span class="gi">+                           if val not in ALL_DH_GROUP_NAMES and</span>
<span class="gi">+                           val not in ALL_CURVE_NAMES]</span>
<span class="gi">+        if unknownKeyShare:</span>
<span class="gi">+            raise ValueError(&quot;Unknown key share: &#39;{0}&#39;&quot;</span>
<span class="gi">+                             .format(unknownKeyShare))</span>
<span class="gi">+</span>
<span class="gi">+        if other.dhParams and (len(other.dhParams) != 2 or</span>
<span class="gi">+                               not isinstance(other.dhParams[0], int_types) or</span>
<span class="gi">+                               not isinstance(other.dhParams[1], int_types)):</span>
<span class="gi">+            raise ValueError(&quot;DH parameters need to be a tuple of integers&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckPrimitivesNames(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if specified cryptographic primitive names are known&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        HandshakeSettings._sanityCheckCipherSettings(other)</span>
<span class="gi">+        HandshakeSettings._sanityCheckDHSettings(other)</span>
<span class="gi">+</span>
<span class="gi">+        not_matching = HandshakeSettings._not_matching</span>
<span class="gi">+</span>
<span class="gi">+        unknownType = not_matching(other.certificateTypes, CERTIFICATE_TYPES)</span>
<span class="gi">+        if unknownType:</span>
<span class="gi">+            raise ValueError(&quot;Unknown certificate type: {0}&quot;</span>
<span class="gi">+                             .format(unknownType))</span>
<span class="gi">+</span>
<span class="gi">+        unknownSigHash = not_matching(other.rsaSigHashes,</span>
<span class="gi">+                                      ALL_RSA_SIGNATURE_HASHES)</span>
<span class="gi">+        if unknownSigHash:</span>
<span class="gi">+            raise ValueError(&quot;Unknown RSA signature hash: &#39;{0}&#39;&quot;</span>
<span class="gi">+                             .format(unknownSigHash))</span>
<span class="gi">+</span>
<span class="gi">+        unknownRSAPad = not_matching(other.rsaSchemes, RSA_SCHEMES)</span>
<span class="gi">+        if unknownRSAPad:</span>
<span class="gi">+            raise ValueError(&quot;Unknown RSA padding mode: &#39;{0}&#39;&quot;</span>
<span class="gi">+                             .format(unknownRSAPad))</span>
<span class="gi">+</span>
<span class="gi">+        unknownSigHash = not_matching(other.dsaSigHashes,</span>
<span class="gi">+                                      DSA_SIGNATURE_HASHES)</span>
<span class="gi">+        if unknownSigHash:</span>
<span class="gi">+            raise ValueError(&quot;Unknown DSA signature hash: &#39;{0}&#39;&quot;</span>
<span class="gi">+                             .format(unknownSigHash))</span>
<span class="gi">+</span>
<span class="gi">+        if not other.rsaSigHashes and not other.ecdsaSigHashes and \</span>
<span class="gi">+                not other.dsaSigHashes and not other.more_sig_schemes and \</span>
<span class="gi">+                other.maxVersion &gt;= (3, 3):</span>
<span class="gi">+            raise ValueError(&quot;TLS 1.2 requires signature algorithms to be set&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckProtocolVersions(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if set protocol version are sane&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.minVersion &gt; other.maxVersion:</span>
<span class="gi">+            raise ValueError(&quot;Versions set incorrectly&quot;)</span>
<span class="gi">+        if other.minVersion not in KNOWN_VERSIONS:</span>
<span class="gi">+            raise ValueError(&quot;minVersion set incorrectly&quot;)</span>
<span class="gi">+        if other.maxVersion not in KNOWN_VERSIONS:</span>
<span class="gi">+            raise ValueError(&quot;maxVersion set incorrectly&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if other.maxVersion &lt; (3, 4):</span>
<span class="gi">+            other.versions = [i for i in other.versions if i &lt; (3, 4)]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckEMSExtension(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if settings for EMS are sane.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.useExtendedMasterSecret not in (True, False):</span>
<span class="gi">+            raise ValueError(&quot;useExtendedMasterSecret must be True or False&quot;)</span>
<span class="gi">+        if other.requireExtendedMasterSecret not in (True, False):</span>
<span class="gi">+            raise ValueError(&quot;requireExtendedMasterSecret must be True &quot;</span>
<span class="gi">+                             &quot;or False&quot;)</span>
<span class="gi">+        if other.requireExtendedMasterSecret and \</span>
<span class="gi">+                not other.useExtendedMasterSecret:</span>
<span class="gi">+            raise ValueError(&quot;requireExtendedMasterSecret requires &quot;</span>
<span class="gi">+                             &quot;useExtendedMasterSecret&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckExtensions(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if set extension settings are sane&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.useEncryptThenMAC not in (True, False):</span>
<span class="gi">+            raise ValueError(&quot;useEncryptThenMAC can only be True or False&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if other.usePaddingExtension not in (True, False):</span>
<span class="gi">+            raise ValueError(&quot;usePaddingExtension must be True or False&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if other.use_heartbeat_extension not in (True, False):</span>
<span class="gi">+            raise ValueError(&quot;use_heartbeat_extension must be True or False&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if other.heartbeat_response_callback and not other.use_heartbeat_extension:</span>
<span class="gi">+            raise ValueError(&quot;heartbeat_response_callback requires &quot;</span>
<span class="gi">+                             &quot;use_heartbeat_extension&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if other.record_size_limit is not None and \</span>
<span class="gi">+                not 64 &lt;= other.record_size_limit &lt;= 2**14 + 1:</span>
<span class="gi">+            raise ValueError(&quot;record_size_limit cannot exceed 2**14+1 bytes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        HandshakeSettings._sanityCheckEMSExtension(other)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _not_allowed_len(values, sieve):
<span class="w"> </span>        &quot;&quot;&quot;Return True if length of any item in values is not in sieve.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sieve = set(sieve)</span>
<span class="gi">+        return any(len(i) not in sieve for i in values)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckPsks(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if the set PSKs are sane.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if HandshakeSettings._not_allowed_len(other.pskConfigs, [2, 3]):</span>
<span class="gi">+            raise ValueError(&quot;pskConfigs items must be a 2 or 3-element&quot;</span>
<span class="gi">+                             &quot;tuples&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        badHashes = [i[2] for i in other.pskConfigs if</span>
<span class="gi">+                     len(i) == 3 and i[2] not in set([&#39;sha256&#39;, &#39;sha384&#39;])]</span>
<span class="gi">+        if badHashes:</span>
<span class="gi">+            raise ValueError(&quot;pskConfigs include invalid hash specifications: &quot;</span>
<span class="gi">+                             &quot;{0}&quot;.format(badHashes))</span>
<span class="gi">+</span>
<span class="gi">+        bad_psk_modes = [i for i in other.psk_modes if</span>
<span class="gi">+                         i not in PSK_MODES]</span>
<span class="gi">+        if bad_psk_modes:</span>
<span class="gi">+            raise ValueError(&quot;psk_modes includes invalid key exchange modes: &quot;</span>
<span class="gi">+                             &quot;{0}&quot;.format(bad_psk_modes))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _sanityCheckTicketSettings(other):
<span class="w"> </span>        &quot;&quot;&quot;Check if the session ticket settings are sane.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.ticketCipher not in TICKET_CIPHERS:</span>
<span class="gi">+            raise ValueError(&quot;Invalid cipher for session ticket encryption: &quot;</span>
<span class="gi">+                             &quot;{0}&quot;.format(other.ticketCipher))</span>
<span class="gi">+</span>
<span class="gi">+        if HandshakeSettings._not_allowed_len(other.ticketKeys, [16, 32]):</span>
<span class="gi">+            raise ValueError(&quot;Session ticket encryption keys must be 16 or 32&quot;</span>
<span class="gi">+                             &quot;bytes long&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not 0 &lt; other.ticketLifetime &lt;= 7 * 24 * 60 * 60:</span>
<span class="gi">+            raise ValueError(&quot;Ticket lifetime must be a positive integer &quot;</span>
<span class="gi">+                             &quot;smaller or equal 604800 (7 days)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # while not ticket setting per-se, it is related to session tickets</span>
<span class="gi">+        if not 0 &lt; other.max_early_data &lt;= 2**64:</span>
<span class="gi">+            raise ValueError(&quot;max_early_data must be between 0 and 2GiB&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not 0 &lt;= other.ticket_count &lt; 2**16:</span>
<span class="gi">+            raise ValueError(&quot;Incorrect amount for number of new session &quot;</span>
<span class="gi">+                             &quot;tickets to send&quot;)</span>

<span class="w"> </span>    def _copy_cipher_settings(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Copy values related to cipher selection.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        other.cipherNames = self.cipherNames</span>
<span class="gi">+        other.macNames = self.macNames</span>
<span class="gi">+        other.keyExchangeNames = self.keyExchangeNames</span>
<span class="gi">+        other.cipherImplementations = self.cipherImplementations</span>
<span class="gi">+        other.minVersion = self.minVersion</span>
<span class="gi">+        other.maxVersion = self.maxVersion</span>
<span class="gi">+        other.versions = self.versions</span>

<span class="w"> </span>    def _copy_extension_settings(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Copy values of settings related to extensions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        other.useExtendedMasterSecret = self.useExtendedMasterSecret</span>
<span class="gi">+        other.requireExtendedMasterSecret = self.requireExtendedMasterSecret</span>
<span class="gi">+        other.useExperimentalTackExtension = self.useExperimentalTackExtension</span>
<span class="gi">+        other.sendFallbackSCSV = self.sendFallbackSCSV</span>
<span class="gi">+        other.useEncryptThenMAC = self.useEncryptThenMAC</span>
<span class="gi">+        other.usePaddingExtension = self.usePaddingExtension</span>
<span class="gi">+        # session tickets</span>
<span class="gi">+        other.padding_cb = self.padding_cb</span>
<span class="gi">+        other.ticketKeys = self.ticketKeys</span>
<span class="gi">+        other.ticketCipher = self.ticketCipher</span>
<span class="gi">+        other.ticketLifetime = self.ticketLifetime</span>
<span class="gi">+        other.max_early_data = self.max_early_data</span>
<span class="gi">+        other.ticket_count = self.ticket_count</span>
<span class="gi">+        other.record_size_limit = self.record_size_limit</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _remove_all_matches(values, needle):
<span class="w"> </span>        &quot;&quot;&quot;Remove all instances of needle from values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        values[:] = (i for i in values if i != needle)</span>

<span class="w"> </span>    def _sanity_check_ciphers(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Remove unsupported ciphers in current configuration.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not cipherfactory.tripleDESPresent:</span>
<span class="gi">+            other.cipherNames = other.cipherNames[:]</span>
<span class="gi">+            self._remove_all_matches(other.cipherNames, &quot;3des&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not other.cipherNames:</span>
<span class="gi">+            raise ValueError(&quot;No supported ciphers&quot;)</span>

<span class="w"> </span>    def _sanity_check_implementations(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Remove all backends that are not loaded.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            self._remove_all_matches(other.cipherImplementations, &quot;openssl&quot;)</span>
<span class="gi">+        if not cryptomath.pycryptoLoaded:</span>
<span class="gi">+            self._remove_all_matches(other.cipherImplementations, &quot;pycrypto&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not other.cipherImplementations:</span>
<span class="gi">+            raise ValueError(&quot;No supported cipher implementations&quot;)</span>

<span class="w"> </span>    def _copy_key_settings(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Copy key-related settings.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        other.minKeySize = self.minKeySize</span>
<span class="gi">+        other.maxKeySize = self.maxKeySize</span>
<span class="gi">+        other.certificateTypes = self.certificateTypes</span>
<span class="gi">+        other.rsaSigHashes = self.rsaSigHashes</span>
<span class="gi">+        other.rsaSchemes = self.rsaSchemes</span>
<span class="gi">+        other.dsaSigHashes = self.dsaSigHashes</span>
<span class="gi">+        other.ecdsaSigHashes = self.ecdsaSigHashes</span>
<span class="gi">+        other.more_sig_schemes = self.more_sig_schemes</span>
<span class="gi">+        other.virtual_hosts = self.virtual_hosts</span>
<span class="gi">+        # DH key params</span>
<span class="gi">+        other.eccCurves = self.eccCurves</span>
<span class="gi">+        other.dhParams = self.dhParams</span>
<span class="gi">+        other.dhGroups = self.dhGroups</span>
<span class="gi">+        other.defaultCurve = self.defaultCurve</span>
<span class="gi">+        other.keyShares = self.keyShares</span>
<span class="gi">+        other.use_heartbeat_extension = self.use_heartbeat_extension</span>
<span class="gi">+        other.heartbeat_response_callback = self.heartbeat_response_callback</span>

<span class="w"> </span>    def validate(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -443,8 +729,46 @@ class HandshakeSettings(object):</span>
<span class="w"> </span>        :returns: a self-consistent copy of settings
<span class="w"> </span>        :raises ValueError: when settings are invalid, insecure or unsupported.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        other = HandshakeSettings()</span>
<span class="gi">+</span>
<span class="gi">+        self._copy_cipher_settings(other)</span>
<span class="gi">+        self._copy_extension_settings(other)</span>
<span class="gi">+        self._copy_key_settings(other)</span>
<span class="gi">+</span>
<span class="gi">+        other.pskConfigs = self.pskConfigs</span>
<span class="gi">+        other.psk_modes = self.psk_modes</span>
<span class="gi">+</span>
<span class="gi">+        if not other.certificateTypes:</span>
<span class="gi">+            raise ValueError(&quot;No supported certificate types&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self._sanityCheckKeySizes(other)</span>
<span class="gi">+</span>
<span class="gi">+        self._sanityCheckPrimitivesNames(other)</span>
<span class="gi">+</span>
<span class="gi">+        self._sanityCheckProtocolVersions(other)</span>
<span class="gi">+</span>
<span class="gi">+        self._sanityCheckExtensions(other)</span>
<span class="gi">+</span>
<span class="gi">+        if other.maxVersion &lt; (3, 3):</span>
<span class="gi">+            # No sha-2 and AEAD pre TLS 1.2</span>
<span class="gi">+            other.macNames = [e for e in self.macNames if</span>
<span class="gi">+                              e == &quot;sha&quot; or e == &quot;md5&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        self._sanityCheckPsks(other)</span>
<span class="gi">+</span>
<span class="gi">+        self._sanityCheckTicketSettings(other)</span>
<span class="gi">+</span>
<span class="gi">+        self._sanity_check_implementations(other)</span>
<span class="gi">+        self._sanity_check_ciphers(other)</span>
<span class="gi">+</span>
<span class="gi">+        return other</span>

<span class="w"> </span>    def getCertificateTypes(self):
<span class="w"> </span>        &quot;&quot;&quot;Get list of certificate types as IDs&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        for ct in self.certificateTypes:</span>
<span class="gi">+            if ct == &quot;x509&quot;:</span>
<span class="gi">+                ret.append(CertificateType.x509)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise AssertionError()</span>
<span class="gi">+        return ret</span>
<span class="gh">diff --git a/tlslite/integration/asyncstatemachine.py b/tlslite/integration/asyncstatemachine.py</span>
<span class="gh">index 2aa8a79..c6d8694 100644</span>
<span class="gd">--- a/tlslite/integration/asyncstatemachine.py</span>
<span class="gi">+++ b/tlslite/integration/asyncstatemachine.py</span>
<span class="gu">@@ -1,8 +1,10 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>A state machine for using TLS Lite with asynchronous I/O.
<span class="w"> </span>&quot;&quot;&quot;

<span class="gd">-</span>
<span class="w"> </span>class AsyncStateMachine:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This is an abstract class that&#39;s used to integrate TLS Lite with
<span class="gu">@@ -27,6 +29,46 @@ class AsyncStateMachine:</span>
<span class="w"> </span>        self.writer = None
<span class="w"> </span>        self._clear()

<span class="gi">+    def _clear(self):</span>
<span class="gi">+        #These store the various asynchronous operations (i.e.</span>
<span class="gi">+        #generators).  Only one of them, at most, is ever active at a</span>
<span class="gi">+        #time.</span>
<span class="gi">+        self.handshaker = None</span>
<span class="gi">+        self.closer = None</span>
<span class="gi">+        self.reader = None</span>
<span class="gi">+        self.writer = None</span>
<span class="gi">+</span>
<span class="gi">+        #This stores the result from the last call to the</span>
<span class="gi">+        #currently active operation.  If 0 it indicates that the</span>
<span class="gi">+        #operation wants to read, if 1 it indicates that the</span>
<span class="gi">+        #operation wants to write.  If None, there is no active</span>
<span class="gi">+        #operation.</span>
<span class="gi">+        self.result = None</span>
<span class="gi">+</span>
<span class="gi">+    def _checkAssert(self, maxActive=1):</span>
<span class="gi">+        #This checks that only one operation, at most, is</span>
<span class="gi">+        #active, and that self.result is set appropriately.</span>
<span class="gi">+        activeOps = 0</span>
<span class="gi">+        if self.handshaker:</span>
<span class="gi">+            activeOps += 1</span>
<span class="gi">+        if self.closer:</span>
<span class="gi">+            activeOps += 1</span>
<span class="gi">+        if self.reader:</span>
<span class="gi">+            activeOps += 1</span>
<span class="gi">+        if self.writer:</span>
<span class="gi">+            activeOps += 1</span>
<span class="gi">+</span>
<span class="gi">+        if self.result == None:</span>
<span class="gi">+            if activeOps != 0:</span>
<span class="gi">+                raise AssertionError()</span>
<span class="gi">+        elif self.result in (0,1):</span>
<span class="gi">+            if activeOps != 1:</span>
<span class="gi">+                raise AssertionError()</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+        if activeOps &gt; maxActive:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+</span>
<span class="w"> </span>    def wantsReadEvent(self):
<span class="w"> </span>        &quot;&quot;&quot;If the state machine wants to read.

<span class="gu">@@ -37,7 +79,9 @@ class AsyncStateMachine:</span>
<span class="w"> </span>        :rtype: bool or None
<span class="w"> </span>        :returns: If the state machine wants to read.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.result != None:</span>
<span class="gi">+            return self.result == 0</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def wantsWriteEvent(self):
<span class="w"> </span>        &quot;&quot;&quot;If the state machine wants to write.
<span class="gu">@@ -49,7 +93,9 @@ class AsyncStateMachine:</span>
<span class="w"> </span>        :rtype: bool or None
<span class="w"> </span>        :returns: If the state machine wants to write.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.result != None:</span>
<span class="gi">+            return self.result == 1</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def outConnectEvent(self):
<span class="w"> </span>        &quot;&quot;&quot;Called when a handshake operation completes.
<span class="gu">@@ -79,11 +125,71 @@ class AsyncStateMachine:</span>

<span class="w"> </span>    def inReadEvent(self):
<span class="w"> </span>        &quot;&quot;&quot;Tell the state machine it can read from the socket.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._checkAssert()</span>
<span class="gi">+            if self.handshaker:</span>
<span class="gi">+                self._doHandshakeOp()</span>
<span class="gi">+            elif self.closer:</span>
<span class="gi">+                self._doCloseOp()</span>
<span class="gi">+            elif self.reader:</span>
<span class="gi">+                self._doReadOp()</span>
<span class="gi">+            elif self.writer:</span>
<span class="gi">+                self._doWriteOp()</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.reader = self.tlsConnection.readAsync(16384)</span>
<span class="gi">+                self._doReadOp()</span>
<span class="gi">+        except:</span>
<span class="gi">+            self._clear()</span>
<span class="gi">+            raise</span>

<span class="w"> </span>    def inWriteEvent(self):
<span class="w"> </span>        &quot;&quot;&quot;Tell the state machine it can write to the socket.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._checkAssert()</span>
<span class="gi">+            if self.handshaker:</span>
<span class="gi">+                self._doHandshakeOp()</span>
<span class="gi">+            elif self.closer:</span>
<span class="gi">+                self._doCloseOp()</span>
<span class="gi">+            elif self.reader:</span>
<span class="gi">+                self._doReadOp()</span>
<span class="gi">+            elif self.writer:</span>
<span class="gi">+                self._doWriteOp()</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.outWriteEvent()</span>
<span class="gi">+        except:</span>
<span class="gi">+            self._clear()</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def _doHandshakeOp(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.result = next(self.handshaker)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            self.handshaker = None</span>
<span class="gi">+            self.result = None</span>
<span class="gi">+            self.outConnectEvent()</span>
<span class="gi">+</span>
<span class="gi">+    def _doCloseOp(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.result = next(self.closer)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            self.closer = None</span>
<span class="gi">+            self.result = None</span>
<span class="gi">+            self.outCloseEvent()</span>
<span class="gi">+</span>
<span class="gi">+    def _doReadOp(self):</span>
<span class="gi">+        self.result = next(self.reader)</span>
<span class="gi">+        if not self.result in (0,1):</span>
<span class="gi">+            readBuffer = self.result</span>
<span class="gi">+            self.reader = None</span>
<span class="gi">+            self.result = None</span>
<span class="gi">+            self.outReadEvent(readBuffer)</span>
<span class="gi">+</span>
<span class="gi">+    def _doWriteOp(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.result = next(self.writer)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            self.writer = None</span>
<span class="gi">+            self.result = None</span>

<span class="w"> </span>    def setHandshakeOp(self, handshaker):
<span class="w"> </span>        &quot;&quot;&quot;Start a handshake operation.
<span class="gu">@@ -93,7 +199,13 @@ class AsyncStateMachine:</span>
<span class="w"> </span>            :py:meth:`~.TLSConnection.handshakeServerAsync` , or
<span class="w"> </span>            handshakeClientxxx(..., async_=True).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._checkAssert(0)</span>
<span class="gi">+            self.handshaker = handshaker</span>
<span class="gi">+            self._doHandshakeOp()</span>
<span class="gi">+        except:</span>
<span class="gi">+            self._clear()</span>
<span class="gi">+            raise</span>

<span class="w"> </span>    def setServerHandshakeOp(self, **args):
<span class="w"> </span>        &quot;&quot;&quot;Start a handshake operation.
<span class="gu">@@ -101,16 +213,30 @@ class AsyncStateMachine:</span>
<span class="w"> </span>        The arguments passed to this function will be forwarded to
<span class="w"> </span>        :py:obj:`~tlslite.tlsconnection.TLSConnection.handshakeServerAsync`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        handshaker = self.tlsConnection.handshakeServerAsync(**args)</span>
<span class="gi">+        self.setHandshakeOp(handshaker)</span>

<span class="w"> </span>    def setCloseOp(self):
<span class="w"> </span>        &quot;&quot;&quot;Start a close operation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._checkAssert(0)</span>
<span class="gi">+            self.closer = self.tlsConnection.closeAsync()</span>
<span class="gi">+            self._doCloseOp()</span>
<span class="gi">+        except:</span>
<span class="gi">+            self._clear()</span>
<span class="gi">+            raise</span>

<span class="w"> </span>    def setWriteOp(self, writeBuffer):
<span class="w"> </span>        &quot;&quot;&quot;Start a write operation.

<span class="w"> </span>        :param str writeBuffer: The string to transmit.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._checkAssert(0)</span>
<span class="gi">+            self.writer = self.tlsConnection.writeAsync(writeBuffer)</span>
<span class="gi">+            self._doWriteOp()</span>
<span class="gi">+        except:</span>
<span class="gi">+            self._clear()</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gh">diff --git a/tlslite/integration/clienthelper.py b/tlslite/integration/clienthelper.py</span>
<span class="gh">index 3bda03e..9155ac2 100644</span>
<span class="gd">--- a/tlslite/integration/clienthelper.py</span>
<span class="gi">+++ b/tlslite/integration/clienthelper.py</span>
<span class="gu">@@ -1,17 +1,28 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Dimitris Moraitis - Anon ciphersuites</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>A helper class for using TLS Lite with stdlib clients
<span class="w"> </span>(httplib, xmlrpclib, imaplib, poplib).
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from tlslite.checker import Checker
<span class="w"> </span>from tlslite.utils.dns_utils import is_valid_hostname

<span class="gd">-</span>
<span class="w"> </span>class ClientHelper(object):
<span class="w"> </span>    &quot;&quot;&quot;This is a helper class used to integrate TLS Lite with various
<span class="w"> </span>    TLS clients (e.g. poplib, smtplib, httplib, etc.)&quot;&quot;&quot;

<span class="gd">-    def __init__(self, username=None, password=None, certChain=None,</span>
<span class="gd">-        privateKey=None, checker=None, settings=None, anon=False, host=None):</span>
<span class="gi">+    def __init__(self,</span>
<span class="gi">+                 username=None, password=None,</span>
<span class="gi">+                 certChain=None, privateKey=None,</span>
<span class="gi">+                 checker=None,</span>
<span class="gi">+                 settings=None,</span>
<span class="gi">+                 anon=False,</span>
<span class="gi">+                 host=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For client authentication, use one of these argument
<span class="w"> </span>        combinations:
<span class="gu">@@ -69,36 +80,84 @@ class ClientHelper(object):</span>
<span class="w"> </span>            include the port (in which case the port will be stripped and
<span class="w"> </span>            ignored).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.username = None
<span class="w"> </span>        self.password = None
<span class="w"> </span>        self.certChain = None
<span class="w"> </span>        self.privateKey = None
<span class="w"> </span>        self.checker = None
<span class="w"> </span>        self.anon = anon
<span class="gd">-        if username and password and not (certChain or privateKey):</span>
<span class="gi">+</span>
<span class="gi">+        #SRP Authentication</span>
<span class="gi">+        if username and password and not \</span>
<span class="gi">+                (certChain or privateKey):</span>
<span class="w"> </span>            self.username = username
<span class="w"> </span>            self.password = password
<span class="gd">-        elif certChain and privateKey and not (username or password):</span>
<span class="gi">+</span>
<span class="gi">+        #Certificate Chain Authentication</span>
<span class="gi">+        elif certChain and privateKey and not \</span>
<span class="gi">+                (username or password):</span>
<span class="w"> </span>            self.certChain = certChain
<span class="w"> </span>            self.privateKey = privateKey
<span class="gd">-        elif not password and not username and not certChain and not privateKey:</span>
<span class="gi">+</span>
<span class="gi">+        #No Authentication</span>
<span class="gi">+        elif not password and not username and not \</span>
<span class="gi">+                certChain and not privateKey:</span>
<span class="w"> </span>            pass
<span class="gi">+</span>
<span class="w"> </span>        else:
<span class="gd">-            raise ValueError(&#39;Bad parameters&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Bad parameters&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.checker = checker
<span class="w"> </span>        self.settings = settings
<span class="gi">+</span>
<span class="w"> </span>        self.tlsSession = None
<span class="gi">+</span>
<span class="w"> </span>        if host is not None and not self._isIP(host):
<span class="gi">+            # name for SNI so port can&#39;t be sent</span>
<span class="w"> </span>            colon = host.find(&#39;:&#39;)
<span class="w"> </span>            if colon &gt; 0:
<span class="w"> </span>                host = host[:colon]
<span class="w"> </span>            self.serverName = host
<span class="w"> </span>            if host and not is_valid_hostname(host):
<span class="gd">-                raise ValueError(&#39;Invalid hostname: {0}&#39;.format(host))</span>
<span class="gi">+                raise ValueError(&quot;Invalid hostname: {0}&quot;.format(host))</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.serverName = None

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _isIP(address):
<span class="w"> </span>        &quot;&quot;&quot;Return True if the address is an IPv4 address&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not address:</span>
<span class="gi">+            return False</span>
<span class="gi">+        vals = address.split(&#39;.&#39;)</span>
<span class="gi">+        if len(vals) != 4:</span>
<span class="gi">+            return False</span>
<span class="gi">+        for i in vals:</span>
<span class="gi">+            if not i.isdigit():</span>
<span class="gi">+                return False</span>
<span class="gi">+            j = int(i)</span>
<span class="gi">+            if not 0 &lt;= j &lt;= 255:</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def _handshake(self, tlsConnection):</span>
<span class="gi">+        if self.username and self.password:</span>
<span class="gi">+            tlsConnection.handshakeClientSRP(username=self.username,</span>
<span class="gi">+                                             password=self.password,</span>
<span class="gi">+                                             checker=self.checker,</span>
<span class="gi">+                                             settings=self.settings,</span>
<span class="gi">+                                             session=self.tlsSession,</span>
<span class="gi">+                                             serverName=self.serverName)</span>
<span class="gi">+        elif self.anon:</span>
<span class="gi">+            tlsConnection.handshakeClientAnonymous(session=self.tlsSession,</span>
<span class="gi">+                                                   settings=self.settings,</span>
<span class="gi">+                                                   checker=self.checker,</span>
<span class="gi">+                                                   serverName=self.serverName)</span>
<span class="gi">+        else:</span>
<span class="gi">+            tlsConnection.handshakeClientCert(certChain=self.certChain,</span>
<span class="gi">+                                              privateKey=self.privateKey,</span>
<span class="gi">+                                              checker=self.checker,</span>
<span class="gi">+                                              settings=self.settings,</span>
<span class="gi">+                                              session=self.tlsSession,</span>
<span class="gi">+                                              serverName=self.serverName)</span>
<span class="gi">+        self.tlsSession = tlsConnection.session</span>
<span class="gh">diff --git a/tlslite/integration/httptlsconnection.py b/tlslite/integration/httptlsconnection.py</span>
<span class="gh">index 9d6129c..c922150 100644</span>
<span class="gd">--- a/tlslite/integration/httptlsconnection.py</span>
<span class="gi">+++ b/tlslite/integration/httptlsconnection.py</span>
<span class="gu">@@ -1,8 +1,18 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Kees Bos - Added ignoreAbruptClose parameter</span>
<span class="gi">+#   Dimitris Moraitis - Anon ciphersuites</span>
<span class="gi">+#   Martin von Loewis - python 3 port</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;TLS Lite + httplib.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>try:
<span class="w"> </span>    import httplib
<span class="w"> </span>except ImportError:
<span class="gi">+    # Python 3</span>
<span class="w"> </span>    from http import client as httplib
<span class="w"> </span>from tlslite.tlsconnection import TLSConnection
<span class="w"> </span>from tlslite.integration.clienthelper import ClientHelper
<span class="gu">@@ -11,10 +21,15 @@ from tlslite.integration.clienthelper import ClientHelper</span>
<span class="w"> </span>class HTTPTLSConnection(httplib.HTTPConnection, ClientHelper):
<span class="w"> </span>    &quot;&quot;&quot;This class extends L{httplib.HTTPConnection} to support TLS.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, host, port=None, strict=None, timeout=socket.</span>
<span class="gd">-        _GLOBAL_DEFAULT_TIMEOUT, source_address=None, username=None,</span>
<span class="gd">-        password=None, certChain=None, privateKey=None, checker=None,</span>
<span class="gd">-        settings=None, ignoreAbruptClose=False, anon=False):</span>
<span class="gi">+    def __init__(self, host, port=None, strict=None,</span>
<span class="gi">+                timeout=socket._GLOBAL_DEFAULT_TIMEOUT,</span>
<span class="gi">+                source_address=None,</span>
<span class="gi">+                username=None, password=None,</span>
<span class="gi">+                certChain=None, privateKey=None,</span>
<span class="gi">+                checker=None,</span>
<span class="gi">+                settings=None,</span>
<span class="gi">+                ignoreAbruptClose=False,</span>
<span class="gi">+                anon=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new HTTPTLSConnection.

<span class="w"> </span>        For client authentication, use one of these argument
<span class="gu">@@ -79,11 +94,27 @@ class HTTPTLSConnection(httplib.HTTPConnection, ClientHelper):</span>
<span class="w"> </span>            unexpected hangup.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if source_address:
<span class="gd">-            httplib.HTTPConnection.__init__(self, host=host, port=port,</span>
<span class="gd">-                timeout=timeout, source_address=source_address)</span>
<span class="gi">+            httplib.HTTPConnection.__init__(self,</span>
<span class="gi">+                    host=host,</span>
<span class="gi">+                    port=port,</span>
<span class="gi">+                    timeout=timeout,</span>
<span class="gi">+                    source_address=source_address)</span>
<span class="w"> </span>        if not source_address:
<span class="gd">-            httplib.HTTPConnection.__init__(self, host=host, port=port,</span>
<span class="gd">-                timeout=timeout)</span>
<span class="gi">+            httplib.HTTPConnection.__init__(self,</span>
<span class="gi">+                    host=host,</span>
<span class="gi">+                    port=port,</span>
<span class="gi">+                    timeout=timeout)</span>
<span class="w"> </span>        self.ignoreAbruptClose = ignoreAbruptClose
<span class="gd">-        ClientHelper.__init__(self, username, password, certChain,</span>
<span class="gd">-            privateKey, checker, settings, anon, host)</span>
<span class="gi">+        ClientHelper.__init__(self,</span>
<span class="gi">+                              username, password,</span>
<span class="gi">+                              certChain, privateKey,</span>
<span class="gi">+                              checker,</span>
<span class="gi">+                              settings,</span>
<span class="gi">+                              anon,</span>
<span class="gi">+                              host)</span>
<span class="gi">+</span>
<span class="gi">+    def connect(self):</span>
<span class="gi">+        httplib.HTTPConnection.connect(self)</span>
<span class="gi">+        self.sock = TLSConnection(self.sock)</span>
<span class="gi">+        self.sock.ignoreAbruptClose = self.ignoreAbruptClose</span>
<span class="gi">+        ClientHelper._handshake(self, self.sock)</span>
<span class="gh">diff --git a/tlslite/integration/imap4_tls.py b/tlslite/integration/imap4_tls.py</span>
<span class="gh">index 8583c78..11f5806 100644</span>
<span class="gd">--- a/tlslite/integration/imap4_tls.py</span>
<span class="gi">+++ b/tlslite/integration/imap4_tls.py</span>
<span class="gu">@@ -1,17 +1,24 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;TLS Lite + imaplib.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>from imaplib import IMAP4
<span class="w"> </span>from tlslite.tlsconnection import TLSConnection
<span class="w"> </span>from tlslite.integration.clienthelper import ClientHelper
<span class="gd">-IMAP4_TLS_PORT = 993</span>

<span class="gi">+# IMAP TLS PORT</span>
<span class="gi">+IMAP4_TLS_PORT = 993</span>

<span class="w"> </span>class IMAP4_TLS(IMAP4, ClientHelper):
<span class="w"> </span>    &quot;&quot;&quot;This class extends :py:class:`imaplib.IMAP4` with TLS support.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, host=&#39;&#39;, port=IMAP4_TLS_PORT, username=None,</span>
<span class="gd">-        password=None, certChain=None, privateKey=None, checker=None,</span>
<span class="gd">-        settings=None):</span>
<span class="gi">+    def __init__(self, host = &#39;&#39;, port = IMAP4_TLS_PORT,</span>
<span class="gi">+                 username=None, password=None,</span>
<span class="gi">+                 certChain=None, privateKey=None,</span>
<span class="gi">+                 checker=None,</span>
<span class="gi">+                 settings=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new IMAP4_TLS.

<span class="w"> </span>        For client authentication, use one of these argument
<span class="gu">@@ -66,14 +73,30 @@ class IMAP4_TLS(IMAP4, ClientHelper):</span>
<span class="w"> </span>            the ciphersuites, certificate types, and SSL/TLS versions
<span class="w"> </span>            offered by the client.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        ClientHelper.__init__(self, username, password, certChain,</span>
<span class="gd">-            privateKey, checker, settings)</span>
<span class="gi">+</span>
<span class="gi">+        ClientHelper.__init__(self,</span>
<span class="gi">+                 username, password,</span>
<span class="gi">+                 certChain, privateKey,</span>
<span class="gi">+                 checker,</span>
<span class="gi">+                 settings)</span>
<span class="gi">+</span>
<span class="w"> </span>        IMAP4.__init__(self, host, port)

<span class="gi">+    # the `timeout` is a new argument in python3.9, so checks with</span>
<span class="gi">+    # older python versions will complain about unmatched parameters</span>
<span class="gi">+    # pylint: disable=arguments-differ</span>
<span class="w"> </span>    def open(self, host=&#39;&#39;, port=IMAP4_TLS_PORT, timeout=None):
<span class="w"> </span>        &quot;&quot;&quot;Setup connection to remote server on &quot;host:port&quot;.

<span class="w"> </span>        This connection will be used by the routines:
<span class="w"> </span>        read, readline, send, shutdown.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        del timeout</span>
<span class="gi">+        self.host = host</span>
<span class="gi">+        self.port = port</span>
<span class="gi">+        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span>
<span class="gi">+        self.sock.connect((host, port))</span>
<span class="gi">+        self.sock = TLSConnection(self.sock)</span>
<span class="gi">+        ClientHelper._handshake(self, self.sock)</span>
<span class="gi">+        self.file = self.sock.makefile(&#39;rb&#39;)</span>
<span class="gi">+    # pylint: enable=arguments-differ</span>
<span class="gh">diff --git a/tlslite/integration/pop3_tls.py b/tlslite/integration/pop3_tls.py</span>
<span class="gh">index 2cce171..814e494 100644</span>
<span class="gd">--- a/tlslite/integration/pop3_tls.py</span>
<span class="gi">+++ b/tlslite/integration/pop3_tls.py</span>
<span class="gu">@@ -1,16 +1,22 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;TLS Lite + poplib.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>from poplib import POP3, POP3_SSL_PORT
<span class="w"> </span>from tlslite.tlsconnection import TLSConnection
<span class="w"> </span>from tlslite.integration.clienthelper import ClientHelper

<span class="gd">-</span>
<span class="w"> </span>class POP3_TLS(POP3, ClientHelper):
<span class="w"> </span>    &quot;&quot;&quot;This class extends :py:class:`poplib.POP3` with TLS support.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, host, port=POP3_SSL_PORT, timeout=socket.</span>
<span class="gd">-        _GLOBAL_DEFAULT_TIMEOUT, username=None, password=None, certChain=</span>
<span class="gd">-        None, privateKey=None, checker=None, settings=None):</span>
<span class="gi">+    def __init__(self, host, port = POP3_SSL_PORT,</span>
<span class="gi">+                 timeout=socket._GLOBAL_DEFAULT_TIMEOUT,</span>
<span class="gi">+                 username=None, password=None,</span>
<span class="gi">+                 certChain=None, privateKey=None,</span>
<span class="gi">+                 checker=None,</span>
<span class="gi">+                 settings=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new POP3_TLS.

<span class="w"> </span>        For client authentication, use one of these argument
<span class="gu">@@ -68,9 +74,12 @@ class POP3_TLS(POP3, ClientHelper):</span>
<span class="w"> </span>        self.host = host
<span class="w"> </span>        self.port = port
<span class="w"> </span>        sock = socket.create_connection((host, port), timeout)
<span class="gd">-        ClientHelper.__init__(self, username, password, certChain,</span>
<span class="gd">-            privateKey, checker, settings)</span>
<span class="gd">-        connection = TLSConnection(sock)</span>
<span class="gi">+        ClientHelper.__init__(self,</span>
<span class="gi">+                 username, password,</span>
<span class="gi">+                 certChain, privateKey,</span>
<span class="gi">+                 checker,</span>
<span class="gi">+                 settings)</span>
<span class="gi">+        connection = TLSConnection(sock) </span>
<span class="w"> </span>        ClientHelper._handshake(self, connection)
<span class="w"> </span>        self.sock = connection
<span class="w"> </span>        self.file = self.sock.makefile(&#39;rb&#39;)
<span class="gh">diff --git a/tlslite/integration/smtp_tls.py b/tlslite/integration/smtp_tls.py</span>
<span class="gh">index 64501b6..1c94d0e 100644</span>
<span class="gd">--- a/tlslite/integration/smtp_tls.py</span>
<span class="gi">+++ b/tlslite/integration/smtp_tls.py</span>
<span class="gu">@@ -1,14 +1,20 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;TLS Lite + smtplib.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from smtplib import SMTP
<span class="w"> </span>from tlslite.tlsconnection import TLSConnection
<span class="w"> </span>from tlslite.integration.clienthelper import ClientHelper

<span class="gd">-</span>
<span class="w"> </span>class SMTP_TLS(SMTP):
<span class="w"> </span>    &quot;&quot;&quot;This class extends :py:class:`smtplib.SMTP` with TLS support.&quot;&quot;&quot;

<span class="gd">-    def starttls(self, username=None, password=None, certChain=None,</span>
<span class="gd">-        privateKey=None, checker=None, settings=None):</span>
<span class="gi">+    def starttls(self,</span>
<span class="gi">+                 username=None, password=None,</span>
<span class="gi">+                 certChain=None, privateKey=None,</span>
<span class="gi">+                 checker=None,</span>
<span class="gi">+                 settings=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Puts the connection to the SMTP server into TLS mode.

<span class="w"> </span>        If the server supports TLS, this will encrypt the rest of the SMTP
<span class="gu">@@ -60,4 +66,15 @@ class SMTP_TLS(SMTP):</span>
<span class="w"> </span>            the ciphersuites, certificate types, and SSL/TLS versions
<span class="w"> </span>            offered by the client.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        (resp, reply) = self.docmd(&quot;STARTTLS&quot;)</span>
<span class="gi">+        if resp == 220:</span>
<span class="gi">+            helper = ClientHelper(</span>
<span class="gi">+                     username, password, </span>
<span class="gi">+                     certChain, privateKey,</span>
<span class="gi">+                     checker,</span>
<span class="gi">+                     settings)</span>
<span class="gi">+            conn = TLSConnection(self.sock)</span>
<span class="gi">+            helper._handshake(conn)</span>
<span class="gi">+            self.sock = conn</span>
<span class="gi">+            self.file = conn.makefile(&#39;rb&#39;)</span>
<span class="gi">+        return (resp, reply)</span>
<span class="gh">diff --git a/tlslite/integration/tlsasyncdispatchermixin.py b/tlslite/integration/tlsasyncdispatchermixin.py</span>
<span class="gh">index 49d0efe..5758608 100644</span>
<span class="gd">--- a/tlslite/integration/tlsasyncdispatchermixin.py</span>
<span class="gi">+++ b/tlslite/integration/tlsasyncdispatchermixin.py</span>
<span class="gu">@@ -1,4 +1,12 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Martin von Loewis - python 3 port</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;TLS Lite + asyncore.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import asyncore
<span class="w"> </span>from tlslite.tlsconnection import TLSConnection
<span class="w"> </span>from .asyncstatemachine import AsyncStateMachine
<span class="gu">@@ -72,13 +80,68 @@ class TLSAsyncDispatcherMixIn(AsyncStateMachine):</span>
<span class="w"> </span>    and removes this instance from the asyncore loop.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+</span>
<span class="w"> </span>    def __init__(self, sock=None):
<span class="w"> </span>        AsyncStateMachine.__init__(self)
<span class="gi">+</span>
<span class="w"> </span>        if sock:
<span class="w"> </span>            self.tlsConnection = TLSConnection(sock)
<span class="gi">+</span>
<span class="gi">+        #Calculate the sibling I&#39;m being mixed in with.</span>
<span class="gi">+        #This is necessary since we override functions</span>
<span class="gi">+        #like readable(), handle_read(), etc., but we</span>
<span class="gi">+        #also want to call the sibling&#39;s versions.</span>
<span class="w"> </span>        for cl in self.__class__.__bases__:
<span class="w"> </span>            if cl != TLSAsyncDispatcherMixIn and cl != AsyncStateMachine:
<span class="w"> </span>                self.siblingClass = cl
<span class="w"> </span>                break
<span class="w"> </span>        else:
<span class="w"> </span>            raise AssertionError()
<span class="gi">+</span>
<span class="gi">+    def readable(self):</span>
<span class="gi">+        result = self.wantsReadEvent()</span>
<span class="gi">+        if result != None:</span>
<span class="gi">+            return result</span>
<span class="gi">+        return self.siblingClass.readable(self)</span>
<span class="gi">+</span>
<span class="gi">+    def writable(self):</span>
<span class="gi">+        result = self.wantsWriteEvent()</span>
<span class="gi">+        if result != None:</span>
<span class="gi">+            return result</span>
<span class="gi">+        return self.siblingClass.writable(self)</span>
<span class="gi">+</span>
<span class="gi">+    def handle_read(self):</span>
<span class="gi">+        self.inReadEvent()</span>
<span class="gi">+</span>
<span class="gi">+    def handle_write(self):</span>
<span class="gi">+        self.inWriteEvent()</span>
<span class="gi">+</span>
<span class="gi">+    def outConnectEvent(self):</span>
<span class="gi">+        self.siblingClass.handle_connect(self)</span>
<span class="gi">+</span>
<span class="gi">+    def outCloseEvent(self):</span>
<span class="gi">+        asyncore.dispatcher.close(self)</span>
<span class="gi">+</span>
<span class="gi">+    def outReadEvent(self, readBuffer):</span>
<span class="gi">+        self.readBuffer = readBuffer</span>
<span class="gi">+        self.siblingClass.handle_read(self)</span>
<span class="gi">+</span>
<span class="gi">+    def outWriteEvent(self):</span>
<span class="gi">+        self.siblingClass.handle_write(self)</span>
<span class="gi">+</span>
<span class="gi">+    def recv(self, bufferSize=16384):</span>
<span class="gi">+        if bufferSize &lt; 16384 or self.readBuffer == None:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+        returnValue = self.readBuffer</span>
<span class="gi">+        self.readBuffer = None</span>
<span class="gi">+        return returnValue</span>
<span class="gi">+</span>
<span class="gi">+    def send(self, writeBuffer):</span>
<span class="gi">+        self.setWriteOp(writeBuffer)</span>
<span class="gi">+        return len(writeBuffer)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        if hasattr(self, &quot;tlsConnection&quot;):</span>
<span class="gi">+            self.setCloseOp()</span>
<span class="gi">+        else:</span>
<span class="gi">+            asyncore.dispatcher.close(self)</span>
<span class="gh">diff --git a/tlslite/integration/tlsasynciodispatchermixin.py b/tlslite/integration/tlsasynciodispatchermixin.py</span>
<span class="gh">index fc83a77..2df7a07 100644</span>
<span class="gd">--- a/tlslite/integration/tlsasynciodispatchermixin.py</span>
<span class="gi">+++ b/tlslite/integration/tlsasynciodispatchermixin.py</span>
<span class="gu">@@ -1,4 +1,10 @@</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Esteban Sanchez (FosanzDev) - python 3.12 port</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;TLS Lite + asyncio.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>from tlslite.tlsconnection import TLSConnection
<span class="w"> </span>from .asyncstatemachine import AsyncStateMachine
<span class="gu">@@ -82,44 +88,82 @@ class TLSAsyncioDispatcherMixIn(asyncio.Protocol):</span>

<span class="w"> </span>    def _get_sibling_class(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the sibling class that this class is mixed in with.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cl in self.__class__.__bases__:</span>
<span class="gi">+            if cl not in (TLSAsyncioDispatcherMixIn, AsyncStateMachine):</span>
<span class="gi">+                return cl</span>
<span class="gi">+        raise AssertionError()</span>
<span class="gi">+</span>
<span class="gi">+    def connection_made(self, transport):</span>
<span class="gi">+        self.transport = transport</span>
<span class="gi">+        # Call the sibling class&#39;s connection_made method</span>
<span class="gi">+        if hasattr(self.sibling_class, &#39;connection_made&#39;):</span>
<span class="gi">+            self.sibling_class.connection_made(transport)</span>
<span class="gi">+</span>
<span class="gi">+    def data_received(self, data):</span>
<span class="gi">+        self.read_buffer = data</span>
<span class="gi">+        if hasattr(self.sibling_class, &#39;data_received&#39;):</span>
<span class="gi">+            self.sibling_class.data_received(self, data)</span>
<span class="gi">+</span>
<span class="gi">+    def connection_lost(self, exc):</span>
<span class="gi">+        self.sibling_class.connection_lost(self, exc)</span>
<span class="gi">+        if hasattr(self, &quot;tls_connection&quot;):</span>
<span class="gi">+            self.set_close_op()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.transport.close()</span>

<span class="w"> </span>    def readable(self):
<span class="w"> </span>        &quot;&quot;&quot;Check if the protocol is ready for reading.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = self.wants_read_event()</span>
<span class="gi">+        return result if result is not None \</span>
<span class="gi">+            else self.sibling_class.readable(self)</span>

<span class="w"> </span>    def writable(self):
<span class="w"> </span>        &quot;&quot;&quot;Check if the protocol is ready for writing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = self.wants_write_event()</span>
<span class="gi">+        return result if result is not None \</span>
<span class="gi">+            else self.sibling_class.writable(self)</span>

<span class="w"> </span>    def handle_read(self):
<span class="w"> </span>        &quot;&quot;&quot;Handle a read event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.in_read_event()</span>

<span class="w"> </span>    def handle_write(self):
<span class="w"> </span>        &quot;&quot;&quot;Handle a write event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.in_write_event()</span>

<span class="w"> </span>    def out_connect_event(self):
<span class="w"> </span>        &quot;&quot;&quot;Handle an outgoing connect event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sibling_class.handle_connect(self)</span>

<span class="w"> </span>    def out_close_event(self):
<span class="w"> </span>        &quot;&quot;&quot;Handle an outgoing close event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.transport.close()</span>

<span class="w"> </span>    def out_read_event(self, read_buffer):
<span class="w"> </span>        &quot;&quot;&quot;Handle an outgoing read event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.read_buffer = read_buffer</span>
<span class="gi">+        self.sibling_class.handle_read(self)</span>

<span class="w"> </span>    def out_write_event(self):
<span class="w"> </span>        &quot;&quot;&quot;Handle an outgoing write event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.sibling_class.handle_write(self)</span>

<span class="w"> </span>    def recv(self, buffer_size=16384):
<span class="w"> </span>        &quot;&quot;&quot;Receive data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if buffer_size &lt; 16384 or self.read_buffer is None:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+        return_value = self.read_buffer</span>
<span class="gi">+        self.read_buffer = None</span>
<span class="gi">+        return return_value</span>
<span class="gi">+</span>
<span class="gi">+    def send(self, write_buffer):</span>
<span class="gi">+        self.set_write_op(write_buffer)</span>
<span class="gi">+        self.transport.write(write_buffer)</span>
<span class="gi">+        return len(write_buffer)</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Close the connection.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &quot;tls_connection&quot;):</span>
<span class="gi">+            self.set_close_op()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.transport.close()</span>
<span class="gh">diff --git a/tlslite/integration/tlssocketservermixin.py b/tlslite/integration/tlssocketservermixin.py</span>
<span class="gh">index 1bc8d49..a279ec1 100644</span>
<span class="gd">--- a/tlslite/integration/tlssocketservermixin.py</span>
<span class="gi">+++ b/tlslite/integration/tlssocketservermixin.py</span>
<span class="gu">@@ -1,6 +1,9 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;TLS Lite + SocketServer.&quot;&quot;&quot;
<span class="gd">-from tlslite.tlsconnection import TLSConnection</span>

<span class="gi">+from tlslite.tlsconnection import TLSConnection</span>

<span class="w"> </span>class TLSSocketServerMixIn:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -45,3 +48,15 @@ class TLSSocketServerMixIn:</span>
<span class="w"> </span>        httpd = MyHTTPServer((&#39;localhost&#39;, 443), SimpleHTTPRequestHandler)
<span class="w"> </span>        httpd.serve_forever()
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def finish_request(self, sock, client_address):</span>
<span class="gi">+        tlsConnection = TLSConnection(sock)</span>
<span class="gi">+        if self.handshake(tlsConnection) == True:</span>
<span class="gi">+            self.RequestHandlerClass(tlsConnection, client_address, self)</span>
<span class="gi">+            tlsConnection.close()</span>
<span class="gi">+</span>
<span class="gi">+    #Implement this method to do some form of handshaking.  Return True</span>
<span class="gi">+    #if the handshake finishes properly and the request is authorized.</span>
<span class="gi">+    def handshake(self, tlsConnection):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gh">diff --git a/tlslite/integration/xmlrpcserver.py b/tlslite/integration/xmlrpcserver.py</span>
<span class="gh">index 1d62452..b9cd66f 100644</span>
<span class="gd">--- a/tlslite/integration/xmlrpcserver.py</span>
<span class="gi">+++ b/tlslite/integration/xmlrpcserver.py</span>
<span class="gu">@@ -1,7 +1,15 @@</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Kees Bos</span>
<span class="gi">+#   Martin von Loewis - python 3 port</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;xmlrpcserver.py - simple XML RPC server supporting TLS.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from SimpleXMLRPCServer import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler
<span class="w"> </span>except ImportError:
<span class="gi">+    # Python 3</span>
<span class="w"> </span>    from xmlrpc.server import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler
<span class="w"> </span>from .tlssocketservermixin import TLSSocketServerMixIn

<span class="gu">@@ -9,16 +17,28 @@ from .tlssocketservermixin import TLSSocketServerMixIn</span>
<span class="w"> </span>class TLSXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
<span class="w"> </span>    &quot;&quot;&quot;XMLRPCRequestHandler using TLS.&quot;&quot;&quot;

<span class="gi">+    # Redefine the setup method (see SocketServer.StreamRequestHandler)</span>
<span class="w"> </span>    def setup(self):
<span class="w"> </span>        &quot;&quot;&quot;Setup the connection for TLS.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.connection = self.request</span>
<span class="gi">+        if getattr(self, &#39;timeout&#39;, None) is not None:</span>
<span class="gi">+            # Python 2.7</span>
<span class="gi">+            self.connection.settimeout(self.timeout)</span>
<span class="gi">+        self.rfile = self.connection.makefile(&#39;rb&#39;, self.rbufsize)</span>
<span class="gi">+        self.wfile = self.connection.makefile(&#39;wb&#39;, self.wbufsize)</span>

<span class="w"> </span>    def do_POST(self):
<span class="w"> </span>        &quot;&quot;&quot;Handle the HTTPS POST request.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        SimpleXMLRPCRequestHandler.do_POST(self)</span>
<span class="gi">+        try:</span>
<span class="gi">+            # shut down the connection</span>
<span class="gi">+            self.connection.shutdown()</span>
<span class="gi">+        except:</span>
<span class="gi">+            pass</span>


<span class="gd">-class TLSXMLRPCServer(TLSSocketServerMixIn, SimpleXMLRPCServer):</span>
<span class="gi">+class TLSXMLRPCServer(TLSSocketServerMixIn,</span>
<span class="gi">+                      SimpleXMLRPCServer):</span>
<span class="w"> </span>    &quot;&quot;&quot;Simple XML-RPC server using TLS.&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, addr, *args, **kwargs):
<span class="gh">diff --git a/tlslite/integration/xmlrpctransport.py b/tlslite/integration/xmlrpctransport.py</span>
<span class="gh">index 256ade1..6f60afa 100644</span>
<span class="gd">--- a/tlslite/integration/xmlrpctransport.py</span>
<span class="gi">+++ b/tlslite/integration/xmlrpctransport.py</span>
<span class="gu">@@ -1,8 +1,18 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Kees Bos - Fixes for compatibility with different Python versions</span>
<span class="gi">+#   Martin von Loewis - python 3 port</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;TLS Lite + xmlrpclib.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import xmlrpclib
<span class="w"> </span>    import httplib
<span class="w"> </span>except ImportError:
<span class="gi">+    # Python 3</span>
<span class="w"> </span>    from xmlrpc import client as xmlrpclib
<span class="w"> </span>    from http import client as httplib
<span class="w"> </span>from tlslite.integration.httptlsconnection import HTTPTLSConnection
<span class="gu">@@ -12,13 +22,18 @@ import tlslite.errors</span>

<span class="w"> </span>class XMLRPCTransport(xmlrpclib.Transport, ClientHelper):
<span class="w"> </span>    &quot;&quot;&quot;Handles an HTTPS transaction to an XML-RPC server.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # Pre python 2.7, the make_connection returns a HTTP class</span>
<span class="w"> </span>    transport = xmlrpclib.Transport()
<span class="w"> </span>    conn_class_is_http = not hasattr(transport, &#39;_connection&#39;)
<span class="gd">-    del transport</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, use_datetime=0, username=None, password=None,</span>
<span class="gd">-        certChain=None, privateKey=None, checker=None, settings=None,</span>
<span class="gd">-        ignoreAbruptClose=False):</span>
<span class="gi">+    del(transport)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, use_datetime=0,</span>
<span class="gi">+                 username=None, password=None,</span>
<span class="gi">+                 certChain=None, privateKey=None,</span>
<span class="gi">+                 checker=None,</span>
<span class="gi">+                 settings=None,</span>
<span class="gi">+                 ignoreAbruptClose=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a new XMLRPCTransport.

<span class="gu">@@ -87,12 +102,37 @@ class XMLRPCTransport(xmlrpclib.Transport, ClientHelper):</span>
<span class="w"> </span>        :param ignoreAbruptClose: ignore the TLSAbruptCloseError on
<span class="w"> </span>            unexpected hangup.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self._connection = None, None</span>
<span class="gi">+        # self._connection is new in python 2.7, since we&#39;re using it here,</span>
<span class="gi">+        # we&#39;ll add this ourselves too, just in case we&#39;re pre-2.7</span>
<span class="gi">+        self._connection = (None, None)</span>
<span class="w"> </span>        xmlrpclib.Transport.__init__(self, use_datetime)
<span class="w"> </span>        self.ignoreAbruptClose = ignoreAbruptClose
<span class="gd">-        ClientHelper.__init__(self, username, password, certChain,</span>
<span class="gd">-            privateKey, checker, settings)</span>
<span class="gi">+        ClientHelper.__init__(self,</span>
<span class="gi">+                 username, password, </span>
<span class="gi">+                 certChain, privateKey,</span>
<span class="gi">+                 checker,</span>
<span class="gi">+                 settings)</span>

<span class="w"> </span>    def make_connection(self, host):
<span class="w"> </span>        &quot;&quot;&quot;Make a connection to `host`. Reuse keepalive connections.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # return an existing connection if possible.  This allows</span>
<span class="gi">+        # HTTP/1.1 keep-alive.</span>
<span class="gi">+        if self._connection and host == self._connection[0]:</span>
<span class="gi">+            http = self._connection[1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # create a HTTPS connection object from a host descriptor</span>
<span class="gi">+            chost, extra_headers, x509 = self.get_host_info(host)</span>
<span class="gi">+</span>
<span class="gi">+            http = HTTPTLSConnection(</span>
<span class="gi">+                chost, None, username=self.username, password=self.password,</span>
<span class="gi">+                certChain=self.certChain, privateKey=self.privateKey,</span>
<span class="gi">+                checker=self.checker,</span>
<span class="gi">+                settings=self.settings,</span>
<span class="gi">+                ignoreAbruptClose=self.ignoreAbruptClose)</span>
<span class="gi">+            # store the host argument along with the connection object</span>
<span class="gi">+            self._connection = host, http</span>
<span class="gi">+        if not self.conn_class_is_http:</span>
<span class="gi">+            return http</span>
<span class="gi">+        http2 = httplib.HTTP()</span>
<span class="gi">+        http2._setup(http)</span>
<span class="gi">+        return http2</span>
<span class="gh">diff --git a/tlslite/keyexchange.py b/tlslite/keyexchange.py</span>
<span class="gh">index 847c510..2242aad 100644</span>
<span class="gd">--- a/tlslite/keyexchange.py</span>
<span class="gi">+++ b/tlslite/keyexchange.py</span>
<span class="gu">@@ -1,19 +1,29 @@</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Hubert Kario (2015)</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="w"> </span>&quot;&quot;&quot;Handling of cryptographic operations for key exchange&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import ecdsa
<span class="gd">-from .mathtls import goodGroupParameters, makeK, makeU, makeX, paramStrength, RFC7919_GROUPS, calc_key</span>
<span class="gd">-from .errors import TLSInsufficientSecurity, TLSUnknownPSKIdentity, TLSIllegalParameterException, TLSDecryptionFailed, TLSInternalError, TLSDecodeError</span>
<span class="gi">+from .mathtls import goodGroupParameters, makeK, makeU, makeX, \</span>
<span class="gi">+        paramStrength, RFC7919_GROUPS, calc_key</span>
<span class="gi">+from .errors import TLSInsufficientSecurity, TLSUnknownPSKIdentity, \</span>
<span class="gi">+        TLSIllegalParameterException, TLSDecryptionFailed, TLSInternalError, \</span>
<span class="gi">+        TLSDecodeError</span>
<span class="w"> </span>from .messages import ServerKeyExchange, ClientKeyExchange, CertificateVerify
<span class="gd">-from .constants import SignatureAlgorithm, HashAlgorithm, CipherSuite, ExtensionType, GroupName, ECCurveType, SignatureScheme</span>
<span class="gi">+from .constants import SignatureAlgorithm, HashAlgorithm, CipherSuite, \</span>
<span class="gi">+        ExtensionType, GroupName, ECCurveType, SignatureScheme</span>
<span class="w"> </span>from .utils.ecc import getCurveByName, getPointByteSize
<span class="w"> </span>from .utils.rsakey import RSAKey
<span class="gd">-from .utils.cryptomath import bytesToNumber, getRandomBytes, powMod, numBits, numberToByteArray, divceil, numBytes, secureHash</span>
<span class="gi">+from .utils.cryptomath import bytesToNumber, getRandomBytes, powMod, \</span>
<span class="gi">+        numBits, numberToByteArray, divceil, numBytes, secureHash</span>
<span class="w"> </span>from .utils.lists import getFirstMatching
<span class="w"> </span>from .utils import tlshashlib as hashlib
<span class="gd">-from .utils.x25519 import x25519, x448, X25519_G, X448_G, X25519_ORDER_SIZE, X448_ORDER_SIZE</span>
<span class="gi">+from .utils.x25519 import x25519, x448, X25519_G, X448_G, X25519_ORDER_SIZE, \</span>
<span class="gi">+        X448_ORDER_SIZE</span>
<span class="w"> </span>from .utils.compat import int_types
<span class="w"> </span>from .utils.codec import DecodeError

<span class="gd">-</span>
<span class="w"> </span>class KeyExchange(object):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Common API for calculating Premaster secret
<span class="gu">@@ -36,7 +46,7 @@ class KeyExchange(object):</span>
<span class="w"> </span>        handshake. If the key exchange method does not send ServerKeyExchange
<span class="w"> </span>        (e.g. RSA), it returns None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    def makeClientKeyExchange(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -45,7 +55,8 @@ class KeyExchange(object):</span>
<span class="w"> </span>        Returns a ClientKeyExchange for the second flight from client in the
<span class="w"> </span>        handshake.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ClientKeyExchange(self.cipherSuite,</span>
<span class="gi">+                                 self.serverHello.server_version)</span>

<span class="w"> </span>    def processClientKeyExchange(self, clientKeyExchange):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -54,23 +65,127 @@ class KeyExchange(object):</span>
<span class="w"> </span>        Processes the client&#39;s ClientKeyExchange message and returns the
<span class="w"> </span>        premaster secret. Raises TLSLocalAlert on error.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def processServerKeyExchange(self, srvPublicKey, serverKeyExchange):</span>
<span class="gi">+    def processServerKeyExchange(self, srvPublicKey,</span>
<span class="gi">+                                 serverKeyExchange):</span>
<span class="w"> </span>        &quot;&quot;&quot;Process the server KEX and return premaster secret&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _tls12_sign_ecdsa_SKE(self, serverKeyExchange, sigHash=None):</span>
<span class="gi">+        try:</span>
<span class="gi">+            serverKeyExchange.hashAlg, serverKeyExchange.signAlg = \</span>
<span class="gi">+                    getattr(SignatureScheme, sigHash)</span>
<span class="gi">+            hashName = SignatureScheme.getHash(sigHash)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            serverKeyExchange.hashAlg = getattr(HashAlgorithm, sigHash)</span>
<span class="gi">+            serverKeyExchange.signAlg = SignatureAlgorithm.ecdsa</span>
<span class="gi">+            hashName = sigHash</span>
<span class="gi">+</span>
<span class="gi">+        hash_bytes = serverKeyExchange.hash(self.clientHello.random,</span>
<span class="gi">+                                            self.serverHello.random)</span>
<span class="gi">+</span>
<span class="gi">+        hash_bytes = hash_bytes[:self.privateKey.private_key.curve.baselen]</span>
<span class="gi">+</span>
<span class="gi">+        serverKeyExchange.signature = \</span>
<span class="gi">+            self.privateKey.sign(hash_bytes, hashAlg=hashName)</span>
<span class="gi">+</span>
<span class="gi">+        if not serverKeyExchange.signature:</span>
<span class="gi">+            raise TLSInternalError(&quot;Empty signature&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not self.privateKey.verify(serverKeyExchange.signature,</span>
<span class="gi">+                                             hash_bytes,</span>
<span class="gi">+                                             ecdsa.util.sigdecode_der):</span>
<span class="gi">+            raise TLSInternalError(&quot;signature validation failure&quot;)</span>

<span class="w"> </span>    def _tls12_sign_dsa_SKE(self, serverKeyExchange, sigHash=None):
<span class="w"> </span>        &quot;&quot;&quot;Sign a TLSv1.2 SKE message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            serverKeyExchange.hashAlg, serverKeyExchange.signAlg = \</span>
<span class="gi">+                getattr(SignatureScheme, sigHash)</span>
<span class="gi">+</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            serverKeyExchange.signAlg = SignatureAlgorithm.dsa</span>
<span class="gi">+            serverKeyExchange.hashAlg = getattr(HashAlgorithm, sigHash)</span>
<span class="gi">+</span>
<span class="gi">+        hashBytes = serverKeyExchange.hash(self.clientHello.random,</span>
<span class="gi">+                                           self.serverHello.random)</span>
<span class="gi">+</span>
<span class="gi">+        serverKeyExchange.signature = \</span>
<span class="gi">+            self.privateKey.sign(hashBytes)</span>
<span class="gi">+</span>
<span class="gi">+        if not serverKeyExchange.signature:</span>
<span class="gi">+            raise TLSInternalError(&quot;Empty signature&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not self.privateKey.verify(serverKeyExchange.signature,</span>
<span class="gi">+                                      hashBytes):</span>
<span class="gi">+            raise TLSInternalError(&quot;Server Key Exchange signature invalid&quot;)</span>

<span class="w"> </span>    def _tls12_sign_eddsa_ske(self, server_key_exchange, sig_hash):
<span class="w"> </span>        &quot;&quot;&quot;Sign a TLSv1.2 SKE message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        server_key_exchange.hashAlg, server_key_exchange.signAlg = \</span>
<span class="gi">+                getattr(SignatureScheme, sig_hash)</span>
<span class="gi">+        pad_type = None</span>
<span class="gi">+        hash_name = None</span>
<span class="gi">+        salt_len = None</span>
<span class="gi">+</span>
<span class="gi">+        hash_bytes = server_key_exchange.hash(self.clientHello.random,</span>
<span class="gi">+                                              self.serverHello.random)</span>
<span class="gi">+</span>
<span class="gi">+        server_key_exchange.signature = \</span>
<span class="gi">+            self.privateKey.hashAndSign(hash_bytes,</span>
<span class="gi">+                                        pad_type,</span>
<span class="gi">+                                        hash_name,</span>
<span class="gi">+                                        salt_len)</span>
<span class="gi">+</span>
<span class="gi">+        if not server_key_exchange.signature:</span>
<span class="gi">+            raise TLSInternalError(&quot;Empty signature&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not self.privateKey.hashAndVerify(</span>
<span class="gi">+                server_key_exchange.signature,</span>
<span class="gi">+                hash_bytes,</span>
<span class="gi">+                pad_type,</span>
<span class="gi">+                hash_name,</span>
<span class="gi">+                salt_len):</span>
<span class="gi">+            raise TLSInternalError(&quot;Server Key Exchange signature invalid&quot;)</span>

<span class="w"> </span>    def _tls12_signSKE(self, serverKeyExchange, sigHash=None):
<span class="w"> </span>        &quot;&quot;&quot;Sign a TLSv1.2 SKE message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            serverKeyExchange.hashAlg, serverKeyExchange.signAlg = \</span>
<span class="gi">+                    getattr(SignatureScheme, sigHash)</span>
<span class="gi">+            keyType = SignatureScheme.getKeyType(sigHash)</span>
<span class="gi">+            padType = SignatureScheme.getPadding(sigHash)</span>
<span class="gi">+            hashName = SignatureScheme.getHash(sigHash)</span>
<span class="gi">+            saltLen = getattr(hashlib, hashName)().digest_size</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            serverKeyExchange.signAlg = SignatureAlgorithm.rsa</span>
<span class="gi">+            serverKeyExchange.hashAlg = getattr(HashAlgorithm, sigHash)</span>
<span class="gi">+            keyType = &#39;rsa&#39;</span>
<span class="gi">+            padType = &#39;pkcs1&#39;</span>
<span class="gi">+            hashName = sigHash</span>
<span class="gi">+            saltLen = 0</span>
<span class="gi">+</span>
<span class="gi">+        assert keyType == &#39;rsa&#39;</span>
<span class="gi">+</span>
<span class="gi">+        hashBytes = serverKeyExchange.hash(self.clientHello.random,</span>
<span class="gi">+                                           self.serverHello.random)</span>
<span class="gi">+</span>
<span class="gi">+        serverKeyExchange.signature = \</span>
<span class="gi">+            self.privateKey.sign(hashBytes,</span>
<span class="gi">+                                 padding=padType,</span>
<span class="gi">+                                 hashAlg=hashName,</span>
<span class="gi">+                                 saltLen=saltLen)</span>
<span class="gi">+</span>
<span class="gi">+        if not serverKeyExchange.signature:</span>
<span class="gi">+            raise TLSInternalError(&quot;Empty signature&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not self.privateKey.verify(serverKeyExchange.signature,</span>
<span class="gi">+                                      hashBytes,</span>
<span class="gi">+                                      padding=padType,</span>
<span class="gi">+                                      hashAlg=hashName,</span>
<span class="gi">+                                      saltLen=saltLen):</span>
<span class="gi">+            raise TLSInternalError(&quot;Server Key Exchange signature invalid&quot;)</span>

<span class="w"> </span>    def signServerKeyExchange(self, serverKeyExchange, sigHash=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -79,40 +194,223 @@ class KeyExchange(object):</span>
<span class="w"> </span>        :type sigHash: str
<span class="w"> </span>        :param sigHash: name of the signature hash to be used for signing
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.serverHello.server_version &lt; (3, 3):</span>
<span class="gi">+            if self.privateKey.key_type == &quot;ecdsa&quot;:</span>
<span class="gi">+                serverKeyExchange.signAlg = SignatureAlgorithm.ecdsa</span>
<span class="gi">+            if self.privateKey.key_type == &quot;dsa&quot;:</span>
<span class="gi">+                serverKeyExchange.signAlg = SignatureAlgorithm.dsa</span>
<span class="gi">+            hashBytes = serverKeyExchange.hash(self.clientHello.random,</span>
<span class="gi">+                                               self.serverHello.random)</span>
<span class="gi">+</span>
<span class="gi">+            serverKeyExchange.signature = self.privateKey.sign(hashBytes)</span>
<span class="gi">+</span>
<span class="gi">+            if not serverKeyExchange.signature:</span>
<span class="gi">+                raise TLSInternalError(&quot;Empty signature&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if not self.privateKey.verify(serverKeyExchange.signature,</span>
<span class="gi">+                                          hashBytes):</span>
<span class="gi">+                raise TLSInternalError(&quot;Server Key Exchange signature invalid&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.privateKey.key_type == &quot;ecdsa&quot;:</span>
<span class="gi">+                self._tls12_sign_ecdsa_SKE(serverKeyExchange, sigHash)</span>
<span class="gi">+            elif self.privateKey.key_type == &quot;dsa&quot;:</span>
<span class="gi">+                self._tls12_sign_dsa_SKE(serverKeyExchange, sigHash)</span>
<span class="gi">+            elif self.privateKey.key_type in (&quot;Ed25519&quot;, &quot;Ed448&quot;):</span>
<span class="gi">+                self._tls12_sign_eddsa_ske(serverKeyExchange, sigHash)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._tls12_signSKE(serverKeyExchange, sigHash)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _tls12_verify_ecdsa_SKE(serverKeyExchange, publicKey, clientRandom,</span>
<span class="gi">+                                serverRandom, validSigAlgs):</span>
<span class="gi">+        hashName = HashAlgorithm.toRepr(serverKeyExchange.hashAlg)</span>
<span class="gi">+        if not hashName:</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Unknown hash algorithm&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        hashBytes = serverKeyExchange.hash(clientRandom, serverRandom)</span>
<span class="gi">+</span>
<span class="gi">+        hashBytes = hashBytes[:publicKey.public_key.curve.baselen]</span>
<span class="gi">+</span>
<span class="gi">+        if not publicKey.verify(serverKeyExchange.signature, hashBytes,</span>
<span class="gi">+                                padding=None,</span>
<span class="gi">+                                hashAlg=hashName,</span>
<span class="gi">+                                saltLen=None):</span>
<span class="gi">+            raise TLSDecryptionFailed(&quot;Server Key Exchange signature &quot;</span>
<span class="gi">+                                      &quot;invalid&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _tls12_verify_eddsa_ske(server_key_exchange, public_key,</span>
<span class="gd">-        client_random, server_random, valid_sig_algs):</span>
<span class="gi">+    def _tls12_verify_eddsa_ske(server_key_exchange, public_key, client_random,</span>
<span class="gi">+                                server_random, valid_sig_algs):</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify SeverKeyExchange messages with EdDSA signatures.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        del valid_sig_algs</span>
<span class="gi">+        sig_bytes = server_key_exchange.signature</span>
<span class="gi">+        if not sig_bytes:</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Empty signature&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        hash_bytes = server_key_exchange.hash(client_random, server_random)</span>
<span class="gi">+</span>
<span class="gi">+        if not public_key.hashAndVerify(sig_bytes,</span>
<span class="gi">+                                        hash_bytes):</span>
<span class="gi">+            raise TLSDecryptionFailed(&quot;Server Key Exchange signature invalid&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _tls12_verify_dsa_SKE(serverKeyExchange, publicKey, clientRandom,</span>
<span class="gi">+                              serverRandom, validSigAlgs):</span>
<span class="gi">+</span>
<span class="gi">+        hashBytes = serverKeyExchange.hash(clientRandom, serverRandom)</span>
<span class="gi">+</span>
<span class="gi">+        if not publicKey.verify(serverKeyExchange.signature, hashBytes):</span>
<span class="gi">+            raise TLSDecryptionFailed(&quot;Server Key Exchange signature &quot;</span>
<span class="gi">+                                      &quot;invalid&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _tls12_verify_SKE(serverKeyExchange, publicKey, clientRandom,
<span class="gd">-        serverRandom, validSigAlgs):</span>
<span class="gi">+                          serverRandom, validSigAlgs):</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify TLSv1.2 version of SKE.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (serverKeyExchange.hashAlg, serverKeyExchange.signAlg) not in \</span>
<span class="gi">+                validSigAlgs:</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Server selected &quot;</span>
<span class="gi">+                                               &quot;invalid signature &quot;</span>
<span class="gi">+                                               &quot;algorithm&quot;)</span>
<span class="gi">+        if (serverKeyExchange.hashAlg, serverKeyExchange.signAlg) in (</span>
<span class="gi">+                SignatureScheme.ed25519, SignatureScheme.ed448):</span>
<span class="gi">+            return KeyExchange._tls12_verify_eddsa_ske(serverKeyExchange,</span>
<span class="gi">+                                                       publicKey,</span>
<span class="gi">+                                                       clientRandom,</span>
<span class="gi">+                                                       serverRandom,</span>
<span class="gi">+                                                       validSigAlgs)</span>
<span class="gi">+        if serverKeyExchange.signAlg == SignatureAlgorithm.ecdsa:</span>
<span class="gi">+            return KeyExchange._tls12_verify_ecdsa_SKE(serverKeyExchange,</span>
<span class="gi">+                                                       publicKey,</span>
<span class="gi">+                                                       clientRandom,</span>
<span class="gi">+                                                       serverRandom,</span>
<span class="gi">+                                                       validSigAlgs)</span>
<span class="gi">+</span>
<span class="gi">+        elif serverKeyExchange.signAlg == SignatureAlgorithm.dsa:</span>
<span class="gi">+            return KeyExchange._tls12_verify_dsa_SKE(serverKeyExchange,</span>
<span class="gi">+                                                     publicKey,</span>
<span class="gi">+                                                     clientRandom,</span>
<span class="gi">+                                                     serverRandom,</span>
<span class="gi">+                                                     validSigAlgs)</span>
<span class="gi">+</span>
<span class="gi">+        schemeID = (serverKeyExchange.hashAlg,</span>
<span class="gi">+                    serverKeyExchange.signAlg)</span>
<span class="gi">+        scheme = SignatureScheme.toRepr(schemeID)</span>
<span class="gi">+        if scheme is not None:</span>
<span class="gi">+            keyType = SignatureScheme.getKeyType(scheme)</span>
<span class="gi">+            padType = SignatureScheme.getPadding(scheme)</span>
<span class="gi">+            hashName = SignatureScheme.getHash(scheme)</span>
<span class="gi">+            saltLen = getattr(hashlib, hashName)().digest_size</span>
<span class="gi">+        else:</span>
<span class="gi">+            if serverKeyExchange.signAlg != SignatureAlgorithm.rsa:</span>
<span class="gi">+                raise TLSInternalError(&quot;non-RSA sigs are not supported&quot;)</span>
<span class="gi">+            keyType = &#39;rsa&#39;</span>
<span class="gi">+            padType = &#39;pkcs1&#39;</span>
<span class="gi">+            saltLen = 0</span>
<span class="gi">+            hashName = HashAlgorithm.toRepr(serverKeyExchange.hashAlg)</span>
<span class="gi">+            if hashName is None:</span>
<span class="gi">+                msg = &quot;Unknown hash ID: {0}&quot;\</span>
<span class="gi">+                        .format(serverKeyExchange.hashAlg)</span>
<span class="gi">+                raise TLSIllegalParameterException(msg)</span>
<span class="gi">+        assert keyType == &#39;rsa&#39;</span>
<span class="gi">+</span>
<span class="gi">+        hashBytes = serverKeyExchange.hash(clientRandom, serverRandom)</span>
<span class="gi">+</span>
<span class="gi">+        sigBytes = serverKeyExchange.signature</span>
<span class="gi">+        if not sigBytes:</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Empty signature&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not publicKey.verify(sigBytes, hashBytes,</span>
<span class="gi">+                                padding=padType,</span>
<span class="gi">+                                hashAlg=hashName,</span>
<span class="gi">+                                saltLen=saltLen):</span>
<span class="gi">+            raise TLSDecryptionFailed(&quot;Server Key Exchange signature &quot;</span>
<span class="gi">+                                      &quot;invalid&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def verifyServerKeyExchange(serverKeyExchange, publicKey, clientRandom,
<span class="gd">-        serverRandom, validSigAlgs):</span>
<span class="gi">+                                serverRandom, validSigAlgs):</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify signature on the Server Key Exchange message

<span class="w"> </span>        the only acceptable signature algorithms are specified by validSigAlgs
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if serverKeyExchange.version &lt; (3, 3):</span>
<span class="gi">+            hashBytes = serverKeyExchange.hash(clientRandom, serverRandom)</span>
<span class="gi">+            sigBytes = serverKeyExchange.signature</span>
<span class="gi">+</span>
<span class="gi">+            if not sigBytes:</span>
<span class="gi">+                raise TLSIllegalParameterException(&quot;Empty signature&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if not publicKey.verify(sigBytes, hashBytes):</span>
<span class="gi">+                raise TLSDecryptionFailed(&quot;Server Key Exchange signature &quot;</span>
<span class="gi">+                                          &quot;invalid&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            KeyExchange._tls12_verify_SKE(serverKeyExchange, publicKey,</span>
<span class="gi">+                                          clientRandom, serverRandom,</span>
<span class="gi">+                                          validSigAlgs)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def calcVerifyBytes(version, handshakeHashes, signatureAlg,
<span class="gd">-        premasterSecret, clientRandom, serverRandom, prf_name=None,</span>
<span class="gd">-        peer_tag=b&#39;client&#39;, key_type=&#39;rsa&#39;):</span>
<span class="gi">+                        premasterSecret, clientRandom, serverRandom,</span>
<span class="gi">+                        prf_name = None, peer_tag=b&#39;client&#39;, key_type=&quot;rsa&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Calculate signed bytes for Certificate Verify&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if version == (3, 0):</span>
<span class="gi">+            masterSecret = calc_key(version, premasterSecret,</span>
<span class="gi">+                                    0, b&quot;master secret&quot;,</span>
<span class="gi">+                                    client_random=clientRandom,</span>
<span class="gi">+                                    server_random=serverRandom,</span>
<span class="gi">+                                    output_length=48)</span>
<span class="gi">+            verifyBytes = handshakeHashes.digestSSL(masterSecret, b&quot;&quot;)</span>
<span class="gi">+        elif version in ((3, 1), (3, 2)):</span>
<span class="gi">+            if key_type != &quot;ecdsa&quot;:</span>
<span class="gi">+                verifyBytes = handshakeHashes.digest()</span>
<span class="gi">+            else:</span>
<span class="gi">+                verifyBytes = handshakeHashes.digest(&quot;sha1&quot;)</span>
<span class="gi">+        elif version == (3, 3):</span>
<span class="gi">+            if signatureAlg in (SignatureScheme.ed25519,</span>
<span class="gi">+                    SignatureScheme.ed448):</span>
<span class="gi">+                hashName = &quot;intrinsic&quot;</span>
<span class="gi">+                padding = None</span>
<span class="gi">+            elif signatureAlg[1] == SignatureAlgorithm.dsa:</span>
<span class="gi">+                hashName = HashAlgorithm.toRepr(signatureAlg[0])</span>
<span class="gi">+                padding = None</span>
<span class="gi">+            elif signatureAlg[1] != SignatureAlgorithm.ecdsa:</span>
<span class="gi">+                scheme = SignatureScheme.toRepr(signatureAlg)</span>
<span class="gi">+                if scheme is None:</span>
<span class="gi">+                    hashName = HashAlgorithm.toRepr(signatureAlg[0])</span>
<span class="gi">+                    padding = &#39;pkcs1&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    hashName = SignatureScheme.getHash(scheme)</span>
<span class="gi">+                    padding = SignatureScheme.getPadding(scheme)</span>
<span class="gi">+            else:</span>
<span class="gi">+                padding = None</span>
<span class="gi">+                hashName = HashAlgorithm.toRepr(signatureAlg[0])</span>
<span class="gi">+            verifyBytes = handshakeHashes.digest(hashName)</span>
<span class="gi">+            if padding == &#39;pkcs1&#39;:</span>
<span class="gi">+                verifyBytes = RSAKey.addPKCS1Prefix(verifyBytes, hashName)</span>
<span class="gi">+        elif version == (3, 4):</span>
<span class="gi">+            scheme = SignatureScheme.toRepr(signatureAlg)</span>
<span class="gi">+            if scheme:</span>
<span class="gi">+                hash_name = SignatureScheme.getHash(scheme)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # handles negative test cases when we try to pass in</span>
<span class="gi">+                # schemes that are not supported in TLS1.3</span>
<span class="gi">+                hash_name = HashAlgorithm.toRepr(signatureAlg[0])</span>
<span class="gi">+            verifyBytes = bytearray(b&#39;\x20&#39; * 64 +</span>
<span class="gi">+                                    b&#39;TLS 1.3, &#39; + peer_tag +</span>
<span class="gi">+                                    b&#39; CertificateVerify&#39; +</span>
<span class="gi">+                                    b&#39;\x00&#39;) + \</span>
<span class="gi">+                          handshakeHashes.digest(prf_name)</span>
<span class="gi">+            if hash_name != &quot;intrinsic&quot;:</span>
<span class="gi">+                verifyBytes = secureHash(verifyBytes, hash_name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Unsupported TLS version {0}&quot;.format(version))</span>
<span class="gi">+        return verifyBytes</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def makeCertificateVerify(version, handshakeHashes, validSigAlgs,
<span class="gd">-        privateKey, certificateRequest, premasterSecret, clientRandom,</span>
<span class="gd">-        serverRandom):</span>
<span class="gi">+                              privateKey, certificateRequest, premasterSecret,</span>
<span class="gi">+                              clientRandom, serverRandom):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a Certificate Verify message

<span class="w"> </span>        :param version: protocol version in use
<span class="gu">@@ -127,7 +425,71 @@ class KeyExchange(object):</span>
<span class="w"> </span>        :param serverRandom: server provided random value, needed only for
<span class="w"> </span>            SSLv3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        signatureAlgorithm = None</span>
<span class="gi">+        if privateKey.key_type == &quot;ecdsa&quot; and version &lt; (3, 3):</span>
<span class="gi">+            signatureAlgorithm = (HashAlgorithm.sha1, SignatureAlgorithm.ecdsa)</span>
<span class="gi">+        # in TLS 1.2 we must decide which algorithm to use for signing</span>
<span class="gi">+        if version == (3, 3):</span>
<span class="gi">+            serverSigAlgs = certificateRequest.supported_signature_algs</span>
<span class="gi">+            signatureAlgorithm = getFirstMatching(validSigAlgs, serverSigAlgs)</span>
<span class="gi">+            # if none acceptable, do a last resort:</span>
<span class="gi">+            if signatureAlgorithm is None:</span>
<span class="gi">+                signatureAlgorithm = validSigAlgs[0]</span>
<span class="gi">+        verifyBytes = KeyExchange.calcVerifyBytes(version, handshakeHashes,</span>
<span class="gi">+                                                  signatureAlgorithm,</span>
<span class="gi">+                                                  premasterSecret,</span>
<span class="gi">+                                                  clientRandom,</span>
<span class="gi">+                                                  serverRandom,</span>
<span class="gi">+                                                  key_type=privateKey.key_type)</span>
<span class="gi">+        if signatureAlgorithm and signatureAlgorithm in (</span>
<span class="gi">+                SignatureScheme.ed25519, SignatureScheme.ed448):</span>
<span class="gi">+            padding = None</span>
<span class="gi">+            hashName = &quot;intrinsic&quot;</span>
<span class="gi">+            saltLen = None</span>
<span class="gi">+            sig_func = privateKey.hashAndSign</span>
<span class="gi">+            ver_func = privateKey.hashAndVerify</span>
<span class="gi">+        elif signatureAlgorithm and \</span>
<span class="gi">+                signatureAlgorithm[1] == SignatureAlgorithm.ecdsa:</span>
<span class="gi">+            padding = None</span>
<span class="gi">+            hashName = HashAlgorithm.toRepr(signatureAlgorithm[0])</span>
<span class="gi">+            saltLen = None</span>
<span class="gi">+            verifyBytes = verifyBytes[:privateKey.private_key.curve.baselen]</span>
<span class="gi">+            sig_func = privateKey.sign</span>
<span class="gi">+            ver_func = privateKey.verify</span>
<span class="gi">+        elif signatureAlgorithm and \</span>
<span class="gi">+                signatureAlgorithm[1] == SignatureAlgorithm.dsa:</span>
<span class="gi">+            padding = None</span>
<span class="gi">+            hashName = HashAlgorithm.toRepr(signatureAlgorithm[0])</span>
<span class="gi">+            saltLen = None</span>
<span class="gi">+            sig_func = privateKey.sign</span>
<span class="gi">+            ver_func = privateKey.verify</span>
<span class="gi">+        else:</span>
<span class="gi">+            scheme = SignatureScheme.toRepr(signatureAlgorithm)</span>
<span class="gi">+            # for pkcs1 signatures hash is used to add PKCS#1 prefix, but</span>
<span class="gi">+            # that was already done by calcVerifyBytes</span>
<span class="gi">+            hashName = None</span>
<span class="gi">+            saltLen = 0</span>
<span class="gi">+            if scheme is None:</span>
<span class="gi">+                padding = &#39;pkcs1&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                padding = SignatureScheme.getPadding(scheme)</span>
<span class="gi">+                if padding == &#39;pss&#39;:</span>
<span class="gi">+                    hashName = SignatureScheme.getHash(scheme)</span>
<span class="gi">+                    saltLen = getattr(hashlib, hashName)().digest_size</span>
<span class="gi">+            sig_func = privateKey.sign</span>
<span class="gi">+            ver_func = privateKey.verify</span>
<span class="gi">+</span>
<span class="gi">+        signedBytes = sig_func(verifyBytes,</span>
<span class="gi">+                               padding,</span>
<span class="gi">+                               hashName,</span>
<span class="gi">+                               saltLen)</span>
<span class="gi">+        if not ver_func(signedBytes, verifyBytes, padding, hashName,</span>
<span class="gi">+                        saltLen):</span>
<span class="gi">+            raise TLSInternalError(&quot;Certificate Verify signature invalid&quot;)</span>
<span class="gi">+        certificateVerify = CertificateVerify(version)</span>
<span class="gi">+        certificateVerify.create(signedBytes, signatureAlgorithm)</span>
<span class="gi">+</span>
<span class="gi">+        return certificateVerify</span>


<span class="w"> </span>class AuthenticatedKeyExchange(KeyExchange):
<span class="gu">@@ -139,7 +501,9 @@ class AuthenticatedKeyExchange(KeyExchange):</span>

<span class="w"> </span>    def makeServerKeyExchange(self, sigHash=None):
<span class="w"> </span>        &quot;&quot;&quot;Prepare server side of key exchange with selected parameters&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ske = super(AuthenticatedKeyExchange, self).makeServerKeyExchange()</span>
<span class="gi">+        self.signServerKeyExchange(ske, sigHash)</span>
<span class="gi">+        return ske</span>


<span class="w"> </span>class RSAKeyExchange(KeyExchange):
<span class="gu">@@ -151,24 +515,49 @@ class RSAKeyExchange(KeyExchange):</span>

<span class="w"> </span>    def __init__(self, cipherSuite, clientHello, serverHello, privateKey):
<span class="w"> </span>        super(RSAKeyExchange, self).__init__(cipherSuite, clientHello,
<span class="gd">-            serverHello, privateKey)</span>
<span class="gi">+                                             serverHello, privateKey)</span>
<span class="w"> </span>        self.encPremasterSecret = None

<span class="w"> </span>    def makeServerKeyExchange(self, sigHash=None):
<span class="w"> </span>        &quot;&quot;&quot;Don&#39;t create a server key exchange for RSA key exchange&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def processClientKeyExchange(self, clientKeyExchange):
<span class="w"> </span>        &quot;&quot;&quot;Decrypt client key exchange, return premaster secret&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def processServerKeyExchange(self, srvPublicKey, serverKeyExchange):</span>
<span class="gi">+        premasterSecret = self.privateKey.decrypt(\</span>
<span class="gi">+            clientKeyExchange.encryptedPreMasterSecret)</span>
<span class="gi">+</span>
<span class="gi">+        # On decryption failure randomize premaster secret to avoid</span>
<span class="gi">+        # Bleichenbacher&#39;s &quot;million message&quot; attack</span>
<span class="gi">+        randomPreMasterSecret = getRandomBytes(48)</span>
<span class="gi">+        if not premasterSecret:</span>
<span class="gi">+            premasterSecret = randomPreMasterSecret</span>
<span class="gi">+        elif len(premasterSecret) != 48:</span>
<span class="gi">+            premasterSecret = randomPreMasterSecret</span>
<span class="gi">+        else:</span>
<span class="gi">+            versionCheck = (premasterSecret[0], premasterSecret[1])</span>
<span class="gi">+            if versionCheck != self.clientHello.client_version:</span>
<span class="gi">+                #Tolerate buggy IE clients</span>
<span class="gi">+                if versionCheck != self.serverHello.server_version:</span>
<span class="gi">+                    premasterSecret = randomPreMasterSecret</span>
<span class="gi">+        return premasterSecret</span>
<span class="gi">+</span>
<span class="gi">+    def processServerKeyExchange(self, srvPublicKey,</span>
<span class="gi">+                                 serverKeyExchange):</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate premaster secret for server&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        del serverKeyExchange # not present in RSA key exchange</span>
<span class="gi">+        premasterSecret = getRandomBytes(48)</span>
<span class="gi">+        premasterSecret[0] = self.clientHello.client_version[0]</span>
<span class="gi">+        premasterSecret[1] = self.clientHello.client_version[1]</span>
<span class="gi">+</span>
<span class="gi">+        self.encPremasterSecret = srvPublicKey.encrypt(premasterSecret)</span>
<span class="gi">+        return premasterSecret</span>

<span class="w"> </span>    def makeClientKeyExchange(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a client key exchange with clients key share&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        clientKeyExchange = super(RSAKeyExchange, self).makeClientKeyExchange()</span>
<span class="gi">+        clientKeyExchange.createRSA(self.encPremasterSecret)</span>
<span class="gi">+        return clientKeyExchange</span>


<span class="w"> </span>class ADHKeyExchange(KeyExchange):
<span class="gu">@@ -178,15 +567,17 @@ class ADHKeyExchange(KeyExchange):</span>
<span class="w"> </span>    FFDHE without signing serverKeyExchange useful for anonymous DH
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, cipherSuite, clientHello, serverHello, dhParams=None,</span>
<span class="gd">-        dhGroups=None):</span>
<span class="gi">+    def __init__(self, cipherSuite, clientHello, serverHello,</span>
<span class="gi">+                 dhParams=None, dhGroups=None):</span>
<span class="w"> </span>        super(ADHKeyExchange, self).__init__(cipherSuite, clientHello,
<span class="gd">-            serverHello)</span>
<span class="gi">+                                             serverHello)</span>
<span class="gi">+#pylint: enable = invalid-name</span>
<span class="w"> </span>        self.dh_Xs = None
<span class="w"> </span>        self.dh_Yc = None
<span class="w"> </span>        if dhParams:
<span class="w"> </span>            self.dh_g, self.dh_p = dhParams
<span class="w"> </span>        else:
<span class="gi">+            # 2048-bit MODP Group (RFC 5054, group 3)</span>
<span class="w"> </span>            self.dh_g, self.dh_p = goodGroupParameters[2]
<span class="w"> </span>        self.dhGroups = dhGroups

<span class="gu">@@ -194,28 +585,70 @@ class ADHKeyExchange(KeyExchange):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Prepare server side of anonymous key exchange with selected parameters
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Check for RFC 7919 support</span>
<span class="gi">+        ext = self.clientHello.getExtension(ExtensionType.supported_groups)</span>
<span class="gi">+        if ext and self.dhGroups:</span>
<span class="gi">+            commonGroup = getFirstMatching(ext.groups, self.dhGroups)</span>
<span class="gi">+            if commonGroup:</span>
<span class="gi">+                self.dh_g, self.dh_p = RFC7919_GROUPS[commonGroup - 256]</span>
<span class="gi">+            elif getFirstMatching(ext.groups, range(256, 512)):</span>
<span class="gi">+                raise TLSInternalError(&quot;DHE key exchange attempted despite no &quot;</span>
<span class="gi">+                                       &quot;overlap between supported groups&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # for TLS &lt; 1.3 we need special algorithm to select params (see above)</span>
<span class="gi">+        # so do not pass in the group, if we selected one</span>
<span class="gi">+        kex = FFDHKeyExchange(None, self.serverHello.server_version,</span>
<span class="gi">+                              self.dh_g, self.dh_p)</span>
<span class="gi">+        self.dh_Xs = kex.get_random_private_key()</span>
<span class="gi">+        dh_Ys = kex.calc_public_value(self.dh_Xs)</span>
<span class="gi">+</span>
<span class="gi">+        version = self.serverHello.server_version</span>
<span class="gi">+        serverKeyExchange = ServerKeyExchange(self.cipherSuite, version)</span>
<span class="gi">+        serverKeyExchange.createDH(self.dh_p, self.dh_g, dh_Ys)</span>
<span class="gi">+        # No sign for anonymous ServerKeyExchange.</span>
<span class="gi">+        return serverKeyExchange</span>

<span class="w"> </span>    def processClientKeyExchange(self, clientKeyExchange):
<span class="w"> </span>        &quot;&quot;&quot;Use client provided parameters to establish premaster secret&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dh_Yc = clientKeyExchange.dh_Yc</span>
<span class="gi">+</span>
<span class="gi">+        kex = FFDHKeyExchange(None, self.serverHello.server_version,</span>
<span class="gi">+                              self.dh_g, self.dh_p)</span>
<span class="gi">+        return kex.calc_shared_key(self.dh_Xs, dh_Yc)</span>

<span class="w"> </span>    def processServerKeyExchange(self, srvPublicKey, serverKeyExchange):
<span class="w"> </span>        &quot;&quot;&quot;Process the server key exchange, return premaster secret.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        del srvPublicKey</span>
<span class="gi">+        dh_p = serverKeyExchange.dh_p</span>
<span class="gi">+        # TODO make the minimum changeable</span>
<span class="gi">+        if dh_p &lt; 2**1023:</span>
<span class="gi">+            raise TLSInsufficientSecurity(&quot;DH prime too small&quot;)</span>
<span class="gi">+        dh_g = serverKeyExchange.dh_g</span>
<span class="gi">+        dh_Ys = serverKeyExchange.dh_Ys</span>
<span class="gi">+</span>
<span class="gi">+        kex = FFDHKeyExchange(None, self.serverHello.server_version,</span>
<span class="gi">+                              dh_g, dh_p)</span>
<span class="gi">+</span>
<span class="gi">+        dh_Xc = kex.get_random_private_key()</span>
<span class="gi">+        self.dh_Yc = kex.calc_public_value(dh_Xc)</span>
<span class="gi">+        return kex.calc_shared_key(dh_Xc, dh_Ys)</span>

<span class="w"> </span>    def makeClientKeyExchange(self):
<span class="w"> </span>        &quot;&quot;&quot;Create client key share for the key exchange&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cke = super(ADHKeyExchange, self).makeClientKeyExchange()</span>
<span class="gi">+        cke.createDH(self.dh_Yc)</span>
<span class="gi">+        return cke</span>


<span class="gi">+# the DHE_RSA part comes from IETF ciphersuite names, we want to keep it</span>
<span class="gi">+#pylint: disable = invalid-name</span>
<span class="w"> </span>class DHE_RSAKeyExchange(AuthenticatedKeyExchange, ADHKeyExchange):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Handling of authenticated ephemeral Diffe-Hellman Key exchange.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, cipherSuite, clientHello, serverHello, privateKey,
<span class="gd">-        dhParams=None, dhGroups=None):</span>
<span class="gi">+                 dhParams=None, dhGroups=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create helper object for Diffie-Hellamn key exchange.

<span class="gu">@@ -226,7 +659,9 @@ class DHE_RSAKeyExchange(AuthenticatedKeyExchange, ADHKeyExchange):</span>
<span class="w"> </span>        :type dhParams: 2-element tuple of int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super(DHE_RSAKeyExchange, self).__init__(cipherSuite, clientHello,
<span class="gd">-            serverHello, dhParams, dhGroups)</span>
<span class="gi">+                                                 serverHello, dhParams,</span>
<span class="gi">+                                                 dhGroups)</span>
<span class="gi">+#pylint: enable = invalid-name</span>
<span class="w"> </span>        self.privateKey = privateKey


<span class="gu">@@ -237,10 +672,10 @@ class AECDHKeyExchange(KeyExchange):</span>
<span class="w"> </span>    ECDHE without signing serverKeyExchange useful for anonymous ECDH
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, cipherSuite, clientHello, serverHello,</span>
<span class="gd">-        acceptedCurves, defaultCurve=GroupName.secp256r1):</span>
<span class="gi">+    def __init__(self, cipherSuite, clientHello, serverHello, acceptedCurves,</span>
<span class="gi">+                 defaultCurve=GroupName.secp256r1):</span>
<span class="w"> </span>        super(AECDHKeyExchange, self).__init__(cipherSuite, clientHello,
<span class="gd">-            serverHello)</span>
<span class="gi">+                                               serverHello)</span>
<span class="w"> </span>        self.ecdhXs = None
<span class="w"> </span>        self.acceptedCurves = acceptedCurves
<span class="w"> </span>        self.group_id = None
<span class="gu">@@ -249,28 +684,100 @@ class AECDHKeyExchange(KeyExchange):</span>

<span class="w"> </span>    def makeServerKeyExchange(self, sigHash=None):
<span class="w"> </span>        &quot;&quot;&quot;Create AECDHE version of Server Key Exchange&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        #Get client supported groups</span>
<span class="gi">+        client_curves = self.clientHello.getExtension(</span>
<span class="gi">+                ExtensionType.supported_groups)</span>
<span class="gi">+        if client_curves is None:</span>
<span class="gi">+            # in case there is no extension, we can pick any curve,</span>
<span class="gi">+            # use the configured one</span>
<span class="gi">+            client_curves = [self.defaultCurve]</span>
<span class="gi">+        elif not client_curves.groups:</span>
<span class="gi">+            # extension should have been validated before</span>
<span class="gi">+            raise TLSInternalError(&quot;Can&#39;t do ECDHE with no client curves&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            client_curves = client_curves.groups</span>
<span class="gi">+</span>
<span class="gi">+        #Pick first client preferred group we support</span>
<span class="gi">+        self.group_id = getFirstMatching(client_curves, self.acceptedCurves)</span>
<span class="gi">+        if self.group_id is None:</span>
<span class="gi">+            raise TLSInsufficientSecurity(&quot;No mutual groups&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        kex = ECDHKeyExchange(self.group_id, self.serverHello.server_version)</span>
<span class="gi">+        self.ecdhXs = kex.get_random_private_key()</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(self.ecdhXs, ecdsa.keys.SigningKey):</span>
<span class="gi">+            ecdhYs = bytearray(</span>
<span class="gi">+                self.ecdhXs.get_verifying_key().to_string(</span>
<span class="gi">+                    encoding = &#39;uncompressed&#39;</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            ecdhYs = kex.calc_public_value(self.ecdhXs)</span>
<span class="gi">+</span>
<span class="gi">+        version = self.serverHello.server_version</span>
<span class="gi">+        serverKeyExchange = ServerKeyExchange(self.cipherSuite, version)</span>
<span class="gi">+        serverKeyExchange.createECDH(ECCurveType.named_curve,</span>
<span class="gi">+                                     named_curve=self.group_id,</span>
<span class="gi">+                                     point=ecdhYs)</span>
<span class="gi">+        # No sign for anonymous ServerKeyExchange</span>
<span class="gi">+        return serverKeyExchange</span>

<span class="w"> </span>    def processClientKeyExchange(self, clientKeyExchange):
<span class="w"> </span>        &quot;&quot;&quot;Calculate premaster secret from previously generated SKE and CKE&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ecdhYc = clientKeyExchange.ecdh_Yc</span>
<span class="gi">+</span>
<span class="gi">+        if not ecdhYc:</span>
<span class="gi">+            raise TLSDecodeError(&quot;No key share&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        kex = ECDHKeyExchange(self.group_id, self.serverHello.server_version)</span>
<span class="gi">+        return kex.calc_shared_key(self.ecdhXs, ecdhYc)</span>

<span class="w"> </span>    def processServerKeyExchange(self, srvPublicKey, serverKeyExchange):
<span class="w"> </span>        &quot;&quot;&quot;Process the server key exchange, return premaster secret&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        del srvPublicKey</span>
<span class="gi">+</span>
<span class="gi">+        if serverKeyExchange.curve_type != ECCurveType.named_curve \</span>
<span class="gi">+            or serverKeyExchange.named_curve not in self.acceptedCurves:</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Server picked curve we &quot;</span>
<span class="gi">+                                               &quot;didn&#39;t advertise&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        ecdh_Ys = serverKeyExchange.ecdh_Ys</span>
<span class="gi">+        if not ecdh_Ys:</span>
<span class="gi">+            raise TLSDecodeError(&quot;Empty server key share&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        kex = ECDHKeyExchange(serverKeyExchange.named_curve,</span>
<span class="gi">+                              self.serverHello.server_version)</span>
<span class="gi">+        ecdhXc = kex.get_random_private_key()</span>
<span class="gi">+        if isinstance(ecdhXc, ecdsa.keys.SigningKey):</span>
<span class="gi">+            self.ecdhYc = bytearray(</span>
<span class="gi">+                ecdhXc.get_verifying_key().to_string(</span>
<span class="gi">+                    encoding = &#39;uncompressed&#39;</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.ecdhYc = kex.calc_public_value(ecdhXc)</span>
<span class="gi">+        return kex.calc_shared_key(ecdhXc, ecdh_Ys)</span>

<span class="w"> </span>    def makeClientKeyExchange(self):
<span class="w"> </span>        &quot;&quot;&quot;Make client key exchange for ECDHE&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cke = super(AECDHKeyExchange, self).makeClientKeyExchange()</span>
<span class="gi">+        cke.createECDH(self.ecdhYc)</span>
<span class="gi">+        return cke</span>


<span class="gi">+# The ECDHE_RSA part comes from the IETF names of ciphersuites, so we want to</span>
<span class="gi">+# keep it</span>
<span class="gi">+#pylint: disable = invalid-name</span>
<span class="w"> </span>class ECDHE_RSAKeyExchange(AuthenticatedKeyExchange, AECDHKeyExchange):
<span class="w"> </span>    &quot;&quot;&quot;Helper class for conducting ECDHE key exchange&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, cipherSuite, clientHello, serverHello, privateKey,
<span class="gd">-        acceptedCurves, defaultCurve=GroupName.secp256r1):</span>
<span class="gi">+                 acceptedCurves, defaultCurve=GroupName.secp256r1):</span>
<span class="w"> </span>        super(ECDHE_RSAKeyExchange, self).__init__(cipherSuite, clientHello,
<span class="gd">-            serverHello, acceptedCurves, defaultCurve)</span>
<span class="gi">+                                                   serverHello,</span>
<span class="gi">+                                                   acceptedCurves,</span>
<span class="gi">+                                                   defaultCurve)</span>
<span class="gi">+#pylint: enable = invalid-name</span>
<span class="w"> </span>        self.privateKey = privateKey


<span class="gu">@@ -278,10 +785,10 @@ class SRPKeyExchange(KeyExchange):</span>
<span class="w"> </span>    &quot;&quot;&quot;Helper class for conducting SRP key exchange&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, cipherSuite, clientHello, serverHello, privateKey,
<span class="gd">-        verifierDB, srpUsername=None, password=None, settings=None):</span>
<span class="gi">+                 verifierDB, srpUsername=None, password=None, settings=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Link Key Exchange options with verifierDB for SRP&quot;&quot;&quot;
<span class="w"> </span>        super(SRPKeyExchange, self).__init__(cipherSuite, clientHello,
<span class="gd">-            serverHello, privateKey)</span>
<span class="gi">+                                             serverHello, privateKey)</span>
<span class="w"> </span>        self.N = None
<span class="w"> </span>        self.v = None
<span class="w"> </span>        self.b = None
<span class="gu">@@ -292,25 +799,86 @@ class SRPKeyExchange(KeyExchange):</span>
<span class="w"> </span>        self.password = password
<span class="w"> </span>        self.settings = settings
<span class="w"> </span>        if srpUsername is not None and not isinstance(srpUsername, bytearray):
<span class="gd">-            raise TypeError(&#39;srpUsername must be a bytearray object&#39;)</span>
<span class="gi">+            raise TypeError(&quot;srpUsername must be a bytearray object&quot;)</span>
<span class="w"> </span>        if password is not None and not isinstance(password, bytearray):
<span class="gd">-            raise TypeError(&#39;password must be a bytearray object&#39;)</span>
<span class="gi">+            raise TypeError(&quot;password must be a bytearray object&quot;)</span>

<span class="w"> </span>    def makeServerKeyExchange(self, sigHash=None):
<span class="w"> </span>        &quot;&quot;&quot;Create SRP version of Server Key Exchange&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        srpUsername = bytes(self.clientHello.srp_username)</span>
<span class="gi">+        #Get parameters from username</span>
<span class="gi">+        try:</span>
<span class="gi">+            entry = self.verifierDB[srpUsername]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise TLSUnknownPSKIdentity(&quot;Unknown identity&quot;)</span>
<span class="gi">+        (self.N, g, s, self.v) = entry</span>
<span class="gi">+</span>
<span class="gi">+        #Calculate server&#39;s ephemeral DH values (b, B)</span>
<span class="gi">+        self.b = bytesToNumber(getRandomBytes(32))</span>
<span class="gi">+        k = makeK(self.N, g)</span>
<span class="gi">+        self.B = (powMod(g, self.b, self.N) + (k * self.v)) % self.N</span>
<span class="gi">+</span>
<span class="gi">+        #Create ServerKeyExchange, signing it if necessary</span>
<span class="gi">+        serverKeyExchange = ServerKeyExchange(self.cipherSuite,</span>
<span class="gi">+                                              self.serverHello.server_version)</span>
<span class="gi">+        serverKeyExchange.createSRP(self.N, g, s, self.B)</span>
<span class="gi">+        if self.cipherSuite in CipherSuite.srpCertSuites:</span>
<span class="gi">+            self.signServerKeyExchange(serverKeyExchange, sigHash)</span>
<span class="gi">+        return serverKeyExchange</span>

<span class="w"> </span>    def processClientKeyExchange(self, clientKeyExchange):
<span class="w"> </span>        &quot;&quot;&quot;Calculate premaster secret from Client Key Exchange and sent SKE&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        A = clientKeyExchange.srp_A</span>
<span class="gi">+        if A % self.N == 0:</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Invalid SRP A value&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        #Calculate u</span>
<span class="gi">+        u = makeU(self.N, A, self.B)</span>
<span class="gi">+</span>
<span class="gi">+        #Calculate premaster secret</span>
<span class="gi">+        S = powMod((A * powMod(self.v, u, self.N)) % self.N, self.b, self.N)</span>
<span class="gi">+        return numberToByteArray(S)</span>

<span class="w"> </span>    def processServerKeyExchange(self, srvPublicKey, serverKeyExchange):
<span class="w"> </span>        &quot;&quot;&quot;Calculate premaster secret from ServerKeyExchange&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        del srvPublicKey # irrelevant for SRP</span>
<span class="gi">+        N = serverKeyExchange.srp_N</span>
<span class="gi">+        g = serverKeyExchange.srp_g</span>
<span class="gi">+        s = serverKeyExchange.srp_s</span>
<span class="gi">+        B = serverKeyExchange.srp_B</span>
<span class="gi">+</span>
<span class="gi">+        if (g, N) not in goodGroupParameters:</span>
<span class="gi">+            raise TLSInsufficientSecurity(&quot;Unknown group parameters&quot;)</span>
<span class="gi">+        if numBits(N) &lt; self.settings.minKeySize:</span>
<span class="gi">+            raise TLSInsufficientSecurity(&quot;N value is too small: {0}&quot;.\</span>
<span class="gi">+                                          format(numBits(N)))</span>
<span class="gi">+        if numBits(N) &gt; self.settings.maxKeySize:</span>
<span class="gi">+            raise TLSInsufficientSecurity(&quot;N value is too large: {0}&quot;.\</span>
<span class="gi">+                                          format(numBits(N)))</span>
<span class="gi">+        if B % N == 0:</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Suspicious B value&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        #Client ephemeral value</span>
<span class="gi">+        a = bytesToNumber(getRandomBytes(32))</span>
<span class="gi">+        self.A = powMod(g, a, N)</span>
<span class="gi">+</span>
<span class="gi">+        #Calculate client&#39;s static DH values (x, v)</span>
<span class="gi">+        x = makeX(s, self.srpUsername, self.password)</span>
<span class="gi">+        v = powMod(g, x, N)</span>
<span class="gi">+</span>
<span class="gi">+        #Calculate u</span>
<span class="gi">+        u = makeU(N, self.A, B)</span>
<span class="gi">+</span>
<span class="gi">+        #Calculate premaster secret</span>
<span class="gi">+        k = makeK(N, g)</span>
<span class="gi">+        S = powMod((B - (k*v)) % N, a+(u*x), N)</span>
<span class="gi">+        return numberToByteArray(S)</span>

<span class="w"> </span>    def makeClientKeyExchange(self):
<span class="w"> </span>        &quot;&quot;&quot;Create ClientKeyExchange&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cke = super(SRPKeyExchange, self).makeClientKeyExchange()</span>
<span class="gi">+        cke.createSRP(self.A)</span>
<span class="gi">+        return cke</span>


<span class="w"> </span>class RawDHKeyExchange(object):
<span class="gu">@@ -333,15 +901,15 @@ class RawDHKeyExchange(object):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Generate a random value suitable for use as the private value of KEX.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Abstract class&quot;)</span>

<span class="w"> </span>    def calc_public_value(self, private):
<span class="w"> </span>        &quot;&quot;&quot;Calculate the public value from the provided private value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Abstract class&quot;)</span>

<span class="w"> </span>    def calc_shared_key(self, private, peer_share):
<span class="w"> </span>        &quot;&quot;&quot;Calcualte the shared key given our private and remote share value&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;Abstract class&quot;)</span>


<span class="w"> </span>class FFDHKeyExchange(RawDHKeyExchange):
<span class="gu">@@ -350,16 +918,16 @@ class FFDHKeyExchange(RawDHKeyExchange):</span>
<span class="w"> </span>    def __init__(self, group, version, generator=None, prime=None):
<span class="w"> </span>        super(FFDHKeyExchange, self).__init__(group, version)
<span class="w"> </span>        if prime and group:
<span class="gd">-            raise ValueError(</span>
<span class="gd">-                &quot;Can&#39;t set the RFC7919 group and custom params at the same time&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise ValueError(&quot;Can&#39;t set the RFC7919 group and custom params&quot;</span>
<span class="gi">+                             &quot; at the same time&quot;)</span>
<span class="w"> </span>        if group:
<span class="gd">-            self.generator, self.prime = RFC7919_GROUPS[group - 256]</span>
<span class="gi">+            self.generator, self.prime = RFC7919_GROUPS[group-256]</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.prime = prime
<span class="w"> </span>            self.generator = generator
<span class="gi">+</span>
<span class="w"> </span>        if not 1 &lt; self.generator &lt; self.prime:
<span class="gd">-            raise TLSIllegalParameterException(&#39;Invalid DH generator&#39;)</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Invalid DH generator&quot;)</span>

<span class="w"> </span>    def get_random_private_key(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -367,7 +935,10 @@ class FFDHKeyExchange(RawDHKeyExchange):</span>

<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Per RFC 3526, Section 1, the exponent should have double the entropy</span>
<span class="gi">+        # of the strength of the group.</span>
<span class="gi">+        needed_bytes = divceil(paramStrength(self.prime) * 2, 8)</span>
<span class="gi">+        return bytesToNumber(getRandomBytes(needed_bytes))</span>

<span class="w"> </span>    def calc_public_value(self, private):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -375,19 +946,45 @@ class FFDHKeyExchange(RawDHKeyExchange):</span>

<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dh_Y = powMod(self.generator, private, self.prime)</span>
<span class="gi">+        if dh_Y in (1, self.prime - 1):</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Small subgroup capture&quot;)</span>
<span class="gi">+        if self.version &lt; (3, 4):</span>
<span class="gi">+            return dh_Y</span>
<span class="gi">+        else:</span>
<span class="gi">+            return numberToByteArray(dh_Y, numBytes(self.prime))</span>

<span class="w"> </span>    def _normalise_peer_share(self, peer_share):
<span class="w"> </span>        &quot;&quot;&quot;Convert the peer_share to number if necessary.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(peer_share, (int_types)):</span>
<span class="gi">+            return peer_share</span>
<span class="gi">+</span>
<span class="gi">+        if numBytes(self.prime) != len(peer_share):</span>
<span class="gi">+            raise TLSIllegalParameterException(</span>
<span class="gi">+                &quot;Key share does not match FFDH prime&quot;)</span>
<span class="gi">+        return bytesToNumber(peer_share)</span>

<span class="w"> </span>    def calc_shared_key(self, private, peer_share):
<span class="w"> </span>        &quot;&quot;&quot;Calculate the shared key.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        peer_share = self._normalise_peer_share(peer_share)</span>
<span class="gi">+        # First half of RFC 2631, Section 2.1.5. Validate the client&#39;s public</span>
<span class="gi">+        # key.</span>
<span class="gi">+        # use of safe primes also means that the p-1 is invalid</span>
<span class="gi">+        if not 2 &lt;= peer_share &lt; self.prime - 1:</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Invalid peer key share&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        S = powMod(peer_share, private, self.prime)</span>
<span class="gi">+        if S in (1, self.prime - 1):</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Small subgroup capture&quot;)</span>
<span class="gi">+        if self.version &lt; (3, 4):</span>
<span class="gi">+            return numberToByteArray(S)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return numberToByteArray(S, numBytes(self.prime))</span>


<span class="w"> </span>class ECDHKeyExchange(RawDHKeyExchange):
<span class="w"> </span>    &quot;&quot;&quot;Implementation of the Elliptic Curve Diffie-Hellman key exchange.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _x_groups = set((GroupName.x25519, GroupName.x448))

<span class="w"> </span>    @staticmethod
<span class="gu">@@ -397,23 +994,71 @@ class ECDHKeyExchange(RawDHKeyExchange):</span>

<span class="w"> </span>        :raises TLSIllegalParameterException: if the value is all zero
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        summa = 0</span>
<span class="gi">+        for i in value:</span>
<span class="gi">+            summa |= i</span>
<span class="gi">+        if summa == 0:</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Invalid key share&quot;)</span>

<span class="w"> </span>    def __init__(self, group, version):
<span class="w"> </span>        super(ECDHKeyExchange, self).__init__(group, version)

<span class="w"> </span>    def get_random_private_key(self):
<span class="w"> </span>        &quot;&quot;&quot;Return random private key value for the selected curve.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.group in self._x_groups:</span>
<span class="gi">+            if self.group == GroupName.x25519:</span>
<span class="gi">+                return getRandomBytes(X25519_ORDER_SIZE)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return getRandomBytes(X448_ORDER_SIZE)</span>
<span class="gi">+        else:</span>
<span class="gi">+            curve = getCurveByName(GroupName.toStr(self.group))</span>
<span class="gi">+            return ecdsa.keys.SigningKey.generate(curve)</span>

<span class="w"> </span>    def _get_fun_gen_size(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the function and generator for X25519/X448 KEX.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.group == GroupName.x25519:</span>
<span class="gi">+            return x25519, bytearray(X25519_G), X25519_ORDER_SIZE</span>
<span class="gi">+        else:</span>
<span class="gi">+            return x448, bytearray(X448_G), X448_ORDER_SIZE</span>

<span class="w"> </span>    def calc_public_value(self, private):
<span class="w"> </span>        &quot;&quot;&quot;Calculate public value for given private key.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(private, ecdsa.keys.SigningKey):</span>
<span class="gi">+            return private.verifying_key.to_string(&#39;uncompressed&#39;)</span>
<span class="gi">+        if self.group in self._x_groups:</span>
<span class="gi">+            fun, generator, _ = self._get_fun_gen_size()</span>
<span class="gi">+            return fun(private, generator)</span>
<span class="gi">+        else:</span>
<span class="gi">+            curve = getCurveByName(GroupName.toStr(self.group))</span>
<span class="gi">+            point = curve.generator * private</span>
<span class="gi">+            return bytearray(point.to_bytes(&#39;uncompressed&#39;))</span>

<span class="w"> </span>    def calc_shared_key(self, private, peer_share):
<span class="w"> </span>        &quot;&quot;&quot;Calculate the shared key,&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if self.group in self._x_groups:</span>
<span class="gi">+            fun, _, size = self._get_fun_gen_size()</span>
<span class="gi">+            if len(peer_share) != size:</span>
<span class="gi">+                raise TLSIllegalParameterException(&quot;Invalid key share&quot;)</span>
<span class="gi">+            if isinstance(private, ecdsa.keys.SigningKey):</span>
<span class="gi">+                private = bytesToNumber(private.to_string())</span>
<span class="gi">+            S = fun(private, peer_share)</span>
<span class="gi">+            self._non_zero_check(S)</span>
<span class="gi">+            return S</span>
<span class="gi">+</span>
<span class="gi">+        curve = getCurveByName(GroupName.toRepr(self.group))</span>
<span class="gi">+        try:</span>
<span class="gi">+            abstractPoint = ecdsa.ellipticcurve.AbstractPoint()</span>
<span class="gi">+            point = abstractPoint.from_bytes(curve.curve, peer_share)</span>
<span class="gi">+            ecdhYc = ecdsa.ellipticcurve.Point(</span>
<span class="gi">+                curve.curve, point[0], point[1])</span>
<span class="gi">+</span>
<span class="gi">+        except (AssertionError, DecodeError):</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Invalid ECC point&quot;)</span>
<span class="gi">+        if isinstance(private, ecdsa.keys.SigningKey):</span>
<span class="gi">+            ecdh = ecdsa.ecdh.ECDH(curve=curve, private_key=private)</span>
<span class="gi">+            ecdh.load_received_public_key_bytes(peer_share)</span>
<span class="gi">+            return bytearray(ecdh.generate_sharedsecret_bytes())</span>
<span class="gi">+        S = ecdhYc * private</span>
<span class="gi">+</span>
<span class="gi">+        return numberToByteArray(S.x(), getPointByteSize(ecdhYc))</span>
<span class="gh">diff --git a/tlslite/mathtls.py b/tlslite/mathtls.py</span>
<span class="gh">index abd3d46..8406ff7 100644</span>
<span class="gd">--- a/tlslite/mathtls.py</span>
<span class="gi">+++ b/tlslite/mathtls.py</span>
<span class="gu">@@ -1,10 +1,21 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Dave Baggett (Arcode Corporation) - MD5 support for MAC_SSL</span>
<span class="gi">+#   Yngve Pettersen (ported by Paul Sokolovsky) - TLS 1.2</span>
<span class="gi">+#   Hubert Kario - SHA384 PRF</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Miscellaneous helper functions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .utils.compat import *
<span class="w"> </span>from .utils.cryptomath import *
<span class="w"> </span>from .constants import CipherSuite
<span class="w"> </span>from .utils import tlshashlib as hashlib
<span class="w"> </span>from .utils import tlshmac as hmac
<span class="w"> </span>from .utils.deprecations import deprecated_method
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>FFDHE_PARAMETERS = {}
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Listing of all well known FFDH parameters.
<span class="gu">@@ -14,26 +25,36 @@ Please note that this dictionary includes all groups that are well-known</span>

<span class="w"> </span>You should use RFC7919_GROUPS for well-known secure groups.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-RFC2409_GROUP1 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 2409 section 6.1, First Oakley Group, 768 bit MODP</span>
<span class="gi">+RFC2409_GROUP1 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>         FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
<span class="w"> </span>         29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
<span class="w"> </span>         EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
<span class="gd">-         E485B576 625E7EC6 F44C42E9 A63A3620 FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC2409 group 1&#39;] = RFC2409_GROUP1</span>
<span class="gd">-RFC2409_GROUP2 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+         E485B576 625E7EC6 F44C42E9 A63A3620 FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC2409 group 1&quot;] = RFC2409_GROUP1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 2409 section 6.2, Second Oakley Group, 1024 bit MODP</span>
<span class="gi">+RFC2409_GROUP2 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>         FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
<span class="w"> </span>         29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
<span class="w"> </span>         EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
<span class="w"> </span>         E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
<span class="w"> </span>         EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381
<span class="gd">-         FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC2409 group 2&#39;] = RFC2409_GROUP2</span>
<span class="gd">-RFC3526_GROUP5 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+         FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC2409 group 2&quot;] = RFC2409_GROUP2</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 3526 section 2, 1536 bit MODP</span>
<span class="gi">+RFC3526_GROUP5 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
<span class="w"> </span>      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
<span class="w"> </span>      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
<span class="gu">@@ -41,11 +62,14 @@ RFC3526_GROUP5 = 2, int(remove_whitespace(</span>
<span class="w"> </span>      EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
<span class="w"> </span>      C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
<span class="w"> </span>      83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
<span class="gd">-      670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC3526 group 5&#39;] = RFC3526_GROUP5</span>
<span class="gd">-RFC3526_GROUP14 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+      670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC3526 group 5&quot;] = RFC3526_GROUP5</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 3526 section 3, 2048 bit MODP</span>
<span class="gi">+RFC3526_GROUP14 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
<span class="w"> </span>      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
<span class="w"> </span>      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
<span class="gu">@@ -56,11 +80,14 @@ RFC3526_GROUP14 = 2, int(remove_whitespace(</span>
<span class="w"> </span>      670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
<span class="w"> </span>      E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
<span class="w"> </span>      DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
<span class="gd">-      15728E5A 8AACAA68 FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC3526 group 14&#39;] = RFC3526_GROUP14</span>
<span class="gd">-RFC3526_GROUP15 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+      15728E5A 8AACAA68 FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC3526 group 14&quot;] = RFC3526_GROUP14</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 3526 section 4, 3072 bit MODP</span>
<span class="gi">+RFC3526_GROUP15 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
<span class="w"> </span>      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
<span class="w"> </span>      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
<span class="gu">@@ -76,11 +103,14 @@ RFC3526_GROUP15 = 2, int(remove_whitespace(</span>
<span class="w"> </span>      ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6B
<span class="w"> </span>      F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
<span class="w"> </span>      BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31
<span class="gd">-      43DB5BFC E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC3526 group 15&#39;] = RFC3526_GROUP15</span>
<span class="gd">-RFC3526_GROUP16 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+      43DB5BFC E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC3526 group 15&quot;] = RFC3526_GROUP15</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 3526 section 5, 4096 bit MODP</span>
<span class="gi">+RFC3526_GROUP16 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
<span class="w"> </span>      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
<span class="w"> </span>      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
<span class="gu">@@ -102,11 +132,14 @@ RFC3526_GROUP16 = 2, int(remove_whitespace(</span>
<span class="w"> </span>      287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED
<span class="w"> </span>      1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA9
<span class="w"> </span>      93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199
<span class="gd">-      FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC3526 group 16&#39;] = RFC3526_GROUP16</span>
<span class="gd">-RFC3526_GROUP17 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+      FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC3526 group 16&quot;] = RFC3526_GROUP16</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 3526 section 6, 6144 bit MODP</span>
<span class="gi">+RFC3526_GROUP17 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>   FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
<span class="w"> </span>   8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
<span class="w"> </span>   302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
<span class="gu">@@ -134,11 +167,14 @@ RFC3526_GROUP17 = 2, int(remove_whitespace(</span>
<span class="w"> </span>   CC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE328 06A1D58B
<span class="w"> </span>   B7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55C DA56C9EC 2EF29632
<span class="w"> </span>   387FE8D7 6E3C0468 043E8F66 3F4860EE 12BF2D5B 0B7474D6 E694F91E
<span class="gd">-   6DCC4024 FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC3526 group 17&#39;] = RFC3526_GROUP17</span>
<span class="gd">-RFC3526_GROUP18 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+   6DCC4024 FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC3526 group 17&quot;] = RFC3526_GROUP17</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 3526 section 7, 8192 bit MODP</span>
<span class="gi">+RFC3526_GROUP18 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
<span class="w"> </span>      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
<span class="w"> </span>      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
<span class="gu">@@ -181,27 +217,34 @@ RFC3526_GROUP18 = 2, int(remove_whitespace(</span>
<span class="w"> </span>      B1D510BD 7EE74D73 FAF36BC3 1ECFA268 359046F4 EB879F92
<span class="w"> </span>      4009438B 481C6CD7 889A002E D5EE382B C9190DA6 FC026E47
<span class="w"> </span>      9558E447 5677E9AA 9E3050E2 765694DF C81F56E8 80B96E71
<span class="gd">-      60C980DD 98EDD3DF FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC3526 group 18&#39;] = RFC3526_GROUP18</span>
<span class="gd">-goodGroupParameters = [(2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+      60C980DD 98EDD3DF FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC3526 group 18&quot;] = RFC3526_GROUP18</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# 1024, 1536, 2048, 3072, 4096, 6144, and 8192 bit groups from RFC 5054</span>
<span class="gi">+# Formatted as in the RFC</span>
<span class="gi">+goodGroupParameters = [</span>
<span class="gi">+    # RFC 5054, 1, 1024-bit Group</span>
<span class="gi">+    (2, int(remove_whitespace(</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="w"> </span>          EEAF0AB9 ADB38DD6 9C33F80A FA8FC5E8 60726187 75FF3C0B 9EA2314C
<span class="w"> </span>          9C256576 D674DF74 96EA81D3 383B4813 D692C6E0 E0D5D8E2 50B98BE4
<span class="w"> </span>          8E495C1D 6089DAD1 5DC7D7B4 6154D6B6 CE8EF4AD 69B15D49 82559B29
<span class="w"> </span>          7BCF1885 C529F566 660E57EC 68EDBC3C 05726CC0 2FD4CBF4 976EAA9A
<span class="gd">-          FD5138FE 8376435B 9FC61D2F C0EB06E3&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)), (2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+          FD5138FE 8376435B 9FC61D2F C0EB06E3&quot;&quot;&quot;), 16)),</span>
<span class="gi">+    # RFC 5054, 2, 1536-bit Group</span>
<span class="gi">+    (2, int(remove_whitespace(</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="w"> </span>          9DEF3CAF B939277A B1F12A86 17A47BBB DBA51DF4 99AC4C80 BEEEA961
<span class="w"> </span>          4B19CC4D 5F4F5F55 6E27CBDE 51C6A94B E4607A29 1558903B A0D0F843
<span class="w"> </span>          80B655BB 9A22E8DC DF028A7C EC67F0D0 8134B1C8 B9798914 9B609E0B
<span class="w"> </span>          E3BAB63D 47548381 DBC5B1FC 764E3F4B 53DD9DA1 158BFD3E 2B9C8CF5
<span class="w"> </span>          6EDF0195 39349627 DB2FD53D 24B7C486 65772E43 7D6C7F8C E442734A
<span class="w"> </span>          F7CCB7AE 837C264A E3A9BEB8 7F8A2FE9 B8B5292E 5A021FFF 5E91479E
<span class="gd">-          8CE7A28C 2442C6F3 15180F93 499A234D CF76E3FE D135F9BB&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)), (2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+          8CE7A28C 2442C6F3 15180F93 499A234D CF76E3FE D135F9BB&quot;&quot;&quot;), 16)),</span>
<span class="gi">+    # RFC 5054, 3, 2048-bit Group</span>
<span class="gi">+    (2, int(remove_whitespace(</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="w"> </span>          AC6BDB41 324A9A9B F166DE5E 1389582F AF72B665 1987EE07 FC319294
<span class="w"> </span>          3DB56050 A37329CB B4A099ED 8193E075 7767A13D D52312AB 4B03310D
<span class="w"> </span>          CD7F48A9 DA04FD50 E8083969 EDB767B0 CF609517 9A163AB3 661A05FB
<span class="gu">@@ -211,9 +254,10 @@ goodGroupParameters = [(2, int(remove_whitespace(</span>
<span class="w"> </span>          5EA77A27 75D2ECFA 032CFBDB F52FB378 61602790 04E57AE6 AF874E73
<span class="w"> </span>          03CE5329 9CCC041C 7BC308D8 2A5698F3 A8D0C382 71AE35F8 E9DBFBB6
<span class="w"> </span>          94B5C803 D89F7AE4 35DE236D 525F5475 9B65E372 FCD68EF2 0FA7111F
<span class="gd">-          9E4AFF73&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)), (5, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+          9E4AFF73&quot;&quot;&quot;), 16)),</span>
<span class="gi">+    # RFC 5054, 4, 3072-bit Group</span>
<span class="gi">+    (5, int(remove_whitespace(</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="w"> </span>          FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
<span class="w"> </span>          8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
<span class="w"> </span>          302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
<span class="gu">@@ -227,9 +271,10 @@ goodGroupParameters = [(2, int(remove_whitespace(</span>
<span class="w"> </span>          B3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226
<span class="w"> </span>          1AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
<span class="w"> </span>          BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFC
<span class="gd">-          E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)), (5, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+          E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16)),</span>
<span class="gi">+    # RFC 5054, 5, 4096-bit Group</span>
<span class="gi">+    (5, int(remove_whitespace(</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="w"> </span>          FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
<span class="w"> </span>          8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
<span class="w"> </span>          302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
<span class="gu">@@ -248,9 +293,10 @@ goodGroupParameters = [(2, int(remove_whitespace(</span>
<span class="w"> </span>          04DE8EF9 2E8EFC14 1FBECAA6 287C5947 4E6BC05D 99B2964F A090C3A2
<span class="w"> </span>          233BA186 515BE7ED 1F612970 CEE2D7AF B81BDD76 2170481C D0069127
<span class="w"> </span>          D5B05AA9 93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199
<span class="gd">-          FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)), (5, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+          FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16)),</span>
<span class="gi">+    # RFC 5054, 6, 6144-bit Group</span>
<span class="gi">+    (5, int(remove_whitespace(</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="w"> </span>          FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
<span class="w"> </span>          8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
<span class="w"> </span>          302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
<span class="gu">@@ -278,9 +324,10 @@ goodGroupParameters = [(2, int(remove_whitespace(</span>
<span class="w"> </span>          CC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE328 06A1D58B
<span class="w"> </span>          B7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55C DA56C9EC 2EF29632
<span class="w"> </span>          387FE8D7 6E3C0468 043E8F66 3F4860EE 12BF2D5B 0B7474D6 E694F91E
<span class="gd">-          6DCC4024 FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)), (19, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+          6DCC4024 FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16)),</span>
<span class="gi">+    # RFC 5054, 7, 8192-bit Group</span>
<span class="gi">+    (19, int(remove_whitespace(</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="w"> </span>          FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
<span class="w"> </span>          8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B
<span class="w"> </span>          302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9
<span class="gu">@@ -317,32 +364,47 @@ goodGroupParameters = [(2, int(remove_whitespace(</span>
<span class="w"> </span>          0846851D F9AB4819 5DED7EA1 B1D510BD 7EE74D73 FAF36BC3 1ECFA268
<span class="w"> </span>          359046F4 EB879F92 4009438B 481C6CD7 889A002E D5EE382B C9190DA6
<span class="w"> </span>          FC026E47 9558E447 5677E9AA 9E3050E2 765694DF C81F56E8 80B96E71
<span class="gd">-          60C980DD 98EDD3DF FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16))]</span>
<span class="gi">+          60C980DD 98EDD3DF FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>for num, group in enumerate(goodGroupParameters, 1):
<span class="gd">-    FFDHE_PARAMETERS[&#39;RFC5054 group {0}&#39;.format(num)] = group</span>
<span class="gi">+    FFDHE_PARAMETERS[&quot;RFC5054 group {0}&quot;.format(num)] = group</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# old versions of tlslite had an incorrect generator for 3072 bit group</span>
<span class="gi">+# from RFC 5054. Since the group is a safe prime, the generator of &quot;2&quot; is</span>
<span class="gi">+# cryptographically safe, so we don&#39;t have reason to reject connections</span>
<span class="gi">+# from old tlslite, so add the old invalid value to the &quot;known good&quot; list</span>
<span class="w"> </span>goodGroupParameters.append((2, goodGroupParameters[3][1]))
<span class="gi">+# we had a bad generator for group 7 (8192 bit) - 5 - while it needs to be 19</span>
<span class="gi">+# same as above, any generator but 1 and p-1 are ok, cryptographically speaking</span>
<span class="w"> </span>goodGroupParameters.append((5, goodGroupParameters[6][1]))
<span class="gd">-RFC5114_GROUP22 = int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# INSECURE groups from RFC 5114, do NOT use</span>
<span class="gi">+# RFC 5114, section 2.1, 1024 bit MODP with 160-bit Prime Order Subgroup</span>
<span class="gi">+RFC5114_GROUP22 = (</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>       A4D1CBD5 C3FD3412 6765A442 EFB99905 F8104DD2 58AC507F
<span class="w"> </span>       D6406CFF 14266D31 266FEA1E 5C41564B 777E690F 5504F213
<span class="w"> </span>       160217B4 B01B886A 5E91547F 9E2749F4 D7FBD7D3 B9A92EE1
<span class="w"> </span>       909D0D22 63F80A76 A6A24C08 7A091F53 1DBF0A01 69B6A28A
<span class="w"> </span>       D662A4D1 8E73AFA3 2D779D59 18D08BC8 858F4DCE F97C2A24
<span class="gd">-       855E6EEB 22B3B2E5&quot;&quot;&quot;</span>
<span class="gd">-    ), 16), int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+       855E6EEB 22B3B2E5&quot;&quot;&quot;), 16),</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>       B10B8F96 A080E01D DE92DE5E AE5D54EC 52C99FBC FB06A3C6
<span class="w"> </span>       9A6A9DCA 52D23B61 6073E286 75A23D18 9838EF1E 2EE652C0
<span class="w"> </span>       13ECB4AE A9061123 24975C3C D49B83BF ACCBDD7D 90C4BD70
<span class="w"> </span>       98488E9C 219A7372 4EFFD6FA E5644738 FAA31A4F F55BCCC0
<span class="w"> </span>       A151AF5F 0DC8B4BD 45BF37DF 365C1A65 E68CFDA7 6D4DA708
<span class="gd">-       DF1FB2BC 2E4A4371&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC5114 group 22&#39;] = RFC5114_GROUP22</span>
<span class="gd">-RFC5114_GROUP23 = int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+       DF1FB2BC 2E4A4371&quot;&quot;&quot;), 16))</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC5114 group 22&quot;] = RFC5114_GROUP22</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 5114, section 2.2, 2048 bit MODP with 224-bit Prime Order Subgroup</span>
<span class="gi">+# INSECURE, do not use</span>
<span class="gi">+RFC5114_GROUP23 = (</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>        AC4032EF 4F2D9AE3 9DF30B5C 8FFDAC50 6CDEBE7B 89998CAF
<span class="w"> </span>        74866A08 CFE4FFE3 A6824A4E 10B9A6F0 DD921F01 A70C4AFA
<span class="w"> </span>        AB739D77 00C29F52 C57DB17C 620A8652 BE5E9001 A8D66AD7
<span class="gu">@@ -353,9 +415,8 @@ RFC5114_GROUP23 = int(remove_whitespace(</span>
<span class="w"> </span>        10E183ED D19963DD D9E263E4 770589EF 6AA21E7F 5F2FF381
<span class="w"> </span>        B539CCE3 409D13CD 566AFBB4 8D6C0191 81E1BCFE 94B30269
<span class="w"> </span>        EDFE72FE 9B6AA4BD 7B5A0F1C 71CFFF4C 19C418E1 F6EC0179
<span class="gd">-        81BC087F 2A7065B3 84B890D3 191F2BFA&quot;&quot;&quot;</span>
<span class="gd">-    ), 16), int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+        81BC087F 2A7065B3 84B890D3 191F2BFA&quot;&quot;&quot;), 16),</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>        AD107E1E 9123A9D0 D660FAA7 9559C51F A20D64E5 683B9FD1
<span class="w"> </span>        B54B1597 B61D0A75 E6FA141D F95A56DB AF9A3C40 7BA1DF15
<span class="w"> </span>        EB3D688A 309C180E 1DE6B85A 1274A0A6 6D3F8152 AD6AC212
<span class="gu">@@ -366,11 +427,14 @@ RFC5114_GROUP23 = int(remove_whitespace(</span>
<span class="w"> </span>        CDF93ACC 44328387 315D75E1 98C641A4 80CD86A1 B9E587E8
<span class="w"> </span>        BE60E69C C928B2B9 C52172E4 13042E9B 23F10B0E 16E79763
<span class="w"> </span>        C9B53DCF 4BA80A29 E3FB73C1 6B8E75B9 7EF363E2 FFA31F71
<span class="gd">-        CF9DE538 4E71B81C 0AC4DFFE 0C10E64F&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC5114 group 23&#39;] = RFC5114_GROUP23</span>
<span class="gd">-RFC5114_GROUP24 = int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+        CF9DE538 4E71B81C 0AC4DFFE 0C10E64F&quot;&quot;&quot;), 16))</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC5114 group 23&quot;] = RFC5114_GROUP23</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 5114, section 2.3, 2048 bit MODP with 256-bit Prime Order Subgroup</span>
<span class="gi">+# INSECURE, do not use</span>
<span class="gi">+RFC5114_GROUP24 = (</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>       3FB32C9B 73134D0B 2E775066 60EDBD48 4CA7B18F 21EF2054
<span class="w"> </span>       07F4793A 1A0BA125 10DBC150 77BE463F FF4FED4A AC0BB555
<span class="w"> </span>       BE3A6C1B 0C6B47B1 BC3773BF 7E8C6F62 901228F8 C28CBB18
<span class="gu">@@ -381,9 +445,8 @@ RFC5114_GROUP24 = int(remove_whitespace(</span>
<span class="w"> </span>       C8484B1E 052588B9 B7D2BBD2 DF016199 ECD06E15 57CD0915
<span class="w"> </span>       B3353BBB 64E0EC37 7FD02837 0DF92B52 C7891428 CDC67EB6
<span class="w"> </span>       184B523D 1DB246C3 2F630784 90F00EF8 D647D148 D4795451
<span class="gd">-       5E2327CF EF98C582 664B4C0F 6CC41659&quot;&quot;&quot;</span>
<span class="gd">-    ), 16), int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+       5E2327CF EF98C582 664B4C0F 6CC41659&quot;&quot;&quot;), 16),</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>       87A8E61D B4B6663C FFBBD19C 65195999 8CEEF608 660DD0F2
<span class="w"> </span>       5D2CEED4 435E3B00 E00DF8F1 D61957D4 FAF7DF45 61B2AA30
<span class="w"> </span>       16C3D911 34096FAA 3BF4296D 830E9A7C 209E0C64 97517ABD
<span class="gu">@@ -394,17 +457,22 @@ RFC5114_GROUP24 = int(remove_whitespace(</span>
<span class="w"> </span>       67E144E5 14056425 1CCACB83 E6B486F6 B3CA3F79 71506026
<span class="w"> </span>       C0B857F6 89962856 DED4010A BD0BE621 C3A3960A 54E710C3
<span class="w"> </span>       75F26375 D7014103 A4B54330 C198AF12 6116D227 6E11715F
<span class="gd">-       693877FA D7EF09CA DB094AE9 1E1A1597&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC5114 group 24&#39;] = RFC5114_GROUP24</span>
<span class="gi">+       693877FA D7EF09CA DB094AE9 1E1A1597&quot;&quot;&quot;), 16))</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC5114 group 24&quot;] = RFC5114_GROUP24</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>RFC7919_GROUPS = []
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>All DH parameters specified in RFC 7919.

<span class="w"> </span>Those are the parameters recommended for use in TLS.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-FFDHE2048 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 7919 ffdhe2048 bit group</span>
<span class="gi">+FFDHE2048 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>    FFFFFFFF FFFFFFFF ADF85458 A2BB4A9A AFDC5620 273D3CF1
<span class="w"> </span>    D8B9C583 CE2D3695 A9E13641 146433FB CC939DCE 249B3EF9
<span class="w"> </span>    7D2FE363 630C75D8 F681B202 AEC4617A D3DF1ED5 D5FD6561
<span class="gu">@@ -415,13 +483,16 @@ FFDHE2048 = 2, int(remove_whitespace(</span>
<span class="w"> </span>    0B07A7C8 EE0A6D70 9E02FCE1 CDF7E2EC C03404CD 28342F61
<span class="w"> </span>    9172FE9C E98583FF 8E4F1232 EEF28183 C3FE3B1B 4C6FAD73
<span class="w"> </span>    3BB5FCBC 2EC22005 C58EF183 7D1683B2 C6F34A26 C1B2EFFA
<span class="gd">-    886B4238 61285C97 FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gi">+    886B4238 61285C97 FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="w"> </span>goodGroupParameters.append(FFDHE2048)
<span class="w"> </span>RFC7919_GROUPS.append(FFDHE2048)
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC7919 ffdhe2048&#39;] = FFDHE2048</span>
<span class="gd">-FFDHE3072 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC7919 ffdhe2048&quot;] = FFDHE2048</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 7919 ffdhe3072 bit group</span>
<span class="gi">+FFDHE3072 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>    FFFFFFFF FFFFFFFF ADF85458 A2BB4A9A AFDC5620 273D3CF1
<span class="w"> </span>    D8B9C583 CE2D3695 A9E13641 146433FB CC939DCE 249B3EF9
<span class="w"> </span>    7D2FE363 630C75D8 F681B202 AEC4617A D3DF1ED5 D5FD6561
<span class="gu">@@ -437,13 +508,16 @@ FFDHE3072 = 2, int(remove_whitespace(</span>
<span class="w"> </span>    AEFE1309 85139270 B4130C93 BC437944 F4FD4452 E2D74DD3
<span class="w"> </span>    64F2E21E 71F54BFF 5CAE82AB 9C9DF69E E86D2BC5 22363A0D
<span class="w"> </span>    ABC52197 9B0DEADA 1DBF9A42 D5C4484E 0ABCD06B FA53DDEF
<span class="gd">-    3C1B20EE 3FD59D7C 25E41D2B 66C62E37 FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gi">+    3C1B20EE 3FD59D7C 25E41D2B 66C62E37 FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="w"> </span>goodGroupParameters.append(FFDHE3072)
<span class="w"> </span>RFC7919_GROUPS.append(FFDHE3072)
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC7919 ffdhe3072&#39;] = FFDHE3072</span>
<span class="gd">-FFDHE4096 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC7919 ffdhe3072&quot;] = FFDHE3072</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 7919 ffdhe4096 bit group</span>
<span class="gi">+FFDHE4096 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>    FFFFFFFF FFFFFFFF ADF85458 A2BB4A9A AFDC5620 273D3CF1
<span class="w"> </span>    D8B9C583 CE2D3695 A9E13641 146433FB CC939DCE 249B3EF9
<span class="w"> </span>    7D2FE363 630C75D8 F681B202 AEC4617A D3DF1ED5 D5FD6561
<span class="gu">@@ -465,13 +539,16 @@ FFDHE4096 = 2, int(remove_whitespace(</span>
<span class="w"> </span>    A907600A 918130C4 6DC778F9 71AD0038 092999A3 33CB8B7A
<span class="w"> </span>    1A1DB93D 7140003C 2A4ECEA9 F98D0ACC 0A8291CD CEC97DCF
<span class="w"> </span>    8EC9B55A 7F88A46B 4DB5A851 F44182E1 C68A007E 5E655F6A
<span class="gd">-    FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gi">+    FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="w"> </span>goodGroupParameters.append(FFDHE4096)
<span class="w"> </span>RFC7919_GROUPS.append(FFDHE4096)
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC7919 ffdhe4096&#39;] = FFDHE4096</span>
<span class="gd">-FFDHE6144 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC7919 ffdhe4096&quot;] = FFDHE4096</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 7919 ffdhe6144 bit group</span>
<span class="gi">+FFDHE6144 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>    FFFFFFFF FFFFFFFF ADF85458 A2BB4A9A AFDC5620 273D3CF1
<span class="w"> </span>    D8B9C583 CE2D3695 A9E13641 146433FB CC939DCE 249B3EF9
<span class="w"> </span>    7D2FE363 630C75D8 F681B202 AEC4617A D3DF1ED5 D5FD6561
<span class="gu">@@ -503,13 +580,16 @@ FFDHE6144 = 2, int(remove_whitespace(</span>
<span class="w"> </span>    D72B0374 6AE77F5E 62292C31 1562A846 505DC82D B854338A
<span class="w"> </span>    E49F5235 C95B9117 8CCF2DD5 CACEF403 EC9D1810 C6272B04
<span class="w"> </span>    5B3B71F9 DC6B80D6 3FDD4A8E 9ADB1E69 62A69526 D43161C1
<span class="gd">-    A41D570D 7938DAD4 A40E329C D0E40E65 FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gi">+    A41D570D 7938DAD4 A40E329C D0E40E65 FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="w"> </span>goodGroupParameters.append(FFDHE6144)
<span class="w"> </span>RFC7919_GROUPS.append(FFDHE6144)
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC7919 ffdhe6144&#39;] = FFDHE6144</span>
<span class="gd">-FFDHE8192 = 2, int(remove_whitespace(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC7919 ffdhe6144&quot;] = FFDHE6144</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# RFC 7919 ffdhe8192 bit group</span>
<span class="gi">+FFDHE8192 = (</span>
<span class="gi">+    2,</span>
<span class="gi">+    int(remove_whitespace(&quot;&quot;&quot;</span>
<span class="w"> </span>    FFFFFFFF FFFFFFFF ADF85458 A2BB4A9A AFDC5620 273D3CF1
<span class="w"> </span>    D8B9C583 CE2D3695 A9E13641 146433FB CC939DCE 249B3EF9
<span class="w"> </span>    7D2FE363 630C75D8 F681B202 AEC4617A D3DF1ED5 D5FD6561
<span class="gu">@@ -552,11 +632,10 @@ FFDHE8192 = 2, int(remove_whitespace(</span>
<span class="w"> </span>    1EFC8CE0 BA8A4FE8 B6855DFE 72B0A66E DED2FBAB FBE58A30
<span class="w"> </span>    FAFABE1C 5D71A87E 2F741EF8 C1FE86FE A6BBFDE5 30677F0D
<span class="w"> </span>    97D11D49 F7A8443D 0822E506 A9F4614E 011E2A94 838FF88C
<span class="gd">-    D68C8BB7 C5C6424C FFFFFFFF FFFFFFFF&quot;&quot;&quot;</span>
<span class="gd">-    ), 16)</span>
<span class="gi">+    D68C8BB7 C5C6424C FFFFFFFF FFFFFFFF&quot;&quot;&quot;), 16))</span>
<span class="w"> </span>goodGroupParameters.append(FFDHE8192)
<span class="w"> </span>RFC7919_GROUPS.append(FFDHE8192)
<span class="gd">-FFDHE_PARAMETERS[&#39;RFC7919 ffdhe8192&#39;] = FFDHE8192</span>
<span class="gi">+FFDHE_PARAMETERS[&quot;RFC7919 ffdhe8192&quot;] = FFDHE8192</span>


<span class="w"> </span>def paramStrength(param):
<span class="gu">@@ -570,41 +649,144 @@ def paramStrength(param):</span>
<span class="w"> </span>    :param param: prime or modulus
<span class="w"> </span>    :type param: int
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    size = numBits(param)</span>
<span class="gi">+    if size &lt; 512:</span>
<span class="gi">+        return 48</span>
<span class="gi">+    elif size &lt; 768:</span>
<span class="gi">+        return 56</span>
<span class="gi">+    elif size &lt; 816:</span>
<span class="gi">+        return 64</span>
<span class="gi">+    elif size &lt; 1023:</span>
<span class="gi">+        return 72</span>
<span class="gi">+    elif size &lt; 1535:</span>
<span class="gi">+        return 80  # NIST SP 800-57</span>
<span class="gi">+    elif size &lt; 2047:</span>
<span class="gi">+        return 88  # rounded RFC 3526</span>
<span class="gi">+    elif size &lt; 3071:</span>
<span class="gi">+        return 112  # NIST SP 800-57</span>
<span class="gi">+    elif size &lt; 4095:</span>
<span class="gi">+        return 128  # NIST SP 800-57</span>
<span class="gi">+    elif size &lt; 6144:</span>
<span class="gi">+        return 152  # rounded RFC 3526</span>
<span class="gi">+    elif size &lt; 7679:</span>
<span class="gi">+        return 168  # rounded RFC 3526</span>
<span class="gi">+    elif size &lt; 15359:</span>
<span class="gi">+        return 192  # NIST SP 800-57</span>
<span class="gi">+    else:</span>
<span class="gi">+        return 256  # NIST SP 800-57</span>


<span class="w"> </span>def P_hash(mac_name, secret, seed, length):
<span class="w"> </span>    &quot;&quot;&quot;Internal method for calculation the PRF in TLS.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ret = bytearray(length)</span>
<span class="gi">+    seed = compatHMAC(seed)</span>
<span class="gi">+    A = seed</span>
<span class="gi">+    index = 0</span>
<span class="gi">+    mac = hmac.HMAC(compatHMAC(secret), digestmod=mac_name)</span>
<span class="gi">+    while index &lt; length:</span>
<span class="gi">+        a_fun = mac.copy()</span>
<span class="gi">+        a_fun.update(A)</span>
<span class="gi">+        A = a_fun.digest()</span>
<span class="gi">+        out_fun = mac.copy()</span>
<span class="gi">+        out_fun.update(A)</span>
<span class="gi">+        out_fun.update(seed)</span>
<span class="gi">+        output = out_fun.digest()</span>
<span class="gi">+</span>
<span class="gi">+        how_many = min(length - index, len(output))</span>
<span class="gi">+        ret[index:index+how_many] = output[:how_many]</span>
<span class="gi">+        index += how_many</span>
<span class="gi">+    return ret</span>
<span class="gi">+</span>

<span class="gi">+def PRF(secret, label, seed, length):</span>
<span class="gi">+    #Split the secret into left and right halves</span>
<span class="gi">+    # which may share a byte if len is odd</span>
<span class="gi">+    S1 = secret[ : int(math.ceil(len(secret)/2.0))]</span>
<span class="gi">+    S2 = secret[ int(math.floor(len(secret)/2.0)) : ]</span>
<span class="gi">+</span>
<span class="gi">+    #Run the left half through P_MD5 and the right half through P_SHA1</span>
<span class="gi">+    p_md5 = P_hash(&quot;md5&quot;, S1, label + seed, length)</span>
<span class="gi">+    p_sha1 = P_hash(&quot;sha1&quot;, S2, label + seed, length)</span>
<span class="gi">+</span>
<span class="gi">+    #XOR the output values and return the result</span>
<span class="gi">+    for x in range(length):</span>
<span class="gi">+        p_md5[x] ^= p_sha1[x]</span>
<span class="gi">+    return p_md5</span>

<span class="w"> </span>def PRF_1_2(secret, label, seed, length):
<span class="w"> </span>    &quot;&quot;&quot;Pseudo Random Function for TLS1.2 ciphers that use SHA256&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    return P_hash(&quot;sha256&quot;, secret, label + seed, length)</span>

<span class="w"> </span>def PRF_1_2_SHA384(secret, label, seed, length):
<span class="w"> </span>    &quot;&quot;&quot;Pseudo Random Function for TLS1.2 ciphers that use SHA384&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return P_hash(&quot;sha384&quot;, secret, label + seed, length)</span>

<span class="gi">+def PRF_SSL(secret, seed, length):</span>
<span class="gi">+    bytes = bytearray(length)</span>
<span class="gi">+    index = 0</span>
<span class="gi">+    for x in range(26):</span>
<span class="gi">+        A = bytearray([ord(&#39;A&#39;)+x] * (x+1)) # &#39;A&#39;, &#39;BB&#39;, &#39;CCC&#39;, etc..</span>
<span class="gi">+        input = secret + SHA1(A + secret + seed)</span>
<span class="gi">+        output = MD5(input)</span>
<span class="gi">+        for c in output:</span>
<span class="gi">+            if index &gt;= length:</span>
<span class="gi">+                return bytes</span>
<span class="gi">+            bytes[index] = c</span>
<span class="gi">+            index += 1</span>
<span class="gi">+    return bytes</span>

<span class="gd">-@deprecated_method(&#39;Please use calc_key function instead.&#39;)</span>
<span class="gi">+@deprecated_method(&quot;Please use calc_key function instead.&quot;)</span>
<span class="w"> </span>def calcExtendedMasterSecret(version, cipherSuite, premasterSecret,
<span class="gd">-    handshakeHashes):</span>
<span class="gi">+                             handshakeHashes):</span>
<span class="w"> </span>    &quot;&quot;&quot;Derive Extended Master Secret from premaster and handshake msgs&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert version in ((3, 1), (3, 2), (3, 3))</span>
<span class="gi">+    if version in ((3, 1), (3, 2)):</span>
<span class="gi">+        masterSecret = PRF(premasterSecret, b&quot;extended master secret&quot;,</span>
<span class="gi">+                           handshakeHashes.digest(&#39;md5&#39;) +</span>
<span class="gi">+                           handshakeHashes.digest(&#39;sha1&#39;),</span>
<span class="gi">+                           48)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if cipherSuite in CipherSuite.sha384PrfSuites:</span>
<span class="gi">+            masterSecret = PRF_1_2_SHA384(premasterSecret,</span>
<span class="gi">+                                          b&quot;extended master secret&quot;,</span>
<span class="gi">+                                          handshakeHashes.digest(&#39;sha384&#39;),</span>
<span class="gi">+                                          48)</span>
<span class="gi">+        else:</span>
<span class="gi">+            masterSecret = PRF_1_2(premasterSecret,</span>
<span class="gi">+                                   b&quot;extended master secret&quot;,</span>
<span class="gi">+                                   handshakeHashes.digest(&#39;sha256&#39;),</span>
<span class="gi">+                                   48)</span>
<span class="gi">+    return masterSecret</span>


<span class="gd">-@deprecated_method(&#39;Please use calc_key function instead.&#39;)</span>
<span class="gi">+@deprecated_method(&quot;Please use calc_key function instead.&quot;)</span>
<span class="w"> </span>def calcMasterSecret(version, cipherSuite, premasterSecret, clientRandom,
<span class="gd">-    serverRandom):</span>
<span class="gi">+                     serverRandom):</span>
<span class="w"> </span>    &quot;&quot;&quot;Derive Master Secret from premaster secret and random values&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if version == (3,0):</span>
<span class="gi">+        masterSecret = PRF_SSL(premasterSecret,</span>
<span class="gi">+                            clientRandom + serverRandom, 48)</span>
<span class="gi">+    elif version in ((3,1), (3,2)):</span>
<span class="gi">+        masterSecret = PRF(premasterSecret, b&quot;master secret&quot;,</span>
<span class="gi">+                            clientRandom + serverRandom, 48)</span>
<span class="gi">+    elif version == (3,3):</span>
<span class="gi">+        if cipherSuite in CipherSuite.sha384PrfSuites:</span>
<span class="gi">+            masterSecret = PRF_1_2_SHA384(premasterSecret,</span>
<span class="gi">+                                          b&quot;master secret&quot;,</span>
<span class="gi">+                                          clientRandom + serverRandom,</span>
<span class="gi">+                                          48)</span>
<span class="gi">+        else:</span>
<span class="gi">+            masterSecret = PRF_1_2(premasterSecret,</span>
<span class="gi">+                                   b&quot;master secret&quot;,</span>
<span class="gi">+                                   clientRandom + serverRandom,</span>
<span class="gi">+                                   48)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise AssertionError()</span>
<span class="gi">+    return masterSecret</span>

<span class="gd">-</span>
<span class="gd">-@deprecated_method(&#39;Please use calc_key function instead.&#39;)</span>
<span class="gd">-def calcFinished(version, masterSecret, cipherSuite, handshakeHashes, isClient</span>
<span class="gd">-    ):</span>
<span class="gi">+@deprecated_method(&quot;Please use calc_key function instead.&quot;)</span>
<span class="gi">+def calcFinished(version, masterSecret, cipherSuite, handshakeHashes,</span>
<span class="gi">+                 isClient):</span>
<span class="w"> </span>    &quot;&quot;&quot;Calculate the Handshake protocol Finished value

<span class="w"> </span>    :param version: TLS protocol version tuple
<span class="gu">@@ -614,11 +796,36 @@ def calcFinished(version, masterSecret, cipherSuite, handshakeHashes, isClient</span>
<span class="w"> </span>    :param isClient: whether the calculation should be performed for message
<span class="w"> </span>        sent by client (True) or by server (False) side of connection
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert version in ((3, 0), (3, 1), (3, 2), (3, 3))</span>
<span class="gi">+    if version == (3,0):</span>
<span class="gi">+        if isClient:</span>
<span class="gi">+            senderStr = b&quot;\x43\x4C\x4E\x54&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            senderStr = b&quot;\x53\x52\x56\x52&quot;</span>
<span class="gi">+</span>
<span class="gi">+        verifyData = handshakeHashes.digestSSL(masterSecret, senderStr)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if isClient:</span>
<span class="gi">+            label = b&quot;client finished&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            label = b&quot;server finished&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if version in ((3,1), (3,2)):</span>
<span class="gi">+            handshakeHash = handshakeHashes.digest()</span>
<span class="gi">+            verifyData = PRF(masterSecret, label, handshakeHash, 12)</span>
<span class="gi">+        else: # version == (3,3):</span>
<span class="gi">+            if cipherSuite in CipherSuite.sha384PrfSuites:</span>
<span class="gi">+                handshakeHash = handshakeHashes.digest(&#39;sha384&#39;)</span>
<span class="gi">+                verifyData = PRF_1_2_SHA384(masterSecret, label,</span>
<span class="gi">+                                            handshakeHash, 12)</span>
<span class="gi">+            else:</span>
<span class="gi">+                handshakeHash = handshakeHashes.digest(&#39;sha256&#39;)</span>
<span class="gi">+                verifyData = PRF_1_2(masterSecret, label, handshakeHash, 12)</span>

<span class="gi">+    return verifyData</span>

<span class="w"> </span>def calc_key(version, secret, cipher_suite, label, handshake_hashes=None,
<span class="gd">-    client_random=None, server_random=None, output_length=None):</span>
<span class="gi">+            client_random=None, server_random=None, output_length=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Method for calculating different keys depending on input.
<span class="w"> </span>    It can be used to calculate finished value, master secret,
<span class="gu">@@ -640,8 +847,136 @@ def calc_key(version, secret, cipher_suite, label, handshake_hashes=None,</span>
<span class="w"> </span>        master secret or key expansion.
<span class="w"> </span>    :param int output_length: Number of bytes to output.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    # SSL3 calculations.</span>
<span class="gi">+    if version == (3, 0):</span>
<span class="gi">+        # Calculating Finished value, either for message sent</span>
<span class="gi">+        # by server or by client</span>
<span class="gi">+        if label == b&quot;client finished&quot;:</span>
<span class="gi">+            senderStr = b&quot;\x43\x4C\x4E\x54&quot;</span>
<span class="gi">+            return handshake_hashes.digestSSL(secret, senderStr)</span>
<span class="gi">+        elif label == b&quot;server finished&quot;:</span>
<span class="gi">+            senderStr = b&quot;\x53\x52\x56\x52&quot;</span>
<span class="gi">+            return handshake_hashes.digestSSL(secret, senderStr)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert label in [b&quot;key expansion&quot;, b&quot;master secret&quot;]</span>
<span class="gi">+            func = PRF_SSL</span>
<span class="gi">+</span>
<span class="gi">+    # TLS1.0 or TLS1.1 calculations.</span>
<span class="gi">+    elif version in ((3, 1), (3, 2)):</span>
<span class="gi">+        func = PRF</span>
<span class="gi">+        # Seed needed for calculating extended master secret</span>
<span class="gi">+        if label == b&quot;extended master secret&quot;:</span>
<span class="gi">+            seed = handshake_hashes.digest(&#39;md5&#39;) + \</span>
<span class="gi">+                   handshake_hashes.digest(&#39;sha1&#39;)</span>
<span class="gi">+        # Seed needed for calculating Finished value</span>
<span class="gi">+        elif label in [b&quot;server finished&quot;, b&quot;client finished&quot;]:</span>
<span class="gi">+            seed = handshake_hashes.digest()</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert label in [b&quot;key expansion&quot;, b&quot;master secret&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    # TLS1.2 calculations.</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert version == (3, 3)</span>
<span class="gi">+        if cipher_suite in CipherSuite.sha384PrfSuites:</span>
<span class="gi">+            func = PRF_1_2_SHA384</span>
<span class="gi">+            # Seed needed for calculating Finished value or extended master</span>
<span class="gi">+            # secret</span>
<span class="gi">+            if label in [b&quot;extended master secret&quot;, b&quot;server finished&quot;,</span>
<span class="gi">+                    b&quot;client finished&quot;]:</span>
<span class="gi">+                seed = handshake_hashes.digest(&#39;sha384&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert label in [b&quot;key expansion&quot;, b&quot;master secret&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Same as above, just using sha256</span>
<span class="gi">+            func = PRF_1_2</span>
<span class="gi">+            if label in [b&quot;extended master secret&quot;, b&quot;server finished&quot;,</span>
<span class="gi">+                    b&quot;client finished&quot;]:</span>
<span class="gi">+                seed = handshake_hashes.digest(&#39;sha256&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert label in [b&quot;key expansion&quot;, b&quot;master secret&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    # Seed needed for calculating key expansion or master secret</span>
<span class="gi">+    if label == b&quot;key expansion&quot;:</span>
<span class="gi">+        seed = server_random + client_random</span>
<span class="gi">+    if label == b&quot;master secret&quot;:</span>
<span class="gi">+        seed = client_random + server_random</span>
<span class="gi">+</span>
<span class="gi">+    if func == PRF_SSL:</span>
<span class="gi">+        return func(secret, seed, output_length)</span>
<span class="gi">+    return func(secret, label, seed, output_length)</span>
<span class="gi">+</span>
<span class="gi">+def makeX(salt, username, password):</span>
<span class="gi">+    if len(username)&gt;=256:</span>
<span class="gi">+        raise ValueError(&quot;username too long&quot;)</span>
<span class="gi">+    if len(salt)&gt;=256:</span>
<span class="gi">+        raise ValueError(&quot;salt too long&quot;)</span>
<span class="gi">+    innerHashResult = SHA1(username + bytearray(b&quot;:&quot;) + password)</span>
<span class="gi">+    outerHashResult = SHA1(salt + innerHashResult)</span>
<span class="gi">+    return bytesToNumber(outerHashResult)</span>
<span class="gi">+</span>
<span class="gi">+#This function is used by VerifierDB.makeVerifier</span>
<span class="gi">+def makeVerifier(username, password, bits):</span>
<span class="gi">+    bitsIndex = {1024:0, 1536:1, 2048:2, 3072:3, 4096:4, 6144:5, 8192:6}[bits]</span>
<span class="gi">+    g,N = goodGroupParameters[bitsIndex]</span>
<span class="gi">+    salt = getRandomBytes(16)</span>
<span class="gi">+    x = makeX(salt, username, password)</span>
<span class="gi">+    verifier = powMod(g, x, N)</span>
<span class="gi">+    return N, g, salt, verifier</span>
<span class="gi">+</span>
<span class="gi">+def PAD(n, x):</span>
<span class="gi">+    nLength = len(numberToByteArray(n))</span>
<span class="gi">+    b = numberToByteArray(x)</span>
<span class="gi">+    if len(b) &lt; nLength:</span>
<span class="gi">+        b = (b&quot;\0&quot; * (nLength-len(b))) + b</span>
<span class="gi">+    return b</span>
<span class="gi">+</span>
<span class="gi">+def makeU(N, A, B):</span>
<span class="gi">+  return bytesToNumber(SHA1(PAD(N, A) + PAD(N, B)))</span>
<span class="gi">+</span>
<span class="gi">+def makeK(N, g):</span>
<span class="gi">+  return bytesToNumber(SHA1(numberToByteArray(N) + PAD(N, g)))</span>
<span class="gi">+</span>
<span class="gi">+def createHMAC(k, digestmod=hashlib.sha1):</span>
<span class="gi">+    h = hmac.HMAC(k, digestmod=digestmod)</span>
<span class="gi">+    if not hasattr(h, &#39;block_size&#39;):</span>
<span class="gi">+        h.block_size = digestmod().block_size</span>
<span class="gi">+    assert h.block_size == digestmod().block_size</span>
<span class="gi">+    return h</span>
<span class="gi">+</span>
<span class="gi">+def createMAC_SSL(k, digestmod=None):</span>
<span class="gi">+    mac = MAC_SSL()</span>
<span class="gi">+    mac.create(k, digestmod=digestmod)</span>
<span class="gi">+    return mac</span>


<span class="w"> </span>class MAC_SSL(object):
<span class="gd">-    pass</span>
<span class="gi">+    def create(self, k, digestmod=None):</span>
<span class="gi">+        self.digestmod = digestmod or hashlib.sha1</span>
<span class="gi">+        self.block_size = self.digestmod().block_size</span>
<span class="gi">+        # Repeat pad bytes 48 times for MD5; 40 times for other hash functions.</span>
<span class="gi">+        self.digest_size = 16 if (self.digestmod is hashlib.md5) else 20</span>
<span class="gi">+        repeat = 40 if self.digest_size == 20 else 48</span>
<span class="gi">+        opad = b&quot;\x5C&quot; * repeat</span>
<span class="gi">+        ipad = b&quot;\x36&quot; * repeat</span>
<span class="gi">+</span>
<span class="gi">+        self.ohash = self.digestmod(k + opad)</span>
<span class="gi">+        self.ihash = self.digestmod(k + ipad)</span>
<span class="gi">+</span>
<span class="gi">+    def update(self, m):</span>
<span class="gi">+        self.ihash.update(m)</span>
<span class="gi">+</span>
<span class="gi">+    def copy(self):</span>
<span class="gi">+        new = MAC_SSL()</span>
<span class="gi">+        new.ihash = self.ihash.copy()</span>
<span class="gi">+        new.ohash = self.ohash.copy()</span>
<span class="gi">+        new.digestmod = self.digestmod</span>
<span class="gi">+        new.digest_size = self.digest_size</span>
<span class="gi">+        new.block_size = self.block_size</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def digest(self):</span>
<span class="gi">+        ohash2 = self.ohash.copy()</span>
<span class="gi">+        ohash2.update(self.ihash.digest())</span>
<span class="gi">+        return bytearray(ohash2.digest())</span>
<span class="gh">diff --git a/tlslite/messages.py b/tlslite/messages.py</span>
<span class="gh">index d4ceb65..1354cd1 100644</span>
<span class="gd">--- a/tlslite/messages.py</span>
<span class="gi">+++ b/tlslite/messages.py</span>
<span class="gu">@@ -1,4 +1,15 @@</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Google - handling CertificateRequest.certificate_types</span>
<span class="gi">+#   Google (adapted by Sam Rushing and Marcelo Fernandez) - NPN support</span>
<span class="gi">+#   Dimitris Moraitis - Anon ciphersuites</span>
<span class="gi">+#   Yngve Pettersen (ported by Paul Sokolovsky) - TLS 1.2</span>
<span class="gi">+#   Hubert Kario - &#39;extensions&#39; cleanup</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Classes representing TLS messages.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .utils.compat import *
<span class="w"> </span>from .utils.cryptomath import *
<span class="w"> </span>from .errors import *
<span class="gu">@@ -18,7 +29,7 @@ class RecordHeader(object):</span>
<span class="w"> </span>    def __init__(self, ssl2):
<span class="w"> </span>        &quot;&quot;&quot;Define instance variables.&quot;&quot;&quot;
<span class="w"> </span>        self.type = 0
<span class="gd">-        self.version = 0, 0</span>
<span class="gi">+        self.version = (0, 0)</span>
<span class="w"> </span>        self.length = 0
<span class="w"> </span>        self.ssl2 = ssl2

<span class="gu">@@ -32,24 +43,46 @@ class RecordHeader3(RecordHeader):</span>

<span class="w"> </span>    def create(self, version, type, length):
<span class="w"> </span>        &quot;&quot;&quot;Set object values for writing (serialisation).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.type = type</span>
<span class="gi">+        self.version = version</span>
<span class="gi">+        self.length = length</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise object to bytearray.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add(self.type, 1)</span>
<span class="gi">+        writer.add(self.version[0], 1)</span>
<span class="gi">+        writer.add(self.version[1], 1)</span>
<span class="gi">+        writer.add(self.length, 2)</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise object from Parser.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.type = parser.get(1)</span>
<span class="gi">+        self.version = (parser.get(1), parser.get(1))</span>
<span class="gi">+        self.length = parser.get(2)</span>
<span class="gi">+        self.ssl2 = False</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def typeName(self):</span>
<span class="gi">+        matching = [x[0] for x in ContentType.__dict__.items()</span>
<span class="gi">+                    if x[1] == self.type]</span>
<span class="gi">+        if len(matching) == 0:</span>
<span class="gi">+            return &quot;unknown(&quot; + str(self.type) + &quot;)&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return str(matching[0])</span>

<span class="w"> </span>    def __str__(self):
<span class="gd">-        return (</span>
<span class="gd">-            &#39;SSLv3 record,version({0[0]}.{0[1]}),content type({1}),length({2})&#39;</span>
<span class="gd">-            .format(self.version, self.typeName, self.length))</span>
<span class="gi">+        return &quot;SSLv3 record,version({0[0]}.{0[1]}),&quot;\</span>
<span class="gi">+                &quot;content type({1}),length({2})&quot;.format(self.version,</span>
<span class="gi">+                                                       self.typeName,</span>
<span class="gi">+                                                       self.length)</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return (&#39;RecordHeader3(type={0}, version=({1[0]}.{1[1]}), length={2})&#39;</span>
<span class="gd">-            .format(self.type, self.version, self.length))</span>
<span class="gi">+        return &quot;RecordHeader3(type={0}, version=({1[0]}.{1[1]}), length={2})&quot;.\</span>
<span class="gi">+                format(self.type, self.version, self.length)</span>


<span class="w"> </span>class RecordHeader2(RecordHeader):
<span class="gu">@@ -71,15 +104,50 @@ class RecordHeader2(RecordHeader):</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise object from Parser.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        firstByte = parser.get(1)</span>
<span class="gi">+        secondByte = parser.get(1)</span>
<span class="gi">+        if firstByte &amp; 0x80:</span>
<span class="gi">+            self.length = ((firstByte &amp; 0x7f) &lt;&lt; 8) | secondByte</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.length = ((firstByte &amp; 0x3f) &lt;&lt; 8) | secondByte</span>
<span class="gi">+            self.securityEscape = firstByte &amp; 0x40 != 0</span>
<span class="gi">+            self.padding = parser.get(1)</span>
<span class="gi">+</span>
<span class="gi">+        self.type = ContentType.handshake</span>
<span class="gi">+        self.version = (2, 0)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def create(self, length, padding=0, securityEscape=False):
<span class="w"> </span>        &quot;&quot;&quot;Set object&#39;s values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.length = length</span>
<span class="gi">+        self.padding = padding</span>
<span class="gi">+        self.securityEscape = securityEscape</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise object to bytearray.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+</span>
<span class="gi">+        shortHeader = not (self.padding or self.securityEscape)</span>
<span class="gi">+</span>
<span class="gi">+        if ((shortHeader and self.length &gt;= 0x8000) or</span>
<span class="gi">+                (not shortHeader and self.length &gt;= 0x4000)):</span>
<span class="gi">+            raise ValueError(&quot;length too large&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        firstByte = 0</span>
<span class="gi">+        if shortHeader:</span>
<span class="gi">+            firstByte |= 0x80</span>
<span class="gi">+        if self.securityEscape:</span>
<span class="gi">+            firstByte |= 0x40</span>
<span class="gi">+        firstByte |= self.length &gt;&gt; 8</span>
<span class="gi">+        secondByte = self.length &amp; 0xff</span>
<span class="gi">+</span>
<span class="gi">+        writer.add(firstByte, 1)</span>
<span class="gi">+        writer.add(secondByte, 1)</span>
<span class="gi">+        if not shortHeader:</span>
<span class="gi">+            writer.add(self.padding, 1)</span>
<span class="gi">+</span>
<span class="gi">+        return writer.bytes</span>


<span class="w"> </span>class Message(object):
<span class="gu">@@ -99,34 +167,60 @@ class Message(object):</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Return serialised object data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.data</span>


<span class="w"> </span>class Alert(object):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.contentType = ContentType.alert
<span class="w"> </span>        self.level = 0
<span class="w"> </span>        self.description = 0

<span class="gi">+    def create(self, description, level=AlertLevel.fatal):</span>
<span class="gi">+        self.level = level</span>
<span class="gi">+        self.description = description</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, p):</span>
<span class="gi">+        p.setLengthCheck(2)</span>
<span class="gi">+        self.level = p.get(1)</span>
<span class="gi">+        self.description = p.get(1)</span>
<span class="gi">+        p.stopLengthCheck()</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def write(self):</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(self.level, 1)</span>
<span class="gi">+        w.add(self.description, 1)</span>
<span class="gi">+        return w.bytes</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def levelName(self):</span>
<span class="gi">+        return none_as_unknown(AlertLevel.toRepr(self.level),</span>
<span class="gi">+                             self.level)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def descriptionName(self):</span>
<span class="gi">+        return none_as_unknown(AlertDescription.toRepr(self.description),</span>
<span class="gi">+                             self.description)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="gd">-        return &#39;Alert, level:{0}, description:{1}&#39;.format(self.levelName,</span>
<span class="gd">-            self.descriptionName)</span>
<span class="gi">+        return &quot;Alert, level:{0}, description:{1}&quot;.format(self.levelName,</span>
<span class="gi">+                                                          self.descriptionName)</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;Alert(level={0}, description={1})&#39;.format(self.level, self.</span>
<span class="gd">-            description)</span>
<span class="gi">+        return &quot;Alert(level={0}, description={1})&quot;.format(self.level,</span>
<span class="gi">+                                                          self.description)</span>


<span class="w"> </span>class HandshakeMsg(object):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, handshakeType):
<span class="w"> </span>        self.contentType = ContentType.handshake
<span class="w"> </span>        self.handshakeType = handshakeType

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Check if other object represents the same data as this object.&quot;&quot;&quot;
<span class="gd">-        if hasattr(self, &#39;write&#39;) and hasattr(other, &#39;write&#39;):</span>
<span class="gi">+        if hasattr(self, &quot;write&quot;) and hasattr(other, &quot;write&quot;):</span>
<span class="w"> </span>            return self.write() == other.write()
<span class="w"> </span>        else:
<span class="w"> </span>            return False
<span class="gu">@@ -135,6 +229,12 @@ class HandshakeMsg(object):</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if other object represents different data as this object.&quot;&quot;&quot;
<span class="w"> </span>        return not self.__eq__(other)

<span class="gi">+    def postWrite(self, w):</span>
<span class="gi">+        headerWriter = Writer()</span>
<span class="gi">+        headerWriter.add(self.handshakeType, 1)</span>
<span class="gi">+        headerWriter.add(len(w.bytes), 3)</span>
<span class="gi">+        return headerWriter.bytes + w.bytes</span>
<span class="gi">+</span>

<span class="w"> </span>class HelloMessage(HandshakeMsg):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -155,7 +255,17 @@ class HelloMessage(HandshakeMsg):</span>
<span class="w"> </span>        :raises TLSInternalError: when there are multiple extensions of the
<span class="w"> </span>            same type
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        exts = [ext for ext in self.extensions if ext.extType == extType]</span>
<span class="gi">+        if len(exts) &gt; 1:</span>
<span class="gi">+            raise TLSInternalError(</span>
<span class="gi">+                &quot;Multiple extensions of the same type present&quot;)</span>
<span class="gi">+        elif len(exts) == 1:</span>
<span class="gi">+            return exts[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def addExtension(self, ext):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -164,15 +274,24 @@ class HelloMessage(HandshakeMsg):</span>
<span class="w"> </span>        :type ext: TLSExtension
<span class="w"> </span>        :param ext: extension object to add to list
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is None:</span>
<span class="gi">+            self.extensions = []</span>
<span class="gi">+</span>
<span class="gi">+        self.extensions.append(ext)</span>

<span class="w"> </span>    def _addExt(self, extType):
<span class="w"> </span>        &quot;&quot;&quot;Add en empty extension of given type, if not already present&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ext = self.getExtension(extType)</span>
<span class="gi">+        if ext is None:</span>
<span class="gi">+            ext = TLSExtension(extType=extType).create(bytearray(0))</span>
<span class="gi">+            self.addExtension(ext)</span>

<span class="w"> </span>    def _removeExt(self, extType):
<span class="w"> </span>        &quot;&quot;&quot;Remove extension of given type&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.extensions is not None:</span>
<span class="gi">+            self.extensions[:] = (i for i in self.extensions</span>
<span class="gi">+                                  if i.extType != extType)</span>
<span class="gi">+</span>

<span class="w"> </span>    def _addOrRemoveExt(self, extType, add):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -183,7 +302,10 @@ class HelloMessage(HandshakeMsg):</span>
<span class="w"> </span>        :type add: boolean
<span class="w"> </span>        :param add: whether to add (True) or remove (False) the extension
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if add:</span>
<span class="gi">+            self._addExt(extType)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._removeExt(extType)</span>


<span class="w"> </span>class ClientHello(HelloMessage):
<span class="gu">@@ -214,11 +336,17 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>    def __init__(self, ssl2=False):
<span class="w"> </span>        super(ClientHello, self).__init__(HandshakeType.client_hello)
<span class="w"> </span>        self.ssl2 = ssl2
<span class="gd">-        self.client_version = 0, 0</span>
<span class="gi">+        self.client_version = (0, 0)</span>
<span class="w"> </span>        self.random = bytearray(32)
<span class="w"> </span>        self.session_id = bytearray(0)
<span class="gd">-        self.cipher_suites = []</span>
<span class="gd">-        self.compression_methods = []</span>
<span class="gi">+        self.cipher_suites = []         # a list of 16-bit values</span>
<span class="gi">+        self.compression_methods = []   # a list of 8-bit values</span>
<span class="gi">+</span>
<span class="gi">+    def _ciphers_to_str(self):</span>
<span class="gi">+        ciphers = &quot;, &quot;.join(</span>
<span class="gi">+            CipherSuite.ietfNames.get(i, str(i))</span>
<span class="gi">+            for i in self.cipher_suites)</span>
<span class="gi">+        return &quot;[{0}]&quot;.format(ciphers)</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -226,17 +354,20 @@ class ClientHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        if self.session_id.count(bytearray(b&#39;\x00&#39;)) == len(self.session_id</span>
<span class="gd">-            ) and len(self.session_id) != 0:</span>
<span class="gi">+        if self.session_id.count(bytearray(b&#39;\x00&#39;)) == len(self.session_id)\</span>
<span class="gi">+                and len(self.session_id) != 0:</span>
<span class="w"> </span>            session = &quot;bytearray(b&#39;\\x00&#39;*{0})&quot;.format(len(self.session_id))
<span class="w"> </span>        else:
<span class="w"> </span>            session = repr(self.session_id)
<span class="gd">-        ret = (</span>
<span class="gd">-            &#39;client_hello,version({0[0]}.{0[1]}),random(...),session ID({1!s}),cipher suites({2}),compression methods({3!r})&#39;</span>
<span class="gd">-            .format(self.client_version, session, self._ciphers_to_str(),</span>
<span class="gd">-            self.compression_methods))</span>
<span class="gi">+        ret = &quot;client_hello,version({0[0]}.{0[1]}),random(...),&quot;\</span>
<span class="gi">+              &quot;session ID({1!s}),cipher suites({2}),&quot;\</span>
<span class="gi">+              &quot;compression methods({3!r})&quot;.format(</span>
<span class="gi">+                  self.client_version, session,</span>
<span class="gi">+                  self._ciphers_to_str(), self.compression_methods)</span>
<span class="gi">+</span>
<span class="w"> </span>        if self.extensions is not None:
<span class="gd">-            ret += &#39;,extensions({0!r})&#39;.format(self.extensions)</span>
<span class="gi">+            ret += &quot;,extensions({0!r})&quot;.format(self.extensions)</span>
<span class="gi">+</span>
<span class="w"> </span>        return ret

<span class="w"> </span>    def __repr__(self):
<span class="gu">@@ -245,11 +376,12 @@ class ClientHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return (</span>
<span class="gd">-            &#39;ClientHello(ssl2={0}, client_version=({1[0]}.{1[1]}), random={2!r}, session_id={3!r}, cipher_suites={4}, compression_methods={5}, extensions={6})&#39;</span>
<span class="gd">-            .format(self.ssl2, self.client_version, self.random, self.</span>
<span class="gd">-            session_id, self._ciphers_to_str(), self.compression_methods,</span>
<span class="gd">-            self.extensions))</span>
<span class="gi">+        return &quot;ClientHello(ssl2={0}, client_version=({1[0]}.{1[1]}), &quot;\</span>
<span class="gi">+               &quot;random={2!r}, session_id={3!r}, cipher_suites={4}, &quot;\</span>
<span class="gi">+               &quot;compression_methods={5}, extensions={6})&quot;.format(</span>
<span class="gi">+                   self.ssl2, self.client_version, self.random,</span>
<span class="gi">+                   self.session_id, self._ciphers_to_str(),</span>
<span class="gi">+                   self.compression_methods, self.extensions)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def certificate_types(self):
<span class="gu">@@ -259,7 +391,13 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        .. deprecated:: 0.5
<span class="w"> </span>            use extensions field to get the extension for inspection
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cert_type = self.getExtension(ExtensionType.cert_type)</span>
<span class="gi">+        if cert_type is None:</span>
<span class="gi">+            # XXX backwards compatibility: TLSConnection</span>
<span class="gi">+            # depends on a default value of this property</span>
<span class="gi">+            return [CertificateType.x509]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return cert_type.certTypes</span>

<span class="w"> </span>    @certificate_types.setter
<span class="w"> </span>    def certificate_types(self, val):
<span class="gu">@@ -274,7 +412,13 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :param val: list of supported certificate types by client encoded as
<span class="w"> </span>            single byte integers
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cert_type = self.getExtension(ExtensionType.cert_type)</span>
<span class="gi">+</span>
<span class="gi">+        if cert_type is None:</span>
<span class="gi">+            ext = ClientCertTypeExtension().create(val)</span>
<span class="gi">+            self.addExtension(ext)</span>
<span class="gi">+        else:</span>
<span class="gi">+            cert_type.certTypes = val</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def srp_username(self):
<span class="gu">@@ -284,7 +428,12 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        .. deprecated:: 0.5
<span class="w"> </span>            use extensions field to get the extension for inspection
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        srp_ext = self.getExtension(ExtensionType.srp)</span>
<span class="gi">+</span>
<span class="gi">+        if srp_ext is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return srp_ext.identity</span>

<span class="w"> </span>    @srp_username.setter
<span class="w"> </span>    def srp_username(self, name):
<span class="gu">@@ -294,7 +443,13 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :type name: bytearray
<span class="w"> </span>        :param name: UTF-8 encoded username
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        srp_ext = self.getExtension(ExtensionType.srp)</span>
<span class="gi">+</span>
<span class="gi">+        if srp_ext is None:</span>
<span class="gi">+            ext = SRPExtension().create(name)</span>
<span class="gi">+            self.addExtension(ext)</span>
<span class="gi">+        else:</span>
<span class="gi">+            srp_ext.identity = name</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def tack(self):
<span class="gu">@@ -306,7 +461,7 @@ class ClientHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: boolean
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.getExtension(ExtensionType.tack) is not None</span>

<span class="w"> </span>    @tack.setter
<span class="w"> </span>    def tack(self, present):
<span class="gu">@@ -317,7 +472,7 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :param present: True will create extension while False will remove
<span class="w"> </span>            extension from client hello
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._addOrRemoveExt(ExtensionType.tack, present)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def supports_npn(self):
<span class="gu">@@ -329,7 +484,7 @@ class ClientHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: boolean
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.getExtension(ExtensionType.supports_npn) is not None</span>

<span class="w"> </span>    @supports_npn.setter
<span class="w"> </span>    def supports_npn(self, present):
<span class="gu">@@ -340,7 +495,7 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :param present: selects whatever to create or remove the extension
<span class="w"> </span>            from list of supported ones
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._addOrRemoveExt(ExtensionType.supports_npn, present)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def server_name(self):
<span class="gu">@@ -352,7 +507,14 @@ class ClientHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sni_ext = self.getExtension(ExtensionType.server_name)</span>
<span class="gi">+        if sni_ext is None:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if len(sni_ext.hostNames) &gt; 0:</span>
<span class="gi">+                return sni_ext.hostNames[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return bytearray(0)</span>

<span class="w"> </span>    @server_name.setter
<span class="w"> </span>    def server_name(self, hostname):
<span class="gu">@@ -362,11 +524,19 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :type hostname: bytearray
<span class="w"> </span>        :param hostname: name of the host_name to set
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sni_ext = self.getExtension(ExtensionType.server_name)</span>
<span class="gi">+        if sni_ext is None:</span>
<span class="gi">+            sni_ext = SNIExtension().create(hostname)</span>
<span class="gi">+            self.addExtension(sni_ext)</span>
<span class="gi">+        else:</span>
<span class="gi">+            names = list(sni_ext.hostNames)</span>
<span class="gi">+            names[0] = hostname</span>
<span class="gi">+            sni_ext.hostNames = names</span>

<span class="w"> </span>    def create(self, version, random, session_id, cipher_suites,
<span class="gd">-        certificate_types=None, srpUsername=None, tack=False, supports_npn=</span>
<span class="gd">-        None, serverName=None, extensions=None):</span>
<span class="gi">+               certificate_types=None, srpUsername=None,</span>
<span class="gi">+               tack=False, supports_npn=None, serverName=None,</span>
<span class="gi">+               extensions=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a ClientHello message for sending.

<span class="gu">@@ -409,19 +579,102 @@ class ClientHello(HelloMessage):</span>
<span class="w"> </span>        :type extensions: list of :py:class:`~.extensions.TLSExtension`
<span class="w"> </span>        :param extensions: list of extensions to advertise
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.client_version = version</span>
<span class="gi">+        self.random = random</span>
<span class="gi">+        self.session_id = session_id</span>
<span class="gi">+        self.cipher_suites = cipher_suites</span>
<span class="gi">+        self.compression_methods = [0]</span>
<span class="gi">+        if extensions is not None:</span>
<span class="gi">+            self.extensions = extensions</span>
<span class="gi">+        if certificate_types is not None:</span>
<span class="gi">+            self.certificate_types = certificate_types</span>
<span class="gi">+        if srpUsername is not None:</span>
<span class="gi">+            if not isinstance(srpUsername, bytearray):</span>
<span class="gi">+                raise TypeError(&quot;srpUsername must be a bytearray object&quot;)</span>
<span class="gi">+            self.srp_username = srpUsername</span>
<span class="gi">+        self.tack = tack</span>
<span class="gi">+        if supports_npn is not None:</span>
<span class="gi">+            self.supports_npn = supports_npn</span>
<span class="gi">+        if serverName is not None:</span>
<span class="gi">+            self.server_name = bytearray(serverName, &quot;utf-8&quot;)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, p):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise object from on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ssl2:</span>
<span class="gi">+            self.client_version = (p.get(1), p.get(1))</span>
<span class="gi">+            cipherSpecsLength = p.get(2)</span>
<span class="gi">+            sessionIDLength = p.get(2)</span>
<span class="gi">+            randomLength = p.get(2)</span>
<span class="gi">+            p.setLengthCheck(cipherSpecsLength +</span>
<span class="gi">+                             sessionIDLength +</span>
<span class="gi">+                             randomLength)</span>
<span class="gi">+            self.cipher_suites = p.getFixList(3, cipherSpecsLength//3)</span>
<span class="gi">+            self.session_id = p.getFixBytes(sessionIDLength)</span>
<span class="gi">+            self.random = p.getFixBytes(randomLength)</span>
<span class="gi">+            if len(self.random) &lt; 32:</span>
<span class="gi">+                zeroBytes = 32-len(self.random)</span>
<span class="gi">+                self.random = bytearray(zeroBytes) + self.random</span>
<span class="gi">+            self.compression_methods = [0]  # Fake this value</span>
<span class="gi">+            p.stopLengthCheck()</span>
<span class="gi">+        else:</span>
<span class="gi">+            p.startLengthCheck(3)</span>
<span class="gi">+            self.client_version = (p.get(1), p.get(1))</span>
<span class="gi">+            self.random = p.getFixBytes(32)</span>
<span class="gi">+            self.session_id = p.getVarBytes(1)</span>
<span class="gi">+            if len(self.session_id) &gt; 32:</span>
<span class="gi">+                raise DecodeError(&quot;session_id too long&quot;)</span>
<span class="gi">+            self.cipher_suites = p.getVarList(2, 2)</span>
<span class="gi">+            self.compression_methods = p.getVarList(1, 1)</span>
<span class="gi">+            if not p.atLengthCheck():</span>
<span class="gi">+                self.extensions = []</span>
<span class="gi">+                totalExtLength = p.get(2)</span>
<span class="gi">+                p2 = Parser(p.getFixBytes(totalExtLength))</span>
<span class="gi">+                while p2.getRemainingLength() &gt; 0:</span>
<span class="gi">+                    ext = TLSExtension().parse(p2)</span>
<span class="gi">+                    self.extensions += [ext]</span>
<span class="gi">+            p.stopLengthCheck()</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def _writeSSL2(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise SSLv2 object to on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add(self.handshakeType, 1)</span>
<span class="gi">+        writer.add(self.client_version[0], 1)</span>
<span class="gi">+        writer.add(self.client_version[1], 1)</span>
<span class="gi">+</span>
<span class="gi">+        ciphersWriter = Writer()</span>
<span class="gi">+        ciphersWriter.addFixSeq(self.cipher_suites, 3)</span>
<span class="gi">+</span>
<span class="gi">+        writer.add(len(ciphersWriter.bytes), 2)</span>
<span class="gi">+        writer.add(len(self.session_id), 2)</span>
<span class="gi">+        writer.add(len(self.random), 2)</span>
<span class="gi">+</span>
<span class="gi">+        writer.bytes += ciphersWriter.bytes</span>
<span class="gi">+        writer.bytes += self.session_id</span>
<span class="gi">+        writer.bytes += self.random</span>
<span class="gi">+</span>
<span class="gi">+        # postWrite() is necessary only for SSLv3/TLS</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def _write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise SSLv3 or TLS object to on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(self.client_version[0], 1)</span>
<span class="gi">+        w.add(self.client_version[1], 1)</span>
<span class="gi">+        w.bytes += self.random</span>
<span class="gi">+        w.addVarSeq(self.session_id, 1, 1)</span>
<span class="gi">+        w.addVarSeq(self.cipher_suites, 2, 2)</span>
<span class="gi">+        w.addVarSeq(self.compression_methods, 1, 1)</span>
<span class="gi">+</span>
<span class="gi">+        if self.extensions is not None:</span>
<span class="gi">+            w2 = Writer()</span>
<span class="gi">+            for ext in self.extensions:</span>
<span class="gi">+                w2.bytes += ext.write()</span>
<span class="gi">+</span>
<span class="gi">+            w.add(len(w2.bytes), 2)</span>
<span class="gi">+            w.bytes += w2.bytes</span>
<span class="gi">+        return self.postWrite(w)</span>

<span class="w"> </span>    def psk_truncate(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a truncated encoding of message without binders.
<span class="gu">@@ -434,11 +687,24 @@ class ClientHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ext = self.extensions[-1]</span>
<span class="gi">+        if not isinstance(ext, PreSharedKeyExtension):</span>
<span class="gi">+            raise ValueError(&quot;Last extension must be the pre_shared_key &quot;</span>
<span class="gi">+                             &quot;extension&quot;)</span>
<span class="gi">+        bts = self.write()</span>
<span class="gi">+        # every binder has 1 byte long header and the list of them</span>
<span class="gi">+        # has a 2 byte header</span>
<span class="gi">+        length = sum(len(i) + 1 for i in ext.binders) + 2</span>
<span class="gi">+</span>
<span class="gi">+        return bts[:-length]</span>
<span class="gi">+</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise object to on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ssl2:</span>
<span class="gi">+            return self._writeSSL2()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._write()</span>


<span class="w"> </span>class HelloRequest(HandshakeMsg):
<span class="gu">@@ -449,6 +715,19 @@ class HelloRequest(HandshakeMsg):</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        super(HelloRequest, self).__init__(HandshakeType.hello_request)

<span class="gi">+    def create(self):</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def write(self):</span>
<span class="gi">+        return self.postWrite(Writer())</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, parser):</span>
<span class="gi">+        # verify that the message is empty (the buffer will just contain</span>
<span class="gi">+        # the length from header)</span>
<span class="gi">+        parser.startLengthCheck(3)</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>

<span class="w"> </span>class ServerHello(HelloMessage):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -487,7 +766,7 @@ class ServerHello(HelloMessage):</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Initialise ServerHello object.&quot;&quot;&quot;
<span class="w"> </span>        super(ServerHello, self).__init__(HandshakeType.server_hello)
<span class="gd">-        self.server_version = 0, 0</span>
<span class="gi">+        self.server_version = (0, 0)</span>
<span class="w"> </span>        self.random = bytearray(32)
<span class="w"> </span>        self.session_id = bytearray(0)
<span class="w"> </span>        self.cipher_suite = 0
<span class="gu">@@ -495,33 +774,47 @@ class ServerHello(HelloMessage):</span>
<span class="w"> </span>        self._tack_ext = None

<span class="w"> </span>    def __str__(self):
<span class="gd">-        base = (</span>
<span class="gd">-            &#39;server_hello,length({0}),version({1[0]}.{1[1]}),random(...),session ID({2!r}),cipher({3:#x}),compression method({4})&#39;</span>
<span class="gd">-            .format(len(self.write()) - 4, self.server_version, self.</span>
<span class="gd">-            session_id, self.cipher_suite, self.compression_method))</span>
<span class="gi">+        base = &quot;server_hello,length({0}),version({1[0]}.{1[1]}),random(...),&quot;\</span>
<span class="gi">+                &quot;session ID({2!r}),cipher({3:#x}),compression method({4})&quot;\</span>
<span class="gi">+                .format(len(self.write())-4, self.server_version,</span>
<span class="gi">+                        self.session_id, self.cipher_suite,</span>
<span class="gi">+                        self.compression_method)</span>
<span class="gi">+</span>
<span class="w"> </span>        if self.extensions is None:
<span class="w"> </span>            return base
<span class="gd">-        ret = &#39;,extensions[&#39;</span>
<span class="gd">-        ret += &#39;,&#39;.join(repr(x) for x in self.extensions)</span>
<span class="gd">-        ret += &#39;]&#39;</span>
<span class="gi">+</span>
<span class="gi">+        ret = &quot;,extensions[&quot;</span>
<span class="gi">+        ret += &quot;,&quot;.join(repr(x) for x in self.extensions)</span>
<span class="gi">+        ret += &quot;]&quot;</span>
<span class="w"> </span>        return base + ret

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return (</span>
<span class="gd">-            &#39;ServerHello(server_version=({0[0]}, {0[1]}), random={1!r}, session_id={2!r}, cipher_suite={3}, compression_method={4}, _tack_ext={5}, extensions={6!r})&#39;</span>
<span class="gd">-            .format(self.server_version, self.random, self.session_id, self</span>
<span class="gd">-            .cipher_suite, self.compression_method, self._tack_ext, self.</span>
<span class="gd">-            extensions))</span>
<span class="gi">+        return &quot;ServerHello(server_version=({0[0]}, {0[1]}), random={1!r}, &quot;\</span>
<span class="gi">+                &quot;session_id={2!r}, cipher_suite={3}, compression_method={4}, &quot;\</span>
<span class="gi">+                &quot;_tack_ext={5}, extensions={6!r})&quot;.format(</span>
<span class="gi">+                    self.server_version, self.random, self.session_id,</span>
<span class="gi">+                    self.cipher_suite, self.compression_method, self._tack_ext,</span>
<span class="gi">+                    self.extensions)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def tackExt(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the TACK extension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._tack_ext is None:</span>
<span class="gi">+            ext = self.getExtension(ExtensionType.tack)</span>
<span class="gi">+            if ext is None or not tackpyLoaded:</span>
<span class="gi">+                return None</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._tack_ext = TackExtension(ext.extData)</span>
<span class="gi">+        return self._tack_ext</span>

<span class="w"> </span>    @tackExt.setter
<span class="w"> </span>    def tackExt(self, val):
<span class="w"> </span>        &quot;&quot;&quot;Set the TACK extension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._tack_ext = val</span>
<span class="gi">+        # makes sure that extensions are included in the on the wire encoding</span>
<span class="gi">+        if val is not None:</span>
<span class="gi">+            if self.extensions is None:</span>
<span class="gi">+                self.extensions = []</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def certificate_type(self):
<span class="gu">@@ -530,7 +823,12 @@ class ServerHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cert_type = self.getExtension(ExtensionType.cert_type)</span>
<span class="gi">+        if cert_type is None:</span>
<span class="gi">+            # XXX backwards compatibility, TLSConnection expects the default</span>
<span class="gi">+            # value to be that</span>
<span class="gi">+            return CertificateType.x509</span>
<span class="gi">+        return cert_type.cert_type</span>

<span class="w"> </span>    @certificate_type.setter
<span class="w"> </span>    def certificate_type(self, val):
<span class="gu">@@ -540,7 +838,17 @@ class ServerHello(HelloMessage):</span>
<span class="w"> </span>        :type val: int
<span class="w"> </span>        :param val: type of certificate
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if val == CertificateType.x509 or val is None:</span>
<span class="gi">+            # XXX backwards compatibility, x509 value should not be sent</span>
<span class="gi">+            self._removeExt(ExtensionType.cert_type)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        cert_type = self.getExtension(ExtensionType.cert_type)</span>
<span class="gi">+        if cert_type is None:</span>
<span class="gi">+            ext = ServerCertTypeExtension().create(val)</span>
<span class="gi">+            self.addExtension(ext)</span>
<span class="gi">+        else:</span>
<span class="gi">+            cert_type.cert_type = val</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def next_protos(self):
<span class="gu">@@ -549,7 +857,12 @@ class ServerHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: list of bytearrays
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        npn_ext = self.getExtension(ExtensionType.supports_npn)</span>
<span class="gi">+</span>
<span class="gi">+        if npn_ext is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return npn_ext.protocols</span>

<span class="w"> </span>    @next_protos.setter
<span class="w"> </span>    def next_protos(self, val):
<span class="gu">@@ -559,7 +872,21 @@ class ServerHello(HelloMessage):</span>
<span class="w"> </span>        :type val: list
<span class="w"> </span>        :param val: list of protocols to advertise as UTF-8 encoded names
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if val is None:</span>
<span class="gi">+            # XXX: do not send empty extension</span>
<span class="gi">+            self._removeExt(ExtensionType.supports_npn)</span>
<span class="gi">+            return</span>
<span class="gi">+        else:</span>
<span class="gi">+            # convinience function, make sure the values are properly encoded</span>
<span class="gi">+            val = [bytearray(x) for x in val]</span>
<span class="gi">+</span>
<span class="gi">+        npn_ext = self.getExtension(ExtensionType.supports_npn)</span>
<span class="gi">+</span>
<span class="gi">+        if npn_ext is None:</span>
<span class="gi">+            ext = NPNExtension().create(val)</span>
<span class="gi">+            self.addExtension(ext)</span>
<span class="gi">+        else:</span>
<span class="gi">+            npn_ext.protocols = val</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def next_protos_advertised(self):
<span class="gu">@@ -568,7 +895,7 @@ class ServerHello(HelloMessage):</span>

<span class="w"> </span>        :rtype: list of bytearrays
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.next_protos</span>

<span class="w"> </span>    @next_protos_advertised.setter
<span class="w"> </span>    def next_protos_advertised(self, val):
<span class="gu">@@ -578,13 +905,68 @@ class ServerHello(HelloMessage):</span>
<span class="w"> </span>        :type val: list
<span class="w"> </span>        :param val: list of protocols to advertise as UTF-8 encoded names
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.next_protos = val</span>

<span class="w"> </span>    def create(self, version, random, session_id, cipher_suite,
<span class="gd">-        certificate_type=None, tackExt=None, next_protos_advertised=None,</span>
<span class="gd">-        extensions=None):</span>
<span class="gi">+               certificate_type=None, tackExt=None,</span>
<span class="gi">+               next_protos_advertised=None,</span>
<span class="gi">+               extensions=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the object for deserialisation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.extensions = extensions</span>
<span class="gi">+        self.server_version = version</span>
<span class="gi">+        self.random = random</span>
<span class="gi">+        self.session_id = session_id</span>
<span class="gi">+        self.cipher_suite = cipher_suite</span>
<span class="gi">+        self.certificate_type = certificate_type</span>
<span class="gi">+        self.compression_method = 0</span>
<span class="gi">+        if tackExt is not None:</span>
<span class="gi">+            self.tackExt = tackExt</span>
<span class="gi">+        self.next_protos_advertised = next_protos_advertised</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, p):</span>
<span class="gi">+        p.startLengthCheck(3)</span>
<span class="gi">+        self.server_version = (p.get(1), p.get(1))</span>
<span class="gi">+        self.random = p.getFixBytes(32)</span>
<span class="gi">+        self.session_id = p.getVarBytes(1)</span>
<span class="gi">+        self.cipher_suite = p.get(2)</span>
<span class="gi">+        self.compression_method = p.get(1)</span>
<span class="gi">+        if not p.atLengthCheck():</span>
<span class="gi">+            self.extensions = []</span>
<span class="gi">+            totalExtLength = p.get(2)</span>
<span class="gi">+            p2 = Parser(p.getFixBytes(totalExtLength))</span>
<span class="gi">+            while p2.getRemainingLength() &gt; 0:</span>
<span class="gi">+                if self.random == TLS_1_3_HRR:</span>
<span class="gi">+                    ext = TLSExtension(hrr=True).parse(p2)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ext = TLSExtension(server=True).parse(p2)</span>
<span class="gi">+                self.extensions += [ext]</span>
<span class="gi">+        p.stopLengthCheck()</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def write(self):</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(self.server_version[0], 1)</span>
<span class="gi">+        w.add(self.server_version[1], 1)</span>
<span class="gi">+        w.bytes += self.random</span>
<span class="gi">+        w.addVarSeq(self.session_id, 1, 1)</span>
<span class="gi">+        w.add(self.cipher_suite, 2)</span>
<span class="gi">+        w.add(self.compression_method, 1)</span>
<span class="gi">+</span>
<span class="gi">+        if self.extensions is not None:</span>
<span class="gi">+            w2 = Writer()</span>
<span class="gi">+            for ext in self.extensions:</span>
<span class="gi">+                w2.bytes += ext.write()</span>
<span class="gi">+</span>
<span class="gi">+            if self.tackExt:</span>
<span class="gi">+                b = self.tackExt.serialize()</span>
<span class="gi">+                w2.add(ExtensionType.tack, 2)</span>
<span class="gi">+                w2.add(len(b), 2)</span>
<span class="gi">+                w2.bytes += b</span>
<span class="gi">+</span>
<span class="gi">+            w.add(len(w2.bytes), 2)</span>
<span class="gi">+            w.bytes += w2.bytes</span>
<span class="gi">+        return self.postWrite(w)</span>


<span class="w"> </span>class ServerHello2(HandshakeMsg):
<span class="gu">@@ -615,23 +997,62 @@ class ServerHello2(HandshakeMsg):</span>
<span class="w"> </span>        super(ServerHello2, self).__init__(SSL2HandshakeType.server_hello)
<span class="w"> </span>        self.session_id_hit = 0
<span class="w"> </span>        self.certificate_type = 0
<span class="gd">-        self.server_version = 0, 0</span>
<span class="gi">+        self.server_version = (0, 0)</span>
<span class="w"> </span>        self.certificate = bytearray(0)
<span class="w"> </span>        self.ciphers = []
<span class="w"> </span>        self.session_id = bytearray(0)

<span class="w"> </span>    def create(self, session_id_hit, certificate_type, server_version,
<span class="gd">-        certificate, ciphers, session_id):</span>
<span class="gi">+               certificate, ciphers, session_id):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize fields of the SERVER-HELLO message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.session_id_hit = session_id_hit</span>
<span class="gi">+        self.certificate_type = certificate_type</span>
<span class="gi">+        self.server_version = server_version</span>
<span class="gi">+        self.certificate = certificate</span>
<span class="gi">+        self.ciphers = ciphers</span>
<span class="gi">+        self.session_id = session_id</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise object to on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add(self.handshakeType, 1)</span>
<span class="gi">+        writer.add(self.session_id_hit, 1)</span>
<span class="gi">+        writer.add(self.certificate_type, 1)</span>
<span class="gi">+        if len(self.server_version) != 2:</span>
<span class="gi">+            raise ValueError(&quot;server version must be a 2-element tuple&quot;)</span>
<span class="gi">+        writer.addFixSeq(self.server_version, 1)</span>
<span class="gi">+        writer.add(len(self.certificate), 2)</span>
<span class="gi">+</span>
<span class="gi">+        ciphersWriter = Writer()</span>
<span class="gi">+        ciphersWriter.addFixSeq(self.ciphers, 3)</span>
<span class="gi">+</span>
<span class="gi">+        writer.add(len(ciphersWriter.bytes), 2)</span>
<span class="gi">+        writer.add(len(self.session_id), 2)</span>
<span class="gi">+</span>
<span class="gi">+        writer.bytes += self.certificate</span>
<span class="gi">+        writer.bytes += ciphersWriter.bytes</span>
<span class="gi">+        writer.bytes += self.session_id</span>
<span class="gi">+</span>
<span class="gi">+        # postWrite() is necessary only for SSLv3/TLS</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise object from on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.session_id_hit = parser.get(1)</span>
<span class="gi">+        self.certificate_type = parser.get(1)</span>
<span class="gi">+        self.server_version = (parser.get(1), parser.get(1))</span>
<span class="gi">+        certificateLength = parser.get(2)</span>
<span class="gi">+        ciphersLength = parser.get(2)</span>
<span class="gi">+        sessionIDLength = parser.get(2)</span>
<span class="gi">+        parser.setLengthCheck(certificateLength +</span>
<span class="gi">+                              ciphersLength +</span>
<span class="gi">+                              sessionIDLength)</span>
<span class="gi">+        self.certificate = parser.getFixBytes(certificateLength)</span>
<span class="gi">+        self.ciphers = parser.getFixList(3, ciphersLength // 3)</span>
<span class="gi">+        self.session_id = parser.getFixBytes(sessionIDLength)</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class CertificateEntry(object):
<span class="gu">@@ -650,24 +1071,53 @@ class CertificateEntry(object):</span>

<span class="w"> </span>    def create(self, certificate, extensions):
<span class="w"> </span>        &quot;&quot;&quot;Set all values of the certificate entry.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.certificate = certificate</span>
<span class="gi">+        self.extensions = extensions</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise the object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        if self.certificateType == CertificateType.x509:</span>
<span class="gi">+            writer.addVarSeq(self.certificate.writeBytes(), 1, 3)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Set certificate type ({0}) unsupported&quot;</span>
<span class="gi">+                             .format(self.certificateType))</span>
<span class="gi">+</span>
<span class="gi">+        if self.extensions is not None:</span>
<span class="gi">+            writer2 = Writer()</span>
<span class="gi">+            for ext in self.extensions:</span>
<span class="gi">+                writer2.bytes += ext.write()</span>
<span class="gi">+            writer.addVarSeq(writer2.bytes, 1, 2)</span>
<span class="gi">+</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise the object from on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.certificateType == CertificateType.x509:</span>
<span class="gi">+            certBytes = parser.getVarBytes(3)</span>
<span class="gi">+            x509 = X509()</span>
<span class="gi">+            x509.parseBinary(certBytes)</span>
<span class="gi">+            self.certificate = x509</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Set certificate type ({0}) unsupported&quot;</span>
<span class="gi">+                             .format(self.certificateType))</span>
<span class="gi">+</span>
<span class="gi">+        self.extensions = []</span>
<span class="gi">+        parser.startLengthCheck(2)</span>
<span class="gi">+        while not parser.atLengthCheck():</span>
<span class="gi">+            ext = TLSExtension(cert=True).parse(parser)</span>
<span class="gi">+            self.extensions.append(ext)</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;CertificateEntry(certificate={0!r}, extensions={1!r})&#39;.format(</span>
<span class="gd">-            self.certificate, self.extensions)</span>
<span class="gi">+        return &quot;CertificateEntry(certificate={0!r}, extensions={1!r})&quot;.format(</span>
<span class="gi">+                self.certificate, self.extensions)</span>


<span class="gd">-@deprecated_attrs({&#39;cert_chain&#39;: &#39;certChain&#39;})</span>
<span class="gi">+@deprecated_attrs({&quot;cert_chain&quot;: &quot;certChain&quot;})</span>
<span class="w"> </span>class Certificate(HandshakeMsg):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, certificateType, version=(3, 2)):
<span class="w"> </span>        HandshakeMsg.__init__(self, HandshakeType.certificate)
<span class="w"> </span>        self.certificateType = certificateType
<span class="gu">@@ -679,31 +1129,129 @@ class Certificate(HandshakeMsg):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def cert_chain(self):
<span class="w"> </span>        &quot;&quot;&quot;Getter for the cert_chain property.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._cert_chain:</span>
<span class="gi">+            return self._cert_chain</span>
<span class="gi">+        elif self.certificate_list:</span>
<span class="gi">+            return X509CertChain([i.certificate</span>
<span class="gi">+                                  for i in self.certificate_list])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    @cert_chain.setter
<span class="w"> </span>    def cert_chain(self, cert_chain):
<span class="w"> </span>        &quot;&quot;&quot;Setter for the cert_chain property.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(cert_chain, X509CertChain):</span>
<span class="gi">+            self._cert_chain = cert_chain</span>
<span class="gi">+            self.certificate_list = [CertificateEntry(self.certificateType)</span>
<span class="gi">+                                     .create(i, []) for i</span>
<span class="gi">+                                     in cert_chain.x509List]</span>
<span class="gi">+        elif cert_chain is None:</span>
<span class="gi">+            self.certificate_list = []</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.certificate_list = cert_chain</span>

<span class="gd">-    @deprecated_params({&#39;cert_chain&#39;: &#39;certChain&#39;})</span>
<span class="gi">+    @deprecated_params({&quot;cert_chain&quot;: &quot;certChain&quot;})</span>
<span class="w"> </span>    def create(self, cert_chain, context=b&#39;&#39;):
<span class="w"> </span>        &quot;&quot;&quot;Initialise fields of the class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.cert_chain = cert_chain</span>
<span class="gi">+        self.certificate_request_context = context</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_certificate_list(self, parser):</span>
<span class="gi">+        self.certificate_list = []</span>
<span class="gi">+        while parser.getRemainingLength():</span>
<span class="gi">+            entry = CertificateEntry(self.certificateType)</span>
<span class="gi">+            self.certificate_list.append(entry.parse(parser))</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_tls13(self, parser):</span>
<span class="gi">+        parser.startLengthCheck(3)</span>
<span class="gi">+        self.certificate_request_context = parser.getVarBytes(1)</span>
<span class="gi">+        self._parse_certificate_list(Parser(parser.getVarBytes(3)))</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_tls12(self, p):</span>
<span class="gi">+        p.startLengthCheck(3)</span>
<span class="gi">+        if self.certificateType == CertificateType.x509:</span>
<span class="gi">+            chainLength = p.get(3)</span>
<span class="gi">+            index = 0</span>
<span class="gi">+            certificate_list = []</span>
<span class="gi">+            while index != chainLength:</span>
<span class="gi">+                certBytes = p.getVarBytes(3)</span>
<span class="gi">+                if not certBytes:</span>
<span class="gi">+                    raise DecodeError(&quot;Client certificate is empty&quot;)</span>
<span class="gi">+                x509 = X509()</span>
<span class="gi">+                try:</span>
<span class="gi">+                    x509.parseBinary(certBytes)</span>
<span class="gi">+                except SyntaxError:</span>
<span class="gi">+                    raise BadCertificateError(&quot;Certificate could not be parsed&quot;)</span>
<span class="gi">+                certificate_list.append(x509)</span>
<span class="gi">+                index += len(certBytes)+3</span>
<span class="gi">+            if certificate_list:</span>
<span class="gi">+                self._cert_chain = X509CertChain(certificate_list)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+</span>
<span class="gi">+        p.stopLengthCheck()</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, p):</span>
<span class="gi">+        if self.version &lt;= (3, 3):</span>
<span class="gi">+            return self._parse_tls12(p)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._parse_tls13(p)</span>
<span class="gi">+</span>
<span class="gi">+    def _write_tls13(self):</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.addVarSeq(self.certificate_request_context, 1, 1)</span>
<span class="gi">+        w2 = Writer()</span>
<span class="gi">+        for entry in self.certificate_list:</span>
<span class="gi">+            w2.bytes += entry.write()</span>
<span class="gi">+        w.addVarSeq(w2.bytes, 1, 3)</span>
<span class="gi">+        return w</span>
<span class="gi">+</span>
<span class="gi">+    def _write_tls12(self):</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        if self.certificateType == CertificateType.x509:</span>
<span class="gi">+            chainLength = 0</span>
<span class="gi">+            if self._cert_chain:</span>
<span class="gi">+                certificate_list = self._cert_chain.x509List</span>
<span class="gi">+            else:</span>
<span class="gi">+                certificate_list = []</span>
<span class="gi">+            # determine length</span>
<span class="gi">+            for cert in certificate_list:</span>
<span class="gi">+                bytes = cert.writeBytes()</span>
<span class="gi">+                chainLength += len(bytes)+3</span>
<span class="gi">+            # add bytes</span>
<span class="gi">+            w.add(chainLength, 3)</span>
<span class="gi">+            for cert in certificate_list:</span>
<span class="gi">+                bytes = cert.writeBytes()</span>
<span class="gi">+                w.addVarSeq(bytes, 1, 3)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+        return w</span>
<span class="gi">+</span>
<span class="gi">+    def write(self):</span>
<span class="gi">+        if self.version &lt;= (3, 3):</span>
<span class="gi">+            writer = self._write_tls12()</span>
<span class="gi">+        else:</span>
<span class="gi">+            writer = self._write_tls13()</span>
<span class="gi">+        return self.postWrite(writer)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        if self.version &lt;= (3, 3):
<span class="gd">-            return &#39;Certificate(cert_chain={0!r})&#39;.format(self.cert_chain.</span>
<span class="gd">-                x509List)</span>
<span class="gd">-        return (&#39;Certificate(request_context={0!r}, certificate_list={1!r})&#39;</span>
<span class="gd">-            .format(self.certificate_request_context, self.certificate_list))</span>
<span class="gi">+            return &quot;Certificate(cert_chain={0!r})&quot;\</span>
<span class="gi">+                   .format(self.cert_chain.x509List)</span>
<span class="gi">+        return &quot;Certificate(request_context={0!r}, &quot;\</span>
<span class="gi">+               &quot;certificate_list={1!r})&quot;\</span>
<span class="gi">+               .format(self.certificate_request_context,</span>
<span class="gi">+                       self.certificate_list)</span>


<span class="w"> </span>class CertificateRequest(HelloMessage):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, version):
<span class="gd">-        super(CertificateRequest, self).__init__(HandshakeType.</span>
<span class="gd">-            certificate_request)</span>
<span class="gi">+        super(CertificateRequest, self).__init__(</span>
<span class="gi">+                HandshakeType.certificate_request)</span>
<span class="w"> </span>        self.certificate_types = []
<span class="w"> </span>        self.certificate_authorities = []
<span class="w"> </span>        self.version = version
<span class="gu">@@ -719,10 +1267,20 @@ class CertificateRequest(HelloMessage):</span>
<span class="w"> </span>        Extensions are used/valid only for TLS 1.3 but they are a good
<span class="w"> </span>        unified storage mechanism for all versions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ext = self.getExtension(ExtensionType.signature_algorithms)</span>
<span class="gi">+        if ext:</span>
<span class="gi">+            return ext.sigalgs</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    @supported_signature_algs.setter</span>
<span class="gi">+    def supported_signature_algs(self, val):</span>
<span class="gi">+        self._removeExt(ExtensionType.signature_algorithms)</span>
<span class="gi">+        if val is not None:</span>
<span class="gi">+            ext = SignatureAlgorithmsExtension().create(val)</span>
<span class="gi">+            self.addExtension(ext)</span>

<span class="w"> </span>    def create(self, certificate_types=None, certificate_authorities=None,
<span class="gd">-        sig_algs=None, context=b&#39;&#39;, extensions=None):</span>
<span class="gi">+               sig_algs=None, context=b&#39;&#39;, extensions=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>            Creates a Certificate Request message.
<span class="w"> </span>            For TLS 1.3 only the context and extensions parameters should be
<span class="gu">@@ -730,7 +1288,81 @@ class CertificateRequest(HelloMessage):</span>
<span class="w"> </span>            For TLS versions below 1.3 instead only the first three parameters
<span class="w"> </span>            are considered.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.certificate_types = certificate_types</span>
<span class="gi">+        self.certificate_authorities = certificate_authorities</span>
<span class="gi">+        self.certificate_request_context = context</span>
<span class="gi">+        self.extensions = extensions</span>
<span class="gi">+        # do this after setting extensions, or it will be overwritten</span>
<span class="gi">+        if sig_algs is not None:</span>
<span class="gi">+            self.supported_signature_algs = sig_algs</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_tls13(self, parser):</span>
<span class="gi">+        parser.startLengthCheck(3)</span>
<span class="gi">+        self.certificate_request_context = parser.getVarBytes(1)</span>
<span class="gi">+        if not parser.getRemainingLength():</span>
<span class="gi">+            raise SyntaxError(&quot;No list of extensions&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.extensions = []</span>
<span class="gi">+            sub_parser = Parser(parser.getVarBytes(2))</span>
<span class="gi">+            while sub_parser.getRemainingLength():</span>
<span class="gi">+                # We care only for universal extensions so far</span>
<span class="gi">+                ext = TLSExtension().parse(sub_parser)</span>
<span class="gi">+                self.extensions.append(ext)</span>
<span class="gi">+</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_tls12(self, p):</span>
<span class="gi">+        p.startLengthCheck(3)</span>
<span class="gi">+        self.certificate_types = p.getVarList(1, 1)</span>
<span class="gi">+        if self.version == (3, 3):</span>
<span class="gi">+            self.supported_signature_algs = p.getVarTupleList(1, 2, 2)</span>
<span class="gi">+        ca_list_length = p.get(2)</span>
<span class="gi">+        index = 0</span>
<span class="gi">+        self.certificate_authorities = []</span>
<span class="gi">+        while index != ca_list_length:</span>
<span class="gi">+            ca_bytes = p.getVarBytes(2)</span>
<span class="gi">+            self.certificate_authorities.append(ca_bytes)</span>
<span class="gi">+            index += len(ca_bytes)+2</span>
<span class="gi">+        p.stopLengthCheck()</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, parser):</span>
<span class="gi">+        if self.version &lt;= (3, 3):</span>
<span class="gi">+            return self._parse_tls12(parser)</span>
<span class="gi">+        return self._parse_tls13(parser)</span>
<span class="gi">+</span>
<span class="gi">+    def _write_tls13(self):</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.addVarSeq(self.certificate_request_context, 1, 1)</span>
<span class="gi">+        sub_writer = Writer()</span>
<span class="gi">+        for ext in self.extensions or []:</span>
<span class="gi">+            sub_writer.bytes += ext.write()</span>
<span class="gi">+        writer.addVarSeq(sub_writer.bytes, 1, 2)</span>
<span class="gi">+        return writer</span>
<span class="gi">+</span>
<span class="gi">+    def _write_tls12(self):</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.addVarSeq(self.certificate_types, 1, 1)</span>
<span class="gi">+        if self.version &gt;= (3, 3):</span>
<span class="gi">+            w.addVarTupleSeq(self.supported_signature_algs, 1, 2)</span>
<span class="gi">+        caLength = 0</span>
<span class="gi">+        # determine length</span>
<span class="gi">+        for ca_dn in self.certificate_authorities:</span>
<span class="gi">+            caLength += len(ca_dn)+2</span>
<span class="gi">+        w.add(caLength, 2)</span>
<span class="gi">+        # add bytes</span>
<span class="gi">+        for ca_dn in self.certificate_authorities:</span>
<span class="gi">+            w.addVarSeq(ca_dn, 1, 2)</span>
<span class="gi">+        return w</span>
<span class="gi">+</span>
<span class="gi">+    def write(self):</span>
<span class="gi">+        if self.version &lt;= (3, 3):</span>
<span class="gi">+            writer = self._write_tls12()</span>
<span class="gi">+        else:</span>
<span class="gi">+            writer = self._write_tls13()</span>
<span class="gi">+        return self.postWrite(writer)</span>


<span class="w"> </span>class ServerKeyExchange(HandshakeMsg):
<span class="gu">@@ -796,47 +1428,69 @@ class ServerKeyExchange(HandshakeMsg):</span>
<span class="w"> </span>        self.srp_s = bytearray(0)
<span class="w"> </span>        self.srp_B = 0
<span class="w"> </span>        self.srp_B_len = None
<span class="gi">+        # Anon DH params:</span>
<span class="w"> </span>        self.dh_p = 0
<span class="w"> </span>        self.dh_p_len = None
<span class="w"> </span>        self.dh_g = 0
<span class="w"> </span>        self.dh_g_len = None
<span class="w"> </span>        self.dh_Ys = 0
<span class="w"> </span>        self.dh_Ys_len = None
<span class="gi">+        # EC settings</span>
<span class="w"> </span>        self.curve_type = None
<span class="w"> </span>        self.named_curve = None
<span class="w"> </span>        self.ecdh_Ys = bytearray(0)
<span class="gi">+        # signature for certificate authenticated ciphersuites</span>
<span class="w"> </span>        self.signature = bytearray(0)
<span class="gi">+        # signature hash algorithm and signing algorithm for TLSv1.2</span>
<span class="w"> </span>        self.hashAlg = 0
<span class="w"> </span>        self.signAlg = 0

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        ret = (&#39;ServerKeyExchange(cipherSuite=CipherSuite.{0}, version={1}&#39;</span>
<span class="gd">-            .format(CipherSuite.ietfNames[self.cipherSuite], self.version))</span>
<span class="gi">+        ret = &quot;ServerKeyExchange(cipherSuite=CipherSuite.{0}, version={1}&quot;\</span>
<span class="gi">+              &quot;&quot;.format(CipherSuite.ietfNames[self.cipherSuite], self.version)</span>
<span class="gi">+</span>
<span class="w"> </span>        if self.srp_N != 0:
<span class="gd">-            ret += &#39;, srp_N={0}, srp_g={1}, srp_s={2!r}, srp_B={3}&#39;.format(self</span>
<span class="gd">-                .srp_N, self.srp_g, self.srp_s, self.srp_B)</span>
<span class="gi">+            ret += &quot;, srp_N={0}, srp_g={1}, srp_s={2!r}, srp_B={3}&quot;.format(</span>
<span class="gi">+                self.srp_N, self.srp_g, self.srp_s, self.srp_B)</span>
<span class="w"> </span>        if self.dh_p != 0:
<span class="gd">-            ret += &#39;, dh_p={0}, dh_g={1}, dh_Ys={2}&#39;.format(self.dh_p, self</span>
<span class="gd">-                .dh_g, self.dh_Ys)</span>
<span class="gi">+            ret += &quot;, dh_p={0}, dh_g={1}, dh_Ys={2}&quot;.format(</span>
<span class="gi">+                self.dh_p, self.dh_g, self.dh_Ys)</span>
<span class="w"> </span>        if self.signAlg != 0:
<span class="gd">-            ret += &#39;, hashAlg={0}, signAlg={1}&#39;.format(self.hashAlg, self.</span>
<span class="gd">-                signAlg)</span>
<span class="gi">+            ret += &quot;, hashAlg={0}, signAlg={1}&quot;.format(</span>
<span class="gi">+                self.hashAlg, self.signAlg)</span>
<span class="w"> </span>        if self.signature != bytearray(0):
<span class="gd">-            ret += &#39;, signature={0!r}&#39;.format(self.signature)</span>
<span class="gd">-        ret += &#39;)&#39;</span>
<span class="gi">+            ret += &quot;, signature={0!r}&quot;.format(self.signature)</span>
<span class="gi">+        ret += &quot;)&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        return ret

<span class="w"> </span>    def createSRP(self, srp_N, srp_g, srp_s, srp_B):
<span class="w"> </span>        &quot;&quot;&quot;Set SRP protocol parameters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.srp_N = srp_N</span>
<span class="gi">+        self.srp_N_len = None</span>
<span class="gi">+        self.srp_g = srp_g</span>
<span class="gi">+        self.srp_g_len = None</span>
<span class="gi">+        self.srp_s = srp_s</span>
<span class="gi">+        self.srp_B = srp_B</span>
<span class="gi">+        self.srp_B_len = None</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def createDH(self, dh_p, dh_g, dh_Ys):
<span class="w"> </span>        &quot;&quot;&quot;Set FFDH protocol parameters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.dh_p = dh_p</span>
<span class="gi">+        self.dh_p_len = None</span>
<span class="gi">+        self.dh_g = dh_g</span>
<span class="gi">+        self.dh_g_len = None</span>
<span class="gi">+        self.dh_Ys = dh_Ys</span>
<span class="gi">+        self.dh_Ys_len = None</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def createECDH(self, curve_type, named_curve=None, point=None):
<span class="w"> </span>        &quot;&quot;&quot;Set ECDH protocol parameters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.curve_type = curve_type</span>
<span class="gi">+        self.named_curve = named_curve</span>
<span class="gi">+        self.ecdh_Ys = point</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -845,7 +1499,41 @@ class ServerKeyExchange(HandshakeMsg):</span>
<span class="w"> </span>        :type parser: Parser
<span class="w"> </span>        :param parser: parser to read data from
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser.startLengthCheck(3)</span>
<span class="gi">+        if self.cipherSuite in CipherSuite.srpAllSuites:</span>
<span class="gi">+            self.srp_N_len = parser.get(2)</span>
<span class="gi">+            self.srp_N = bytesToNumber(parser.getFixBytes(self.srp_N_len))</span>
<span class="gi">+            self.srp_g_len = parser.get(2)</span>
<span class="gi">+            self.srp_g = bytesToNumber(parser.getFixBytes(self.srp_g_len))</span>
<span class="gi">+            self.srp_s = parser.getVarBytes(1)</span>
<span class="gi">+            self.srp_B_len = parser.get(2)</span>
<span class="gi">+            self.srp_B = bytesToNumber(parser.getFixBytes(self.srp_B_len))</span>
<span class="gi">+        elif self.cipherSuite in CipherSuite.dhAllSuites:</span>
<span class="gi">+            self.dh_p_len = parser.get(2)</span>
<span class="gi">+            self.dh_p = bytesToNumber(parser.getFixBytes(self.dh_p_len))</span>
<span class="gi">+            self.dh_g_len = parser.get(2)</span>
<span class="gi">+            self.dh_g = bytesToNumber(parser.getFixBytes(self.dh_g_len))</span>
<span class="gi">+            self.dh_Ys_len = parser.get(2)</span>
<span class="gi">+            self.dh_Ys = bytesToNumber(parser.getFixBytes(self.dh_Ys_len))</span>
<span class="gi">+        elif self.cipherSuite in CipherSuite.ecdhAllSuites:</span>
<span class="gi">+            self.curve_type = parser.get(1)</span>
<span class="gi">+            # only named curves supported</span>
<span class="gi">+            assert self.curve_type == 3</span>
<span class="gi">+            self.named_curve = parser.get(2)</span>
<span class="gi">+            self.ecdh_Ys = parser.getVarBytes(1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+</span>
<span class="gi">+        if self.cipherSuite in CipherSuite.certAllSuites or\</span>
<span class="gi">+                self.cipherSuite in CipherSuite.ecdheEcdsaSuites or\</span>
<span class="gi">+                self.cipherSuite in CipherSuite.dheDsaSuites:</span>
<span class="gi">+            if self.version == (3, 3):</span>
<span class="gi">+                self.hashAlg = parser.get(1)</span>
<span class="gi">+                self.signAlg = parser.get(1)</span>
<span class="gi">+            self.signature = parser.getVarBytes(2)</span>
<span class="gi">+</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def writeParams(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -853,7 +1541,30 @@ class ServerKeyExchange(HandshakeMsg):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        if self.cipherSuite in CipherSuite.srpAllSuites:</span>
<span class="gi">+            writer.addVarSeq(numberToByteArray(self.srp_N, self.srp_N_len),</span>
<span class="gi">+                             1, 2)</span>
<span class="gi">+            writer.addVarSeq(numberToByteArray(self.srp_g, self.srp_g_len),</span>
<span class="gi">+                             1, 2)</span>
<span class="gi">+            writer.addVarSeq(self.srp_s, 1, 1)</span>
<span class="gi">+            writer.addVarSeq(numberToByteArray(self.srp_B, self.srp_B_len),</span>
<span class="gi">+                             1, 2)</span>
<span class="gi">+        elif self.cipherSuite in CipherSuite.dhAllSuites:</span>
<span class="gi">+            writer.addVarSeq(numberToByteArray(self.dh_p, self.dh_p_len),</span>
<span class="gi">+                             1, 2)</span>
<span class="gi">+            writer.addVarSeq(numberToByteArray(self.dh_g, self.dh_g_len),</span>
<span class="gi">+                             1, 2)</span>
<span class="gi">+            writer.addVarSeq(numberToByteArray(self.dh_Ys, self.dh_Ys_len),</span>
<span class="gi">+                             1, 2)</span>
<span class="gi">+        elif self.cipherSuite in CipherSuite.ecdhAllSuites:</span>
<span class="gi">+            writer.add(self.curve_type, 1)</span>
<span class="gi">+            assert self.curve_type == 3</span>
<span class="gi">+            writer.add(self.named_curve, 2)</span>
<span class="gi">+            writer.addVarSeq(self.ecdh_Ys, 1, 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert(False)</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -861,7 +1572,17 @@ class ServerKeyExchange(HandshakeMsg):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.bytes += self.writeParams()</span>
<span class="gi">+        if self.cipherSuite in CipherSuite.certAllSuites or \</span>
<span class="gi">+                self.cipherSuite in CipherSuite.ecdheEcdsaSuites or \</span>
<span class="gi">+                self.cipherSuite in CipherSuite.dheDsaSuites:</span>
<span class="gi">+            if self.version &gt;= (3, 3):</span>
<span class="gi">+                assert self.hashAlg != 0 and self.signAlg != 0</span>
<span class="gi">+                writer.add(self.hashAlg, 1)</span>
<span class="gi">+                writer.add(self.signAlg, 1)</span>
<span class="gi">+            writer.addVarSeq(self.signature, 1, 2)</span>
<span class="gi">+        return self.postWrite(writer)</span>

<span class="w"> </span>    def hash(self, clientRandom, serverRandom):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -869,17 +1590,46 @@ class ServerKeyExchange(HandshakeMsg):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        bytesToHash = clientRandom + serverRandom + self.writeParams()</span>
<span class="gi">+        if self.version &gt;= (3, 3):</span>
<span class="gi">+            sigScheme = SignatureScheme.toRepr((self.hashAlg, self.signAlg))</span>
<span class="gi">+            if sigScheme is None:</span>
<span class="gi">+                hashAlg = HashAlgorithm.toRepr(self.hashAlg)</span>
<span class="gi">+                if hashAlg is None:</span>
<span class="gi">+                    raise AssertionError(&quot;Unknown hash algorithm: {0}&quot;.</span>
<span class="gi">+                                         format(self.hashAlg))</span>
<span class="gi">+            else:</span>
<span class="gi">+                hashAlg = SignatureScheme.getHash(sigScheme)</span>
<span class="gi">+            if hashAlg == &quot;intrinsic&quot;:</span>
<span class="gi">+                return bytesToHash</span>
<span class="gi">+            return secureHash(bytesToHash, hashAlg)</span>
<span class="gi">+        # DSA and ECDSA ciphers in TLS 1.1 and earlier sign the messages using</span>
<span class="gi">+        # SHA-1 only</span>
<span class="gi">+        if self.cipherSuite in CipherSuite.ecdheEcdsaSuites or\</span>
<span class="gi">+                self.cipherSuite in CipherSuite.dheDsaSuites:</span>
<span class="gi">+            return SHA1(bytesToHash)</span>
<span class="gi">+        return MD5(bytesToHash) + SHA1(bytesToHash)</span>


<span class="w"> </span>class ServerHelloDone(HandshakeMsg):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        HandshakeMsg.__init__(self, HandshakeType.server_hello_done)

<span class="gi">+    def create(self):</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, p):</span>
<span class="gi">+        p.startLengthCheck(3)</span>
<span class="gi">+        p.stopLengthCheck()</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def write(self):</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        return self.postWrite(w)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        &quot;&quot;&quot;Human readable representation of object.&quot;&quot;&quot;
<span class="gd">-        return &#39;ServerHelloDone()&#39;</span>
<span class="gi">+        return &quot;ServerHelloDone()&quot;</span>


<span class="w"> </span>class ClientKeyExchange(HandshakeMsg):
<span class="gu">@@ -928,7 +1678,8 @@ class ClientKeyExchange(HandshakeMsg):</span>
<span class="w"> </span>        :param srp_A: client SRP answer
<span class="w"> </span>        :rtype: ClientKeyExchange
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.srp_A = srp_A</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def createRSA(self, encryptedPreMasterSecret):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -939,7 +1690,8 @@ class ClientKeyExchange(HandshakeMsg):</span>
<span class="w"> </span>        :type encryptedPreMasterSecret: bytearray
<span class="w"> </span>        :rtype: ClientKeyExchange
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.encryptedPreMasterSecret = encryptedPreMasterSecret</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def createDH(self, dh_Yc):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -950,7 +1702,8 @@ class ClientKeyExchange(HandshakeMsg):</span>
<span class="w"> </span>        :type dh_Yc: int
<span class="w"> </span>        :rtype: ClientKeyExchange
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.dh_Yc = dh_Yc</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def createECDH(self, ecdh_Yc):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -961,7 +1714,8 @@ class ClientKeyExchange(HandshakeMsg):</span>
<span class="w"> </span>        :type ecdh_Yc: bytearray
<span class="w"> </span>        :rtype: ClientKeyExchange
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.ecdh_Yc = ecdh_Yc</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -972,7 +1726,25 @@ class ClientKeyExchange(HandshakeMsg):</span>
<span class="w"> </span>        :type parser: Parser
<span class="w"> </span>        :rtype: ClientKeyExchange
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser.startLengthCheck(3)</span>
<span class="gi">+        if self.cipherSuite in CipherSuite.srpAllSuites:</span>
<span class="gi">+            self.srp_A = bytesToNumber(parser.getVarBytes(2))</span>
<span class="gi">+        elif self.cipherSuite in CipherSuite.certSuites:</span>
<span class="gi">+            if self.version in ((3, 1), (3, 2), (3, 3)):</span>
<span class="gi">+                self.encryptedPreMasterSecret = parser.getVarBytes(2)</span>
<span class="gi">+            elif self.version == (3, 0):</span>
<span class="gi">+                self.encryptedPreMasterSecret = \</span>
<span class="gi">+                    parser.getFixBytes(parser.getRemainingLength())</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise AssertionError()</span>
<span class="gi">+        elif self.cipherSuite in CipherSuite.dhAllSuites:</span>
<span class="gi">+            self.dh_Yc = bytesToNumber(parser.getVarBytes(2))</span>
<span class="gi">+        elif self.cipherSuite in CipherSuite.ecdhAllSuites:</span>
<span class="gi">+            self.ecdh_Yc = parser.getVarBytes(1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -980,7 +1752,23 @@ class ClientKeyExchange(HandshakeMsg):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        if self.cipherSuite in CipherSuite.srpAllSuites:</span>
<span class="gi">+            w.addVarSeq(numberToByteArray(self.srp_A), 1, 2)</span>
<span class="gi">+        elif self.cipherSuite in CipherSuite.certSuites:</span>
<span class="gi">+            if self.version in ((3, 1), (3, 2), (3, 3)):</span>
<span class="gi">+                w.addVarSeq(self.encryptedPreMasterSecret, 1, 2)</span>
<span class="gi">+            elif self.version == (3, 0):</span>
<span class="gi">+                w.bytes += self.encryptedPreMasterSecret</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise AssertionError()</span>
<span class="gi">+        elif self.cipherSuite in CipherSuite.dhAllSuites:</span>
<span class="gi">+            w.addVarSeq(numberToByteArray(self.dh_Yc), 1, 2)</span>
<span class="gi">+        elif self.cipherSuite in CipherSuite.ecdhAllSuites:</span>
<span class="gi">+            w.addVarSeq(self.ecdh_Yc, 1, 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+        return self.postWrite(w)</span>


<span class="w"> </span>class ClientMasterKey(HandshakeMsg):
<span class="gu">@@ -1002,8 +1790,8 @@ class ClientMasterKey(HandshakeMsg):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self):
<span class="gd">-        super(ClientMasterKey, self).__init__(SSL2HandshakeType.</span>
<span class="gd">-            client_master_key)</span>
<span class="gi">+        super(ClientMasterKey,</span>
<span class="gi">+              self).__init__(SSL2HandshakeType.client_master_key)</span>
<span class="w"> </span>        self.cipher = 0
<span class="w"> </span>        self.clear_key = bytearray(0)
<span class="w"> </span>        self.encrypted_key = bytearray(0)
<span class="gu">@@ -1011,15 +1799,39 @@ class ClientMasterKey(HandshakeMsg):</span>

<span class="w"> </span>    def create(self, cipher, clear_key, encrypted_key, key_argument):
<span class="w"> </span>        &quot;&quot;&quot;Set values of the CLIENT-MASTER-KEY object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.cipher = cipher</span>
<span class="gi">+        self.clear_key = clear_key</span>
<span class="gi">+        self.encrypted_key = encrypted_key</span>
<span class="gi">+        self.key_argument = key_argument</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise the object to on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add(self.handshakeType, 1)</span>
<span class="gi">+        writer.add(self.cipher, 3)</span>
<span class="gi">+        writer.add(len(self.clear_key), 2)</span>
<span class="gi">+        writer.add(len(self.encrypted_key), 2)</span>
<span class="gi">+        writer.add(len(self.key_argument), 2)</span>
<span class="gi">+        writer.bytes += self.clear_key</span>
<span class="gi">+        writer.bytes += self.encrypted_key</span>
<span class="gi">+        writer.bytes += self.key_argument</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise object from on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.cipher = parser.get(3)</span>
<span class="gi">+        clear_key_length = parser.get(2)</span>
<span class="gi">+        encrypted_key_length = parser.get(2)</span>
<span class="gi">+        key_argument_length = parser.get(2)</span>
<span class="gi">+        parser.setLengthCheck(clear_key_length +</span>
<span class="gi">+                              encrypted_key_length +</span>
<span class="gi">+                              key_argument_length)</span>
<span class="gi">+        self.clear_key = parser.getFixBytes(clear_key_length)</span>
<span class="gi">+        self.encrypted_key = parser.getFixBytes(encrypted_key_length)</span>
<span class="gi">+        self.key_argument = parser.getFixBytes(key_argument_length)</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class CertificateVerify(HandshakeMsg):
<span class="gu">@@ -1044,7 +1856,9 @@ class CertificateVerify(HandshakeMsg):</span>
<span class="w"> </span>        :param signatureAlgorithm: signature algorithm used to make the
<span class="w"> </span>            signature (TLSv1.2 only)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.signatureAlgorithm = signatureAlgorithm</span>
<span class="gi">+        self.signature = signature</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1052,7 +1866,12 @@ class CertificateVerify(HandshakeMsg):</span>

<span class="w"> </span>        :param parser: parser with data to read
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser.startLengthCheck(3)</span>
<span class="gi">+        if self.version &gt;= (3, 3):</span>
<span class="gi">+            self.signatureAlgorithm = (parser.get(1), parser.get(1))</span>
<span class="gi">+        self.signature = parser.getVarBytes(2)</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1060,46 +1879,117 @@ class CertificateVerify(HandshakeMsg):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        if self.version &gt;= (3, 3):</span>
<span class="gi">+            writer.add(self.signatureAlgorithm[0], 1)</span>
<span class="gi">+            writer.add(self.signatureAlgorithm[1], 1)</span>
<span class="gi">+        writer.addVarSeq(self.signature, 1, 2)</span>
<span class="gi">+        return self.postWrite(writer)</span>


<span class="w"> </span>class ChangeCipherSpec(object):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.contentType = ContentType.change_cipher_spec
<span class="w"> </span>        self.type = 1

<span class="gi">+    def create(self):</span>
<span class="gi">+        self.type = 1</span>
<span class="gi">+        return self</span>

<span class="gd">-class NextProtocol(HandshakeMsg):</span>
<span class="gi">+    def parse(self, p):</span>
<span class="gi">+        p.setLengthCheck(1)</span>
<span class="gi">+        self.type = p.get(1)</span>
<span class="gi">+        p.stopLengthCheck()</span>
<span class="gi">+        if p.getRemainingLength():</span>
<span class="gi">+            raise DecodeError(&quot;Multi-byte CCS message&quot;)</span>
<span class="gi">+        return self</span>

<span class="gi">+    def write(self):</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(self.type, 1)</span>
<span class="gi">+        return w.bytes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class NextProtocol(HandshakeMsg):</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        HandshakeMsg.__init__(self, HandshakeType.next_protocol)
<span class="w"> </span>        self.next_proto = None

<span class="gi">+    def create(self, next_proto):</span>
<span class="gi">+        self.next_proto = next_proto</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, p):</span>
<span class="gi">+        p.startLengthCheck(3)</span>
<span class="gi">+        self.next_proto = p.getVarBytes(1)</span>
<span class="gi">+        _ = p.getVarBytes(1)</span>
<span class="gi">+        p.stopLengthCheck()</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, trial=False):</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.addVarSeq(self.next_proto, 1, 1)</span>
<span class="gi">+        paddingLen = 32 - ((len(self.next_proto) + 2) % 32)</span>
<span class="gi">+        w.addVarSeq(bytearray(paddingLen), 1, 1)</span>
<span class="gi">+        return self.postWrite(w)</span>

<span class="gd">-class Finished(HandshakeMsg):</span>

<span class="gi">+class Finished(HandshakeMsg):</span>
<span class="w"> </span>    def __init__(self, version, hash_length=None):
<span class="w"> </span>        HandshakeMsg.__init__(self, HandshakeType.finished)
<span class="w"> </span>        self.version = version
<span class="w"> </span>        self.verify_data = bytearray(0)
<span class="w"> </span>        self.hash_length = hash_length

<span class="gi">+    def create(self, verify_data):</span>
<span class="gi">+        self.verify_data = verify_data</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, p):</span>
<span class="gi">+        p.startLengthCheck(3)</span>
<span class="gi">+        if self.version == (3, 0):</span>
<span class="gi">+            self.verify_data = p.getFixBytes(36)</span>
<span class="gi">+        elif self.version in ((3, 1), (3, 2), (3, 3)):</span>
<span class="gi">+            self.verify_data = p.getFixBytes(12)</span>
<span class="gi">+        elif self.version &gt; (3, 3):</span>
<span class="gi">+            self.verify_data = p.getFixBytes(self.hash_length)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+        p.stopLengthCheck()</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def write(self):</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.bytes += self.verify_data</span>
<span class="gi">+        return self.postWrite(w)</span>
<span class="gi">+</span>

<span class="w"> </span>class EncryptedExtensions(HelloMessage):
<span class="w"> </span>    &quot;&quot;&quot;Handling of the TLS1.3 Encrypted Extensions message.&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self):
<span class="gd">-        super(EncryptedExtensions, self).__init__(HandshakeType.</span>
<span class="gd">-            encrypted_extensions)</span>
<span class="gi">+        super(EncryptedExtensions, self).__init__(</span>
<span class="gi">+                HandshakeType.encrypted_extensions)</span>

<span class="w"> </span>    def create(self, extensions):
<span class="w"> </span>        &quot;&quot;&quot;Set the extensions in the message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.extensions = extensions</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Parse the extensions from on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser.startLengthCheck(3)</span>
<span class="gi">+</span>
<span class="gi">+        if not parser.getRemainingLength():</span>
<span class="gi">+            raise SyntaxError(&quot;No list of extensions&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.extensions = []</span>
<span class="gi">+            p2 = Parser(parser.getVarBytes(2))</span>
<span class="gi">+            while p2.getRemainingLength():</span>
<span class="gi">+                self.extensions.append(TLSExtension(encExt=True).parse(p2))</span>
<span class="gi">+</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1107,7 +1997,15 @@ class EncryptedExtensions(HelloMessage):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w2 = Writer()</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            w2.bytes += ext.write()</span>
<span class="gi">+</span>
<span class="gi">+        w.add(len(w2.bytes), 2)</span>
<span class="gi">+        w.bytes += w2.bytes</span>
<span class="gi">+</span>
<span class="gi">+        return self.postWrite(w)</span>


<span class="w"> </span>class NewSessionTicket(HelloMessage):
<span class="gu">@@ -1115,19 +2013,26 @@ class NewSessionTicket(HelloMessage):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create New Session Ticket object.&quot;&quot;&quot;
<span class="gd">-        super(NewSessionTicket, self).__init__(HandshakeType.new_session_ticket</span>
<span class="gd">-            )</span>
<span class="gi">+        super(NewSessionTicket, self).__init__(HandshakeType</span>
<span class="gi">+                                               .new_session_ticket)</span>
<span class="w"> </span>        self.ticket_lifetime = 0
<span class="w"> </span>        self.ticket_age_add = 0
<span class="w"> </span>        self.ticket_nonce = bytearray(0)
<span class="w"> </span>        self.ticket = bytearray(0)
<span class="w"> </span>        self.extensions = []
<span class="gi">+        # time at which the ticket was received, not sent on the wire</span>
<span class="gi">+        # in seconds in Unix Epoch</span>
<span class="w"> </span>        self.time = None

<span class="w"> </span>    def create(self, ticket_lifetime, ticket_age_add, ticket_nonce, ticket,
<span class="gd">-        extensions):</span>
<span class="gi">+               extensions):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialise a New Session Ticket.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.ticket_lifetime = ticket_lifetime</span>
<span class="gi">+        self.ticket_age_add = ticket_age_add</span>
<span class="gi">+        self.ticket_nonce = ticket_nonce</span>
<span class="gi">+        self.ticket = ticket</span>
<span class="gi">+        self.extensions = extensions</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1135,11 +2040,34 @@ class NewSessionTicket(HelloMessage):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(self.ticket_lifetime, 4)</span>
<span class="gi">+        w.add(self.ticket_age_add, 4)</span>
<span class="gi">+        w.addVarSeq(self.ticket_nonce, 1, 1)</span>
<span class="gi">+        w.addVarSeq(self.ticket, 1, 2)</span>
<span class="gi">+        w2 = Writer()</span>
<span class="gi">+        for ext in self.extensions:</span>
<span class="gi">+            w2.bytes += ext.write()</span>
<span class="gi">+        w.add(len(w2.bytes), 2)</span>
<span class="gi">+        w.bytes += w2.bytes</span>
<span class="gi">+</span>
<span class="gi">+        return self.postWrite(w)</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Parse the object from on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser.startLengthCheck(3)</span>
<span class="gi">+</span>
<span class="gi">+        self.ticket_lifetime = parser.get(4)</span>
<span class="gi">+        self.ticket_age_add = parser.get(4)</span>
<span class="gi">+        self.ticket_nonce = parser.getVarBytes(1)</span>
<span class="gi">+        self.ticket = parser.getVarBytes(2)</span>
<span class="gi">+        self.extensions = []</span>
<span class="gi">+        ext_parser = Parser(parser.getVarBytes(2))</span>
<span class="gi">+        while ext_parser.getRemainingLength():</span>
<span class="gi">+            self.extensions.append(TLSExtension().parse(ext_parser))</span>
<span class="gi">+</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class NewSessionTicket1_0(HelloMessage):
<span class="gu">@@ -1147,14 +2075,16 @@ class NewSessionTicket1_0(HelloMessage):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create New Session Ticket object.&quot;&quot;&quot;
<span class="gd">-        super(NewSessionTicket1_0, self).__init__(HandshakeType.</span>
<span class="gd">-            new_session_ticket)</span>
<span class="gi">+        super(NewSessionTicket1_0, self).__init__(HandshakeType</span>
<span class="gi">+                                                  .new_session_ticket)</span>
<span class="w"> </span>        self.ticket_lifetime = 0
<span class="w"> </span>        self.ticket = bytearray(0)

<span class="w"> </span>    def create(self, ticket_lifetime, ticket):
<span class="w"> </span>        &quot;&quot;&quot;Initialise a New Session Ticket.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.ticket_lifetime = ticket_lifetime</span>
<span class="gi">+        self.ticket = ticket</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1162,11 +2092,22 @@ class NewSessionTicket1_0(HelloMessage):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(self.ticket_lifetime, 4)</span>
<span class="gi">+        w.addVarSeq(self.ticket, 1, 2)</span>
<span class="gi">+        w2 = Writer()</span>
<span class="gi">+        w.bytes += w2.bytes</span>
<span class="gi">+</span>
<span class="gi">+        return self.postWrite(w)</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Parse the object from on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser.startLengthCheck(3)</span>
<span class="gi">+        self.ticket_lifetime = parser.get(4)</span>
<span class="gi">+        self.ticket = parser.getVarBytes(2)</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+</span>
<span class="gi">+        return self</span>


<span class="w"> </span>class SessionTicketPayload(object):
<span class="gu">@@ -1211,19 +2152,89 @@ class SessionTicketPayload(object):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def client_cert_chain(self):
<span class="w"> </span>        &quot;&quot;&quot;Getter for the client_cert_chain property.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._cert_chain:</span>
<span class="gi">+            return X509CertChain([i.certificate</span>
<span class="gi">+                                  for i in self._cert_chain])</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @client_cert_chain.setter
<span class="w"> </span>    def client_cert_chain(self, client_cert_chain):
<span class="w"> </span>        &quot;&quot;&quot;Setter for the cert_chain property.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._cert_chain = [CertificateEntry(CertificateType.x509)</span>
<span class="gi">+                            .create(i, []) for i in client_cert_chain.x509List]</span>

<span class="w"> </span>    def create(self, master_secret, protocol_version, cipher_suite,
<span class="gd">-        creation_time, nonce=bytearray(), client_cert_chain=None,</span>
<span class="gd">-        encrypt_then_mac=False, extended_master_secret=False, server_name=</span>
<span class="gd">-        bytearray()):</span>
<span class="gi">+               creation_time, nonce=bytearray(), client_cert_chain=None,</span>
<span class="gi">+               encrypt_then_mac=False, extended_master_secret=False,</span>
<span class="gi">+               server_name=bytearray()):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialise the object with cryptographic data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.master_secret = master_secret</span>
<span class="gi">+        self.protocol_version = protocol_version</span>
<span class="gi">+        self.cipher_suite = cipher_suite</span>
<span class="gi">+        self.creation_time = creation_time</span>
<span class="gi">+        self.nonce = nonce</span>
<span class="gi">+        if client_cert_chain:</span>
<span class="gi">+            self.version = 1</span>
<span class="gi">+            self.client_cert_chain = client_cert_chain</span>
<span class="gi">+        if encrypt_then_mac or extended_master_secret or server_name:</span>
<span class="gi">+            if self.client_cert_chain is None:</span>
<span class="gi">+                self._cert_chain = []</span>
<span class="gi">+            self.version = 2</span>
<span class="gi">+            self.encrypt_then_mac = encrypt_then_mac</span>
<span class="gi">+            self.extended_master_secret = extended_master_secret</span>
<span class="gi">+            if server_name is None:</span>
<span class="gi">+                self.server_name = bytearray()</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.server_name = server_name</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_cert_chain(self, parser):</span>
<span class="gi">+        self._cert_chain = []</span>
<span class="gi">+        while parser.getRemainingLength():</span>
<span class="gi">+            entry = CertificateEntry(CertificateType.x509)</span>
<span class="gi">+            self._cert_chain.append(entry.parse(parser))</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, parser):</span>
<span class="gi">+        self.version = parser.get(2)</span>
<span class="gi">+        if self.version &gt; 2:</span>
<span class="gi">+            raise ValueError(&quot;Unrecognised version number&quot;)</span>
<span class="gi">+        self.master_secret = parser.getVarBytes(2)</span>
<span class="gi">+        self.protocol_version = (parser.get(1), parser.get(1))</span>
<span class="gi">+        self.cipher_suite = parser.get(2)</span>
<span class="gi">+        self.nonce = parser.getVarBytes(1)</span>
<span class="gi">+        self.creation_time = parser.get(8)</span>
<span class="gi">+        if self.version &gt;= 1:</span>
<span class="gi">+            self._parse_cert_chain(Parser(parser.getVarBytes(3)))</span>
<span class="gi">+        if self.version &gt;= 2:</span>
<span class="gi">+            self.encrypt_then_mac = bool(parser.get(1))</span>
<span class="gi">+            self.extended_master_secret = bool(parser.get(1))</span>
<span class="gi">+            self.server_name = parser.getVarBytes(2)</span>
<span class="gi">+        if parser.getRemainingLength():</span>
<span class="gi">+            raise ValueError(&quot;Malformed ticket&quot;)</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def write(self):</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.addTwo(self.version)</span>
<span class="gi">+        writer.addTwo(len(self.master_secret))</span>
<span class="gi">+        writer.bytes += self.master_secret</span>
<span class="gi">+        writer.addOne(self.protocol_version[0])</span>
<span class="gi">+        writer.addOne(self.protocol_version[1])</span>
<span class="gi">+        writer.addTwo(self.cipher_suite)</span>
<span class="gi">+        writer.addOne(len(self.nonce))</span>
<span class="gi">+        writer.bytes += self.nonce</span>
<span class="gi">+        writer.add(self.creation_time, 8)</span>
<span class="gi">+        if self.version &gt;= 1:</span>
<span class="gi">+            wcert = Writer()</span>
<span class="gi">+            for entry in self._cert_chain:</span>
<span class="gi">+                wcert.bytes += entry.write()</span>
<span class="gi">+            writer.addVarSeq(wcert.bytes, 1, 3)</span>
<span class="gi">+        if self.version &gt;= 2:</span>
<span class="gi">+            writer.addOne(int(self.encrypt_then_mac))</span>
<span class="gi">+            writer.addOne(int(self.extended_master_secret))</span>
<span class="gi">+            writer.addTwo(len(self.server_name))</span>
<span class="gi">+            writer.bytes += self.server_name</span>
<span class="gi">+        return writer.bytes</span>


<span class="w"> </span>class SSL2Finished(HandshakeMsg):
<span class="gu">@@ -1235,15 +2246,21 @@ class SSL2Finished(HandshakeMsg):</span>

<span class="w"> </span>    def create(self, verify_data):
<span class="w"> </span>        &quot;&quot;&quot;Set the message payload.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.verify_data = verify_data</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise the message from on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.verify_data = parser.getFixBytes(parser.getRemainingLength())</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise the message to on the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add(self.handshakeType, 1)</span>
<span class="gi">+        writer.bytes += self.verify_data</span>
<span class="gi">+        # does not use postWrite() as it&#39;s a SSLv2 message</span>
<span class="gi">+        return writer.bytes</span>


<span class="w"> </span>class ClientFinished(SSL2Finished):
<span class="gu">@@ -1285,30 +2302,55 @@ class CertificateStatus(HandshakeMsg):</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        &quot;&quot;&quot;Create the objet, set its type.&quot;&quot;&quot;
<span class="gd">-        super(CertificateStatus, self).__init__(HandshakeType.</span>
<span class="gd">-            certificate_status)</span>
<span class="gi">+        super(CertificateStatus, self).__init__(</span>
<span class="gi">+                HandshakeType.certificate_status)</span>
<span class="w"> </span>        self.status_type = None
<span class="w"> </span>        self.ocsp = bytearray()

<span class="w"> </span>    def create(self, status_type, ocsp):
<span class="w"> </span>        &quot;&quot;&quot;Set up message payload.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.status_type = status_type</span>
<span class="gi">+        self.ocsp = ocsp</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, parser):
<span class="w"> </span>        &quot;&quot;&quot;Deserialise the message from one the wire data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser.startLengthCheck(3)</span>
<span class="gi">+        self.status_type = parser.get(1)</span>
<span class="gi">+        self.ocsp = parser.getVarBytes(3)</span>
<span class="gi">+        parser.stopLengthCheck()</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise the message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add(self.status_type, 1)</span>
<span class="gi">+        writer.add(len(self.ocsp), 3)</span>
<span class="gi">+        writer.bytes += self.ocsp</span>
<span class="gi">+        return self.postWrite(writer)</span>


<span class="w"> </span>class ApplicationData(object):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.contentType = ContentType.application_data
<span class="w"> </span>        self.bytes = bytearray(0)

<span class="gi">+    def create(self, bytes):</span>
<span class="gi">+        self.bytes = bytes</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def splitFirstByte(self):</span>
<span class="gi">+        newMsg = ApplicationData().create(self.bytes[:1])</span>
<span class="gi">+        self.bytes = self.bytes[1:]</span>
<span class="gi">+        return newMsg</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, p):</span>
<span class="gi">+        self.bytes = p.bytes</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def write(self):</span>
<span class="gi">+        return self.bytes</span>
<span class="gi">+</span>

<span class="w"> </span>class Heartbeat(object):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -1332,11 +2374,18 @@ class Heartbeat(object):</span>

<span class="w"> </span>    def create(self, message_type, payload, padding_length):
<span class="w"> </span>        &quot;&quot;&quot;Create heartbeat request or response with selected parameters&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.message_type = message_type</span>
<span class="gi">+        self.payload = payload</span>
<span class="gi">+        self.padding = getRandomBytes(padding_length)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def create_response(self):
<span class="w"> </span>        &quot;&quot;&quot;Creates heartbeat response based on request.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        heartbeat_response = Heartbeat().create(</span>
<span class="gi">+            HeartbeatMessageType.heartbeat_response,</span>
<span class="gi">+            self.payload,</span>
<span class="gi">+            16)</span>
<span class="gi">+        return heartbeat_response</span>

<span class="w"> </span>    def parse(self, p):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -1345,20 +2394,29 @@ class Heartbeat(object):</span>
<span class="w"> </span>        We are reading only message type and payload, ignoring
<span class="w"> </span>        leftover bytes (padding).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.message_type = p.get(1)</span>
<span class="gi">+        self.payload = p.getVarBytes(2)</span>
<span class="gi">+        self.padding = p.getFixBytes(p.getRemainingLength())</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise heartbeat message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w = Writer()</span>
<span class="gi">+        w.add(self.message_type, 1)</span>
<span class="gi">+        w.add(len(self.payload), 2)</span>
<span class="gi">+        w.bytes += self.payload</span>
<span class="gi">+        w.bytes += self.padding</span>
<span class="gi">+        return w.bytes</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _message_type(self):
<span class="w"> </span>        &quot;&quot;&quot;Format heartbeat message to human readable representation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return none_as_unknown(HeartbeatMessageType.toRepr(self.message_type),</span>
<span class="gi">+                               self.message_type)</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        &quot;&quot;&quot;Return human readable representation of heartbeat message.&quot;&quot;&quot;
<span class="gd">-        return &#39;heartbeat {0}&#39;.format(self._message_type)</span>
<span class="gi">+        return &quot;heartbeat {0}&quot;.format(self._message_type)</span>


<span class="w"> </span>class KeyUpdate(HandshakeMsg):
<span class="gu">@@ -1376,12 +2434,18 @@ class KeyUpdate(HandshakeMsg):</span>

<span class="w"> </span>    def create(self, message_type):
<span class="w"> </span>        &quot;&quot;&quot;Create KeyUpdate message with selected parameter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.message_type = message_type</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parse(self, p):
<span class="w"> </span>        &quot;&quot;&quot;Deserialize keyupdate message from parser.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        p.startLengthCheck(3)</span>
<span class="gi">+        self.message_type = p.get(1)</span>
<span class="gi">+        p.stopLengthCheck()</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def write(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise keyupdate message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add(self.message_type, 1)</span>
<span class="gi">+        return self.postWrite(writer)</span>
<span class="gh">diff --git a/tlslite/messagesocket.py b/tlslite/messagesocket.py</span>
<span class="gh">index 0cb49ef..7a38598 100644</span>
<span class="gd">--- a/tlslite/messagesocket.py</span>
<span class="gi">+++ b/tlslite/messagesocket.py</span>
<span class="gu">@@ -1,11 +1,18 @@</span>
<span class="gi">+# vim: set fileencoding=utf8</span>
<span class="gi">+#</span>
<span class="gi">+# Copyright © 2015, Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Wrapper of TLS RecordLayer providing message-level abstraction&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .recordlayer import RecordLayer
<span class="w"> </span>from .constants import ContentType
<span class="w"> </span>from .messages import RecordHeader3, Message
<span class="w"> </span>from .utils.codec import Parser

<span class="gd">-</span>
<span class="w"> </span>class MessageSocket(RecordLayer):
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;TLS Record Layer socket that provides Message level abstraction

<span class="w"> </span>    Because the record layer has a hard size limit on sent messages, they need
<span class="gu">@@ -43,13 +50,16 @@ class MessageSocket(RecordLayer):</span>
<span class="w"> </span>        :param defragmenter: defragmenter to apply on the records read
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        super(MessageSocket, self).__init__(sock)
<span class="gi">+</span>
<span class="w"> </span>        self.defragmenter = defragmenter
<span class="w"> </span>        self.unfragmentedDataTypes = (ContentType.application_data,
<span class="gd">-            ContentType.heartbeat)</span>
<span class="gd">-        self._lastRecordVersion = 0, 0</span>
<span class="gi">+                                      ContentType.heartbeat)</span>
<span class="gi">+        self._lastRecordVersion = (0, 0)</span>
<span class="gi">+</span>
<span class="w"> </span>        self._sendBuffer = bytearray(0)
<span class="w"> </span>        self._sendBufferType = None
<span class="gd">-        self.recordSize = 2 ** 14</span>
<span class="gi">+</span>
<span class="gi">+        self.recordSize = 2**14</span>

<span class="w"> </span>    def recvMessage(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -61,11 +71,39 @@ class MessageSocket(RecordLayer):</span>

<span class="w"> </span>        :rtype: generator
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while True:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                ret = self.defragmenter.get_message()</span>
<span class="gi">+                if ret is None:</span>
<span class="gi">+                    break</span>
<span class="gi">+                header = RecordHeader3().create(self._lastRecordVersion,</span>
<span class="gi">+                                                ret[0],</span>
<span class="gi">+                                                0)</span>
<span class="gi">+                yield header, Parser(ret[1])</span>
<span class="gi">+</span>
<span class="gi">+            for ret in self.recvRecord():</span>
<span class="gi">+                if ret in (0, 1):</span>
<span class="gi">+                    yield ret</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            header, parser = ret</span>
<span class="gi">+            if header.type in self.unfragmentedDataTypes:</span>
<span class="gi">+                yield ret</span>
<span class="gi">+            # TODO probably needs a bit better handling...</span>
<span class="gi">+            if header.ssl2:</span>
<span class="gi">+                yield ret</span>
<span class="gi">+</span>
<span class="gi">+            self.defragmenter.add_data(header.type, parser.bytes)</span>
<span class="gi">+            self._lastRecordVersion = header.version</span>

<span class="w"> </span>    def recvMessageBlocking(self):
<span class="w"> </span>        &quot;&quot;&quot;Blocking variant of :py:meth:`recvMessage`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for res in self.recvMessage():</span>
<span class="gi">+            if res in (0, 1):</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                return res</span>

<span class="w"> </span>    def flush(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -76,11 +114,20 @@ class MessageSocket(RecordLayer):</span>

<span class="w"> </span>        :rtype: generator
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while len(self._sendBuffer) &gt; 0:</span>
<span class="gi">+            recordPayload = self._sendBuffer[:self.recordSize]</span>
<span class="gi">+            self._sendBuffer = self._sendBuffer[self.recordSize:]</span>
<span class="gi">+            msg = Message(self._sendBufferType, recordPayload)</span>
<span class="gi">+            for res in self.sendRecord(msg):</span>
<span class="gi">+                yield res</span>
<span class="gi">+</span>
<span class="gi">+        assert len(self._sendBuffer) == 0</span>
<span class="gi">+        self._sendBufferType = None</span>

<span class="w"> </span>    def flushBlocking(self):
<span class="w"> </span>        &quot;&quot;&quot;Blocking variant of :py:meth:`flush`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for _ in self.flush():</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    def queueMessage(self, msg):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -94,11 +141,24 @@ class MessageSocket(RecordLayer):</span>

<span class="w"> </span>        :rtype: generator
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._sendBufferType is None:</span>
<span class="gi">+            self._sendBufferType = msg.contentType</span>
<span class="gi">+</span>
<span class="gi">+        if msg.contentType == self._sendBufferType:</span>
<span class="gi">+            self._sendBuffer += msg.write()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for res in self.flush():</span>
<span class="gi">+            yield res</span>
<span class="gi">+</span>
<span class="gi">+        assert self._sendBufferType is None</span>
<span class="gi">+        self._sendBufferType = msg.contentType</span>
<span class="gi">+        self._sendBuffer += msg.write()</span>

<span class="w"> </span>    def queueMessageBlocking(self, msg):
<span class="w"> </span>        &quot;&quot;&quot;Blocking variant of :py:meth:`queueMessage`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for _ in self.queueMessage(msg):</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    def sendMessage(self, msg):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -115,8 +175,13 @@ class MessageSocket(RecordLayer):</span>

<span class="w"> </span>        :rtype: generator
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for res in self.queueMessage(msg):</span>
<span class="gi">+            yield res</span>
<span class="gi">+</span>
<span class="gi">+        for res in self.flush():</span>
<span class="gi">+            yield res</span>

<span class="w"> </span>    def sendMessageBlocking(self, msg):
<span class="w"> </span>        &quot;&quot;&quot;Blocking variant of :py:meth:`sendMessage`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for _ in self.sendMessage(msg):</span>
<span class="gi">+            pass</span>
<span class="gh">diff --git a/tlslite/ocsp.py b/tlslite/ocsp.py</span>
<span class="gh">index 0745404..78955cf 100644</span>
<span class="gd">--- a/tlslite/ocsp.py</span>
<span class="gi">+++ b/tlslite/ocsp.py</span>
<span class="gu">@@ -1,17 +1,17 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Class for handling primary OCSP responses&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .utils.asn1parser import ASN1Parser
<span class="w"> </span>from .utils.cryptomath import bytesToNumber, numBytes, secureHash
<span class="w"> </span>from .x509 import X509
<span class="w"> </span>from .signed import SignedObject
<span class="w"> </span>from .errors import TLSIllegalParameterException

<span class="gd">-</span>
<span class="w"> </span>class OCSPRespStatus(object):
<span class="w"> </span>    &quot;&quot;&quot; OCSP response status codes (RFC 2560) &quot;&quot;&quot;
<span class="w"> </span>    successful = 0
<span class="w"> </span>    malformedRequest = 1
<span class="w"> </span>    internalError = 2
<span class="gd">-    tryLater = 3</span>
<span class="gi">+    tryLater = 3    # 4 is not used to match RFC2560 specification</span>
<span class="w"> </span>    sigRequired = 5
<span class="w"> </span>    unauthorized = 6

<span class="gu">@@ -23,7 +23,6 @@ class CertStatus(object):</span>

<span class="w"> </span>class SingleResponse(object):
<span class="w"> </span>    &quot;&quot;&quot; This class represents SingleResponse ASN1 type (defined in RFC2560) &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, value):
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self.cert_hash_alg = None
<span class="gu">@@ -34,16 +33,63 @@ class SingleResponse(object):</span>
<span class="w"> </span>        self.this_update = None
<span class="w"> </span>        self.next_update = None
<span class="w"> </span>        self.parse(value)
<span class="gd">-    _hash_algs_OIDs = {tuple([42, 134, 72, 134, 247, 13, 2, 5]): &#39;md5&#39;,</span>
<span class="gd">-        tuple([43, 14, 3, 2, 26]): &#39;sha1&#39;, tuple([96, 134, 72, 1, 101, 3, 4,</span>
<span class="gd">-        2, 4]): &#39;sha224&#39;, tuple([96, 134, 72, 1, 101, 3, 4, 2, 1]):</span>
<span class="gd">-        &#39;sha256&#39;, tuple([96, 134, 72, 1, 101, 3, 4, 2, 2]): &#39;sha384&#39;, tuple</span>
<span class="gd">-        ([96, 134, 72, 1, 101, 3, 4, 2, 3]): &#39;sha512&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    _hash_algs_OIDs = {</span>
<span class="gi">+        tuple([0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x2, 0x5]): &#39;md5&#39;,</span>
<span class="gi">+        tuple([0x2b, 0xe, 0x3, 0x2, 0x1a]): &#39;sha1&#39;,</span>
<span class="gi">+        tuple([0x60, 0x86, 0x48, 0x1, 0x65, 0x3, 0x4, 0x2, 0x4]): &#39;sha224&#39;,</span>
<span class="gi">+        tuple([0x60, 0x86, 0x48, 0x1, 0x65, 0x3, 0x4, 0x2, 0x1]): &#39;sha256&#39;,</span>
<span class="gi">+        tuple([0x60, 0x86, 0x48, 0x1, 0x65, 0x3, 0x4, 0x2, 0x2]): &#39;sha384&#39;,</span>
<span class="gi">+        tuple([0x60, 0x86, 0x48, 0x1, 0x65, 0x3, 0x4, 0x2, 0x3]): &#39;sha512&#39;</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, value):</span>
<span class="gi">+        cert_id = value.getChild(0)</span>
<span class="gi">+        self.cert_hash_alg = cert_id.getChild(0).getChild(0).value</span>
<span class="gi">+        self.cert_issuer_name_hash = cert_id.getChild(1).value</span>
<span class="gi">+        self.cert_issuer_key_hash = cert_id.getChild(2).value</span>
<span class="gi">+        self.cert_serial_num = bytesToNumber(cert_id.getChild(3).value)</span>
<span class="gi">+        self.cert_status = value.getChild(1).value</span>
<span class="gi">+        self.this_update = value.getChild(2).value</span>
<span class="gi">+        # next_update is optional</span>
<span class="gi">+        try:</span>
<span class="gi">+            fld = value.getChild(3)</span>
<span class="gi">+            if fld.type.tag_id == 0:</span>
<span class="gi">+                self.next_update = fld.value</span>
<span class="gi">+        except SyntaxError:</span>
<span class="gi">+            self.next_update = None</span>
<span class="gi">+</span>
<span class="gi">+    def verify_cert_match(self, server_cert, issuer_cert):</span>
<span class="gi">+        # extact subject public key</span>
<span class="gi">+        issuer_key = issuer_cert.subject_public_key</span>
<span class="gi">+</span>
<span class="gi">+        # extract issuer DN</span>
<span class="gi">+        issuer_name = issuer_cert.subject</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            alg = self._hash_algs_OIDs[tuple(self.cert_hash_alg)]</span>
<span class="gi">+        except KeyError as e:</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Unknown hash algorithm: {0}&quot;.format(</span>
<span class="gi">+                            list(self.cert_hash_alg)))</span>
<span class="gi">+</span>
<span class="gi">+        # hash issuer key</span>
<span class="gi">+        hashed_key = secureHash(issuer_key, alg)</span>
<span class="gi">+        if hashed_key != self.cert_issuer_key_hash:</span>
<span class="gi">+            raise ValueError(&quot;Could not verify certificate public key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # hash issuer name</span>
<span class="gi">+        hashed_name = secureHash(issuer_name, alg)</span>
<span class="gi">+        if hashed_name != self.cert_issuer_name_hash:</span>
<span class="gi">+            raise ValueError(&quot;Could not verify certificate DN&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # serial number</span>
<span class="gi">+        if server_cert.serial_number != self.cert_serial_num:</span>
<span class="gi">+            raise ValueError(&quot;Could not verify certificate serial number&quot;)</span>
<span class="gi">+        return True</span>


<span class="w"> </span>class OCSPResponse(SignedObject):
<span class="w"> </span>    &quot;&quot;&quot; This class represents an OCSP response. &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, value):
<span class="w"> </span>        super(OCSPResponse, self).__init__()
<span class="w"> </span>        self.bytes = None
<span class="gu">@@ -63,7 +109,34 @@ class OCSPResponse(SignedObject):</span>
<span class="w"> </span>        :type value: stream of bytes
<span class="w"> </span>        :param value: An DER-encoded OCSP response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.bytes = bytearray(value)</span>
<span class="gi">+        parser = ASN1Parser(self.bytes)</span>
<span class="gi">+        resp_status = parser.getChild(0)</span>
<span class="gi">+        self.resp_status = resp_status.value[0]</span>
<span class="gi">+        # if the response status is not successsful, abort parsing other fields</span>
<span class="gi">+        if self.resp_status != OCSPRespStatus.successful:</span>
<span class="gi">+            return self</span>
<span class="gi">+        resp_bytes = parser.getChild(1).getChild(0)</span>
<span class="gi">+        self.resp_type = resp_bytes.getChild(0).value</span>
<span class="gi">+        response = resp_bytes.getChild(1)</span>
<span class="gi">+        # check if response is id-pkix-ocsp-basic</span>
<span class="gi">+        if list(self.resp_type) != [43, 6, 1, 5, 5, 7, 48, 1, 1]:</span>
<span class="gi">+            raise SyntaxError()</span>
<span class="gi">+        basic_resp = response.getChild(0)</span>
<span class="gi">+        # parsing tbsResponseData fields</span>
<span class="gi">+        self._tbsdataparse(basic_resp.getChild(0))</span>
<span class="gi">+        self.tbs_data = basic_resp.getChildBytes(0)</span>
<span class="gi">+        self.signature_alg = basic_resp.getChild(1).getChild(0).value</span>
<span class="gi">+        self.signature = basic_resp.getChild(2).value</span>
<span class="gi">+        # test if certs field is present</span>
<span class="gi">+        if basic_resp.getChildCount() &gt; 3:</span>
<span class="gi">+            certs = basic_resp.getChild(3)</span>
<span class="gi">+            cnt = certs.getChildCount()</span>
<span class="gi">+            for i in range(cnt):</span>
<span class="gi">+                certificate = X509()</span>
<span class="gi">+                certificate.parseBinary(certs.getChild(i).value)</span>
<span class="gi">+                self.certs.append(certificate)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def _tbsdataparse(self, value):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -72,4 +145,20 @@ class OCSPResponse(SignedObject):</span>
<span class="w"> </span>        :type value: stream of bytes
<span class="w"> </span>        :param value: TBS data
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # test if version is ommited</span>
<span class="gi">+        field = value.getChild(0)</span>
<span class="gi">+        cnt = 0</span>
<span class="gi">+        if field.type.tag_id == 0:</span>
<span class="gi">+            # version is not omitted</span>
<span class="gi">+            cnt += 1</span>
<span class="gi">+            self.version = field.value</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.version = 1</span>
<span class="gi">+        self.resp_id = value.getChild(cnt).value</span>
<span class="gi">+        self.produced_at = value.getChild(cnt+1).value</span>
<span class="gi">+        responses = value.getChild(cnt+2)</span>
<span class="gi">+        resp_cnt = responses.getChildCount()</span>
<span class="gi">+        for i in range(resp_cnt):</span>
<span class="gi">+            resp = responses.getChild(i)</span>
<span class="gi">+            parsed_resp = SingleResponse(resp)</span>
<span class="gi">+            self.responses.append(parsed_resp)</span>
<span class="gh">diff --git a/tlslite/recordlayer.py b/tlslite/recordlayer.py</span>
<span class="gh">index 72658db..5b21a1e 100644</span>
<span class="gd">--- a/tlslite/recordlayer.py</span>
<span class="gi">+++ b/tlslite/recordlayer.py</span>
<span class="gu">@@ -1,27 +1,37 @@</span>
<span class="gi">+# Copyright (c) 2014, Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Implementation of the TLS Record Layer protocol&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>import errno
<span class="w"> </span>import copy
<span class="w"> </span>try:
<span class="gi">+    # in python 3 the native zip() returns iterator</span>
<span class="w"> </span>    from itertools import izip
<span class="w"> </span>except ImportError:
<span class="w"> </span>    izip = zip
<span class="w"> </span>try:
<span class="gi">+    # in python 3 the native range() returns an object/iterator</span>
<span class="w"> </span>    xrange
<span class="w"> </span>except NameError:
<span class="w"> </span>    xrange = range
<span class="gi">+</span>
<span class="w"> </span>from .utils import tlshashlib as hashlib
<span class="w"> </span>from .constants import ContentType, CipherSuite
<span class="w"> </span>from .messages import RecordHeader3, RecordHeader2, Message
<span class="gd">-from .utils.cipherfactory import createAESCCM, createAESCCM_8, createAESGCM, createAES, createRC4, createTripleDES, createCHACHA20</span>
<span class="gi">+from .utils.cipherfactory import createAESCCM, createAESCCM_8, createAESGCM,\</span>
<span class="gi">+        createAES, createRC4, createTripleDES, createCHACHA20</span>
<span class="w"> </span>from .utils.codec import Parser, Writer
<span class="w"> </span>from .utils.compat import compatHMAC
<span class="w"> </span>from .utils.cryptomath import getRandomBytes, MD5, HKDF_expand_label
<span class="w"> </span>from .utils.constanttime import ct_compare_digest, ct_check_cbc_mac_and_pad
<span class="gd">-from .errors import TLSRecordOverflow, TLSIllegalParameterException, TLSAbruptCloseError, TLSDecryptionFailed, TLSBadRecordMAC, TLSUnexpectedMessage</span>
<span class="gi">+from .errors import TLSRecordOverflow, TLSIllegalParameterException,\</span>
<span class="gi">+        TLSAbruptCloseError, TLSDecryptionFailed, TLSBadRecordMAC, \</span>
<span class="gi">+        TLSUnexpectedMessage</span>
<span class="w"> </span>from .mathtls import createMAC_SSL, createHMAC, calc_key

<span class="gd">-</span>
<span class="w"> </span>class RecordSocket(object):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Socket wrapper for reading and writing TLS Records.
<span class="gu">@@ -41,9 +51,9 @@ class RecordSocket(object):</span>
<span class="w"> </span>        :type sock: socket.socket
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.sock = sock
<span class="gd">-        self.version = 0, 0</span>
<span class="gi">+        self.version = (0, 0)</span>
<span class="w"> </span>        self.tls13record = False
<span class="gd">-        self.recv_record_limit = 2 ** 14</span>
<span class="gi">+        self.recv_record_limit = 2**14</span>

<span class="w"> </span>    def _sockSendAll(self, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -53,7 +63,19 @@ class RecordSocket(object):</span>
<span class="w"> </span>        :param data: data to send
<span class="w"> </span>        :raises socket.error: when write to socket failed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            try:</span>
<span class="gi">+                bytesSent = self.sock.send(data)</span>
<span class="gi">+            except socket.error as why:</span>
<span class="gi">+                if why.args[0] in (errno.EWOULDBLOCK, errno.EAGAIN):</span>
<span class="gi">+                    yield 1</span>
<span class="gi">+                    continue</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+            if bytesSent == len(data):</span>
<span class="gi">+                return</span>
<span class="gi">+            data = data[bytesSent:]</span>
<span class="gi">+            yield 1</span>

<span class="w"> </span>    def send(self, msg, padding=0):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -65,7 +87,20 @@ class RecordSocket(object):</span>
<span class="w"> </span>        :param padding: amount of padding to specify for SSLv2
<span class="w"> </span>        :raises socket.error: when write to socket failed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = msg.write()</span>
<span class="gi">+</span>
<span class="gi">+        if self.version in ((2, 0), (0, 2)):</span>
<span class="gi">+            header = RecordHeader2().create(len(data),</span>
<span class="gi">+                                            padding)</span>
<span class="gi">+        else:</span>
<span class="gi">+            header = RecordHeader3().create(self.version,</span>
<span class="gi">+                                            msg.contentType,</span>
<span class="gi">+                                            len(data))</span>
<span class="gi">+</span>
<span class="gi">+        data = header.write() + data</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._sockSendAll(data):</span>
<span class="gi">+            yield result</span>

<span class="w"> </span>    def _sockRecvAll(self, length):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -76,11 +111,84 @@ class RecordSocket(object):</span>
<span class="w"> </span>            blocking and would block and bytearray in case the read finished
<span class="w"> </span>        :raises TLSAbruptCloseError: when the socket closed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        buf = bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        if length == 0:</span>
<span class="gi">+            yield buf</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                socketBytes = self.sock.recv(length - len(buf))</span>
<span class="gi">+            except socket.error as why:</span>
<span class="gi">+                if why.args[0] in (errno.EWOULDBLOCK, errno.EAGAIN):</span>
<span class="gi">+                    yield 0</span>
<span class="gi">+                    continue</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise</span>
<span class="gi">+</span>
<span class="gi">+            #if the connection closed, raise socket error</span>
<span class="gi">+            if len(socketBytes) == 0:</span>
<span class="gi">+                raise TLSAbruptCloseError()</span>
<span class="gi">+</span>
<span class="gi">+            buf += bytearray(socketBytes)</span>
<span class="gi">+            if len(buf) == length:</span>
<span class="gi">+                yield buf</span>

<span class="w"> </span>    def _recvHeader(self):
<span class="w"> </span>        &quot;&quot;&quot;Read a single record header from socket&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        #Read the next record header</span>
<span class="gi">+        buf = bytearray(0)</span>
<span class="gi">+        ssl2 = False</span>
<span class="gi">+</span>
<span class="gi">+        result = None</span>
<span class="gi">+        for result in self._sockRecvAll(1):</span>
<span class="gi">+            if result in (0, 1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+        assert result is not None</span>
<span class="gi">+</span>
<span class="gi">+        buf += result</span>
<span class="gi">+</span>
<span class="gi">+        if buf[0] in ContentType.all:</span>
<span class="gi">+            ssl2 = False</span>
<span class="gi">+            # SSLv3 record layer header is 5 bytes long, we already read 1</span>
<span class="gi">+            result = None</span>
<span class="gi">+            for result in self._sockRecvAll(4):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            assert result is not None</span>
<span class="gi">+            buf += result</span>
<span class="gi">+        else:</span>
<span class="gi">+            # if header has no pading the header is 2 bytes long, 3 otherwise</span>
<span class="gi">+            # at the same time we already read 1 byte</span>
<span class="gi">+            ssl2 = True</span>
<span class="gi">+            if buf[0] &amp; 0x80:</span>
<span class="gi">+                readLen = 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                readLen = 2</span>
<span class="gi">+            result = None</span>
<span class="gi">+            for result in self._sockRecvAll(readLen):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            assert result is not None</span>
<span class="gi">+            buf += result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+        #Parse the record header</span>
<span class="gi">+        if ssl2:</span>
<span class="gi">+            record = RecordHeader2().parse(Parser(buf))</span>
<span class="gi">+            # padding can&#39;t be longer than overall length and if it is present</span>
<span class="gi">+            # the overall size must be a multiple of cipher block size</span>
<span class="gi">+            if ((record.padding &gt; record.length) or</span>
<span class="gi">+                    (record.padding and record.length % 8)):</span>
<span class="gi">+                raise TLSIllegalParameterException(\</span>
<span class="gi">+                        &quot;Malformed record layer header&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            record = RecordHeader3().parse(Parser(buf))</span>
<span class="gi">+</span>
<span class="gi">+        yield record</span>

<span class="w"> </span>    def recv(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -98,10 +206,38 @@ class RecordSocket(object):</span>
<span class="w"> </span>        :raises TLSIllegalParameterException: When the record header was
<span class="w"> </span>            malformed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        record = None</span>
<span class="gi">+        for record in self._recvHeader():</span>
<span class="gi">+            if record in (0, 1):</span>
<span class="gi">+                yield record</span>
<span class="gi">+            else: break</span>
<span class="gi">+        assert record is not None</span>
<span class="gi">+</span>
<span class="gi">+        #Check the record header fields</span>
<span class="gi">+        # 18432 = 2**14 (default record size limit) + 1024 (maximum compression</span>
<span class="gi">+        # overhead) + 1024 (maximum encryption overhead)</span>
<span class="gi">+        if record.length &gt; self.recv_record_limit + 1024 + 1024:</span>
<span class="gi">+            raise TLSRecordOverflow()</span>
<span class="gi">+        if self.tls13record and record.length &gt; self.recv_record_limit + 256:</span>
<span class="gi">+            raise TLSRecordOverflow()</span>
<span class="gi">+</span>
<span class="gi">+        #Read the record contents</span>
<span class="gi">+        buf = bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        result = None</span>
<span class="gi">+        for result in self._sockRecvAll(record.length):</span>
<span class="gi">+            if result in (0, 1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+        assert result is not None</span>
<span class="gi">+</span>
<span class="gi">+        buf += result</span>
<span class="gi">+</span>
<span class="gi">+        yield (record, buf)</span>


<span class="w"> </span>class ConnectionState(object):
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;Preserve the connection state for reading and writing data to records&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self):
<span class="gu">@@ -114,7 +250,10 @@ class ConnectionState(object):</span>

<span class="w"> </span>    def getSeqNumBytes(self):
<span class="w"> </span>        &quot;&quot;&quot;Return encoded sequence number and increment it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = Writer()</span>
<span class="gi">+        writer.add(self.seqnum, 8)</span>
<span class="gi">+        self.seqnum += 1</span>
<span class="gi">+        return writer.bytes</span>

<span class="w"> </span>    def __copy__(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a copy of the object.&quot;&quot;&quot;
<span class="gu">@@ -128,6 +267,7 @@ class ConnectionState(object):</span>


<span class="w"> </span>class RecordLayer(object):
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Implementation of TLS record layer protocol

<span class="gu">@@ -155,25 +295,34 @@ class RecordLayer(object):</span>
<span class="w"> </span>    def __init__(self, sock):
<span class="w"> </span>        self.sock = sock
<span class="w"> </span>        self._recordSocket = RecordSocket(sock)
<span class="gd">-        self._version = 0, 0</span>
<span class="gi">+        self._version = (0, 0)</span>
<span class="w"> </span>        self._tls13record = False
<span class="gi">+</span>
<span class="w"> </span>        self.client = True
<span class="gi">+</span>
<span class="w"> </span>        self._writeState = ConnectionState()
<span class="w"> </span>        self._readState = ConnectionState()
<span class="w"> </span>        self._pendingWriteState = ConnectionState()
<span class="w"> </span>        self._pendingReadState = ConnectionState()
<span class="w"> </span>        self.fixedIVBlock = None
<span class="gi">+</span>
<span class="w"> </span>        self.handshake_finished = False
<span class="gi">+</span>
<span class="w"> </span>        self.padding_cb = None
<span class="gi">+</span>
<span class="w"> </span>        self._early_data_ok = False
<span class="w"> </span>        self.max_early_data = 0
<span class="w"> </span>        self._early_data_processed = 0
<span class="gd">-        self.send_record_limit = 2 ** 14</span>
<span class="gi">+        self.send_record_limit = 2**14</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def recv_record_limit(self):
<span class="w"> </span>        &quot;&quot;&quot;Maximum record size that is permitted for receiving.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._recordSocket.recv_record_limit</span>
<span class="gi">+</span>
<span class="gi">+    @recv_record_limit.setter</span>
<span class="gi">+    def recv_record_limit(self, value):</span>
<span class="gi">+        self._recordSocket.recv_record_limit = value</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def early_data_ok(self):
<span class="gu">@@ -188,7 +337,12 @@ class RecordLayer(object):</span>
<span class="w"> </span>        Use max_early_data to set the limit of the total size of records
<span class="w"> </span>        that will be processed like this.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._early_data_ok</span>
<span class="gi">+</span>
<span class="gi">+    @early_data_ok.setter</span>
<span class="gi">+    def early_data_ok(self, val):</span>
<span class="gi">+        self._early_data_processed = 0</span>
<span class="gi">+        self._early_data_ok = val</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def encryptThenMAC(self):
<span class="gu">@@ -199,47 +353,60 @@ class RecordLayer(object):</span>
<span class="w"> </span>        integrity for next parameter change (after CCS),
<span class="w"> </span>        gets current state
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._writeState.encryptThenMAC</span>
<span class="gi">+</span>
<span class="gi">+    @encryptThenMAC.setter</span>
<span class="gi">+    def encryptThenMAC(self, value):</span>
<span class="gi">+        self._pendingWriteState.encryptThenMAC = value</span>
<span class="gi">+        self._pendingReadState.encryptThenMAC = value</span>

<span class="w"> </span>    def _get_pending_state_etm(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the state of encrypt then MAC for the connection after
<span class="w"> </span>        CCS will be exchanged
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._pendingWriteState.encryptThenMAC</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def blockSize(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the size of block used by current symmetric cipher (R/O)&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._writeState.encContext.block_size</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def tls13record(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the value of the tls13record state.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._tls13record</span>

<span class="w"> </span>    @tls13record.setter
<span class="w"> </span>    def tls13record(self, val):
<span class="w"> </span>        &quot;&quot;&quot;Change the record layer to TLS1.3-like operation, if applicable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._tls13record = val</span>
<span class="gi">+        self._recordSocket.tls13record = val</span>
<span class="gi">+        self._handle_tls13_record()</span>

<span class="w"> </span>    def _is_tls13_plus(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if we&#39;re doing real TLS 1.3.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._version &gt; (3, 3) and self._tls13record</span>

<span class="w"> </span>    def _handle_tls13_record(self):
<span class="w"> </span>        &quot;&quot;&quot;Make sure that the version and tls13record setting is consistent.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._is_tls13_plus():</span>
<span class="gi">+            # in TLS 1.3 all records need to be sent with the generic version</span>
<span class="gi">+            # which is the same as TLS 1.2</span>
<span class="gi">+            self._recordSocket.version = (3, 3)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._recordSocket.version = self._version</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def version(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the TLS version used by record layer&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._version</span>

<span class="w"> </span>    @version.setter
<span class="w"> </span>    def version(self, val):
<span class="w"> </span>        &quot;&quot;&quot;Set the TLS version used by record layer&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._version = val</span>
<span class="gi">+        self._handle_tls13_record()</span>

<span class="w"> </span>    def getCipherName(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -248,7 +415,9 @@ class RecordLayer(object):</span>
<span class="w"> </span>        :rtype: str
<span class="w"> </span>        :returns: The name of the cipher, like &#39;aes128&#39;, &#39;rc4&#39;, etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._writeState.encContext is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self._writeState.encContext.name</span>

<span class="w"> </span>    def getCipherImplementation(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -259,43 +428,166 @@ class RecordLayer(object):</span>
<span class="w"> </span>        :rtype: str
<span class="w"> </span>        :returns: Name of cipher implementation used, None if not initialised
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._writeState.encContext is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self._writeState.encContext.implementation</span>

<span class="w"> </span>    def shutdown(self):
<span class="w"> </span>        &quot;&quot;&quot;Clear read and write states&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._writeState = ConnectionState()</span>
<span class="gi">+        self._readState = ConnectionState()</span>
<span class="gi">+        self._pendingWriteState = ConnectionState()</span>
<span class="gi">+        self._pendingReadState = ConnectionState()</span>

<span class="w"> </span>    def isCBCMode(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns true if cipher uses CBC mode&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._writeState and self._writeState.encContext and \</span>
<span class="gi">+                self._writeState.encContext.isBlockCipher:</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False</span>
<span class="gi">+    #</span>
<span class="gi">+    # sending messages</span>
<span class="gi">+    #</span>

<span class="w"> </span>    def addPadding(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Add padding to data so that it is multiple of block size&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        currentLength = len(data)</span>
<span class="gi">+        blockLength = self.blockSize</span>
<span class="gi">+        paddingLength = blockLength - 1 - (currentLength % blockLength)</span>
<span class="gi">+</span>
<span class="gi">+        paddingBytes = bytearray([paddingLength] * (paddingLength+1))</span>
<span class="gi">+        data += paddingBytes</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    def calculateMAC(self, mac, seqnumBytes, contentType, data):
<span class="w"> </span>        &quot;&quot;&quot;Calculate the SSL/TLS version of a MAC&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mac.update(compatHMAC(seqnumBytes))</span>
<span class="gi">+        mac.update(compatHMAC(bytearray([contentType])))</span>
<span class="gi">+        assert self.version in ((3, 0), (3, 1), (3, 2), (3, 3))</span>
<span class="gi">+        if self.version != (3, 0):</span>
<span class="gi">+            mac.update(compatHMAC(bytearray([self.version[0]])))</span>
<span class="gi">+            mac.update(compatHMAC(bytearray([self.version[1]])))</span>
<span class="gi">+        mac.update(compatHMAC(bytearray([len(data)//256])))</span>
<span class="gi">+        mac.update(compatHMAC(bytearray([len(data)%256])))</span>
<span class="gi">+        mac.update(compatHMAC(data))</span>
<span class="gi">+        return bytearray(mac.digest())</span>

<span class="w"> </span>    def _macThenEncrypt(self, data, contentType):
<span class="w"> </span>        &quot;&quot;&quot;MAC, pad then encrypt data&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._writeState.macContext:</span>
<span class="gi">+            seqnumBytes = self._writeState.getSeqNumBytes()</span>
<span class="gi">+            mac = self._writeState.macContext.copy()</span>
<span class="gi">+            macBytes = self.calculateMAC(mac, seqnumBytes, contentType, data)</span>
<span class="gi">+            data += macBytes</span>
<span class="gi">+</span>
<span class="gi">+        #Encrypt for Block or Stream Cipher</span>
<span class="gi">+        if self._writeState.encContext:</span>
<span class="gi">+            #Add padding (for Block Cipher):</span>
<span class="gi">+            if self._writeState.encContext.isBlockCipher:</span>
<span class="gi">+</span>
<span class="gi">+                #Add TLS 1.1 fixed block</span>
<span class="gi">+                if self.version &gt;= (3, 2):</span>
<span class="gi">+                    data = self.fixedIVBlock + data</span>
<span class="gi">+</span>
<span class="gi">+                data = self.addPadding(data)</span>
<span class="gi">+</span>
<span class="gi">+            #Encrypt</span>
<span class="gi">+            data = self._writeState.encContext.encrypt(data)</span>
<span class="gi">+</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    def _encryptThenMAC(self, buf, contentType):
<span class="w"> </span>        &quot;&quot;&quot;Pad, encrypt and then MAC the data&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._writeState.encContext:</span>
<span class="gi">+            # add IV for TLS1.1+</span>
<span class="gi">+            if self.version &gt;= (3, 2):</span>
<span class="gi">+                buf = self.fixedIVBlock + buf</span>
<span class="gi">+</span>
<span class="gi">+            buf = self.addPadding(buf)</span>
<span class="gi">+</span>
<span class="gi">+            buf = self._writeState.encContext.encrypt(buf)</span>
<span class="gi">+</span>
<span class="gi">+        # add MAC</span>
<span class="gi">+        if self._writeState.macContext:</span>
<span class="gi">+            seqnumBytes = self._writeState.getSeqNumBytes()</span>
<span class="gi">+            mac = self._writeState.macContext.copy()</span>
<span class="gi">+</span>
<span class="gi">+            # append MAC</span>
<span class="gi">+            macBytes = self.calculateMAC(mac, seqnumBytes, contentType, buf)</span>
<span class="gi">+            buf += macBytes</span>
<span class="gi">+</span>
<span class="gi">+        return buf</span>

<span class="w"> </span>    def _getNonce(self, state, seqnum):
<span class="w"> </span>        &quot;&quot;&quot;Calculate a nonce for a given enc/dec context&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # ChaCha is using the draft-TLS1.3-like nonce derivation</span>
<span class="gi">+        if (state.encContext.name == &quot;chacha20-poly1305&quot; and</span>
<span class="gi">+                len(state.fixedNonce) == 12) or self._is_tls13_plus():</span>
<span class="gi">+            # 4 byte nonce is used by the draft cipher</span>
<span class="gi">+            pad = bytearray(len(state.fixedNonce) - len(seqnum))</span>
<span class="gi">+            nonce = bytearray(i ^ j for i, j in zip(pad + seqnum,</span>
<span class="gi">+                                                    state.fixedNonce))</span>
<span class="gi">+        else:</span>
<span class="gi">+            nonce = state.fixedNonce + seqnum</span>
<span class="gi">+        return nonce</span>
<span class="gi">+</span>

<span class="w"> </span>    def _encryptThenSeal(self, buf, contentType):
<span class="w"> </span>        &quot;&quot;&quot;Encrypt with AEAD cipher&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        #Assemble the authenticated data.</span>
<span class="gi">+        seqNumBytes = self._writeState.getSeqNumBytes()</span>
<span class="gi">+        if not self._is_tls13_plus():</span>
<span class="gi">+            authData = seqNumBytes + bytearray([contentType,</span>
<span class="gi">+                                                self.version[0],</span>
<span class="gi">+                                                self.version[1],</span>
<span class="gi">+                                                len(buf)//256,</span>
<span class="gi">+                                                len(buf)%256])</span>
<span class="gi">+        else:  # TLS 1.3</span>
<span class="gi">+            out_len = len(buf) + self._writeState.encContext.tagLength</span>
<span class="gi">+            # this is just recreated Record Layer header</span>
<span class="gi">+            authData = bytearray([contentType,</span>
<span class="gi">+                                  self._recordSocket.version[0],</span>
<span class="gi">+                                  self._recordSocket.version[1],</span>
<span class="gi">+                                  out_len // 256, out_len % 256])</span>
<span class="gi">+</span>
<span class="gi">+        nonce = self._getNonce(self._writeState, seqNumBytes)</span>
<span class="gi">+</span>
<span class="gi">+        assert len(nonce) == self._writeState.encContext.nonceLength</span>
<span class="gi">+</span>
<span class="gi">+        buf = self._writeState.encContext.seal(nonce, buf, authData)</span>
<span class="gi">+</span>
<span class="gi">+        #AES-GCM, has an explicit variable nonce.</span>
<span class="gi">+        if &quot;aes&quot; in self._writeState.encContext.name and \</span>
<span class="gi">+                not self._is_tls13_plus():</span>
<span class="gi">+            buf = seqNumBytes + buf</span>
<span class="gi">+</span>
<span class="gi">+        return buf</span>

<span class="w"> </span>    def _ssl2Encrypt(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Encrypt in SSL2 mode&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # in SSLv2 sequence numbers are incremented for plaintext records too</span>
<span class="gi">+        seqnumBytes = self._writeState.getSeqNumBytes()</span>
<span class="gi">+</span>
<span class="gi">+        if (self._writeState.encContext and</span>
<span class="gi">+                self._writeState.encContext.isBlockCipher):</span>
<span class="gi">+            plaintext_len = len(data)</span>
<span class="gi">+            data = self.addPadding(data)</span>
<span class="gi">+            padding = len(data) - plaintext_len</span>
<span class="gi">+        else:</span>
<span class="gi">+            padding = 0</span>
<span class="gi">+</span>
<span class="gi">+        if self._writeState.macContext:</span>
<span class="gi">+            mac = self._writeState.macContext.copy()</span>
<span class="gi">+            mac.update(compatHMAC(data))</span>
<span class="gi">+            mac.update(compatHMAC(seqnumBytes[-4:]))</span>
<span class="gi">+</span>
<span class="gi">+            data = bytearray(mac.digest()) + data</span>
<span class="gi">+</span>
<span class="gi">+        if self._writeState.encContext:</span>
<span class="gi">+            data = self._writeState.encContext.encrypt(data)</span>
<span class="gi">+</span>
<span class="gi">+        return data, padding</span>

<span class="w"> </span>    def sendRecord(self, msg):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -307,15 +599,124 @@ class RecordLayer(object):</span>
<span class="w"> </span>        :param msg: TLS message to send
<span class="w"> </span>        :type msg: ApplicationData, HandshakeMessage, etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = msg.write()</span>
<span class="gi">+        contentType = msg.contentType</span>
<span class="gi">+</span>
<span class="gi">+        # TLS 1.3 hides the content type of messages</span>
<span class="gi">+        # but CCS is always not encrypted</span>
<span class="gi">+        if self._is_tls13_plus() and self._writeState.encContext and \</span>
<span class="gi">+                contentType != ContentType.change_cipher_spec:</span>
<span class="gi">+            data += bytearray([contentType])</span>
<span class="gi">+            if self.padding_cb:</span>
<span class="gi">+                max_padding = self.send_record_limit - len(data) - 1</span>
<span class="gi">+                # add number of zero bytes specified by padding_cb()</span>
<span class="gi">+                data += bytearray(self.padding_cb(len(data),</span>
<span class="gi">+                                                  contentType,</span>
<span class="gi">+                                                  max_padding))</span>
<span class="gi">+            # in TLS 1.3 contentType is ignored by _encryptThenSeal</span>
<span class="gi">+            contentType = ContentType.application_data</span>
<span class="gi">+</span>
<span class="gi">+        padding = 0</span>
<span class="gi">+        if self.version in ((0, 2), (2, 0)):</span>
<span class="gi">+            data, padding = self._ssl2Encrypt(data)</span>
<span class="gi">+        elif self.version &gt; (3, 3) and \</span>
<span class="gi">+                contentType == ContentType.change_cipher_spec:</span>
<span class="gi">+            # TLS 1.3 does not encrypt CCS messages</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif self._writeState.encContext and \</span>
<span class="gi">+                self._writeState.encContext.isAEAD:</span>
<span class="gi">+            data = self._encryptThenSeal(data, contentType)</span>
<span class="gi">+        elif self._writeState.encryptThenMAC:</span>
<span class="gi">+            data = self._encryptThenMAC(data, contentType)</span>
<span class="gi">+        else:</span>
<span class="gi">+            data = self._macThenEncrypt(data, contentType)</span>
<span class="gi">+</span>
<span class="gi">+        encryptedMessage = Message(contentType, data)</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._recordSocket.send(encryptedMessage, padding):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # receiving messages</span>
<span class="gi">+    #</span>

<span class="w"> </span>    def _decryptStreamThenMAC(self, recordType, data):
<span class="w"> </span>        &quot;&quot;&quot;Decrypt a stream cipher and check MAC&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._readState.encContext:</span>
<span class="gi">+            assert self.version in ((3, 0), (3, 1), (3, 2), (3, 3))</span>
<span class="gi">+</span>
<span class="gi">+            data = self._readState.encContext.decrypt(data)</span>
<span class="gi">+</span>
<span class="gi">+        if self._readState.macContext:</span>
<span class="gi">+            #Check MAC</span>
<span class="gi">+            macGood = True</span>
<span class="gi">+            macLength = self._readState.macContext.digest_size</span>
<span class="gi">+            endLength = macLength</span>
<span class="gi">+            if endLength &gt; len(data):</span>
<span class="gi">+                macGood = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                #Read MAC</span>
<span class="gi">+                startIndex = len(data) - endLength</span>
<span class="gi">+                endIndex = startIndex + macLength</span>
<span class="gi">+                checkBytes = data[startIndex : endIndex]</span>
<span class="gi">+</span>
<span class="gi">+                #Calculate MAC</span>
<span class="gi">+                seqnumBytes = self._readState.getSeqNumBytes()</span>
<span class="gi">+                data = data[:-endLength]</span>
<span class="gi">+                mac = self._readState.macContext.copy()</span>
<span class="gi">+                macBytes = self.calculateMAC(mac, seqnumBytes, recordType,</span>
<span class="gi">+                                             data)</span>
<span class="gi">+</span>
<span class="gi">+                #Compare MACs</span>
<span class="gi">+                if not ct_compare_digest(macBytes, checkBytes):</span>
<span class="gi">+                    macGood = False</span>
<span class="gi">+</span>
<span class="gi">+            if not macGood:</span>
<span class="gi">+                raise TLSBadRecordMAC()</span>
<span class="gi">+</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>

<span class="w"> </span>    def _decryptThenMAC(self, recordType, data):
<span class="w"> </span>        &quot;&quot;&quot;Decrypt data, check padding and MAC&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._readState.encContext:</span>
<span class="gi">+            assert self.version in ((3, 0), (3, 1), (3, 2), (3, 3))</span>
<span class="gi">+            assert self._readState.encContext.isBlockCipher</span>
<span class="gi">+            assert self._readState.macContext</span>
<span class="gi">+</span>
<span class="gi">+            #</span>
<span class="gi">+            # decrypt the record</span>
<span class="gi">+            #</span>
<span class="gi">+            blockLength = self._readState.encContext.block_size</span>
<span class="gi">+            if len(data) % blockLength != 0:</span>
<span class="gi">+                raise TLSDecryptionFailed()</span>
<span class="gi">+            data = self._readState.encContext.decrypt(data)</span>
<span class="gi">+            if self.version &gt;= (3, 2): #For TLS 1.1, remove explicit IV</span>
<span class="gi">+                data = data[self._readState.encContext.block_size : ]</span>
<span class="gi">+</span>
<span class="gi">+            #</span>
<span class="gi">+            # check padding and MAC</span>
<span class="gi">+            #</span>
<span class="gi">+            seqnumBytes = self._readState.getSeqNumBytes()</span>
<span class="gi">+</span>
<span class="gi">+            if not ct_check_cbc_mac_and_pad(</span>
<span class="gi">+                    data,</span>
<span class="gi">+                    self._readState.macContext,</span>
<span class="gi">+                    seqnumBytes,</span>
<span class="gi">+                    recordType,</span>
<span class="gi">+                    self.version,</span>
<span class="gi">+                    self._readState.encContext.block_size):</span>
<span class="gi">+                raise TLSBadRecordMAC()</span>
<span class="gi">+</span>
<span class="gi">+            #</span>
<span class="gi">+            # strip padding and MAC</span>
<span class="gi">+            #</span>
<span class="gi">+</span>
<span class="gi">+            endLength = data[-1] + 1 + self._readState.macContext.digest_size</span>
<span class="gi">+</span>
<span class="gi">+            data = data[:-endLength]</span>
<span class="gi">+</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    def _macThenDecrypt(self, recordType, buf):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -324,15 +725,139 @@ class RecordLayer(object):</span>
<span class="w"> </span>        :raises TLSBadRecordMAC: when the mac value is invalid
<span class="w"> </span>        :raises TLSDecryptionFailed: when the data to decrypt has invalid size
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._readState.macContext:</span>
<span class="gi">+            macLength = self._readState.macContext.digest_size</span>
<span class="gi">+            if len(buf) &lt; macLength:</span>
<span class="gi">+                raise TLSBadRecordMAC(&quot;Truncated data&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            checkBytes = buf[-macLength:]</span>
<span class="gi">+            buf = buf[:-macLength]</span>
<span class="gi">+</span>
<span class="gi">+            seqnumBytes = self._readState.getSeqNumBytes()</span>
<span class="gi">+            mac = self._readState.macContext.copy()</span>
<span class="gi">+</span>
<span class="gi">+            macBytes = self.calculateMAC(mac, seqnumBytes, recordType, buf)</span>
<span class="gi">+</span>
<span class="gi">+            if not ct_compare_digest(macBytes, checkBytes):</span>
<span class="gi">+                raise TLSBadRecordMAC(&quot;MAC mismatch&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if self._readState.encContext:</span>
<span class="gi">+            blockLength = self._readState.encContext.block_size</span>
<span class="gi">+            if len(buf) % blockLength != 0:</span>
<span class="gi">+                raise TLSDecryptionFailed(&quot;data length not multiple of &quot;\</span>
<span class="gi">+                                          &quot;block size&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            buf = self._readState.encContext.decrypt(buf)</span>
<span class="gi">+</span>
<span class="gi">+            # remove explicit IV</span>
<span class="gi">+            if self.version &gt;= (3, 2):</span>
<span class="gi">+                buf = buf[blockLength:]</span>
<span class="gi">+</span>
<span class="gi">+            if len(buf) == 0:</span>
<span class="gi">+                raise TLSBadRecordMAC(&quot;No data left after IV removal&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            # check padding</span>
<span class="gi">+            paddingLength = buf[-1]</span>
<span class="gi">+            if paddingLength + 1 &gt; len(buf):</span>
<span class="gi">+                raise TLSBadRecordMAC(&quot;Invalid padding length&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            paddingGood = True</span>
<span class="gi">+            totalPaddingLength = paddingLength+1</span>
<span class="gi">+            if self.version != (3, 0):</span>
<span class="gi">+                paddingBytes = buf[-totalPaddingLength:-1]</span>
<span class="gi">+                for byte in paddingBytes:</span>
<span class="gi">+                    if byte != paddingLength:</span>
<span class="gi">+                        paddingGood = False</span>
<span class="gi">+</span>
<span class="gi">+            if not paddingGood:</span>
<span class="gi">+                raise TLSBadRecordMAC(&quot;Invalid padding byte values&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            # remove padding</span>
<span class="gi">+            buf = buf[:-totalPaddingLength]</span>
<span class="gi">+</span>
<span class="gi">+        return buf</span>

<span class="w"> </span>    def _decryptAndUnseal(self, header, buf):
<span class="w"> </span>        &quot;&quot;&quot;Decrypt AEAD encrypted data&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        seqnumBytes = self._readState.getSeqNumBytes()</span>
<span class="gi">+        # AES-GCM has an explicit variable nonce in TLS 1.2</span>
<span class="gi">+        if &quot;aes&quot; in self._readState.encContext.name and \</span>
<span class="gi">+                not self._is_tls13_plus():</span>
<span class="gi">+            explicitNonceLength = 8</span>
<span class="gi">+            if explicitNonceLength &gt; len(buf):</span>
<span class="gi">+                #Publicly invalid.</span>
<span class="gi">+                raise TLSBadRecordMAC(&quot;Truncated nonce&quot;)</span>
<span class="gi">+            nonce = self._readState.fixedNonce + buf[:explicitNonceLength]</span>
<span class="gi">+            buf = buf[8:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # for TLS 1.3 and Chacha20 in TLS 1.2 share nonce generation</span>
<span class="gi">+            # algorithm</span>
<span class="gi">+            nonce = self._getNonce(self._readState, seqnumBytes)</span>
<span class="gi">+</span>
<span class="gi">+        if self._readState.encContext.tagLength &gt; len(buf):</span>
<span class="gi">+            #Publicly invalid.</span>
<span class="gi">+            raise TLSBadRecordMAC(&quot;Truncated tag&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not self._is_tls13_plus():</span>
<span class="gi">+            plaintextLen = len(buf) - self._readState.encContext.tagLength</span>
<span class="gi">+            authData = seqnumBytes + bytearray([header.type, self.version[0],</span>
<span class="gi">+                                                self.version[1],</span>
<span class="gi">+                                                plaintextLen//256,</span>
<span class="gi">+                                                plaintextLen%256])</span>
<span class="gi">+        else:  # TLS 1.3</span>
<span class="gi">+            # enforce the checks for encrypted records</span>
<span class="gi">+            if header.type != ContentType.application_data:</span>
<span class="gi">+                raise TLSUnexpectedMessage(</span>
<span class="gi">+                    &quot;Invalid ContentType for encrypted record: {0}&quot;</span>
<span class="gi">+                    .format(ContentType.toStr(header.type)))</span>
<span class="gi">+            if header.version != (3, 3):</span>
<span class="gi">+                raise TLSIllegalParameterException(</span>
<span class="gi">+                    &quot;Unexpected version in encrypted record: {0}&quot;</span>
<span class="gi">+                    .format(header.version))</span>
<span class="gi">+            if header.length != len(buf):</span>
<span class="gi">+                raise TLSBadRecordMAC(&quot;Length mismatch&quot;)</span>
<span class="gi">+            authData = header.write()</span>
<span class="gi">+</span>
<span class="gi">+        buf = self._readState.encContext.open(nonce, buf, authData)</span>
<span class="gi">+        if buf is None:</span>
<span class="gi">+            raise TLSBadRecordMAC(&quot;Invalid tag, decryption failure&quot;)</span>
<span class="gi">+        return buf</span>

<span class="w"> </span>    def _decryptSSL2(self, data, padding):
<span class="w"> </span>        &quot;&quot;&quot;Decrypt SSL2 encrypted data&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # sequence numbers are incremented for plaintext records too</span>
<span class="gi">+        seqnumBytes = self._readState.getSeqNumBytes()</span>
<span class="gi">+</span>
<span class="gi">+        #</span>
<span class="gi">+        # decrypt</span>
<span class="gi">+        #</span>
<span class="gi">+        if self._readState.encContext:</span>
<span class="gi">+            if self._readState.encContext.isBlockCipher:</span>
<span class="gi">+                blockLength = self._readState.encContext.block_size</span>
<span class="gi">+                if len(data) % blockLength:</span>
<span class="gi">+                    raise TLSDecryptionFailed()</span>
<span class="gi">+            data = self._readState.encContext.decrypt(data)</span>
<span class="gi">+</span>
<span class="gi">+        #</span>
<span class="gi">+        # strip and check MAC</span>
<span class="gi">+        #</span>
<span class="gi">+        if self._readState.macContext:</span>
<span class="gi">+            macBytes = data[:16]</span>
<span class="gi">+            data = data[16:]</span>
<span class="gi">+</span>
<span class="gi">+            mac = self._readState.macContext.copy()</span>
<span class="gi">+            mac.update(compatHMAC(data))</span>
<span class="gi">+            mac.update(compatHMAC(seqnumBytes[-4:]))</span>
<span class="gi">+            calcMac = bytearray(mac.digest())</span>
<span class="gi">+            if macBytes != calcMac:</span>
<span class="gi">+                raise TLSBadRecordMAC()</span>
<span class="gi">+</span>
<span class="gi">+        #</span>
<span class="gi">+        # strip padding</span>
<span class="gi">+        #</span>
<span class="gi">+        if padding:</span>
<span class="gi">+            data = data[:-padding]</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _tls13_de_pad(data):
<span class="gu">@@ -344,7 +869,19 @@ class RecordLayer(object):</span>

<span class="w"> </span>        :rtype: tuple
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # the padding is at the end and the first non-zero byte is the</span>
<span class="gi">+        # padding</span>
<span class="gi">+        # could be reversed(enumerate(data)), if that worked at all</span>
<span class="gi">+        # could be reversed(list(enumerate(data))), if that didn&#39;t double</span>
<span class="gi">+        # memory usage</span>
<span class="gi">+        for pos, value in izip(reversed(xrange(len(data))), reversed(data)):</span>
<span class="gi">+            if value != 0:</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TLSUnexpectedMessage(&quot;Malformed record layer inner plaintext&quot;</span>
<span class="gi">+                                       &quot; - content type missing&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return data[:pos], value</span>

<span class="w"> </span>    def recvRecord(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -358,7 +895,96 @@ class RecordLayer(object):</span>
<span class="w"> </span>        :raises TLSRecordOverflow: when the received record was longer than
<span class="w"> </span>            allowed by negotiated version of TLS
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while True:</span>
<span class="gi">+            result = None</span>
<span class="gi">+            for result in self._recordSocket.recv():</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            assert result is not None</span>
<span class="gi">+</span>
<span class="gi">+            (header, data) = result</span>
<span class="gi">+            # as trying decryption increments sequence number, we need to</span>
<span class="gi">+            # keep the old one (we do copy of the whole object in case</span>
<span class="gi">+            # some cipher has an internal state itself)</span>
<span class="gi">+            read_state_copy = None</span>
<span class="gi">+            if self.early_data_ok:</span>
<span class="gi">+                # do the copy only when needed</span>
<span class="gi">+                read_state_copy = copy.copy(self._readState)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                if isinstance(header, RecordHeader2):</span>
<span class="gi">+                    data = self._decryptSSL2(data, header.padding)</span>
<span class="gi">+                    if self.handshake_finished:</span>
<span class="gi">+                        header.type = ContentType.application_data</span>
<span class="gi">+                # in TLS 1.3, the other party may send an unprotected CCS</span>
<span class="gi">+                # message at any point in connection</span>
<span class="gi">+                elif self._is_tls13_plus() and \</span>
<span class="gi">+                        header.type == ContentType.change_cipher_spec:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                # when we&#39;re in the early handshake, then unencrypted alerts</span>
<span class="gi">+                # are fine too</span>
<span class="gi">+                elif self._is_tls13_plus() and \</span>
<span class="gi">+                        header.type == ContentType.alert and \</span>
<span class="gi">+                        len(data) &lt; 3 and \</span>
<span class="gi">+                        self._readState and \</span>
<span class="gi">+                        self._readState.encContext and \</span>
<span class="gi">+                        self._readState.seqnum == 0:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif self._readState and \</span>
<span class="gi">+                    self._readState.encContext and \</span>
<span class="gi">+                    self._readState.encContext.isAEAD:</span>
<span class="gi">+                    data = self._decryptAndUnseal(header, data)</span>
<span class="gi">+                elif self._readState and self._readState.encryptThenMAC:</span>
<span class="gi">+                    data = self._macThenDecrypt(header.type, data)</span>
<span class="gi">+                elif self._readState and \</span>
<span class="gi">+                        self._readState.encContext and \</span>
<span class="gi">+                        self._readState.encContext.isBlockCipher:</span>
<span class="gi">+                    data = self._decryptThenMAC(header.type, data)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    data = self._decryptStreamThenMAC(header.type, data)</span>
<span class="gi">+                # if we don&#39;t have an encryption context established</span>
<span class="gi">+                # and early data is ok, that means we have received</span>
<span class="gi">+                # encrypted record in case the type of record is</span>
<span class="gi">+                # application_data (from TLS 1.3)</span>
<span class="gi">+                if not self._readState.encContext \</span>
<span class="gi">+                        and not self._readState.macContext \</span>
<span class="gi">+                        and self.early_data_ok and \</span>
<span class="gi">+                        header.type == ContentType.application_data:</span>
<span class="gi">+                    raise TLSBadRecordMAC(&quot;early data received&quot;)</span>
<span class="gi">+            except TLSBadRecordMAC:</span>
<span class="gi">+                if self.early_data_ok and (</span>
<span class="gi">+                        self._early_data_processed + len(data)</span>
<span class="gi">+                        &lt; self.max_early_data):</span>
<span class="gi">+                    # ignore exception, retry reading</span>
<span class="gi">+                    self._early_data_processed += len(data)</span>
<span class="gi">+                    # reload state for decryption</span>
<span class="gi">+                    self._readState = read_state_copy</span>
<span class="gi">+                    continue</span>
<span class="gi">+                raise</span>
<span class="gi">+            # as soon as we&#39;re able to decrypt messages again, we must</span>
<span class="gi">+            # start checking the MACs</span>
<span class="gi">+            self.early_data_ok = False</span>
<span class="gi">+</span>
<span class="gi">+            # TLS 1.3 encrypts the type, CCS and Alerts are not encrypted</span>
<span class="gi">+            if self._is_tls13_plus() and self._readState and \</span>
<span class="gi">+                    self._readState.encContext and\</span>
<span class="gi">+                    header.type == ContentType.application_data:</span>
<span class="gi">+                # check if plaintext is not too big, RFC 8446, section 5.4</span>
<span class="gi">+                if len(data) &gt; self.recv_record_limit + 1:</span>
<span class="gi">+                    raise TLSRecordOverflow()</span>
<span class="gi">+                data, contentType = self._tls13_de_pad(data)</span>
<span class="gi">+                header = RecordHeader3().create((3, 4), contentType, len(data))</span>
<span class="gi">+</span>
<span class="gi">+            # RFC 5246, section 6.2.1</span>
<span class="gi">+            if len(data) &gt; self.recv_record_limit:</span>
<span class="gi">+                raise TLSRecordOverflow()</span>
<span class="gi">+</span>
<span class="gi">+            yield (header, Parser(data))</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # cryptography state methods</span>
<span class="gi">+    #</span>

<span class="w"> </span>    def changeWriteState(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -369,7 +995,12 @@ class RecordLayer(object):</span>
<span class="w"> </span>        performed and directly after sending a :py:class:`ChangeCipherSpec`
<span class="w"> </span>        message.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.version in ((0, 2), (2, 0)):</span>
<span class="gi">+            # in SSLv2 sequence numbers carry over from plaintext to encrypted</span>
<span class="gi">+            # context</span>
<span class="gi">+            self._pendingWriteState.seqnum = self._writeState.seqnum</span>
<span class="gi">+        self._writeState = self._pendingWriteState</span>
<span class="gi">+        self._pendingWriteState = ConnectionState()</span>

<span class="w"> </span>    def changeReadState(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -380,25 +1011,109 @@ class RecordLayer(object):</span>
<span class="w"> </span>        performed and directly after receiving a :py:class:`ChangeCipherSpec`
<span class="w"> </span>        message.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.version in ((0, 2), (2, 0)):</span>
<span class="gi">+            # in SSLv2 sequence numbers carry over from plaintext to encrypted</span>
<span class="gi">+            # context</span>
<span class="gi">+            self._pendingReadState.seqnum = self._readState.seqnum</span>
<span class="gi">+        self._readState = self._pendingReadState</span>
<span class="gi">+        self._pendingReadState = ConnectionState()</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _getCipherSettings(cipherSuite):
<span class="w"> </span>        &quot;&quot;&quot;Get the settings for cipher suite used&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cipherSuite in CipherSuite.aes256GcmSuites:</span>
<span class="gi">+            keyLength = 32</span>
<span class="gi">+            ivLength = 4</span>
<span class="gi">+            createCipherFunc = createAESGCM</span>
<span class="gi">+        elif cipherSuite in CipherSuite.aes128GcmSuites:</span>
<span class="gi">+            keyLength = 16</span>
<span class="gi">+            ivLength = 4</span>
<span class="gi">+            createCipherFunc = createAESGCM</span>
<span class="gi">+        elif cipherSuite in CipherSuite.aes256Ccm_8Suites:</span>
<span class="gi">+            keyLength = 32</span>
<span class="gi">+            ivLength = 4</span>
<span class="gi">+            createCipherFunc = createAESCCM_8</span>
<span class="gi">+        elif cipherSuite in CipherSuite.aes256CcmSuites:</span>
<span class="gi">+            keyLength = 32</span>
<span class="gi">+            ivLength = 4</span>
<span class="gi">+            createCipherFunc = createAESCCM</span>
<span class="gi">+        elif cipherSuite in CipherSuite.aes128Ccm_8Suites:</span>
<span class="gi">+            keyLength = 16</span>
<span class="gi">+            ivLength = 4</span>
<span class="gi">+            createCipherFunc = createAESCCM_8</span>
<span class="gi">+        elif cipherSuite in CipherSuite.aes128CcmSuites:</span>
<span class="gi">+            keyLength = 16</span>
<span class="gi">+            ivLength = 4</span>
<span class="gi">+            createCipherFunc = createAESCCM</span>
<span class="gi">+        elif cipherSuite in CipherSuite.chacha20Suites:</span>
<span class="gi">+            keyLength = 32</span>
<span class="gi">+            ivLength = 12</span>
<span class="gi">+            createCipherFunc = createCHACHA20</span>
<span class="gi">+        elif cipherSuite in CipherSuite.chacha20draft00Suites:</span>
<span class="gi">+            keyLength = 32</span>
<span class="gi">+            ivLength = 4</span>
<span class="gi">+            createCipherFunc = createCHACHA20</span>
<span class="gi">+        elif cipherSuite in CipherSuite.aes128Suites:</span>
<span class="gi">+            keyLength = 16</span>
<span class="gi">+            ivLength = 16</span>
<span class="gi">+            createCipherFunc = createAES</span>
<span class="gi">+        elif cipherSuite in CipherSuite.aes256Suites:</span>
<span class="gi">+            keyLength = 32</span>
<span class="gi">+            ivLength = 16</span>
<span class="gi">+            createCipherFunc = createAES</span>
<span class="gi">+        elif cipherSuite in CipherSuite.rc4Suites:</span>
<span class="gi">+            keyLength = 16</span>
<span class="gi">+            ivLength = 0</span>
<span class="gi">+            createCipherFunc = createRC4</span>
<span class="gi">+        elif cipherSuite in CipherSuite.tripleDESSuites:</span>
<span class="gi">+            keyLength = 24</span>
<span class="gi">+            ivLength = 8</span>
<span class="gi">+            createCipherFunc = createTripleDES</span>
<span class="gi">+        elif cipherSuite in CipherSuite.nullSuites:</span>
<span class="gi">+            keyLength = 0</span>
<span class="gi">+            ivLength = 0</span>
<span class="gi">+            createCipherFunc = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+</span>
<span class="gi">+        return (keyLength, ivLength, createCipherFunc)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _getMacSettings(cipherSuite):
<span class="w"> </span>        &quot;&quot;&quot;Get settings for HMAC used&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cipherSuite in CipherSuite.aeadSuites:</span>
<span class="gi">+            macLength = 0</span>
<span class="gi">+            digestmod = None</span>
<span class="gi">+        elif cipherSuite in CipherSuite.shaSuites:</span>
<span class="gi">+            macLength = 20</span>
<span class="gi">+            digestmod = hashlib.sha1</span>
<span class="gi">+        elif cipherSuite in CipherSuite.sha256Suites:</span>
<span class="gi">+            macLength = 32</span>
<span class="gi">+            digestmod = hashlib.sha256</span>
<span class="gi">+        elif cipherSuite in CipherSuite.sha384Suites:</span>
<span class="gi">+            macLength = 48</span>
<span class="gi">+            digestmod = hashlib.sha384</span>
<span class="gi">+        elif cipherSuite in CipherSuite.md5Suites:</span>
<span class="gi">+            macLength = 16</span>
<span class="gi">+            digestmod = hashlib.md5</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+</span>
<span class="gi">+        return macLength, digestmod</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _getHMACMethod(version):
<span class="w"> </span>        &quot;&quot;&quot;Get the HMAC method&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert version in ((3, 0), (3, 1), (3, 2), (3, 3))</span>
<span class="gi">+        if version == (3, 0):</span>
<span class="gi">+            createMACFunc = createMAC_SSL</span>
<span class="gi">+        elif version in ((3, 1), (3, 2), (3, 3)):</span>
<span class="gi">+            createMACFunc = createHMAC</span>
<span class="gi">+</span>
<span class="gi">+        return createMACFunc</span>

<span class="w"> </span>    def calcSSL2PendingStates(self, cipherSuite, masterSecret, clientRandom,
<span class="gd">-        serverRandom, implementations):</span>
<span class="gi">+                              serverRandom, implementations):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create the keys for encryption and decryption in SSLv2

<span class="gu">@@ -406,15 +1121,153 @@ class RecordLayer(object):</span>
<span class="w"> </span>        key-arg data for the server that needs to be passed up to handshake
<span class="w"> </span>        protocol.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cipherSuite in CipherSuite.ssl2_128Key:</span>
<span class="gi">+            key_length = 16</span>
<span class="gi">+        elif cipherSuite in CipherSuite.ssl2_192Key:</span>
<span class="gi">+            key_length = 24</span>
<span class="gi">+        elif cipherSuite in CipherSuite.ssl2_64Key:</span>
<span class="gi">+            key_length = 8</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Unknown cipher specified&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        key_material = bytearray(key_length * 2)</span>
<span class="gi">+        md5_output_size = 16</span>
<span class="gi">+        for i, pos in enumerate(range(0, key_length * 2, md5_output_size)):</span>
<span class="gi">+            key_material[pos:pos+md5_output_size] = MD5(\</span>
<span class="gi">+                    masterSecret +</span>
<span class="gi">+                    bytearray(str(i), &quot;ascii&quot;) +</span>
<span class="gi">+                    clientRandom + serverRandom)</span>
<span class="gi">+</span>
<span class="gi">+        serverWriteKey = key_material[:key_length]</span>
<span class="gi">+        clientWriteKey = key_material[key_length:]</span>
<span class="gi">+</span>
<span class="gi">+        # specification draft says that DES key should not use the</span>
<span class="gi">+        # incrementing label but all implementations use it anyway</span>
<span class="gi">+        #elif cipherSuite in CipherSuite.ssl2_64Key:</span>
<span class="gi">+        #    key_material = MD5(masterSecret + clientRandom + serverRandom)</span>
<span class="gi">+        #    serverWriteKey = key_material[0:8]</span>
<span class="gi">+        #    clientWriteKey = key_material[8:16]</span>
<span class="gi">+</span>
<span class="gi">+        # RC4 cannot use initialisation vector</span>
<span class="gi">+        if cipherSuite not in CipherSuite.ssl2rc4:</span>
<span class="gi">+            iv = getRandomBytes(8)</span>
<span class="gi">+        else:</span>
<span class="gi">+            iv = bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        clientPendingState = ConnectionState()</span>
<span class="gi">+        serverPendingState = ConnectionState()</span>
<span class="gi">+</span>
<span class="gi">+        # MAC</span>
<span class="gi">+        clientPendingState.macContext = hashlib.md5()</span>
<span class="gi">+        clientPendingState.macContext.update(compatHMAC(clientWriteKey))</span>
<span class="gi">+        serverPendingState.macContext = hashlib.md5()</span>
<span class="gi">+        serverPendingState.macContext.update(compatHMAC(serverWriteKey))</span>
<span class="gi">+</span>
<span class="gi">+        # ciphers</span>
<span class="gi">+        if cipherSuite in CipherSuite.ssl2rc4:</span>
<span class="gi">+            cipherMethod = createRC4</span>
<span class="gi">+        elif cipherSuite in CipherSuite.ssl2_3des:</span>
<span class="gi">+            cipherMethod = createTripleDES</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError(&quot;Unknown cipher&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        clientPendingState.encContext = cipherMethod(clientWriteKey, iv,</span>
<span class="gi">+                                                     implementations)</span>
<span class="gi">+        serverPendingState.encContext = cipherMethod(serverWriteKey, iv,</span>
<span class="gi">+                                                     implementations)</span>
<span class="gi">+</span>
<span class="gi">+        # Assign new connection states to pending states</span>
<span class="gi">+        if self.client:</span>
<span class="gi">+            self._pendingWriteState = clientPendingState</span>
<span class="gi">+            self._pendingReadState = serverPendingState</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._pendingWriteState = serverPendingState</span>
<span class="gi">+            self._pendingReadState = clientPendingState</span>
<span class="gi">+</span>
<span class="gi">+        return iv</span>

<span class="w"> </span>    def calcPendingStates(self, cipherSuite, masterSecret, clientRandom,
<span class="gd">-        serverRandom, implementations):</span>
<span class="gi">+                          serverRandom, implementations):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create pending states for encryption and decryption.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        keyLength, ivLength, createCipherFunc = \</span>
<span class="gi">+                self._getCipherSettings(cipherSuite)</span>
<span class="gi">+</span>
<span class="gi">+        macLength, digestmod = self._getMacSettings(cipherSuite)</span>
<span class="gi">+</span>
<span class="gi">+        if not digestmod:</span>
<span class="gi">+            createMACFunc = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            createMACFunc = self._getHMACMethod(self.version)</span>
<span class="gi">+</span>
<span class="gi">+        outputLength = (macLength*2) + (keyLength*2) + (ivLength*2)</span>
<span class="gi">+</span>
<span class="gi">+        #Calculate Keying Material from Master Secret</span>
<span class="gi">+        keyBlock = calc_key(self.version, masterSecret, cipherSuite,</span>
<span class="gi">+                            b&quot;key expansion&quot;, client_random=clientRandom,</span>
<span class="gi">+                            server_random=serverRandom,</span>
<span class="gi">+                            output_length=outputLength)</span>
<span class="gi">+</span>
<span class="gi">+        #Slice up Keying Material</span>
<span class="gi">+        clientPendingState = ConnectionState()</span>
<span class="gi">+        serverPendingState = ConnectionState()</span>
<span class="gi">+        parser = Parser(keyBlock)</span>
<span class="gi">+        clientMACBlock = parser.getFixBytes(macLength)</span>
<span class="gi">+        serverMACBlock = parser.getFixBytes(macLength)</span>
<span class="gi">+        clientKeyBlock = parser.getFixBytes(keyLength)</span>
<span class="gi">+        serverKeyBlock = parser.getFixBytes(keyLength)</span>
<span class="gi">+        clientIVBlock = parser.getFixBytes(ivLength)</span>
<span class="gi">+        serverIVBlock = parser.getFixBytes(ivLength)</span>
<span class="gi">+</span>
<span class="gi">+        if digestmod:</span>
<span class="gi">+            # Legacy cipher</span>
<span class="gi">+            clientPendingState.macContext = createMACFunc(</span>
<span class="gi">+                compatHMAC(clientMACBlock), digestmod=digestmod)</span>
<span class="gi">+            serverPendingState.macContext = createMACFunc(</span>
<span class="gi">+                compatHMAC(serverMACBlock), digestmod=digestmod)</span>
<span class="gi">+            if createCipherFunc is not None:</span>
<span class="gi">+                clientPendingState.encContext = \</span>
<span class="gi">+                                            createCipherFunc(clientKeyBlock,</span>
<span class="gi">+                                                             clientIVBlock,</span>
<span class="gi">+                                                             implementations)</span>
<span class="gi">+                serverPendingState.encContext = \</span>
<span class="gi">+                                            createCipherFunc(serverKeyBlock,</span>
<span class="gi">+                                                             serverIVBlock,</span>
<span class="gi">+                                                             implementations)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # AEAD</span>
<span class="gi">+            clientPendingState.macContext = None</span>
<span class="gi">+            serverPendingState.macContext = None</span>
<span class="gi">+            clientPendingState.encContext = createCipherFunc(clientKeyBlock,</span>
<span class="gi">+                                                             implementations)</span>
<span class="gi">+            serverPendingState.encContext = createCipherFunc(serverKeyBlock,</span>
<span class="gi">+                                                             implementations)</span>
<span class="gi">+            clientPendingState.fixedNonce = clientIVBlock</span>
<span class="gi">+            serverPendingState.fixedNonce = serverIVBlock</span>
<span class="gi">+</span>
<span class="gi">+        #Assign new connection states to pending states</span>
<span class="gi">+        if self.client:</span>
<span class="gi">+            clientPendingState.encryptThenMAC = \</span>
<span class="gi">+                    self._pendingWriteState.encryptThenMAC</span>
<span class="gi">+            self._pendingWriteState = clientPendingState</span>
<span class="gi">+            serverPendingState.encryptThenMAC = \</span>
<span class="gi">+                    self._pendingReadState.encryptThenMAC</span>
<span class="gi">+            self._pendingReadState = serverPendingState</span>
<span class="gi">+        else:</span>
<span class="gi">+            serverPendingState.encryptThenMAC = \</span>
<span class="gi">+                    self._pendingWriteState.encryptThenMAC</span>
<span class="gi">+            self._pendingWriteState = serverPendingState</span>
<span class="gi">+            clientPendingState.encryptThenMAC = \</span>
<span class="gi">+                    self._pendingReadState.encryptThenMAC</span>
<span class="gi">+            self._pendingReadState = clientPendingState</span>
<span class="gi">+</span>
<span class="gi">+        if self.version &gt;= (3, 2) and ivLength:</span>
<span class="gi">+            #Choose fixedIVBlock for TLS 1.1 (this is encrypted with the CBC</span>
<span class="gi">+            #residue to create the IV for each sent block)</span>
<span class="gi">+            self.fixedIVBlock = getRandomBytes(ivLength)</span>

<span class="w"> </span>    def calcTLS1_3PendingState(self, cipherSuite, cl_traffic_secret,
<span class="gd">-        sr_traffic_secret, implementations):</span>
<span class="gi">+                               sr_traffic_secret,</span>
<span class="gi">+                               implementations):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create pending state for encryption in TLS 1.3.

<span class="gu">@@ -427,4 +1280,96 @@ class RecordLayer(object):</span>
<span class="w"> </span>        :param list implementations: list of names of implementations that
<span class="w"> </span>            are permitted for the connection
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prf_name = &#39;sha384&#39; if cipherSuite \</span>
<span class="gi">+                   in CipherSuite.sha384PrfSuites \</span>
<span class="gi">+                   else &#39;sha256&#39;</span>
<span class="gi">+</span>
<span class="gi">+        key_length, iv_length, cipher_func = \</span>
<span class="gi">+            self._getCipherSettings(cipherSuite)</span>
<span class="gi">+        iv_length = 12</span>
<span class="gi">+</span>
<span class="gi">+        clientPendingState = ConnectionState()</span>
<span class="gi">+        serverPendingState = ConnectionState()</span>
<span class="gi">+</span>
<span class="gi">+        clientPendingState.macContext = None</span>
<span class="gi">+        clientPendingState.encContext = \</span>
<span class="gi">+            cipher_func(HKDF_expand_label(cl_traffic_secret,</span>
<span class="gi">+                                          b&quot;key&quot;, b&quot;&quot;,</span>
<span class="gi">+                                          key_length,</span>
<span class="gi">+                                          prf_name),</span>
<span class="gi">+                        implementations)</span>
<span class="gi">+        clientPendingState.fixedNonce = HKDF_expand_label(cl_traffic_secret,</span>
<span class="gi">+                                                          b&quot;iv&quot;, b&quot;&quot;,</span>
<span class="gi">+                                                          iv_length,</span>
<span class="gi">+                                                          prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        serverPendingState.macContext = None</span>
<span class="gi">+        serverPendingState.encContext = \</span>
<span class="gi">+            cipher_func(HKDF_expand_label(sr_traffic_secret,</span>
<span class="gi">+                                          b&quot;key&quot;, b&quot;&quot;,</span>
<span class="gi">+                                          key_length,</span>
<span class="gi">+                                          prf_name),</span>
<span class="gi">+                        implementations)</span>
<span class="gi">+        serverPendingState.fixedNonce = HKDF_expand_label(sr_traffic_secret,</span>
<span class="gi">+                                                          b&quot;iv&quot;, b&quot;&quot;,</span>
<span class="gi">+                                                          iv_length,</span>
<span class="gi">+                                                          prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        if self.client:</span>
<span class="gi">+            self._pendingWriteState = clientPendingState</span>
<span class="gi">+            self._pendingReadState = serverPendingState</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._pendingWriteState = serverPendingState</span>
<span class="gi">+            self._pendingReadState = clientPendingState</span>
<span class="gi">+</span>
<span class="gi">+    def _calcTLS1_3KeyUpdate(self, cipherSuite, app_secret):</span>
<span class="gi">+        prf_name, prf_length = (&#39;sha384&#39;, 48) if cipherSuite \</span>
<span class="gi">+                                in CipherSuite.sha384PrfSuites \</span>
<span class="gi">+                                else (&#39;sha256&#39;, 32)</span>
<span class="gi">+        key_length, iv_length, cipher_func = \</span>
<span class="gi">+            self._getCipherSettings(cipherSuite)</span>
<span class="gi">+        iv_length = 12</span>
<span class="gi">+</span>
<span class="gi">+        new_app_secret = HKDF_expand_label(app_secret,</span>
<span class="gi">+                                           b&quot;traffic upd&quot;, b&quot;&quot;,</span>
<span class="gi">+                                           prf_length,</span>
<span class="gi">+                                           prf_name)</span>
<span class="gi">+        new_state = ConnectionState()</span>
<span class="gi">+        new_state.macContext = None</span>
<span class="gi">+        new_state.encContext = \</span>
<span class="gi">+            cipher_func(HKDF_expand_label(new_app_secret,</span>
<span class="gi">+                                          b&quot;key&quot;, b&quot;&quot;,</span>
<span class="gi">+                                          key_length,</span>
<span class="gi">+                                          prf_name),</span>
<span class="gi">+                        None)</span>
<span class="gi">+        new_state.fixedNonce = HKDF_expand_label(new_app_secret,</span>
<span class="gi">+                                                 b&quot;iv&quot;, b&quot;&quot;,</span>
<span class="gi">+                                                 iv_length,</span>
<span class="gi">+                                                 prf_name)</span>
<span class="gi">+        return new_app_secret, new_state</span>
<span class="gi">+</span>
<span class="gi">+    def calcTLS1_3KeyUpdate_sender(self, cipherSuite, cl_app_secret,</span>
<span class="gi">+                                   sr_app_secret):</span>
<span class="gi">+        if self.client:</span>
<span class="gi">+            new_sr_app_secret, server_state = self._calcTLS1_3KeyUpdate(</span>
<span class="gi">+                cipherSuite, sr_app_secret)</span>
<span class="gi">+            self._readState = server_state</span>
<span class="gi">+            return cl_app_secret, new_sr_app_secret</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_cl_app_secret, client_state = self._calcTLS1_3KeyUpdate(</span>
<span class="gi">+                cipherSuite, cl_app_secret)</span>
<span class="gi">+            self._readState = client_state</span>
<span class="gi">+            return new_cl_app_secret, sr_app_secret</span>
<span class="gi">+</span>
<span class="gi">+    def calcTLS1_3KeyUpdate_reciever(self, cipherSuite, cl_app_secret,</span>
<span class="gi">+                                     sr_app_secret):</span>
<span class="gi">+        if self.client:</span>
<span class="gi">+            new_cl_app_secret, client_state = self._calcTLS1_3KeyUpdate(</span>
<span class="gi">+                cipherSuite, cl_app_secret)</span>
<span class="gi">+            self._writeState = client_state</span>
<span class="gi">+            return new_cl_app_secret, sr_app_secret</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_sr_app_secret, server_state = self._calcTLS1_3KeyUpdate(</span>
<span class="gi">+                cipherSuite, sr_app_secret)</span>
<span class="gi">+            self._writeState = server_state</span>
<span class="gi">+            return cl_app_secret, new_sr_app_secret</span>
<span class="gh">diff --git a/tlslite/session.py b/tlslite/session.py</span>
<span class="gh">index 3df1059..0e310b7 100644</span>
<span class="gd">--- a/tlslite/session.py</span>
<span class="gi">+++ b/tlslite/session.py</span>
<span class="gu">@@ -1,9 +1,15 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Dave Baggett (Arcode Corporation) - canonicalCipherName</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Class representing a TLS session.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .utils.compat import *
<span class="w"> </span>from .mathtls import *
<span class="w"> </span>from .constants import *

<span class="gd">-</span>
<span class="w"> </span>class Session(object):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This class represents a TLS session.
<span class="gu">@@ -72,12 +78,12 @@ class Session(object):</span>
<span class="w"> </span>        self.masterSecret = bytearray(0)
<span class="w"> </span>        self.sessionID = bytearray(0)
<span class="w"> </span>        self.cipherSuite = 0
<span class="gd">-        self.srpUsername = &#39;&#39;</span>
<span class="gi">+        self.srpUsername = &quot;&quot;</span>
<span class="w"> </span>        self.clientCertChain = None
<span class="w"> </span>        self.serverCertChain = None
<span class="w"> </span>        self.tackExt = None
<span class="w"> </span>        self.tackInHelloExt = False
<span class="gd">-        self.serverName = &#39;&#39;</span>
<span class="gi">+        self.serverName = &quot;&quot;</span>
<span class="w"> </span>        self.resumable = False
<span class="w"> </span>        self.encryptThenMAC = False
<span class="w"> </span>        self.extendedMasterSecret = False
<span class="gu">@@ -89,13 +95,84 @@ class Session(object):</span>
<span class="w"> </span>        self.tickets = None
<span class="w"> </span>        self.tls_1_0_tickets = None

<span class="gi">+    def create(self, masterSecret, sessionID, cipherSuite,</span>
<span class="gi">+               srpUsername, clientCertChain, serverCertChain,</span>
<span class="gi">+               tackExt, tackInHelloExt, serverName, resumable=True,</span>
<span class="gi">+               encryptThenMAC=False, extendedMasterSecret=False,</span>
<span class="gi">+               appProto=bytearray(0), cl_app_secret=bytearray(0),</span>
<span class="gi">+               sr_app_secret=bytearray(0), exporterMasterSecret=bytearray(0),</span>
<span class="gi">+               resumptionMasterSecret=bytearray(0), tickets=None,</span>
<span class="gi">+               tls_1_0_tickets=None):</span>
<span class="gi">+        self.masterSecret = masterSecret</span>
<span class="gi">+        self.sessionID = sessionID</span>
<span class="gi">+        self.cipherSuite = cipherSuite</span>
<span class="gi">+        self.srpUsername = srpUsername</span>
<span class="gi">+        self.clientCertChain = clientCertChain</span>
<span class="gi">+        self.serverCertChain = serverCertChain</span>
<span class="gi">+        self.tackExt = tackExt</span>
<span class="gi">+        self.tackInHelloExt = tackInHelloExt  </span>
<span class="gi">+        self.serverName = serverName</span>
<span class="gi">+        self.resumable = resumable</span>
<span class="gi">+        self.encryptThenMAC = encryptThenMAC</span>
<span class="gi">+        self.extendedMasterSecret = extendedMasterSecret</span>
<span class="gi">+        self.appProto = appProto</span>
<span class="gi">+        self.cl_app_secret = cl_app_secret</span>
<span class="gi">+        self.sr_app_secret = sr_app_secret</span>
<span class="gi">+        self.exporterMasterSecret = exporterMasterSecret</span>
<span class="gi">+        self.resumptionMasterSecret = resumptionMasterSecret</span>
<span class="gi">+        # NOTE we need a reference copy not a copy of object here!</span>
<span class="gi">+        self.tickets = tickets</span>
<span class="gi">+        self.tls_1_0_tickets = tls_1_0_tickets</span>
<span class="gi">+</span>
<span class="gi">+    def _clone(self):</span>
<span class="gi">+        other = Session()</span>
<span class="gi">+        other.masterSecret = self.masterSecret</span>
<span class="gi">+        other.sessionID = self.sessionID</span>
<span class="gi">+        other.cipherSuite = self.cipherSuite</span>
<span class="gi">+        other.srpUsername = self.srpUsername</span>
<span class="gi">+        other.clientCertChain = self.clientCertChain</span>
<span class="gi">+        other.serverCertChain = self.serverCertChain</span>
<span class="gi">+        other.tackExt = self.tackExt</span>
<span class="gi">+        other.tackInHelloExt = self.tackInHelloExt</span>
<span class="gi">+        other.serverName = self.serverName</span>
<span class="gi">+        other.resumable = self.resumable</span>
<span class="gi">+        other.encryptThenMAC = self.encryptThenMAC</span>
<span class="gi">+        other.extendedMasterSecret = self.extendedMasterSecret</span>
<span class="gi">+        other.appProto = self.appProto</span>
<span class="gi">+        other.cl_app_secret = self.cl_app_secret</span>
<span class="gi">+        other.sr_app_secret = self.sr_app_secret</span>
<span class="gi">+        other.exporterMasterSecret = self.exporterMasterSecret</span>
<span class="gi">+        other.resumptionMasterSecret = self.resumptionMasterSecret</span>
<span class="gi">+        other.tickets = self.tickets</span>
<span class="gi">+        other.tls_1_0_tickets = self.tls_1_0_tickets</span>
<span class="gi">+        return other</span>
<span class="gi">+</span>
<span class="w"> </span>    def valid(self):
<span class="w"> </span>        &quot;&quot;&quot;If this session can be used for session resumption.

<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        :returns: If this session can be used for session resumption.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO add checks for tickets received from server (freshness etc.)</span>
<span class="gi">+        return self.resumable and (self.sessionID or self.tickets or</span>
<span class="gi">+                                   self.tls_1_0_tickets)</span>
<span class="gi">+</span>
<span class="gi">+    def _setResumable(self, boolean):</span>
<span class="gi">+        #Only let it be set to True if the sessionID is non-null</span>
<span class="gi">+        if (not boolean) or (boolean and self.sessionID):</span>
<span class="gi">+            self.resumable = boolean</span>
<span class="gi">+</span>
<span class="gi">+    def getTackId(self):</span>
<span class="gi">+        if self.tackExt and self.tackExt.tack:</span>
<span class="gi">+            return self.tackExt.tack.getTackId()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+        </span>
<span class="gi">+    def getBreakSigs(self):</span>
<span class="gi">+        if self.tackExt and self.tackExt.break_sigs:</span>
<span class="gi">+            return self.tackExt.break_sigs</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def getCipherName(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the name of the cipher used with this connection.
<span class="gu">@@ -103,15 +180,15 @@ class Session(object):</span>
<span class="w"> </span>        :rtype: str
<span class="w"> </span>        :returns: The name of the cipher used with this connection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        return CipherSuite.canonicalCipherName(self.cipherSuite)</span>
<span class="gi">+        </span>
<span class="w"> </span>    def getMacName(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the name of the HMAC hash algo used with this connection.

<span class="w"> </span>        :rtype: str
<span class="w"> </span>        :returns: The name of the HMAC hash algo used with this connection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return CipherSuite.canonicalMacName(self.cipherSuite)</span>


<span class="w"> </span>class Ticket(object):
<span class="gu">@@ -144,3 +221,6 @@ class Ticket(object):</span>
<span class="w"> </span>        self.master_secret = master_secret
<span class="w"> </span>        self.cipher_suite = cipher_suite
<span class="w"> </span>        self.time_received = time.time()
<span class="gi">+</span>
<span class="gi">+    def valid(self):</span>
<span class="gi">+        return time.time() &lt; self.time_received + self.ticket_lifetime</span>
<span class="gh">diff --git a/tlslite/sessioncache.py b/tlslite/sessioncache.py</span>
<span class="gh">index a40c490..ac54e49 100644</span>
<span class="gd">--- a/tlslite/sessioncache.py</span>
<span class="gi">+++ b/tlslite/sessioncache.py</span>
<span class="gu">@@ -1,8 +1,15 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Martin von Loewis - python 3 port</span>
<span class="gi">+#   Mirko Dziadzka - bugfix</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Class for caching TLS sessions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import threading
<span class="w"> </span>import time

<span class="gd">-</span>
<span class="w"> </span>class SessionCache(object):
<span class="w"> </span>    &quot;&quot;&quot;This class is used by the server to cache TLS sessions.

<span class="gu">@@ -14,6 +21,11 @@ class SessionCache(object):</span>
<span class="w"> </span>    This class is thread-safe.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    #References to these instances</span>
<span class="gi">+    #are also held by the caller, who may change the &#39;resumable&#39;</span>
<span class="gi">+    #flag, so the SessionCache must return the same instances</span>
<span class="gi">+    #it was passed in.</span>
<span class="gi">+</span>
<span class="w"> </span>    def __init__(self, maxEntries=10000, maxAge=14400):
<span class="w"> </span>        &quot;&quot;&quot;Create a new SessionCache.

<span class="gu">@@ -25,9 +37,15 @@ class SessionCache(object):</span>
<span class="w"> </span>        :type maxAge: int
<span class="w"> </span>        :param maxAge:  The number of seconds before a session expires
<span class="w"> </span>            from the cache.  The default is 14400 (i.e. 4 hours).&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.lock = threading.Lock()
<span class="gi">+</span>
<span class="gi">+        # Maps sessionIDs to sessions</span>
<span class="w"> </span>        self.entriesDict = {}
<span class="gd">-        self.entriesList = [(None, None)] * maxEntries</span>
<span class="gi">+</span>
<span class="gi">+        #Circular list of (sessionID, timestamp) pairs</span>
<span class="gi">+        self.entriesList = [(None,None)] * maxEntries</span>
<span class="gi">+</span>
<span class="w"> </span>        self.firstIndex = 0
<span class="w"> </span>        self.lastIndex = 0
<span class="w"> </span>        self.maxAge = maxAge
<span class="gu">@@ -35,8 +53,14 @@ class SessionCache(object):</span>
<span class="w"> </span>    def __getitem__(self, sessionID):
<span class="w"> </span>        self.lock.acquire()
<span class="w"> </span>        try:
<span class="gd">-            self._purge()</span>
<span class="gi">+            self._purge() #Delete old items, so we&#39;re assured of a new one</span>
<span class="w"> </span>            session = self.entriesDict[bytes(sessionID)]
<span class="gi">+</span>
<span class="gi">+            #When we add sessions they&#39;re resumable, but it&#39;s possible</span>
<span class="gi">+            #for the session to be invalidated later on (if a fatal alert</span>
<span class="gi">+            #is returned), so we have to check for resumability before</span>
<span class="gi">+            #returning the session.</span>
<span class="gi">+</span>
<span class="w"> </span>            if session.valid():
<span class="w"> </span>                return session
<span class="w"> </span>            else:
<span class="gu">@@ -44,14 +68,36 @@ class SessionCache(object):</span>
<span class="w"> </span>        finally:
<span class="w"> </span>            self.lock.release()

<span class="gi">+</span>
<span class="w"> </span>    def __setitem__(self, sessionID, session):
<span class="w"> </span>        self.lock.acquire()
<span class="w"> </span>        try:
<span class="gi">+            #Add the new element</span>
<span class="w"> </span>            self.entriesDict[bytes(sessionID)] = session
<span class="gd">-            self.entriesList[self.lastIndex] = bytes(sessionID), time.time()</span>
<span class="gd">-            self.lastIndex = (self.lastIndex + 1) % len(self.entriesList)</span>
<span class="gi">+            self.entriesList[self.lastIndex] = (bytes(sessionID), time.time())</span>
<span class="gi">+            self.lastIndex = (self.lastIndex+1) % len(self.entriesList)</span>
<span class="gi">+</span>
<span class="gi">+            #If the cache is full, we delete the oldest element to make an</span>
<span class="gi">+            #empty space</span>
<span class="w"> </span>            if self.lastIndex == self.firstIndex:
<span class="gd">-                del self.entriesDict[self.entriesList[self.firstIndex][0]]</span>
<span class="gd">-                self.firstIndex = (self.firstIndex + 1) % len(self.entriesList)</span>
<span class="gi">+                del(self.entriesDict[self.entriesList[self.firstIndex][0]])</span>
<span class="gi">+                self.firstIndex = (self.firstIndex+1) % len(self.entriesList)</span>
<span class="w"> </span>        finally:
<span class="w"> </span>            self.lock.release()
<span class="gi">+</span>
<span class="gi">+    #Delete expired items</span>
<span class="gi">+    def _purge(self):</span>
<span class="gi">+        currentTime = time.time()</span>
<span class="gi">+</span>
<span class="gi">+        #Search through the circular list, deleting expired elements until</span>
<span class="gi">+        #we reach a non-expired element.  Since elements in list are</span>
<span class="gi">+        #ordered in time, we can break once we reach the first non-expired</span>
<span class="gi">+        #element</span>
<span class="gi">+        index = self.firstIndex</span>
<span class="gi">+        while index != self.lastIndex:</span>
<span class="gi">+            if currentTime - self.entriesList[index][1] &gt; self.maxAge:</span>
<span class="gi">+                del(self.entriesDict[self.entriesList[index][0]])</span>
<span class="gi">+                index = (index+1) % len(self.entriesList)</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        self.firstIndex = index</span>
<span class="gh">diff --git a/tlslite/signed.py b/tlslite/signed.py</span>
<span class="gh">index 20048da..97c1fc2 100644</span>
<span class="gd">--- a/tlslite/signed.py</span>
<span class="gi">+++ b/tlslite/signed.py</span>
<span class="gu">@@ -1,34 +1,87 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Base class that represents any signed object&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .utils.cryptomath import numBytes
<span class="gd">-RSA_SIGNATURE_HASHES = [&#39;sha512&#39;, &#39;sha384&#39;, &#39;sha256&#39;, &#39;sha224&#39;, &#39;sha1&#39;]</span>
<span class="gd">-ALL_RSA_SIGNATURE_HASHES = RSA_SIGNATURE_HASHES + [&#39;md5&#39;]</span>
<span class="gd">-RSA_SCHEMES = [&#39;pss&#39;, &#39;pkcs1&#39;]</span>

<span class="gi">+RSA_SIGNATURE_HASHES = [&quot;sha512&quot;, &quot;sha384&quot;, &quot;sha256&quot;, &quot;sha224&quot;, &quot;sha1&quot;]</span>
<span class="gi">+ALL_RSA_SIGNATURE_HASHES = RSA_SIGNATURE_HASHES + [&quot;md5&quot;]</span>
<span class="gi">+RSA_SCHEMES = [&quot;pss&quot;, &quot;pkcs1&quot;]</span>

<span class="gd">-class SignatureSettings(object):</span>

<span class="gd">-    def __init__(self, min_key_size=None, max_key_size=None, rsa_sig_hashes</span>
<span class="gd">-        =None, rsa_schemes=None):</span>
<span class="gi">+class SignatureSettings(object):</span>
<span class="gi">+    def __init__(self, min_key_size=None, max_key_size=None,</span>
<span class="gi">+                 rsa_sig_hashes=None, rsa_schemes=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create default variables for key-related settings.&quot;&quot;&quot;
<span class="w"> </span>        self.min_key_size = min_key_size or 1023
<span class="w"> </span>        self.max_key_size = max_key_size or 8193
<span class="w"> </span>        self.rsa_sig_hashes = rsa_sig_hashes or list(RSA_SIGNATURE_HASHES)
<span class="w"> </span>        self.rsa_schemes = rsa_schemes or list(RSA_SCHEMES)

<span class="gi">+    def _copy_settings(self, other):</span>
<span class="gi">+        other.min_key_size = self.min_key_size</span>
<span class="gi">+        other.max_key_size = self.max_key_size</span>
<span class="gi">+        other.rsa_sig_hashes = self.rsa_sig_hashes</span>
<span class="gi">+        other.rsa_schemes = self.rsa_schemes</span>

<span class="gd">-class SignedObject(object):</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _sanityCheckKeySizes(other):</span>
<span class="gi">+        if other.min_key_size &lt; 512:</span>
<span class="gi">+            raise ValueError(&quot;min_key_size too small&quot;)</span>
<span class="gi">+        if other.min_key_size &gt; 16384:</span>
<span class="gi">+            raise ValueError(&quot;min_key_size too large&quot;)</span>
<span class="gi">+        if other.max_key_size &lt; 512:</span>
<span class="gi">+            raise ValueError(&quot;max_key_size too small&quot;)</span>
<span class="gi">+        if other.max_key_size &gt; 16384:</span>
<span class="gi">+            raise ValueError(&quot;max_key_size too large&quot;)</span>
<span class="gi">+        if other.max_key_size &lt; other.min_key_size:</span>
<span class="gi">+            raise ValueError(&quot;max_key_size smaller than min_key_size&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _sanityCheckSignatureAlgs(other):</span>
<span class="gi">+        not_allowed = [alg for alg in other.rsa_sig_hashes</span>
<span class="gi">+                       if alg not in ALL_RSA_SIGNATURE_HASHES]</span>
<span class="gi">+        if len(not_allowed) &gt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Following signature algorithms are not allowed: &quot;</span>
<span class="gi">+                             &quot;{0}&quot;.format(&quot;, &quot;.join(not_allowed)))</span>
<span class="gi">+</span>
<span class="gi">+    def validate(self):</span>
<span class="gi">+        other = SignatureSettings()</span>
<span class="gi">+        self._copy_settings(other)</span>
<span class="gi">+        self._sanityCheckKeySizes(other)</span>
<span class="gi">+        self._sanityCheckSignatureAlgs(other)</span>
<span class="gi">+        return other</span>

<span class="gi">+</span>
<span class="gi">+class SignedObject(object):</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.tbs_data = None
<span class="w"> </span>        self.signature = None
<span class="w"> </span>        self.signature_alg = None
<span class="gd">-    _hash_algs_OIDs = {tuple([42, 134, 72, 134, 247, 13, 1, 1, 4]): &#39;md5&#39;,</span>
<span class="gd">-        tuple([42, 134, 72, 134, 247, 13, 1, 1, 5]): &#39;sha1&#39;, tuple([42, 134,</span>
<span class="gd">-        72, 134, 247, 13, 1, 1, 14]): &#39;sha224&#39;, tuple([42, 134, 72, 134, </span>
<span class="gd">-        247, 13, 1, 1, 12]): &#39;sha384&#39;, tuple([42, 134, 72, 134, 247, 13, 1,</span>
<span class="gd">-        1, 11]): &#39;sha256&#39;, tuple([42, 134, 72, 134, 247, 13, 1, 1, 13]):</span>
<span class="gd">-        &#39;sha512&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    _hash_algs_OIDs = {</span>
<span class="gi">+        tuple([0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0x4]): &#39;md5&#39;,</span>
<span class="gi">+        tuple([0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0x5]): &#39;sha1&#39;,</span>
<span class="gi">+        tuple([0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0xe]): &#39;sha224&#39;,</span>
<span class="gi">+        tuple([0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0xc]): &#39;sha384&#39;,</span>
<span class="gi">+        tuple([0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0xb]): &#39;sha256&#39;,</span>
<span class="gi">+        tuple([0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0xd]): &#39;sha512&#39;</span>
<span class="gi">+    }</span>

<span class="w"> </span>    def verify_signature(self, publicKey, settings=None):
<span class="w"> </span>        &quot;&quot;&quot; Verify signature in a reponse&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        offset = 0</span>
<span class="gi">+        settings = settings or SignatureSettings()</span>
<span class="gi">+</span>
<span class="gi">+        # workaround as some signature encodings could be zero left-padded</span>
<span class="gi">+        if (self.signature[0] == 0 and</span>
<span class="gi">+                numBytes(publicKey.n) + 1 == len(self.signature)):</span>
<span class="gi">+            offset = 1</span>
<span class="gi">+</span>
<span class="gi">+        alg = self._hash_algs_OIDs[tuple(self.signature_alg)]</span>
<span class="gi">+        if alg not in settings.rsa_sig_hashes:</span>
<span class="gi">+            raise ValueError(&quot;Invalid signature algorithm: {0}&quot;.format(alg))</span>
<span class="gi">+        verified = publicKey.hashAndVerify(self.signature[offset:],</span>
<span class="gi">+                                           self.tbs_data, hAlg=alg)</span>
<span class="gi">+        if not verified:</span>
<span class="gi">+            raise ValueError(&quot;Signature could not be verified for {0}&quot;</span>
<span class="gi">+                             .format(alg))</span>
<span class="gi">+        return True</span>
<span class="gh">diff --git a/tlslite/tlsconnection.py b/tlslite/tlsconnection.py</span>
<span class="gh">index 73f8e07..587556f 100644</span>
<span class="gd">--- a/tlslite/tlsconnection.py</span>
<span class="gi">+++ b/tlslite/tlsconnection.py</span>
<span class="gu">@@ -1,6 +1,20 @@</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Google - added reqCAs parameter</span>
<span class="gi">+#   Google (adapted by Sam Rushing and Marcelo Fernandez) - NPN support</span>
<span class="gi">+#   Google - FALLBACK_SCSV</span>
<span class="gi">+#   Dimitris Moraitis - Anon ciphersuites</span>
<span class="gi">+#   Martin von Loewis - python 3 port</span>
<span class="gi">+#   Yngve Pettersen (ported by Paul Sokolovsky) - TLS 1.2</span>
<span class="gi">+#   Hubert Kario - complete refactoring of key exchange methods, addition</span>
<span class="gi">+#          of ECDH support</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>MAIN CLASS FOR TLS LITE (START HERE!).
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import division
<span class="w"> </span>import time
<span class="w"> </span>import socket
<span class="gu">@@ -19,10 +33,12 @@ from .handshakesettings import HandshakeSettings, KNOWN_VERSIONS, CURVE_ALIASES</span>
<span class="w"> </span>from .handshakehashes import HandshakeHashes
<span class="w"> </span>from .utils.tackwrapper import *
<span class="w"> </span>from .utils.deprecations import deprecated_params
<span class="gd">-from .keyexchange import KeyExchange, RSAKeyExchange, DHE_RSAKeyExchange, ECDHE_RSAKeyExchange, SRPKeyExchange, ADHKeyExchange, AECDHKeyExchange, FFDHKeyExchange, ECDHKeyExchange</span>
<span class="gi">+from .keyexchange import KeyExchange, RSAKeyExchange, DHE_RSAKeyExchange, \</span>
<span class="gi">+        ECDHE_RSAKeyExchange, SRPKeyExchange, ADHKeyExchange, \</span>
<span class="gi">+        AECDHKeyExchange, FFDHKeyExchange, ECDHKeyExchange</span>
<span class="w"> </span>from .handshakehelpers import HandshakeHelpers
<span class="gd">-from .utils.cipherfactory import createAESCCM, createAESCCM_8, createAESGCM, createCHACHA20</span>
<span class="gd">-</span>
<span class="gi">+from .utils.cipherfactory import createAESCCM, createAESCCM_8, \</span>
<span class="gi">+        createAESGCM, createCHACHA20</span>

<span class="w"> </span>class TLSConnection(TLSRecordLayer):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -64,7 +80,10 @@ class TLSConnection(TLSRecordLayer):</span>
<span class="w"> </span>        self._clientRandom = bytearray(0)
<span class="w"> </span>        self._serverRandom = bytearray(0)
<span class="w"> </span>        self.next_proto = None
<span class="gi">+        # whether the CCS was already sent in the connection (for hello retry)</span>
<span class="w"> </span>        self._ccs_sent = False
<span class="gi">+        # if and how big is the limit on records peer is willing to accept</span>
<span class="gi">+        # used only for TLS 1.2 and earlier</span>
<span class="w"> </span>        self._peer_record_size_limit = None
<span class="w"> </span>        self._pha_supported = False

<span class="gu">@@ -77,12 +96,45 @@ class TLSConnection(TLSRecordLayer):</span>
<span class="w"> </span>        :type length: int
<span class="w"> </span>        :param length: number of bytes of the keying material to export
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if label in (b&#39;server finished&#39;, b&#39;client finished&#39;,</span>
<span class="gi">+                     b&#39;master secret&#39;, b&#39;key expansion&#39;):</span>
<span class="gi">+            raise ValueError(&quot;Forbidden label value&quot;)</span>
<span class="gi">+        if self.version &lt; (3, 1):</span>
<span class="gi">+            raise ValueError(&quot;Supported only in TLSv1.0 and later&quot;)</span>
<span class="gi">+        elif self.version &lt; (3, 3):</span>
<span class="gi">+            return PRF(self.session.masterSecret, label,</span>
<span class="gi">+                       self._clientRandom + self._serverRandom,</span>
<span class="gi">+                       length)</span>
<span class="gi">+        elif self.version == (3, 3):</span>
<span class="gi">+            if self.session.cipherSuite in CipherSuite.sha384PrfSuites:</span>
<span class="gi">+                return PRF_1_2_SHA384(self.session.masterSecret, label,</span>
<span class="gi">+                                      self._clientRandom + self._serverRandom,</span>
<span class="gi">+                                      length)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return PRF_1_2(self.session.masterSecret, label,</span>
<span class="gi">+                               self._clientRandom + self._serverRandom,</span>
<span class="gi">+                               length)</span>
<span class="gi">+        elif self.version == (3, 4):</span>
<span class="gi">+            prf = &#39;sha256&#39;</span>
<span class="gi">+            if self.session.cipherSuite in CipherSuite.sha384PrfSuites:</span>
<span class="gi">+                prf = &#39;sha384&#39;</span>
<span class="gi">+            secret = derive_secret(self.session.exporterMasterSecret, label,</span>
<span class="gi">+                                   None, prf)</span>
<span class="gi">+            ctxhash = secureHash(bytearray(b&#39;&#39;), prf)</span>
<span class="gi">+            return HKDF_expand_label(secret, b&quot;exporter&quot;, ctxhash, length, prf)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError(&quot;Unknown protocol version&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    #*********************************************************</span>
<span class="gi">+    # Client Handshake Functions</span>
<span class="gi">+    #*********************************************************</span>

<span class="gd">-    @deprecated_params({&#39;async_&#39;: &#39;async&#39;},</span>
<span class="gd">-        &quot;&#39;{old_name}&#39; is a keyword in Python 3.7, use&#39;{new_name}&#39;&quot;)</span>
<span class="gd">-    def handshakeClientAnonymous(self, session=None, settings=None, checker</span>
<span class="gd">-        =None, serverName=None, async_=False):</span>
<span class="gi">+    @deprecated_params({&quot;async_&quot;: &quot;async&quot;},</span>
<span class="gi">+                       &quot;&#39;{old_name}&#39; is a keyword in Python 3.7, use&quot;</span>
<span class="gi">+                       &quot;&#39;{new_name}&#39;&quot;)</span>
<span class="gi">+    def handshakeClientAnonymous(self, session=None, settings=None,</span>
<span class="gi">+                                 checker=None, serverName=None,</span>
<span class="gi">+                                 async_=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform an anonymous handshake in the role of client.

<span class="w"> </span>        This function performs an SSL or TLS handshake using an
<span class="gu">@@ -135,12 +187,23 @@ class TLSConnection(TLSRecordLayer):</span>
<span class="w"> </span>        :raises tlslite.errors.TLSAuthenticationError: If the checker
<span class="w"> </span>            doesn&#39;t like the other party&#39;s authentication credentials.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        handshaker = self._handshakeClientAsync(anonParams=(True),</span>
<span class="gi">+                                                session=session,</span>
<span class="gi">+                                                settings=settings,</span>
<span class="gi">+                                                checker=checker,</span>
<span class="gi">+                                                serverName=serverName)</span>
<span class="gi">+        if async_:</span>
<span class="gi">+            return handshaker</span>
<span class="gi">+        for result in handshaker:</span>
<span class="gi">+            pass</span>

<span class="gd">-    @deprecated_params({&#39;async_&#39;: &#39;async&#39;},</span>
<span class="gd">-        &quot;&#39;{old_name}&#39; is a keyword in Python 3.7, use&#39;{new_name}&#39;&quot;)</span>
<span class="gd">-    def handshakeClientSRP(self, username, password, session=None, settings</span>
<span class="gd">-        =None, checker=None, reqTack=True, serverName=None, async_=False):</span>
<span class="gi">+    @deprecated_params({&quot;async_&quot;: &quot;async&quot;},</span>
<span class="gi">+                       &quot;&#39;{old_name}&#39; is a keyword in Python 3.7, use&quot;</span>
<span class="gi">+                       &quot;&#39;{new_name}&#39;&quot;)</span>
<span class="gi">+    def handshakeClientSRP(self, username, password, session=None,</span>
<span class="gi">+                           settings=None, checker=None,</span>
<span class="gi">+                           reqTack=True, serverName=None,</span>
<span class="gi">+                           async_=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform an SRP handshake in the role of client.

<span class="w"> </span>        This function performs a TLS/SRP handshake.  SRP mutually
<span class="gu">@@ -204,13 +267,33 @@ class TLSConnection(TLSRecordLayer):</span>
<span class="w"> </span>        :raises tlslite.errors.TLSAuthenticationError: If the checker
<span class="w"> </span>            doesn&#39;t like the other party&#39;s authentication credentials.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO add deprecation warning</span>
<span class="gi">+        if isinstance(username, str):</span>
<span class="gi">+            username = bytearray(username, &#39;utf-8&#39;)</span>
<span class="gi">+        if isinstance(password, str):</span>
<span class="gi">+            password = bytearray(password, &#39;utf-8&#39;)</span>
<span class="gi">+        handshaker = self._handshakeClientAsync(srpParams=(username, password),</span>
<span class="gi">+                        session=session, settings=settings, checker=checker,</span>
<span class="gi">+                        reqTack=reqTack, serverName=serverName)</span>
<span class="gi">+        # The handshaker is a Python Generator which executes the handshake.</span>
<span class="gi">+        # It allows the handshake to be run in a &quot;piecewise&quot;, asynchronous</span>
<span class="gi">+        # fashion, returning 1 when it is waiting to able to write, 0 when</span>
<span class="gi">+        # it is waiting to read.</span>
<span class="gi">+        #</span>
<span class="gi">+        # If &#39;async_&#39; is True, the generator is returned to the caller,</span>
<span class="gi">+        # otherwise it is executed to completion here.</span>
<span class="gi">+        if async_:</span>
<span class="gi">+            return handshaker</span>
<span class="gi">+        for result in handshaker:</span>
<span class="gi">+            pass</span>

<span class="gd">-    @deprecated_params({&#39;async_&#39;: &#39;async&#39;},</span>
<span class="gd">-        &quot;&#39;{old_name}&#39; is a keyword in Python 3.7, use&#39;{new_name}&#39;&quot;)</span>
<span class="gd">-    def handshakeClientCert(self, certChain=None, privateKey=None, session=</span>
<span class="gd">-        None, settings=None, checker=None, nextProtos=None, reqTack=True,</span>
<span class="gd">-        serverName=None, async_=False, alpn=None):</span>
<span class="gi">+    @deprecated_params({&quot;async_&quot;: &quot;async&quot;},</span>
<span class="gi">+                       &quot;&#39;{old_name}&#39; is a keyword in Python 3.7, use&quot;</span>
<span class="gi">+                       &quot;&#39;{new_name}&#39;&quot;)</span>
<span class="gi">+    def handshakeClientCert(self, certChain=None, privateKey=None,</span>
<span class="gi">+                            session=None, settings=None, checker=None,</span>
<span class="gi">+                            nextProtos=None, reqTack=True, serverName=None,</span>
<span class="gi">+                            async_=False, alpn=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform a certificate-based handshake in the role of client.

<span class="w"> </span>        This function performs an SSL or TLS handshake.  The server
<span class="gu">@@ -291,34 +374,1502 @@ class TLSConnection(TLSRecordLayer):</span>
<span class="w"> </span>        :raises tlslite.errors.TLSAuthenticationError: If the checker
<span class="w"> </span>            doesn&#39;t like the other party&#39;s authentication credentials.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        handshaker = \</span>
<span class="gi">+                self._handshakeClientAsync(certParams=(certChain, privateKey),</span>
<span class="gi">+                                           session=session, settings=settings,</span>
<span class="gi">+                                           checker=checker,</span>
<span class="gi">+                                           serverName=serverName,</span>
<span class="gi">+                                           nextProtos=nextProtos,</span>
<span class="gi">+                                           reqTack=reqTack,</span>
<span class="gi">+                                           alpn=alpn)</span>
<span class="gi">+        # The handshaker is a Python Generator which executes the handshake.</span>
<span class="gi">+        # It allows the handshake to be run in a &quot;piecewise&quot;, asynchronous</span>
<span class="gi">+        # fashion, returning 1 when it is waiting to able to write, 0 when</span>
<span class="gi">+        # it is waiting to read.</span>
<span class="gi">+        #</span>
<span class="gi">+        # If &#39;async_&#39; is True, the generator is returned to the caller,</span>
<span class="gi">+        # otherwise it is executed to completion here.</span>
<span class="gi">+        if async_:</span>
<span class="gi">+            return handshaker</span>
<span class="gi">+        for result in handshaker:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def _handshakeClientAsync(self, srpParams=(), certParams=(), anonParams=(),</span>
<span class="gi">+                              session=None, settings=None, checker=None,</span>
<span class="gi">+                              nextProtos=None, serverName=None, reqTack=True,</span>
<span class="gi">+                              alpn=None):</span>
<span class="gi">+</span>
<span class="gi">+        handshaker = self._handshakeClientAsyncHelper(srpParams=srpParams,</span>
<span class="gi">+                certParams=certParams,</span>
<span class="gi">+                anonParams=anonParams,</span>
<span class="gi">+                session=session,</span>
<span class="gi">+                settings=settings,</span>
<span class="gi">+                serverName=serverName,</span>
<span class="gi">+                nextProtos=nextProtos,</span>
<span class="gi">+                reqTack=reqTack,</span>
<span class="gi">+                alpn=alpn)</span>
<span class="gi">+        for result in self._handshakeWrapperAsync(handshaker, checker):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def _handshakeClientAsyncHelper(self, srpParams, certParams, anonParams,</span>
<span class="gi">+                               session, settings, serverName, nextProtos,</span>
<span class="gi">+                               reqTack, alpn):</span>
<span class="gi">+</span>
<span class="gi">+        self._handshakeStart(client=True)</span>
<span class="gi">+</span>
<span class="gi">+        #Unpack parameters</span>
<span class="gi">+        srpUsername = None      # srpParams[0]</span>
<span class="gi">+        password = None         # srpParams[1]</span>
<span class="gi">+        clientCertChain = None  # certParams[0]</span>
<span class="gi">+        privateKey = None       # certParams[1]</span>
<span class="gi">+</span>
<span class="gi">+        # Allow only one of (srpParams, certParams, anonParams)</span>
<span class="gi">+        if srpParams:</span>
<span class="gi">+            assert(not certParams)</span>
<span class="gi">+            assert(not anonParams)</span>
<span class="gi">+            srpUsername, password = srpParams</span>
<span class="gi">+        if certParams:</span>
<span class="gi">+            assert(not srpParams)</span>
<span class="gi">+            assert(not anonParams)</span>
<span class="gi">+            clientCertChain, privateKey = certParams</span>
<span class="gi">+        if anonParams:</span>
<span class="gi">+            assert(not srpParams)</span>
<span class="gi">+            assert(not certParams)</span>
<span class="gi">+</span>
<span class="gi">+        #Validate parameters</span>
<span class="gi">+        if srpUsername and not password:</span>
<span class="gi">+            raise ValueError(&quot;Caller passed a username but no password&quot;)</span>
<span class="gi">+        if password and not srpUsername:</span>
<span class="gi">+            raise ValueError(&quot;Caller passed a password but no username&quot;)</span>
<span class="gi">+        if clientCertChain and not privateKey:</span>
<span class="gi">+            raise ValueError(&quot;Caller passed a cert_chain but no privateKey&quot;)</span>
<span class="gi">+        if privateKey and not clientCertChain:</span>
<span class="gi">+            raise ValueError(&quot;Caller passed a privateKey but no cert_chain&quot;)</span>
<span class="gi">+        if reqTack:</span>
<span class="gi">+            if not tackpyLoaded:</span>
<span class="gi">+                reqTack = False</span>
<span class="gi">+            if not settings or not settings.useExperimentalTackExtension:</span>
<span class="gi">+                reqTack = False</span>
<span class="gi">+        if nextProtos is not None:</span>
<span class="gi">+            if len(nextProtos) == 0:</span>
<span class="gi">+                raise ValueError(&quot;Caller passed no nextProtos&quot;)</span>
<span class="gi">+        if alpn is not None and not alpn:</span>
<span class="gi">+            raise ValueError(&quot;Caller passed empty alpn list&quot;)</span>
<span class="gi">+        # reject invalid hostnames but accept empty/None ones</span>
<span class="gi">+        if serverName and not is_valid_hostname(serverName):</span>
<span class="gi">+            raise ValueError(&quot;Caller provided invalid server host name: {0}&quot;</span>
<span class="gi">+                             .format(serverName))</span>
<span class="gi">+</span>
<span class="gi">+        # Validates the settings and filters out any unsupported ciphers</span>
<span class="gi">+        # or crypto libraries that were requested</span>
<span class="gi">+        if not settings:</span>
<span class="gi">+            settings = HandshakeSettings()</span>
<span class="gi">+        settings = settings.validate()</span>
<span class="gi">+        self.sock.padding_cb = settings.padding_cb</span>
<span class="gi">+</span>
<span class="gi">+        if clientCertChain:</span>
<span class="gi">+            if not isinstance(clientCertChain, X509CertChain):</span>
<span class="gi">+                raise ValueError(&quot;Unrecognized certificate type&quot;)</span>
<span class="gi">+            if &quot;x509&quot; not in settings.certificateTypes:</span>
<span class="gi">+                raise ValueError(&quot;Client certificate doesn&#39;t match &quot;\</span>
<span class="gi">+                                 &quot;Handshake Settings&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if session:</span>
<span class="gi">+            # session.valid() ensures session is resumable and has</span>
<span class="gi">+            # non-empty sessionID</span>
<span class="gi">+            if not session.valid():</span>
<span class="gi">+                session = None #ignore non-resumable sessions...</span>
<span class="gi">+            elif session.resumable:</span>
<span class="gi">+                if session.srpUsername != srpUsername:</span>
<span class="gi">+                    raise ValueError(&quot;Session username doesn&#39;t match&quot;)</span>
<span class="gi">+                if session.serverName != serverName:</span>
<span class="gi">+                    raise ValueError(&quot;Session servername doesn&#39;t match&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        #Add Faults to parameters</span>
<span class="gi">+        if srpUsername and self.fault == Fault.badUsername:</span>
<span class="gi">+            srpUsername += bytearray(b&quot;GARBAGE&quot;)</span>
<span class="gi">+        if password and self.fault == Fault.badPassword:</span>
<span class="gi">+            password += bytearray(b&quot;GARBAGE&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Tentatively set the client&#39;s record version.</span>
<span class="gi">+        # We&#39;ll use this for the ClientHello, and if an error occurs</span>
<span class="gi">+        # parsing the Server Hello, we&#39;ll use this version for the response</span>
<span class="gi">+        # in TLS 1.3 it always needs to be set to TLS 1.0</span>
<span class="gi">+        self.version = \</span>
<span class="gi">+            (3, 1) if settings.maxVersion &gt; (3, 3) else settings.maxVersion</span>
<span class="gi">+</span>
<span class="gi">+        # OK Start sending messages!</span>
<span class="gi">+        # *****************************</span>
<span class="gi">+</span>
<span class="gi">+        # Send the ClientHello.</span>
<span class="gi">+        for result in self._clientSendClientHello(settings, session,</span>
<span class="gi">+                                        srpUsername, srpParams, certParams,</span>
<span class="gi">+                                        anonParams, serverName, nextProtos,</span>
<span class="gi">+                                        reqTack, alpn):</span>
<span class="gi">+            if result in (0,1): yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+        clientHello = result</span>
<span class="gi">+</span>
<span class="gi">+        #Get the ServerHello.</span>
<span class="gi">+        for result in self._clientGetServerHello(settings, session,</span>
<span class="gi">+                                                 clientHello):</span>
<span class="gi">+            if result in (0,1): yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+        serverHello = result</span>
<span class="gi">+        cipherSuite = serverHello.cipher_suite</span>
<span class="gi">+</span>
<span class="gi">+        # Check the serverHello.random  if it includes the downgrade protection</span>
<span class="gi">+        # values as described in RFC8446 section 4.1.3</span>
<span class="gi">+</span>
<span class="gi">+        # For TLS1.3</span>
<span class="gi">+        if (settings.maxVersion &gt; (3, 3) and self.version &lt;= (3, 3)) and \</span>
<span class="gi">+                (serverHello.random[-8:] == TLS_1_2_DOWNGRADE_SENTINEL or</span>
<span class="gi">+                 serverHello.random[-8:] == TLS_1_1_DOWNGRADE_SENTINEL):</span>
<span class="gi">+            for result in self._sendError(AlertDescription.illegal_parameter,</span>
<span class="gi">+                                          &quot;Connection terminated because &quot;</span>
<span class="gi">+                                          &quot;of downgrade protection.&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # For TLS1.2</span>
<span class="gi">+        if settings.maxVersion == (3, 3) and self.version &lt; (3, 3) and \</span>
<span class="gi">+                serverHello.random[-8:] == TLS_1_1_DOWNGRADE_SENTINEL:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.illegal_parameter,</span>
<span class="gi">+                                          &quot;Connection terminated because &quot;</span>
<span class="gi">+                                          &quot;of downgrade protection.&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # if we&#39;re doing tls1.3, use the new code as the negotiation is much</span>
<span class="gi">+        # different</span>
<span class="gi">+        ext = serverHello.getExtension(ExtensionType.supported_versions)</span>
<span class="gi">+        if ext and ext.version &gt; (3, 3):</span>
<span class="gi">+            for result in self._clientTLS13Handshake(settings, session,</span>
<span class="gi">+                                                     clientHello,</span>
<span class="gi">+                                                     clientCertChain,</span>
<span class="gi">+                                                     privateKey,</span>
<span class="gi">+                                                     serverHello):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+            if result in [&quot;finished&quot;, &quot;resumed_and_finished&quot;]:</span>
<span class="gi">+                self._handshakeDone(resumed=(result == &quot;resumed_and_finished&quot;))</span>
<span class="gi">+                self._serverRandom = serverHello.random</span>
<span class="gi">+                self._clientRandom = clientHello.random</span>
<span class="gi">+                return</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise Exception(&quot;unexpected return&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Choose a matching Next Protocol from server list against ours</span>
<span class="gi">+        # (string or None)</span>
<span class="gi">+        nextProto = self._clientSelectNextProto(nextProtos, serverHello)</span>
<span class="gi">+</span>
<span class="gi">+        # Check if server selected encrypt-then-MAC</span>
<span class="gi">+        if serverHello.getExtension(ExtensionType.encrypt_then_mac):</span>
<span class="gi">+            self._recordLayer.encryptThenMAC = True</span>
<span class="gi">+</span>
<span class="gi">+        if serverHello.getExtension(ExtensionType.extended_master_secret):</span>
<span class="gi">+            self.extendedMasterSecret = True</span>
<span class="gi">+</span>
<span class="gi">+        #If the server elected to resume the session, it is handled here.</span>
<span class="gi">+        for result in self._clientResume(session, serverHello,</span>
<span class="gi">+                        clientHello.random,</span>
<span class="gi">+                        nextProto, settings):</span>
<span class="gi">+            if result in (0,1): yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+</span>
<span class="gi">+        if result == &quot;resumed_and_finished&quot;:</span>
<span class="gi">+            self._handshakeDone(resumed=True)</span>
<span class="gi">+            self._serverRandom = serverHello.random</span>
<span class="gi">+            self._clientRandom = clientHello.random</span>
<span class="gi">+            # alpn protocol is independent of resumption and renegotiation</span>
<span class="gi">+            # and needs to be negotiated every time</span>
<span class="gi">+            alpnExt = serverHello.getExtension(ExtensionType.alpn)</span>
<span class="gi">+            if alpnExt:</span>
<span class="gi">+                session.appProto = alpnExt.protocol_names[0]</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        #If the server selected an SRP ciphersuite, the client finishes</span>
<span class="gi">+        #reading the post-ServerHello messages, then derives a</span>
<span class="gi">+        #premasterSecret and sends a corresponding ClientKeyExchange.</span>
<span class="gi">+        if cipherSuite in CipherSuite.srpAllSuites:</span>
<span class="gi">+            keyExchange = SRPKeyExchange(cipherSuite, clientHello,</span>
<span class="gi">+                                         serverHello, None, None,</span>
<span class="gi">+                                         srpUsername=srpUsername,</span>
<span class="gi">+                                         password=password,</span>
<span class="gi">+                                         settings=settings)</span>
<span class="gi">+</span>
<span class="gi">+        #If the server selected an anonymous ciphersuite, the client</span>
<span class="gi">+        #finishes reading the post-ServerHello messages.</span>
<span class="gi">+        elif cipherSuite in CipherSuite.dhAllSuites:</span>
<span class="gi">+            keyExchange = DHE_RSAKeyExchange(cipherSuite, clientHello,</span>
<span class="gi">+                                             serverHello, None)</span>
<span class="gi">+</span>
<span class="gi">+        elif cipherSuite in CipherSuite.ecdhAllSuites:</span>
<span class="gi">+            acceptedCurves = self._curveNamesToList(settings)</span>
<span class="gi">+            keyExchange = ECDHE_RSAKeyExchange(cipherSuite, clientHello,</span>
<span class="gi">+                                               serverHello, None,</span>
<span class="gi">+                                               acceptedCurves)</span>
<span class="gi">+</span>
<span class="gi">+        #If the server selected a certificate-based RSA ciphersuite,</span>
<span class="gi">+        #the client finishes reading the post-ServerHello messages. If</span>
<span class="gi">+        #a CertificateRequest message was sent, the client responds with</span>
<span class="gi">+        #a Certificate message containing its certificate chain (if any),</span>
<span class="gi">+        #and also produces a CertificateVerify message that signs the</span>
<span class="gi">+        #ClientKeyExchange.</span>
<span class="gi">+        else:</span>
<span class="gi">+            keyExchange = RSAKeyExchange(cipherSuite, clientHello,</span>
<span class="gi">+                                         serverHello, None)</span>
<span class="gi">+</span>
<span class="gi">+        # we&#39;ll send few messages here, send them in single TCP packet</span>
<span class="gi">+        self.sock.buffer_writes = True</span>
<span class="gi">+        for result in self._clientKeyExchange(settings, cipherSuite,</span>
<span class="gi">+                                              clientCertChain,</span>
<span class="gi">+                                              privateKey,</span>
<span class="gi">+                                              serverHello.certificate_type,</span>
<span class="gi">+                                              serverHello.tackExt,</span>
<span class="gi">+                                              clientHello.random,</span>
<span class="gi">+                                              serverHello.random,</span>
<span class="gi">+                                              keyExchange):</span>
<span class="gi">+            if result in (0, 1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+        (premasterSecret, serverCertChain, clientCertChain,</span>
<span class="gi">+         tackExt) = result</span>
<span class="gi">+</span>
<span class="gi">+        #After having previously sent a ClientKeyExchange, the client now</span>
<span class="gi">+        #initiates an exchange of Finished messages.</span>
<span class="gi">+        # socket buffering is turned off in _clientFinished</span>
<span class="gi">+        for result in self._clientFinished(premasterSecret,</span>
<span class="gi">+                            clientHello.random,</span>
<span class="gi">+                            serverHello.random,</span>
<span class="gi">+                            cipherSuite, settings.cipherImplementations,</span>
<span class="gi">+                            nextProto, settings):</span>
<span class="gi">+                if result in (0,1): yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+        masterSecret = result</span>
<span class="gi">+</span>
<span class="gi">+        # check if an application layer protocol was negotiated</span>
<span class="gi">+        alpnProto = None</span>
<span class="gi">+        alpnExt = serverHello.getExtension(ExtensionType.alpn)</span>
<span class="gi">+        if alpnExt:</span>
<span class="gi">+            alpnProto = alpnExt.protocol_names[0]</span>
<span class="gi">+</span>
<span class="gi">+        # Create the session object which is used for resumptions</span>
<span class="gi">+        self.session = Session()</span>
<span class="gi">+        self.session.create(masterSecret, serverHello.session_id, cipherSuite,</span>
<span class="gi">+                            srpUsername, clientCertChain, serverCertChain,</span>
<span class="gi">+                            tackExt, (serverHello.tackExt is not None),</span>
<span class="gi">+                            serverName,</span>
<span class="gi">+                            encryptThenMAC=self._recordLayer.encryptThenMAC,</span>
<span class="gi">+                            extendedMasterSecret=self.extendedMasterSecret,</span>
<span class="gi">+                            appProto=alpnProto,</span>
<span class="gi">+                            # NOTE it must be a reference not a copy</span>
<span class="gi">+                            tickets=self.tickets,</span>
<span class="gi">+                            tls_1_0_tickets=self.tls_1_0_tickets)</span>
<span class="gi">+        self._handshakeDone(resumed=False)</span>
<span class="gi">+        self._serverRandom = serverHello.random</span>
<span class="gi">+        self._clientRandom = clientHello.random</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def _clientSendClientHello(self, settings, session, srpUsername,</span>
<span class="gi">+                                srpParams, certParams, anonParams,</span>
<span class="gi">+                                serverName, nextProtos, reqTack, alpn):</span>
<span class="gi">+        #Initialize acceptable ciphersuites</span>
<span class="gi">+        cipherSuites = [CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV]</span>
<span class="gi">+        if srpParams:</span>
<span class="gi">+            cipherSuites += CipherSuite.getSrpAllSuites(settings)</span>
<span class="gi">+        elif certParams:</span>
<span class="gi">+            cipherSuites += CipherSuite.getTLS13Suites(settings)</span>
<span class="gi">+            cipherSuites += CipherSuite.getEcdsaSuites(settings)</span>
<span class="gi">+            cipherSuites += CipherSuite.getEcdheCertSuites(settings)</span>
<span class="gi">+            cipherSuites += CipherSuite.getDheCertSuites(settings)</span>
<span class="gi">+            cipherSuites += CipherSuite.getCertSuites(settings)</span>
<span class="gi">+            cipherSuites += CipherSuite.getDheDsaSuites(settings)</span>
<span class="gi">+        elif anonParams:</span>
<span class="gi">+            cipherSuites += CipherSuite.getEcdhAnonSuites(settings)</span>
<span class="gi">+            cipherSuites += CipherSuite.getAnonSuites(settings)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert False</span>
<span class="gi">+</span>
<span class="gi">+        #Add any SCSVs. These are not real cipher suites, but signaling</span>
<span class="gi">+        #values which reuse the cipher suite field in the ClientHello.</span>
<span class="gi">+        wireCipherSuites = list(cipherSuites)</span>
<span class="gi">+        if settings.sendFallbackSCSV:</span>
<span class="gi">+            wireCipherSuites.append(CipherSuite.TLS_FALLBACK_SCSV)</span>
<span class="gi">+</span>
<span class="gi">+        #Initialize acceptable certificate types</span>
<span class="gi">+        certificateTypes = settings.getCertificateTypes()</span>
<span class="gi">+</span>
<span class="gi">+        extensions = []</span>
<span class="gi">+</span>
<span class="gi">+        #Initialize TLS extensions</span>
<span class="gi">+        if settings.useEncryptThenMAC:</span>
<span class="gi">+            extensions.append(TLSExtension().\</span>
<span class="gi">+                              create(ExtensionType.encrypt_then_mac,</span>
<span class="gi">+                                     bytearray(0)))</span>
<span class="gi">+        if settings.useExtendedMasterSecret:</span>
<span class="gi">+            extensions.append(TLSExtension().create(ExtensionType.</span>
<span class="gi">+                                                    extended_master_secret,</span>
<span class="gi">+                                                    bytearray(0)))</span>
<span class="gi">+        # In TLS1.2 advertise support for additional signature types</span>
<span class="gi">+        if settings.maxVersion &gt;= (3, 3):</span>
<span class="gi">+            sigList = self._sigHashesToList(settings)</span>
<span class="gi">+            assert len(sigList) &gt; 0</span>
<span class="gi">+            extensions.append(SignatureAlgorithmsExtension().\</span>
<span class="gi">+                              create(sigList))</span>
<span class="gi">+        # if we know any protocols for ALPN, advertise them</span>
<span class="gi">+        if alpn:</span>
<span class="gi">+            extensions.append(ALPNExtension().create(alpn))</span>
<span class="gi">+</span>
<span class="gi">+        session_id = bytearray()</span>
<span class="gi">+        # when TLS 1.3 advertised, add key shares, set fake session_id</span>
<span class="gi">+        shares = None</span>
<span class="gi">+        if next((i for i in settings.versions if i &gt; (3, 3)), None):</span>
<span class="gi">+            # if we have a client cert configured, do indicate we&#39;re willing</span>
<span class="gi">+            # to perform Post Handshake Authentication</span>
<span class="gi">+            if certParams and certParams[1]:</span>
<span class="gi">+                extensions.append(TLSExtension(</span>
<span class="gi">+                    extType=ExtensionType.post_handshake_auth).</span>
<span class="gi">+                    create(bytearray(b&#39;&#39;)))</span>
<span class="gi">+                self._client_keypair = certParams</span>
<span class="gi">+</span>
<span class="gi">+            # fake session_id for middlebox compatibility mode</span>
<span class="gi">+            session_id = getRandomBytes(32)</span>
<span class="gi">+</span>
<span class="gi">+            extensions.append(SupportedVersionsExtension().</span>
<span class="gi">+                              create(settings.versions))</span>
<span class="gi">+</span>
<span class="gi">+            shares = []</span>
<span class="gi">+            for group_name in settings.keyShares:</span>
<span class="gi">+                group_id = getattr(GroupName, group_name)</span>
<span class="gi">+                key_share = self._genKeyShareEntry(group_id, (3, 4))</span>
<span class="gi">+</span>
<span class="gi">+                shares.append(key_share)</span>
<span class="gi">+            # if TLS 1.3 is enabled, key_share must always be sent</span>
<span class="gi">+            # (unless only static PSK is used)</span>
<span class="gi">+            extensions.append(ClientKeyShareExtension().create(shares))</span>
<span class="gi">+</span>
<span class="gi">+            # add info on types of PSKs supported (also used for</span>
<span class="gi">+            # NewSessionTicket so send basically always)</span>
<span class="gi">+            ext = PskKeyExchangeModesExtension().create(</span>
<span class="gi">+                [getattr(PskKeyExchangeMode, i) for i in settings.psk_modes])</span>
<span class="gi">+            extensions.append(ext)</span>
<span class="gi">+</span>
<span class="gi">+        groups = []</span>
<span class="gi">+        #Send the ECC extensions only if we advertise ECC ciphers</span>
<span class="gi">+        if next((cipher for cipher in cipherSuites \</span>
<span class="gi">+                if cipher in CipherSuite.ecdhAllSuites), None) is not None:</span>
<span class="gi">+            groups.extend(self._curveNamesToList(settings))</span>
<span class="gi">+            extensions.append(ECPointFormatsExtension().\</span>
<span class="gi">+                              create([ECPointFormat.uncompressed]))</span>
<span class="gi">+        # Advertise FFDHE groups if we have DHE ciphers</span>
<span class="gi">+        if next((cipher for cipher in cipherSuites</span>
<span class="gi">+                 if cipher in CipherSuite.dhAllSuites), None) is not None:</span>
<span class="gi">+            groups.extend(self._groupNamesToList(settings))</span>
<span class="gi">+        # Send the extension only if it will be non empty</span>
<span class="gi">+        if groups:</span>
<span class="gi">+            if shares:</span>
<span class="gi">+                # put the groups used for key shares first, and in order</span>
<span class="gi">+                # (req. from RFC 8446, section 4.2.8)</span>
<span class="gi">+                share_ids = [i.group for i in shares]</span>
<span class="gi">+                diff = set(groups) - set(share_ids)</span>
<span class="gi">+                groups = share_ids + [i for i in groups if i in diff]</span>
<span class="gi">+            extensions.append(SupportedGroupsExtension().create(groups))</span>
<span class="gi">+</span>
<span class="gi">+        if settings.use_heartbeat_extension:</span>
<span class="gi">+            extensions.append(HeartbeatExtension().create(</span>
<span class="gi">+                HeartbeatMode.PEER_ALLOWED_TO_SEND))</span>
<span class="gi">+            self.heartbeat_can_receive = True</span>
<span class="gi">+</span>
<span class="gi">+        if settings.record_size_limit:</span>
<span class="gi">+            extensions.append(RecordSizeLimitExtension().create(</span>
<span class="gi">+                settings.record_size_limit))</span>
<span class="gi">+</span>
<span class="gi">+        # If SessionTicket support is enabled and we have a valid ticket, we</span>
<span class="gi">+        # send it in an attempt to resume the session, if SessionTicket support</span>
<span class="gi">+        # is enabled but we don&#39;t have a valid ticket, we send an empty ext</span>
<span class="gi">+        # to indicate support for the feaure</span>
<span class="gi">+        if session and session.tls_1_0_tickets:</span>
<span class="gi">+            # first get rid of expired tickets</span>
<span class="gi">+            session.tls_1_0_tickets[:] = [</span>
<span class="gi">+                i for i in session.tls_1_0_tickets if i.valid()]</span>
<span class="gi">+            # then send first ticket</span>
<span class="gi">+            for cached_ticket in session.tls_1_0_tickets:</span>
<span class="gi">+                extensions.append(SessionTicketExtension().create(</span>
<span class="gi">+                    cached_ticket.ticket))</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                # or just advertise that we support session resumption</span>
<span class="gi">+                extensions.append(SessionTicketExtension().create(</span>
<span class="gi">+                    bytearray(0)))</span>
<span class="gi">+        else:</span>
<span class="gi">+            extensions.append(SessionTicketExtension().create(</span>
<span class="gi">+                bytearray(0)))</span>
<span class="gi">+</span>
<span class="gi">+        # don&#39;t send empty list of extensions or extensions in SSLv3</span>
<span class="gi">+        if not extensions or settings.maxVersion == (3, 0):</span>
<span class="gi">+            extensions = None</span>
<span class="gi">+</span>
<span class="gi">+        sent_version = min(settings.maxVersion, (3, 3))</span>
<span class="gi">+</span>
<span class="gi">+        #Either send ClientHello (with a resumable session)...</span>
<span class="gi">+        if session and session.sessionID:</span>
<span class="gi">+            #If it&#39;s resumable, then its</span>
<span class="gi">+            #ciphersuite must be one of the acceptable ciphersuites</span>
<span class="gi">+            if session.cipherSuite not in cipherSuites:</span>
<span class="gi">+                raise ValueError(&quot;Session&#39;s cipher suite not consistent &quot;\</span>
<span class="gi">+                                 &quot;with parameters&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                clientHello = ClientHello()</span>
<span class="gi">+                clientHello.create(sent_version, getRandomBytes(32),</span>
<span class="gi">+                                   session.sessionID, wireCipherSuites,</span>
<span class="gi">+                                   certificateTypes,</span>
<span class="gi">+                                   session.srpUsername,</span>
<span class="gi">+                                   reqTack, nextProtos is not None,</span>
<span class="gi">+                                   session.serverName,</span>
<span class="gi">+                                   extensions=extensions)</span>
<span class="gi">+</span>
<span class="gi">+        #Or send ClientHello (without)</span>
<span class="gi">+        else:</span>
<span class="gi">+            clientHello = ClientHello()</span>
<span class="gi">+            clientHello.create(sent_version, getRandomBytes(32),</span>
<span class="gi">+                               session_id, wireCipherSuites,</span>
<span class="gi">+                               certificateTypes,</span>
<span class="gi">+                               srpUsername,</span>
<span class="gi">+                               reqTack, nextProtos is not None,</span>
<span class="gi">+                               serverName,</span>
<span class="gi">+                               extensions=extensions)</span>
<span class="gi">+</span>
<span class="gi">+        # Check if padding extension should be added</span>
<span class="gi">+        # we want to add extensions even when using just SSLv3</span>
<span class="gi">+        if settings.usePaddingExtension:</span>
<span class="gi">+            HandshakeHelpers.alignClientHelloPadding(clientHello)</span>
<span class="gi">+</span>
<span class="gi">+        # because TLS 1.3 PSK is sent in ClientHello and signs the ClientHello</span>
<span class="gi">+        # we need to send it as the last extension</span>
<span class="gi">+        if (settings.pskConfigs or (session and session.tickets)) \</span>
<span class="gi">+                and settings.maxVersion &gt;= (3, 4):</span>
<span class="gi">+            ext = PreSharedKeyExtension()</span>
<span class="gi">+            idens = []</span>
<span class="gi">+            binders = []</span>
<span class="gi">+            # if we have a previous session, include it in PSKs too</span>
<span class="gi">+            if session and session.tickets:</span>
<span class="gi">+                now = time.time()</span>
<span class="gi">+                # clean the list from obsolete ones</span>
<span class="gi">+                # RFC says that the tickets MUST NOT be cached longer than</span>
<span class="gi">+                # 7 days</span>
<span class="gi">+                session.tickets[:] = (i for i in session.tickets if</span>
<span class="gi">+                                      i.time + i.ticket_lifetime &gt; now and</span>
<span class="gi">+                                      i.time + 7 * 24 * 60 * 60 &gt; now)</span>
<span class="gi">+                if session.tickets:</span>
<span class="gi">+                    ticket = session.tickets[0]</span>
<span class="gi">+</span>
<span class="gi">+                    # ticket.time is in seconds while the obfuscated time</span>
<span class="gi">+                    # is in ms</span>
<span class="gi">+                    ticket_time = int(</span>
<span class="gi">+                        time.time() * 1000 -</span>
<span class="gi">+                        ticket.time * 1000 +</span>
<span class="gi">+                        ticket.ticket_age_add) % 2**32</span>
<span class="gi">+                    idens.append(PskIdentity().create(ticket.ticket,</span>
<span class="gi">+                                                      ticket_time))</span>
<span class="gi">+                    binder_len = 48 if session.cipherSuite in \</span>
<span class="gi">+                        CipherSuite.sha384PrfSuites else 32</span>
<span class="gi">+                    binders.append(bytearray(binder_len))</span>
<span class="gi">+            for psk in settings.pskConfigs:</span>
<span class="gi">+                # skip PSKs with no identities as they&#39;re TLS1.3 incompatible</span>
<span class="gi">+                if not psk[0]:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                idens.append(PskIdentity().create(psk[0], 0))</span>
<span class="gi">+                psk_hash = psk[2] if len(psk) &gt; 2 else &#39;sha256&#39;</span>
<span class="gi">+                assert psk_hash in set([&#39;sha256&#39;, &#39;sha384&#39;])</span>
<span class="gi">+                # create fake binder values to create correct length fields</span>
<span class="gi">+                binders.append(bytearray(32 if psk_hash == &#39;sha256&#39; else 48))</span>
<span class="gi">+</span>
<span class="gi">+            if idens:</span>
<span class="gi">+                ext.create(idens, binders)</span>
<span class="gi">+                clientHello.extensions.append(ext)</span>
<span class="gi">+</span>
<span class="gi">+                # for HRR case we&#39;ll need 1st CH and HRR in handshake hashes,</span>
<span class="gi">+                # so pass them in, truncated CH will be added by the helpers to</span>
<span class="gi">+                # the copy of the hashes</span>
<span class="gi">+                HandshakeHelpers.update_binders(clientHello,</span>
<span class="gi">+                                                self._handshake_hash,</span>
<span class="gi">+                                                settings.pskConfigs,</span>
<span class="gi">+                                                session.tickets if session</span>
<span class="gi">+                                                else None,</span>
<span class="gi">+                                                session.resumptionMasterSecret</span>
<span class="gi">+                                                if session else None)</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._sendMsg(clientHello):</span>
<span class="gi">+            yield result</span>
<span class="gi">+        yield clientHello</span>
<span class="gi">+</span>
<span class="gi">+    def _clientGetServerHello(self, settings, session, clientHello):</span>
<span class="gi">+        client_hello_hash = self._handshake_hash.copy()</span>
<span class="gi">+        for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                   HandshakeType.server_hello):</span>
<span class="gi">+            if result in (0,1): yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+</span>
<span class="gi">+        hello_retry = None</span>
<span class="gi">+        ext = result.getExtension(ExtensionType.supported_versions)</span>
<span class="gi">+        if result.random == TLS_1_3_HRR and ext and ext.version &gt; (3, 3):</span>
<span class="gi">+            self.version = ext.version</span>
<span class="gi">+            hello_retry = result</span>
<span class="gi">+</span>
<span class="gi">+            # create synthetic handshake hash</span>
<span class="gi">+            prf_name, prf_size = self._getPRFParams(hello_retry.cipher_suite)</span>
<span class="gi">+</span>
<span class="gi">+            self._handshake_hash = HandshakeHashes()</span>
<span class="gi">+            writer = Writer()</span>
<span class="gi">+            writer.add(HandshakeType.message_hash, 1)</span>
<span class="gi">+            writer.addVarSeq(client_hello_hash.digest(prf_name), 1, 3)</span>
<span class="gi">+            self._handshake_hash.update(writer.bytes)</span>
<span class="gi">+            self._handshake_hash.update(hello_retry.write())</span>
<span class="gi">+</span>
<span class="gi">+            # check if all extensions in the HRR were present in client hello</span>
<span class="gi">+            ch_ext_types = set(i.extType for i in clientHello.extensions)</span>
<span class="gi">+            ch_ext_types.add(ExtensionType.cookie)</span>
<span class="gi">+</span>
<span class="gi">+            bad_ext = next((i for i in hello_retry.extensions</span>
<span class="gi">+                            if i.extType not in ch_ext_types), None)</span>
<span class="gi">+            if bad_ext:</span>
<span class="gi">+                bad_ext = ExtensionType.toStr(bad_ext)</span>
<span class="gi">+                for result in self._sendError(AlertDescription</span>
<span class="gi">+                                              .unsupported_extension,</span>
<span class="gi">+                                              (&quot;Unexpected extension in HRR: &quot;</span>
<span class="gi">+                                               &quot;{0}&quot;).format(bad_ext)):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+            # handle cookie extension</span>
<span class="gi">+            cookie = hello_retry.getExtension(ExtensionType.cookie)</span>
<span class="gi">+            if cookie:</span>
<span class="gi">+                clientHello.addExtension(cookie)</span>
<span class="gi">+</span>
<span class="gi">+            # handle key share extension</span>
<span class="gi">+            sr_key_share_ext = hello_retry.getExtension(ExtensionType</span>
<span class="gi">+                                                        .key_share)</span>
<span class="gi">+            if sr_key_share_ext:</span>
<span class="gi">+                group_id = sr_key_share_ext.selected_group</span>
<span class="gi">+                # check if group selected by server is valid</span>
<span class="gi">+                groups_ext = clientHello.getExtension(ExtensionType</span>
<span class="gi">+                                                      .supported_groups)</span>
<span class="gi">+                if group_id not in groups_ext.groups:</span>
<span class="gi">+                    for result in self._sendError(AlertDescription</span>
<span class="gi">+                                                  .illegal_parameter,</span>
<span class="gi">+                                                  &quot;Server selected group we &quot;</span>
<span class="gi">+                                                  &quot;did not advertise&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                cl_key_share_ext = clientHello.getExtension(ExtensionType</span>
<span class="gi">+                                                            .key_share)</span>
<span class="gi">+                # check if the server didn&#39;t ask for a group we already sent</span>
<span class="gi">+                if next((entry for entry in cl_key_share_ext.client_shares</span>
<span class="gi">+                         if entry.group == group_id), None):</span>
<span class="gi">+                    for result in self._sendError(AlertDescription</span>
<span class="gi">+                                                  .illegal_parameter,</span>
<span class="gi">+                                                  &quot;Server selected group we &quot;</span>
<span class="gi">+                                                  &quot;did sent the key share &quot;</span>
<span class="gi">+                                                  &quot;for&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                key_share = self._genKeyShareEntry(group_id, (3, 4))</span>
<span class="gi">+</span>
<span class="gi">+                # old key shares need to be removed</span>
<span class="gi">+                cl_key_share_ext.client_shares = [key_share]</span>
<span class="gi">+</span>
<span class="gi">+            if not cookie and not sr_key_share_ext:</span>
<span class="gi">+                # HRR did not result in change to Client Hello</span>
<span class="gi">+                for result in self._sendError(AlertDescription.</span>
<span class="gi">+                                              illegal_parameter,</span>
<span class="gi">+                                              &quot;Received HRR did not cause &quot;</span>
<span class="gi">+                                              &quot;update to Client Hello&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+            if clientHello.session_id != hello_retry.session_id:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Received HRR session_id does not match the one in &quot;</span>
<span class="gi">+                        &quot;ClientHello&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+            ext = clientHello.getExtension(ExtensionType.pre_shared_key)</span>
<span class="gi">+            if ext:</span>
<span class="gi">+                # move the extension to end (in case extension like cookie was</span>
<span class="gi">+                # added</span>
<span class="gi">+                clientHello.extensions.remove(ext)</span>
<span class="gi">+                clientHello.extensions.append(ext)</span>
<span class="gi">+                HandshakeHelpers.update_binders(clientHello,</span>
<span class="gi">+                                                self._handshake_hash,</span>
<span class="gi">+                                                settings.pskConfigs,</span>
<span class="gi">+                                                session.tickets if session</span>
<span class="gi">+                                                else None,</span>
<span class="gi">+                                                session.resumptionMasterSecret</span>
<span class="gi">+                                                if session else None)</span>
<span class="gi">+</span>
<span class="gi">+            # resend the client hello with performed changes</span>
<span class="gi">+            msgs = []</span>
<span class="gi">+            if clientHello.session_id:</span>
<span class="gi">+                ccs = ChangeCipherSpec().create()</span>
<span class="gi">+                msgs.append(ccs)</span>
<span class="gi">+            msgs.append(clientHello)</span>
<span class="gi">+            for result in self._sendMsgs(msgs):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            self._ccs_sent = True</span>
<span class="gi">+</span>
<span class="gi">+            # retry getting server hello</span>
<span class="gi">+            for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                       HandshakeType.server_hello):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        serverHello = result</span>
<span class="gi">+</span>
<span class="gi">+        #Get the server version.  Do this before anything else, so any</span>
<span class="gi">+        #error alerts will use the server&#39;s version</span>
<span class="gi">+        real_version = serverHello.server_version</span>
<span class="gi">+        if serverHello.server_version &gt;= (3, 3):</span>
<span class="gi">+            ext = serverHello.getExtension(ExtensionType.supported_versions)</span>
<span class="gi">+            if ext:</span>
<span class="gi">+                real_version = ext.version</span>
<span class="gi">+        self.version = real_version</span>
<span class="gi">+</span>
<span class="gi">+        #Check ServerHello</span>
<span class="gi">+        if hello_retry and \</span>
<span class="gi">+                hello_retry.cipher_suite != serverHello.cipher_suite:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.illegal_parameter,</span>
<span class="gi">+                                          &quot;server selected different cipher &quot;</span>
<span class="gi">+                                          &quot;in HRR and Server Hello&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        if real_version &lt; settings.minVersion:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.protocol_version,</span>
<span class="gi">+                    &quot;Too old version: {0} (min: {1})&quot;</span>
<span class="gi">+                    .format(real_version, settings.minVersion)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        if real_version &gt; settings.maxVersion and \</span>
<span class="gi">+                real_version not in settings.versions:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.protocol_version,</span>
<span class="gi">+                    &quot;Too new version: {0} (max: {1})&quot;</span>
<span class="gi">+                    .format(real_version, settings.maxVersion)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        if real_version &gt; (3, 3) and \</span>
<span class="gi">+                serverHello.session_id != clientHello.session_id:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.illegal_parameter,</span>
<span class="gi">+                    &quot;Received ServerHello session_id does not match the one &quot;</span>
<span class="gi">+                    &quot;in ClientHello&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        cipherSuites = CipherSuite.filterForVersion(clientHello.cipher_suites,</span>
<span class="gi">+                                                    minVersion=real_version,</span>
<span class="gi">+                                                    maxVersion=real_version)</span>
<span class="gi">+        if serverHello.cipher_suite not in cipherSuites:</span>
<span class="gi">+            for result in self._sendError(\</span>
<span class="gi">+                AlertDescription.illegal_parameter,</span>
<span class="gi">+                &quot;Server responded with incorrect ciphersuite&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        if serverHello.certificate_type not in clientHello.certificate_types:</span>
<span class="gi">+            for result in self._sendError(\</span>
<span class="gi">+                AlertDescription.illegal_parameter,</span>
<span class="gi">+                &quot;Server responded with incorrect certificate type&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        if serverHello.compression_method != 0:</span>
<span class="gi">+            for result in self._sendError(\</span>
<span class="gi">+                AlertDescription.illegal_parameter,</span>
<span class="gi">+                &quot;Server responded with incorrect compression method&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        if serverHello.tackExt:</span>
<span class="gi">+            if not clientHello.tack:</span>
<span class="gi">+                for result in self._sendError(\</span>
<span class="gi">+                    AlertDescription.illegal_parameter,</span>
<span class="gi">+                    &quot;Server responded with unrequested Tack Extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if not serverHello.tackExt.verifySignatures():</span>
<span class="gi">+                for result in self._sendError(\</span>
<span class="gi">+                    AlertDescription.decrypt_error,</span>
<span class="gi">+                    &quot;TackExtension contains an invalid signature&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+        if serverHello.next_protos and not clientHello.supports_npn:</span>
<span class="gi">+            for result in self._sendError(\</span>
<span class="gi">+                AlertDescription.illegal_parameter,</span>
<span class="gi">+                &quot;Server responded with unrequested NPN Extension&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        if not serverHello.getExtension(ExtensionType.extended_master_secret)\</span>
<span class="gi">+            and settings.requireExtendedMasterSecret:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.insufficient_security,</span>
<span class="gi">+                    &quot;Negotiation of Extended master Secret failed&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        alpnExt = serverHello.getExtension(ExtensionType.alpn)</span>
<span class="gi">+        if alpnExt:</span>
<span class="gi">+            if not alpnExt.protocol_names or \</span>
<span class="gi">+                    len(alpnExt.protocol_names) != 1:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Server responded with invalid ALPN extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            clntAlpnExt = clientHello.getExtension(ExtensionType.alpn)</span>
<span class="gi">+            if not clntAlpnExt:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.unsupported_extension,</span>
<span class="gi">+                        &quot;Server sent ALPN extension without one in &quot;</span>
<span class="gi">+                        &quot;client hello&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if alpnExt.protocol_names[0] not in clntAlpnExt.protocol_names:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Server selected ALPN protocol we did not advertise&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+        heartbeat_ext = serverHello.getExtension(ExtensionType.heartbeat)</span>
<span class="gi">+        if heartbeat_ext:</span>
<span class="gi">+            if not settings.use_heartbeat_extension:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.unsupported_extension,</span>
<span class="gi">+                        &quot;Server sent Heartbeat extension without one in &quot;</span>
<span class="gi">+                        &quot;client hello&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if heartbeat_ext.mode == HeartbeatMode.PEER_ALLOWED_TO_SEND and \</span>
<span class="gi">+                    settings.heartbeat_response_callback:</span>
<span class="gi">+                self.heartbeat_can_send = True</span>
<span class="gi">+                self.heartbeat_response_callback = settings.\</span>
<span class="gi">+                    heartbeat_response_callback</span>
<span class="gi">+            elif heartbeat_ext.mode == HeartbeatMode.\</span>
<span class="gi">+                    PEER_NOT_ALLOWED_TO_SEND or not settings.\</span>
<span class="gi">+                    heartbeat_response_callback:</span>
<span class="gi">+                self.heartbeat_can_send = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Server responded with invalid Heartbeat extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            self.heartbeat_supported = True</span>
<span class="gi">+        size_limit_ext = serverHello.getExtension(</span>
<span class="gi">+            ExtensionType.record_size_limit)</span>
<span class="gi">+        if size_limit_ext:</span>
<span class="gi">+            if size_limit_ext.record_size_limit is None:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.decode_error,</span>
<span class="gi">+                        &quot;Malformed record_size_limit extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            # if we got the extension in ServerHello it means we&#39;re doing</span>
<span class="gi">+            # TLS 1.2 so the max value for extension is 2^14</span>
<span class="gi">+            if not 64 &lt;= size_limit_ext.record_size_limit &lt;= 2**14:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Server responed with invalid value in &quot;</span>
<span class="gi">+                        &quot;record_size_limit extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            self._peer_record_size_limit = size_limit_ext.record_size_limit</span>
<span class="gi">+        yield serverHello</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _getKEX(group, version):
<span class="w"> </span>        &quot;&quot;&quot;Get object for performing key exchange.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if group in GroupName.allFF:</span>
<span class="gi">+            return FFDHKeyExchange(group, version)</span>
<span class="gi">+        return ECDHKeyExchange(group, version)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def _genKeyShareEntry(cls, group, version):
<span class="w"> </span>        &quot;&quot;&quot;Generate KeyShareEntry object from randomly selected private value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kex = cls._getKEX(group, version)</span>
<span class="gi">+        private = kex.get_random_private_key()</span>
<span class="gi">+        share = kex.calc_public_value(private)</span>
<span class="gi">+        return KeyShareEntry().create(group, share, private)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _getPRFParams(cipher_suite):
<span class="w"> </span>        &quot;&quot;&quot;Return name of hash used for PRF and the hash output size.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cipher_suite in CipherSuite.sha384PrfSuites:</span>
<span class="gi">+            return &#39;sha384&#39;, 48</span>
<span class="gi">+        return &#39;sha256&#39;, 32</span>

<span class="w"> </span>    def _clientTLS13Handshake(self, settings, session, clientHello,
<span class="gd">-        clientCertChain, privateKey, serverHello):</span>
<span class="gi">+                              clientCertChain, privateKey, serverHello):</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform TLS 1.3 handshake as a client.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prfName, prf_size = self._getPRFParams(serverHello.cipher_suite)</span>
<span class="gi">+</span>
<span class="gi">+        # we have client and server hello in TLS 1.3 so we have the necessary</span>
<span class="gi">+        # key shares to derive the handshake receive key</span>
<span class="gi">+        sr_kex = serverHello.getExtension(ExtensionType.key_share)</span>
<span class="gi">+        sr_psk = serverHello.getExtension(ExtensionType.pre_shared_key)</span>
<span class="gi">+        if not sr_kex and not sr_psk:</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;Server did not select PSK nor &quot;</span>
<span class="gi">+                                               &quot;an (EC)DH group&quot;)</span>
<span class="gi">+        if sr_kex:</span>
<span class="gi">+            sr_kex = sr_kex.server_share</span>
<span class="gi">+            self.ecdhCurve = sr_kex.group</span>
<span class="gi">+            cl_key_share_ex = clientHello.getExtension(ExtensionType.key_share)</span>
<span class="gi">+            cl_kex = next((i for i in cl_key_share_ex.client_shares</span>
<span class="gi">+                           if i.group == sr_kex.group), None)</span>
<span class="gi">+            if cl_kex is None:</span>
<span class="gi">+                raise TLSIllegalParameterException(&quot;Server selected not &quot;</span>
<span class="gi">+                                                   &quot;advertised group.&quot;)</span>
<span class="gi">+            kex = self._getKEX(sr_kex.group, self.version)</span>
<span class="gi">+</span>
<span class="gi">+            shared_sec = kex.calc_shared_key(cl_kex.private,</span>
<span class="gi">+                                             sr_kex.key_exchange)</span>
<span class="gi">+        else:</span>
<span class="gi">+            shared_sec = bytearray(prf_size)</span>
<span class="gi">+</span>
<span class="gi">+        # if server agreed to perform resumption, find the matching secret key</span>
<span class="gi">+        resuming = False</span>
<span class="gi">+        if sr_psk:</span>
<span class="gi">+            clPSK = clientHello.getExtension(ExtensionType.pre_shared_key)</span>
<span class="gi">+            ident = clPSK.identities[sr_psk.selected]</span>
<span class="gi">+            psk = [i[1] for i in settings.pskConfigs if i[0] == ident.identity]</span>
<span class="gi">+            if psk:</span>
<span class="gi">+                psk = psk[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                resuming = True</span>
<span class="gi">+                psk = HandshakeHelpers.calc_res_binder_psk(</span>
<span class="gi">+                    ident, session.resumptionMasterSecret,</span>
<span class="gi">+                    session.tickets)</span>
<span class="gi">+        else:</span>
<span class="gi">+            psk = bytearray(prf_size)</span>
<span class="gi">+</span>
<span class="gi">+        secret = bytearray(prf_size)</span>
<span class="gi">+        # Early Secret</span>
<span class="gi">+        secret = secureHMAC(secret, psk, prfName)</span>
<span class="gi">+</span>
<span class="gi">+        # Handshake Secret</span>
<span class="gi">+        secret = derive_secret(secret, bytearray(b&#39;derived&#39;),</span>
<span class="gi">+                               None, prfName)</span>
<span class="gi">+        secret = secureHMAC(secret, shared_sec, prfName)</span>
<span class="gi">+</span>
<span class="gi">+        sr_handshake_traffic_secret = derive_secret(secret,</span>
<span class="gi">+                                                    bytearray(b&#39;s hs traffic&#39;),</span>
<span class="gi">+                                                    self._handshake_hash,</span>
<span class="gi">+                                                    prfName)</span>
<span class="gi">+        cl_handshake_traffic_secret = derive_secret(secret,</span>
<span class="gi">+                                                    bytearray(b&#39;c hs traffic&#39;),</span>
<span class="gi">+                                                    self._handshake_hash,</span>
<span class="gi">+                                                    prfName)</span>
<span class="gi">+</span>
<span class="gi">+        # prepare for reading encrypted messages</span>
<span class="gi">+        self._recordLayer.calcTLS1_3PendingState(</span>
<span class="gi">+            serverHello.cipher_suite,</span>
<span class="gi">+            cl_handshake_traffic_secret,</span>
<span class="gi">+            sr_handshake_traffic_secret,</span>
<span class="gi">+            settings.cipherImplementations)</span>
<span class="gi">+</span>
<span class="gi">+        self._changeReadState()</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                   HandshakeType.encrypted_extensions):</span>
<span class="gi">+            if result in (0, 1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        encrypted_extensions = result</span>
<span class="gi">+        assert isinstance(encrypted_extensions, EncryptedExtensions)</span>
<span class="gi">+</span>
<span class="gi">+        size_limit_ext = encrypted_extensions.getExtension(</span>
<span class="gi">+            ExtensionType.record_size_limit)</span>
<span class="gi">+        if size_limit_ext and not settings.record_size_limit:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.illegal_parameter,</span>
<span class="gi">+                    &quot;Server sent record_size_limit extension despite us not &quot;</span>
<span class="gi">+                    &quot;advertising it&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        if size_limit_ext:</span>
<span class="gi">+            if size_limit_ext.record_size_limit is None:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.decode_error,</span>
<span class="gi">+                        &quot;Malformed record_size_limit extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if not 64 &lt;= size_limit_ext.record_size_limit &lt;= 2**14+1:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Invalid valid in record_size_limit extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            # the record layer code expects a limit that excludes content type</span>
<span class="gi">+            # from the value while extension is defined including it</span>
<span class="gi">+            self._send_record_limit = size_limit_ext.record_size_limit - 1</span>
<span class="gi">+            self._recv_record_limit = min(2**14, settings.record_size_limit - 1)</span>
<span class="gi">+</span>
<span class="gi">+        # if we negotiated PSK then Certificate is not sent</span>
<span class="gi">+        certificate_request = None</span>
<span class="gi">+        certificate = None</span>
<span class="gi">+        if not sr_psk:</span>
<span class="gi">+            for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                       (HandshakeType.certificate_request,</span>
<span class="gi">+                                        HandshakeType.certificate),</span>
<span class="gi">+                                       CertificateType.x509):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(result, CertificateRequest):</span>
<span class="gi">+                certificate_request = result</span>
<span class="gi">+</span>
<span class="gi">+                # we got CertificateRequest so now we&#39;ll get Certificate</span>
<span class="gi">+                for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                           HandshakeType.certificate,</span>
<span class="gi">+                                           CertificateType.x509):</span>
<span class="gi">+                    if result in (0, 1):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+            certificate = result</span>
<span class="gi">+            assert isinstance(certificate, Certificate)</span>
<span class="gi">+</span>
<span class="gi">+            srv_cert_verify_hh = self._handshake_hash.copy()</span>
<span class="gi">+</span>
<span class="gi">+            for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                       HandshakeType.certificate_verify):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+            certificate_verify = result</span>
<span class="gi">+            assert isinstance(certificate_verify, CertificateVerify)</span>
<span class="gi">+</span>
<span class="gi">+            signature_scheme = certificate_verify.signatureAlgorithm</span>
<span class="gi">+            self.serverSigAlg = signature_scheme</span>
<span class="gi">+</span>
<span class="gi">+            signature_context = KeyExchange.calcVerifyBytes((3, 4),</span>
<span class="gi">+                                                            srv_cert_verify_hh,</span>
<span class="gi">+                                                            signature_scheme,</span>
<span class="gi">+                                                            None, None, None,</span>
<span class="gi">+                                                            prfName, b&#39;server&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            for result in self._clientGetKeyFromChain(certificate, settings):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+            publicKey, serverCertChain, tackExt = result</span>
<span class="gi">+</span>
<span class="gi">+            if signature_scheme in (SignatureScheme.ed25519,</span>
<span class="gi">+                                    SignatureScheme.ed448):</span>
<span class="gi">+                pad_type = None</span>
<span class="gi">+                hash_name = &quot;intrinsic&quot;</span>
<span class="gi">+                salt_len = None</span>
<span class="gi">+                method = publicKey.hashAndVerify</span>
<span class="gi">+            elif signature_scheme[1] == SignatureAlgorithm.ecdsa:</span>
<span class="gi">+                pad_type = None</span>
<span class="gi">+                hash_name = HashAlgorithm.toRepr(signature_scheme[0])</span>
<span class="gi">+                matching_hash = self._curve_name_to_hash_name(</span>
<span class="gi">+                    publicKey.curve_name)</span>
<span class="gi">+                if hash_name != matching_hash:</span>
<span class="gi">+                    raise TLSIllegalParameterException(</span>
<span class="gi">+                        &quot;server selected signature method invalid for the &quot;</span>
<span class="gi">+                        &quot;certificate it presented (curve mismatch)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                salt_len = None</span>
<span class="gi">+                method = publicKey.verify</span>
<span class="gi">+            else:</span>
<span class="gi">+                scheme = SignatureScheme.toRepr(signature_scheme)</span>
<span class="gi">+                pad_type = SignatureScheme.getPadding(scheme)</span>
<span class="gi">+                hash_name = SignatureScheme.getHash(scheme)</span>
<span class="gi">+                salt_len = getattr(hashlib, hash_name)().digest_size</span>
<span class="gi">+                method = publicKey.verify</span>
<span class="gi">+</span>
<span class="gi">+            if not method(certificate_verify.signature,</span>
<span class="gi">+                          signature_context,</span>
<span class="gi">+                          pad_type,</span>
<span class="gi">+                          hash_name,</span>
<span class="gi">+                          salt_len):</span>
<span class="gi">+                raise TLSDecryptionFailed(&quot;server Certificate Verify &quot;</span>
<span class="gi">+                                          &quot;signature &quot;</span>
<span class="gi">+                                          &quot;verification failed&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        transcript_hash = self._handshake_hash.digest(prfName)</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                   HandshakeType.finished,</span>
<span class="gi">+                                   prf_size):</span>
<span class="gi">+            if result in (0, 1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        finished = result</span>
<span class="gi">+</span>
<span class="gi">+        server_finish_hs = self._handshake_hash.copy()</span>
<span class="gi">+</span>
<span class="gi">+        assert isinstance(finished, Finished)</span>
<span class="gi">+</span>
<span class="gi">+        finished_key = HKDF_expand_label(sr_handshake_traffic_secret,</span>
<span class="gi">+                                         b&quot;finished&quot;, b&#39;&#39;, prf_size, prfName)</span>
<span class="gi">+        verify_data = secureHMAC(finished_key, transcript_hash, prfName)</span>
<span class="gi">+</span>
<span class="gi">+        if finished.verify_data != verify_data:</span>
<span class="gi">+            raise TLSDecryptionFailed(&quot;Finished value is not valid&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # now send client set of messages</span>
<span class="gi">+        self._changeWriteState()</span>
<span class="gi">+</span>
<span class="gi">+        # Master secret</span>
<span class="gi">+        secret = derive_secret(secret, bytearray(b&#39;derived&#39;), None, prfName)</span>
<span class="gi">+        secret = secureHMAC(secret, bytearray(prf_size), prfName)</span>
<span class="gi">+</span>
<span class="gi">+        cl_app_traffic = derive_secret(secret, bytearray(b&#39;c ap traffic&#39;),</span>
<span class="gi">+                                       server_finish_hs, prfName)</span>
<span class="gi">+        sr_app_traffic = derive_secret(secret, bytearray(b&#39;s ap traffic&#39;),</span>
<span class="gi">+                                       server_finish_hs, prfName)</span>
<span class="gi">+</span>
<span class="gi">+        if certificate_request:</span>
<span class="gi">+            client_certificate = Certificate(serverHello.certificate_type,</span>
<span class="gi">+                                             self.version)</span>
<span class="gi">+            if clientCertChain:</span>
<span class="gi">+                # Check to make sure we have the same type of certificates the</span>
<span class="gi">+                # server requested</span>
<span class="gi">+                if serverHello.certificate_type == CertificateType.x509 \</span>
<span class="gi">+                    and not isinstance(clientCertChain, X509CertChain):</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.handshake_failure,</span>
<span class="gi">+                            &quot;Client certificate is of wrong type&quot;):</span>
<span class="gi">+                        yield result</span>

<span class="gd">-    def _clientKeyExchange(self, settings, cipherSuite, clientCertChain,</span>
<span class="gd">-        privateKey, certificateType, tackExt, clientRandom, serverRandom,</span>
<span class="gd">-        keyExchange):</span>
<span class="gi">+            client_certificate.create(clientCertChain)</span>
<span class="gi">+            # we need to send the message even if we don&#39;t have a certificate</span>
<span class="gi">+            for result in self._sendMsg(client_certificate):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+            if clientCertChain and privateKey:</span>
<span class="gi">+                valid_sig_algs = certificate_request.supported_signature_algs</span>
<span class="gi">+                if not valid_sig_algs:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.missing_extension,</span>
<span class="gi">+                            &quot;No Signature Algorithms found&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                availSigAlgs = self._sigHashesToList(settings, privateKey,</span>
<span class="gi">+                                                     clientCertChain,</span>
<span class="gi">+                                                     version=(3, 4))</span>
<span class="gi">+                signature_scheme = getFirstMatching(availSigAlgs,</span>
<span class="gi">+                                                    valid_sig_algs)</span>
<span class="gi">+                scheme = SignatureScheme.toRepr(signature_scheme)</span>
<span class="gi">+                signature_scheme = getattr(SignatureScheme, scheme)</span>
<span class="gi">+</span>
<span class="gi">+                signature_context = \</span>
<span class="gi">+                    KeyExchange.calcVerifyBytes((3, 4), self._handshake_hash,</span>
<span class="gi">+                                                signature_scheme, None, None,</span>
<span class="gi">+                                                None, prfName, b&#39;client&#39;)</span>
<span class="gi">+</span>
<span class="gi">+                if signature_scheme in (SignatureScheme.ed25519,</span>
<span class="gi">+                        SignatureScheme.ed448):</span>
<span class="gi">+                    pad_type = None</span>
<span class="gi">+                    hash_name = &quot;intrinsic&quot;</span>
<span class="gi">+                    salt_len = None</span>
<span class="gi">+                    sig_func = privateKey.hashAndSign</span>
<span class="gi">+                    ver_func = privateKey.hashAndVerify</span>
<span class="gi">+                elif signature_scheme[1] == SignatureAlgorithm.ecdsa:</span>
<span class="gi">+                    pad_type = None</span>
<span class="gi">+                    hash_name = HashAlgorithm.toRepr(signature_scheme[0])</span>
<span class="gi">+                    salt_len = None</span>
<span class="gi">+                    sig_func = privateKey.sign</span>
<span class="gi">+                    ver_func = privateKey.verify</span>
<span class="gi">+                else:</span>
<span class="gi">+                    pad_type = SignatureScheme.getPadding(scheme)</span>
<span class="gi">+                    hash_name = SignatureScheme.getHash(scheme)</span>
<span class="gi">+                    salt_len = getattr(hashlib, hash_name)().digest_size</span>
<span class="gi">+                    sig_func = privateKey.sign</span>
<span class="gi">+                    ver_func = privateKey.verify</span>
<span class="gi">+</span>
<span class="gi">+                signature = sig_func(signature_context,</span>
<span class="gi">+                                     pad_type,</span>
<span class="gi">+                                     hash_name,</span>
<span class="gi">+                                     salt_len)</span>
<span class="gi">+                if not ver_func(signature, signature_context,</span>
<span class="gi">+                                pad_type,</span>
<span class="gi">+                                hash_name,</span>
<span class="gi">+                                salt_len):</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.internal_error,</span>
<span class="gi">+                            &quot;Certificate Verify signature failed&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                certificate_verify = CertificateVerify(self.version)</span>
<span class="gi">+                certificate_verify.create(signature, signature_scheme)</span>
<span class="gi">+</span>
<span class="gi">+                for result in self._sendMsg(certificate_verify):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+        # Do after client cert and verify messages has been sent.</span>
<span class="gi">+        exporter_master_secret = derive_secret(secret,</span>
<span class="gi">+                                               bytearray(b&#39;exp master&#39;),</span>
<span class="gi">+                                               self._handshake_hash, prfName)</span>
<span class="gi">+</span>
<span class="gi">+        self._recordLayer.calcTLS1_3PendingState(</span>
<span class="gi">+            serverHello.cipher_suite,</span>
<span class="gi">+            cl_app_traffic,</span>
<span class="gi">+            sr_app_traffic,</span>
<span class="gi">+            settings.cipherImplementations)</span>
<span class="gi">+        # be ready to process alert messages from the server, which</span>
<span class="gi">+        # MUST be encrypted with ap traffic secret when they are sent after</span>
<span class="gi">+        # Finished</span>
<span class="gi">+        self._changeReadState()</span>
<span class="gi">+</span>
<span class="gi">+        cl_finished_key = HKDF_expand_label(cl_handshake_traffic_secret,</span>
<span class="gi">+                                            b&quot;finished&quot;, b&#39;&#39;,</span>
<span class="gi">+                                            prf_size, prfName)</span>
<span class="gi">+        cl_verify_data = secureHMAC(</span>
<span class="gi">+            cl_finished_key,</span>
<span class="gi">+            self._handshake_hash.digest(prfName),</span>
<span class="gi">+            prfName)</span>
<span class="gi">+</span>
<span class="gi">+        cl_finished = Finished(self.version, prf_size)</span>
<span class="gi">+        cl_finished.create(cl_verify_data)</span>
<span class="gi">+</span>
<span class="gi">+        if not self._ccs_sent and clientHello.session_id:</span>
<span class="gi">+            ccs = ChangeCipherSpec().create()</span>
<span class="gi">+            msgs = [ccs, cl_finished]</span>
<span class="gi">+        else:</span>
<span class="gi">+            msgs = [cl_finished]</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._sendMsgs(msgs):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+        # CCS messages are not allowed in post handshake authentication</span>
<span class="gi">+        self._middlebox_compat_mode = False</span>
<span class="gi">+</span>
<span class="gi">+        # fully switch to application data</span>
<span class="gi">+        self._changeWriteState()</span>
<span class="gi">+</span>
<span class="gi">+        self._first_handshake_hashes = self._handshake_hash.copy()</span>
<span class="gi">+</span>
<span class="gi">+        resumption_master_secret = derive_secret(secret,</span>
<span class="gi">+                                                 bytearray(b&#39;res master&#39;),</span>
<span class="gi">+                                                 self._handshake_hash, prfName)</span>
<span class="gi">+</span>
<span class="gi">+        self.session = Session()</span>
<span class="gi">+        self.extendedMasterSecret = True</span>
<span class="gi">+</span>
<span class="gi">+        serverName = None</span>
<span class="gi">+        if clientHello.server_name:</span>
<span class="gi">+            serverName = clientHello.server_name.decode(&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        appProto = None</span>
<span class="gi">+        alpnExt = encrypted_extensions.getExtension(ExtensionType.alpn)</span>
<span class="gi">+        if alpnExt:</span>
<span class="gi">+            appProto = alpnExt.protocol_names[0]</span>
<span class="gi">+</span>
<span class="gi">+        heartbeat_ext = encrypted_extensions.getExtension(ExtensionType.heartbeat)</span>
<span class="gi">+        if heartbeat_ext:</span>
<span class="gi">+            if not settings.use_heartbeat_extension:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.unsupported_extension,</span>
<span class="gi">+                        &quot;Server sent Heartbeat extension without one in &quot;</span>
<span class="gi">+                        &quot;client hello&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if heartbeat_ext.mode == HeartbeatMode.PEER_ALLOWED_TO_SEND and \</span>
<span class="gi">+                    settings.heartbeat_response_callback:</span>
<span class="gi">+                self.heartbeat_can_send = True</span>
<span class="gi">+                self.heartbeat_response_callback = settings.\</span>
<span class="gi">+                    heartbeat_response_callback</span>
<span class="gi">+            elif heartbeat_ext.mode == HeartbeatMode.\</span>
<span class="gi">+                    PEER_NOT_ALLOWED_TO_SEND or not settings.\</span>
<span class="gi">+                    heartbeat_response_callback:</span>
<span class="gi">+                self.heartbeat_can_send = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Server responded with invalid Heartbeat extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            self.heartbeat_supported = True</span>
<span class="gi">+</span>
<span class="gi">+        self.session.create(secret,</span>
<span class="gi">+                            bytearray(b&#39;&#39;),  # no session_id in TLS 1.3</span>
<span class="gi">+                            serverHello.cipher_suite,</span>
<span class="gi">+                            None,  # no SRP</span>
<span class="gi">+                            clientCertChain,</span>
<span class="gi">+                            certificate.cert_chain if certificate else None,</span>
<span class="gi">+                            None,  # no TACK</span>
<span class="gi">+                            False,  # no TACK in hello</span>
<span class="gi">+                            serverName,</span>
<span class="gi">+                            encryptThenMAC=False,  # all ciphers are AEAD</span>
<span class="gi">+                            extendedMasterSecret=True,  # all TLS1.3 are EMS</span>
<span class="gi">+                            appProto=appProto,</span>
<span class="gi">+                            cl_app_secret=cl_app_traffic,</span>
<span class="gi">+                            sr_app_secret=sr_app_traffic,</span>
<span class="gi">+                            exporterMasterSecret=exporter_master_secret,</span>
<span class="gi">+                            resumptionMasterSecret=resumption_master_secret,</span>
<span class="gi">+                            # NOTE it must be a reference, not a copy!</span>
<span class="gi">+                            tickets=self.tickets)</span>
<span class="gi">+</span>
<span class="gi">+        yield &quot;finished&quot; if not resuming else &quot;resumed_and_finished&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _clientSelectNextProto(self, nextProtos, serverHello):</span>
<span class="gi">+        # nextProtos is None or non-empty list of strings</span>
<span class="gi">+        # serverHello.next_protos is None or possibly-empty list of strings</span>
<span class="gi">+        #</span>
<span class="gi">+        # !!! We assume the client may have specified nextProtos as a list of</span>
<span class="gi">+        # strings so we convert them to bytearrays (it&#39;s awkward to require</span>
<span class="gi">+        # the user to specify a list of bytearrays or &quot;bytes&quot;, and in</span>
<span class="gi">+        # Python 2.6 bytes() is just an alias for str() anyways...</span>
<span class="gi">+        if nextProtos is not None and serverHello.next_protos is not None:</span>
<span class="gi">+            for p in nextProtos:</span>
<span class="gi">+                if bytearray(p) in serverHello.next_protos:</span>
<span class="gi">+                    return bytearray(p)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # If the client doesn&#39;t support any of server&#39;s protocols,</span>
<span class="gi">+                # or the server doesn&#39;t advertise any (next_protos == [])</span>
<span class="gi">+                # the client SHOULD select the first protocol it supports.</span>
<span class="gi">+                return bytearray(nextProtos[0])</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _clientResume(self, session, serverHello, clientRandom,</span>
<span class="gi">+                      nextProto, settings):</span>
<span class="gi">+</span>
<span class="gi">+        if session and ((session.sessionID and \</span>
<span class="gi">+            serverHello.session_id == session.sessionID) or</span>
<span class="gi">+            session.tls_1_0_tickets):</span>
<span class="gi">+</span>
<span class="gi">+            if serverHello.cipher_suite != session.cipherSuite:</span>
<span class="gi">+                for result in self._sendError(\</span>
<span class="gi">+                    AlertDescription.illegal_parameter,\</span>
<span class="gi">+                    &quot;Server&#39;s ciphersuite doesn&#39;t match session&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+            #Calculate pending connection states</span>
<span class="gi">+            self._calcPendingStates(session.cipherSuite,</span>
<span class="gi">+                                    session.masterSecret,</span>
<span class="gi">+                                    clientRandom, serverHello.random,</span>
<span class="gi">+                                    settings.cipherImplementations)</span>
<span class="gi">+</span>
<span class="gi">+            #Exchange ChangeCipherSpec and Finished messages</span>
<span class="gi">+            for result in self._getFinished(session.masterSecret,</span>
<span class="gi">+                                            session.cipherSuite):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            # buffer writes so that CCS and Finished go out in one TCP packet</span>
<span class="gi">+            self.sock.buffer_writes = True</span>
<span class="gi">+            for result in self._sendFinished(session.masterSecret,</span>
<span class="gi">+                                             session.cipherSuite,</span>
<span class="gi">+                                             nextProto,</span>
<span class="gi">+                                             settings=settings):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            self.sock.flush()</span>
<span class="gi">+            self.sock.buffer_writes = False</span>
<span class="gi">+</span>
<span class="gi">+            #Set the session for this connection</span>
<span class="gi">+            self.session = session</span>
<span class="gi">+            yield &quot;resumed_and_finished&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _clientKeyExchange(self, settings, cipherSuite,</span>
<span class="gi">+                           clientCertChain, privateKey,</span>
<span class="gi">+                           certificateType,</span>
<span class="gi">+                           tackExt, clientRandom, serverRandom,</span>
<span class="gi">+                           keyExchange):</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform the client side of key exchange&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # if server chose cipher suite with authentication, get the certificate</span>
<span class="gi">+        if cipherSuite in CipherSuite.certAllSuites or \</span>
<span class="gi">+                cipherSuite in CipherSuite.ecdheEcdsaSuites or \</span>
<span class="gi">+                cipherSuite in CipherSuite.dheDsaSuites:</span>
<span class="gi">+            for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                       HandshakeType.certificate,</span>
<span class="gi">+                                       certificateType):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            serverCertificate = result</span>
<span class="gi">+        else:</span>
<span class="gi">+            serverCertificate = None</span>
<span class="gi">+        # if server chose RSA key exchange, we need to skip SKE message</span>
<span class="gi">+        if cipherSuite not in CipherSuite.certSuites:</span>
<span class="gi">+            for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                       HandshakeType.server_key_exchange,</span>
<span class="gi">+                                       cipherSuite):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            serverKeyExchange = result</span>
<span class="gi">+        else:</span>
<span class="gi">+            serverKeyExchange = None</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                   (HandshakeType.certificate_request,</span>
<span class="gi">+                                    HandshakeType.server_hello_done)):</span>
<span class="gi">+            if result in (0, 1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+</span>
<span class="gi">+        certificateRequest = None</span>
<span class="gi">+        if isinstance(result, CertificateRequest):</span>
<span class="gi">+            certificateRequest = result</span>
<span class="gi">+</span>
<span class="gi">+            #abort if Certificate Request with inappropriate ciphersuite</span>
<span class="gi">+            if cipherSuite not in CipherSuite.certAllSuites \</span>
<span class="gi">+                and cipherSuite not in CipherSuite.ecdheEcdsaSuites \</span>
<span class="gi">+                and cipherSuite not in CipherSuite.dheDsaSuites\</span>
<span class="gi">+                or cipherSuite in CipherSuite.srpAllSuites:</span>
<span class="gi">+                for result in self._sendError(\</span>
<span class="gi">+                        AlertDescription.unexpected_message,</span>
<span class="gi">+                        &quot;Certificate Request with incompatible cipher suite&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+            # we got CertificateRequest so now we&#39;ll get ServerHelloDone</span>
<span class="gi">+            for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                       HandshakeType.server_hello_done):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+        serverHelloDone = result</span>
<span class="gi">+</span>
<span class="gi">+        serverCertChain = None</span>
<span class="gi">+        publicKey = None</span>
<span class="gi">+        if cipherSuite in CipherSuite.certAllSuites or \</span>
<span class="gi">+                cipherSuite in CipherSuite.ecdheEcdsaSuites or \</span>
<span class="gi">+                cipherSuite in CipherSuite.dheDsaSuites:</span>
<span class="gi">+            # get the certificate</span>
<span class="gi">+            for result in self._clientGetKeyFromChain(serverCertificate,</span>
<span class="gi">+                                                      settings,</span>
<span class="gi">+                                                      tackExt):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            publicKey, serverCertChain, tackExt = result</span>
<span class="gi">+</span>
<span class="gi">+            #Check the server&#39;s signature, if the server chose an authenticated</span>
<span class="gi">+            # PFS-enabled ciphersuite</span>
<span class="gi">+</span>
<span class="gi">+            if serverKeyExchange:</span>
<span class="gi">+                valid_sig_algs = \</span>
<span class="gi">+                    self._sigHashesToList(settings,</span>
<span class="gi">+                                          certList=serverCertChain)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    KeyExchange.verifyServerKeyExchange(serverKeyExchange,</span>
<span class="gi">+                                                        publicKey,</span>
<span class="gi">+                                                        clientRandom,</span>
<span class="gi">+                                                        serverRandom,</span>
<span class="gi">+                                                        valid_sig_algs)</span>
<span class="gi">+                except TLSIllegalParameterException:</span>
<span class="gi">+                    for result in self._sendError(AlertDescription.\</span>
<span class="gi">+                                                  illegal_parameter):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                except TLSDecryptionFailed:</span>
<span class="gi">+                    for result in self._sendError(\</span>
<span class="gi">+                            AlertDescription.decrypt_error):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+        if serverKeyExchange:</span>
<span class="gi">+            # store key exchange metadata for user applications</span>
<span class="gi">+            if self.version &gt;= (3, 3) \</span>
<span class="gi">+                    and (cipherSuite in CipherSuite.certAllSuites or</span>
<span class="gi">+                         cipherSuite in CipherSuite.ecdheEcdsaSuites) \</span>
<span class="gi">+                    and cipherSuite not in CipherSuite.certSuites:</span>
<span class="gi">+                self.serverSigAlg = (serverKeyExchange.hashAlg,</span>
<span class="gi">+                                     serverKeyExchange.signAlg)</span>
<span class="gi">+</span>
<span class="gi">+            if cipherSuite in CipherSuite.dhAllSuites:</span>
<span class="gi">+                self.dhGroupSize = numBits(serverKeyExchange.dh_p)</span>
<span class="gi">+            if cipherSuite in CipherSuite.ecdhAllSuites:</span>
<span class="gi">+                self.ecdhCurve = serverKeyExchange.named_curve</span>
<span class="gi">+</span>
<span class="gi">+        #Send Certificate if we were asked for it</span>
<span class="gi">+        if certificateRequest:</span>
<span class="gi">+            # if a peer doesn&#39;t advertise support for any algorithm in TLSv1.2,</span>
<span class="gi">+            # support for SHA1+RSA can be assumed</span>
<span class="gi">+            if self.version == (3, 3)\</span>
<span class="gi">+                and not [sig for sig in \</span>
<span class="gi">+                         certificateRequest.supported_signature_algs\</span>
<span class="gi">+                         if sig[1] == SignatureAlgorithm.rsa]:</span>
<span class="gi">+                for result in self._sendError(\</span>
<span class="gi">+                        AlertDescription.handshake_failure,</span>
<span class="gi">+                        &quot;Server doesn&#39;t accept any sigalgs we support: &quot; +</span>
<span class="gi">+                        str(certificateRequest.supported_signature_algs)):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            clientCertificate = Certificate(certificateType)</span>
<span class="gi">+</span>
<span class="gi">+            if clientCertChain:</span>
<span class="gi">+                #Check to make sure we have the same type of</span>
<span class="gi">+                #certificates the server requested</span>
<span class="gi">+                if certificateType == CertificateType.x509 \</span>
<span class="gi">+                    and not isinstance(clientCertChain, X509CertChain):</span>
<span class="gi">+                    for result in self._sendError(\</span>
<span class="gi">+                            AlertDescription.handshake_failure,</span>
<span class="gi">+                            &quot;Client certificate is of wrong type&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                clientCertificate.create(clientCertChain)</span>
<span class="gi">+            # we need to send the message even if we don&#39;t have a certificate</span>
<span class="gi">+            for result in self._sendMsg(clientCertificate):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        else:</span>
<span class="gi">+            #Server didn&#39;t ask for cer, zeroise so session doesn&#39;t store them</span>
<span class="gi">+            privateKey = None</span>
<span class="gi">+            clientCertChain = None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            ske = serverKeyExchange</span>
<span class="gi">+            premasterSecret = keyExchange.processServerKeyExchange(publicKey,</span>
<span class="gi">+                                                                   ske)</span>
<span class="gi">+        except TLSInsufficientSecurity as e:</span>
<span class="gi">+            for result in self._sendError(\</span>
<span class="gi">+                    AlertDescription.insufficient_security, e):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSIllegalParameterException as e:</span>
<span class="gi">+            for result in self._sendError(\</span>
<span class="gi">+                    AlertDescription.illegal_parameter, e):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        clientKeyExchange = keyExchange.makeClientKeyExchange()</span>
<span class="gi">+</span>
<span class="gi">+        #Send ClientKeyExchange</span>
<span class="gi">+        for result in self._sendMsg(clientKeyExchange):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+        # the Extended Master Secret calculation uses the same handshake</span>
<span class="gi">+        # hashes as the Certificate Verify calculation so we need to</span>
<span class="gi">+        # make a copy of it</span>
<span class="gi">+        self._certificate_verify_handshake_hash = self._handshake_hash.copy()</span>
<span class="gi">+</span>
<span class="gi">+        #if client auth was requested and we have a private key, send a</span>
<span class="gi">+        #CertificateVerify</span>
<span class="gi">+        if certificateRequest and privateKey:</span>
<span class="gi">+            valid_sig_algs = self._sigHashesToList(settings, privateKey,</span>
<span class="gi">+                                                   clientCertChain)</span>
<span class="gi">+            try:</span>
<span class="gi">+                certificateVerify = KeyExchange.makeCertificateVerify(</span>
<span class="gi">+                    self.version,</span>
<span class="gi">+                    self._certificate_verify_handshake_hash,</span>
<span class="gi">+                    valid_sig_algs,</span>
<span class="gi">+                    privateKey,</span>
<span class="gi">+                    certificateRequest,</span>
<span class="gi">+                    premasterSecret,</span>
<span class="gi">+                    clientRandom,</span>
<span class="gi">+                    serverRandom)</span>
<span class="gi">+            except TLSInternalError as exception:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.internal_error, exception):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            for result in self._sendMsg(certificateVerify):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        yield (premasterSecret, serverCertChain, clientCertChain, tackExt)</span>
<span class="gi">+</span>
<span class="gi">+    def _clientFinished(self, premasterSecret, clientRandom, serverRandom,</span>
<span class="gi">+                        cipherSuite, cipherImplementations, nextProto,</span>
<span class="gi">+                        settings):</span>
<span class="gi">+</span>
<span class="gi">+        masterSecret = self._calculate_master_secret(premasterSecret,</span>
<span class="gi">+                                                     cipherSuite,</span>
<span class="gi">+                                                     clientRandom,</span>
<span class="gi">+                                                     serverRandom)</span>
<span class="gi">+        self._calcPendingStates(cipherSuite, masterSecret,</span>
<span class="gi">+                                clientRandom, serverRandom,</span>
<span class="gi">+                                cipherImplementations)</span>
<span class="gi">+</span>
<span class="gi">+        #Exchange ChangeCipherSpec and Finished messages</span>
<span class="gi">+        for result in self._sendFinished(masterSecret, cipherSuite, nextProto,</span>
<span class="gi">+                settings=settings):</span>
<span class="gi">+            yield result</span>
<span class="gi">+        self.sock.flush()</span>
<span class="gi">+        self.sock.buffer_writes = False</span>
<span class="gi">+        for result in self._getFinished(masterSecret,</span>
<span class="gi">+                                        cipherSuite,</span>
<span class="gi">+                                        nextProto=nextProto):</span>
<span class="gi">+            yield result</span>
<span class="gi">+        yield masterSecret</span>

<span class="w"> </span>    def _check_certchain_with_settings(self, cert_chain, settings):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -327,12 +1878,120 @@ class TLSConnection(TLSRecordLayer):</span>
<span class="w"> </span>        Checks if the certificate key size matches the minimum and maximum
<span class="w"> </span>        sizes set or that it uses curves enabled in settings
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        #Get and check public key from the cert chain</span>
<span class="gi">+        publicKey = cert_chain.getEndEntityPublicKey()</span>
<span class="gi">+        cert_type = cert_chain.x509List[0].certAlg</span>
<span class="gi">+        if cert_type == &quot;ecdsa&quot;:</span>
<span class="gi">+            curve_name = publicKey.curve_name</span>
<span class="gi">+            for name, aliases in CURVE_ALIASES.items():</span>
<span class="gi">+                if curve_name in aliases:</span>
<span class="gi">+                    curve_name = name</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            if self.version &lt;= (3, 3) and curve_name not in settings.eccCurves:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.handshake_failure,</span>
<span class="gi">+                        &quot;Peer sent certificate with curve we did not &quot;</span>
<span class="gi">+                        &quot;advertise support for: {0}&quot;.format(curve_name)):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if self.version &gt;= (3, 4):</span>
<span class="gi">+                if curve_name not in (&#39;secp256r1&#39;, &#39;secp384r1&#39;, &#39;secp521r1&#39;):</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter,</span>
<span class="gi">+                            &quot;Peer sent certificate with curve not supported &quot;</span>
<span class="gi">+                            &quot;in TLS 1.3: {0}&quot;.format(curve_name)):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if curve_name == &#39;secp256r1&#39;:</span>
<span class="gi">+                    sig_alg_for_curve = &#39;sha256&#39;</span>
<span class="gi">+                elif curve_name == &#39;secp384r1&#39;:</span>
<span class="gi">+                    sig_alg_for_curve = &#39;sha384&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    assert curve_name == &#39;secp521r1&#39;</span>
<span class="gi">+                    sig_alg_for_curve = &#39;sha512&#39;</span>
<span class="gi">+                if sig_alg_for_curve not in settings.ecdsaSigHashes:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter,</span>
<span class="gi">+                            &quot;Peer selected certificate with ECDSA curve we &quot;</span>
<span class="gi">+                            &quot;did not advertise support for: {0}&quot;</span>
<span class="gi">+                            .format(curve_name)):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+        elif cert_type in (&quot;Ed25519&quot;, &quot;Ed448&quot;):</span>
<span class="gi">+            if self.version &lt; (3, 3):</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Peer sent certificate incompatible with negotiated &quot;</span>
<span class="gi">+                        &quot;TLS version&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if cert_type not in settings.more_sig_schemes:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.handshake_failure,</span>
<span class="gi">+                        &quot;Peer sent certificate we did not advertise support &quot;</span>
<span class="gi">+                        &quot;for: {0}&quot;.format(cert_type)):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # for RSA and DSA keys</span>
<span class="gi">+            if len(publicKey) &lt; settings.minKeySize:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.handshake_failure,</span>
<span class="gi">+                        &quot;Other party&#39;s public key too small: %d&quot; %</span>
<span class="gi">+                        len(publicKey)):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if len(publicKey) &gt; settings.maxKeySize:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.handshake_failure,</span>
<span class="gi">+                        &quot;Other party&#39;s public key too large: %d&quot; %</span>
<span class="gi">+                        len(publicKey)):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+        yield publicKey</span>
<span class="gi">+</span>
<span class="gi">+    def _clientGetKeyFromChain(self, certificate, settings, tack_ext=None):</span>
<span class="gi">+        #Get and check cert chain from the Certificate message</span>
<span class="gi">+        cert_chain = certificate.cert_chain</span>
<span class="gi">+        if not cert_chain or cert_chain.getNumCerts() == 0:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.illegal_parameter,</span>
<span class="gi">+                    &quot;Other party sent a Certificate message without &quot;\</span>
<span class="gi">+                    &quot;certificates&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._check_certchain_with_settings(</span>
<span class="gi">+                cert_chain,</span>
<span class="gi">+                settings):</span>
<span class="gi">+            if result in (0, 1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+        public_key = result</span>
<span class="gi">+</span>
<span class="gi">+        # If there&#39;s no TLS Extension, look for a TACK cert</span>
<span class="gi">+        if tackpyLoaded:</span>
<span class="gi">+            if not tack_ext:</span>
<span class="gi">+                tack_ext = cert_chain.getTackExt()</span>
<span class="gi">+</span>
<span class="gi">+            # If there&#39;s a TACK (whether via TLS or TACK Cert), check that it</span>
<span class="gi">+            # matches the cert chain</span>
<span class="gi">+            if tack_ext and tack_ext.tacks:</span>
<span class="gi">+                for tack in tack_ext.tacks:</span>
<span class="gi">+                    if not cert_chain.checkTack(tack):</span>
<span class="gi">+                        for result in self._sendError(</span>
<span class="gi">+                                AlertDescription.illegal_parameter,</span>
<span class="gi">+                                &quot;Other party&#39;s TACK doesn&#39;t match their public key&quot;):</span>
<span class="gi">+                                yield result</span>

<span class="gd">-    def handshakeServer(self, verifierDB=None, certChain=None, privateKey=</span>
<span class="gd">-        None, reqCert=False, sessionCache=None, settings=None, checker=None,</span>
<span class="gd">-        reqCAs=None, tacks=None, activationFlags=0, nextProtos=None, anon=</span>
<span class="gd">-        False, alpn=None, sni=None):</span>
<span class="gi">+        yield public_key, cert_chain, tack_ext</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    #*********************************************************</span>
<span class="gi">+    # Server Handshake Functions</span>
<span class="gi">+    #*********************************************************</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def handshakeServer(self, verifierDB=None,</span>
<span class="gi">+                        certChain=None, privateKey=None, reqCert=False,</span>
<span class="gi">+                        sessionCache=None, settings=None, checker=None,</span>
<span class="gi">+                        reqCAs=None,</span>
<span class="gi">+                        tacks=None, activationFlags=0,</span>
<span class="gi">+                        nextProtos=None, anon=False, alpn=None, sni=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform a handshake in the role of server.

<span class="w"> </span>        This function performs an SSL or TLS handshake.  Depending on
<span class="gu">@@ -420,12 +2079,21 @@ class TLSConnection(TLSRecordLayer):</span>
<span class="w"> </span>        :raises tlslite.errors.TLSAuthenticationError: If the checker
<span class="w"> </span>            doesn&#39;t like the other party&#39;s authentication credentials.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for result in self.handshakeServerAsync(verifierDB,</span>
<span class="gi">+                certChain, privateKey, reqCert, sessionCache, settings,</span>
<span class="gi">+                checker, reqCAs,</span>
<span class="gi">+                tacks=tacks, activationFlags=activationFlags,</span>
<span class="gi">+                nextProtos=nextProtos, anon=anon, alpn=alpn, sni=sni):</span>
<span class="gi">+            pass</span>

<span class="gd">-    def handshakeServerAsync(self, verifierDB=None, certChain=None,</span>
<span class="gd">-        privateKey=None, reqCert=False, sessionCache=None, settings=None,</span>
<span class="gd">-        checker=None, reqCAs=None, tacks=None, activationFlags=0,</span>
<span class="gd">-        nextProtos=None, anon=False, alpn=None, sni=None):</span>
<span class="gi">+</span>
<span class="gi">+    def handshakeServerAsync(self, verifierDB=None,</span>
<span class="gi">+                             certChain=None, privateKey=None, reqCert=False,</span>
<span class="gi">+                             sessionCache=None, settings=None, checker=None,</span>
<span class="gi">+                             reqCAs=None,</span>
<span class="gi">+                             tacks=None, activationFlags=0,</span>
<span class="gi">+                             nextProtos=None, anon=False, alpn=None, sni=None</span>
<span class="gi">+                             ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Start a server handshake operation on the TLS connection.

<span class="w"> </span>        This function returns a generator which behaves similarly to
<span class="gu">@@ -437,7 +2105,345 @@ class TLSConnection(TLSRecordLayer):</span>
<span class="w"> </span>        :rtype: iterable
<span class="w"> </span>        :returns: A generator; see above for details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        handshaker = self._handshakeServerAsyncHelper(\</span>
<span class="gi">+            verifierDB=verifierDB, cert_chain=certChain,</span>
<span class="gi">+            privateKey=privateKey, reqCert=reqCert,</span>
<span class="gi">+            sessionCache=sessionCache, settings=settings,</span>
<span class="gi">+            reqCAs=reqCAs,</span>
<span class="gi">+            tacks=tacks, activationFlags=activationFlags,</span>
<span class="gi">+            nextProtos=nextProtos, anon=anon, alpn=alpn, sni=sni)</span>
<span class="gi">+        for result in self._handshakeWrapperAsync(handshaker, checker):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def _handshakeServerAsyncHelper(self, verifierDB,</span>
<span class="gi">+                                    cert_chain, privateKey, reqCert,</span>
<span class="gi">+                                    sessionCache, settings, reqCAs, tacks,</span>
<span class="gi">+                                    activationFlags, nextProtos, anon, alpn,</span>
<span class="gi">+                                    sni):</span>
<span class="gi">+</span>
<span class="gi">+        self._handshakeStart(client=False)</span>
<span class="gi">+</span>
<span class="gi">+        if not settings:</span>
<span class="gi">+            settings = HandshakeSettings()</span>
<span class="gi">+        settings = settings.validate()</span>
<span class="gi">+</span>
<span class="gi">+        if (not verifierDB) and (not cert_chain) and not anon and \</span>
<span class="gi">+                not settings.pskConfigs and not settings.virtual_hosts:</span>
<span class="gi">+            raise ValueError(&quot;Caller passed no authentication credentials&quot;)</span>
<span class="gi">+        if cert_chain and not privateKey:</span>
<span class="gi">+            raise ValueError(&quot;Caller passed a cert_chain but no privateKey&quot;)</span>
<span class="gi">+        if privateKey and not cert_chain:</span>
<span class="gi">+            raise ValueError(&quot;Caller passed a privateKey but no cert_chain&quot;)</span>
<span class="gi">+        if reqCAs and not reqCert:</span>
<span class="gi">+            raise ValueError(&quot;Caller passed reqCAs but not reqCert&quot;)</span>
<span class="gi">+        if cert_chain and not isinstance(cert_chain, X509CertChain):</span>
<span class="gi">+            raise ValueError(&quot;Unrecognized certificate type&quot;)</span>
<span class="gi">+        if activationFlags and not tacks:</span>
<span class="gi">+            raise ValueError(&quot;Nonzero activationFlags requires tacks&quot;)</span>
<span class="gi">+        if tacks:</span>
<span class="gi">+            if not tackpyLoaded:</span>
<span class="gi">+                raise ValueError(&quot;tackpy is not loaded&quot;)</span>
<span class="gi">+            if not settings.useExperimentalTackExtension:</span>
<span class="gi">+                raise ValueError(&quot;useExperimentalTackExtension not enabled&quot;)</span>
<span class="gi">+        if alpn is not None and not alpn:</span>
<span class="gi">+            raise ValueError(&quot;Empty list of ALPN protocols&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.sock.padding_cb = settings.padding_cb</span>
<span class="gi">+</span>
<span class="gi">+        # OK Start exchanging messages</span>
<span class="gi">+        # ******************************</span>
<span class="gi">+</span>
<span class="gi">+        # Handle ClientHello and resumption</span>
<span class="gi">+        for result in self._serverGetClientHello(settings, privateKey,</span>
<span class="gi">+                                                 cert_chain,</span>
<span class="gi">+                                                 verifierDB, sessionCache,</span>
<span class="gi">+                                                 anon, alpn, sni):</span>
<span class="gi">+            if result in (0,1): yield result</span>
<span class="gi">+            elif result == None:</span>
<span class="gi">+                self._handshakeDone(resumed=True)</span>
<span class="gi">+                return # Handshake was resumed, we&#39;re done</span>
<span class="gi">+            else: break</span>
<span class="gi">+        (clientHello, version, cipherSuite, sig_scheme, privateKey,</span>
<span class="gi">+            cert_chain) = result</span>
<span class="gi">+</span>
<span class="gi">+        # in TLS 1.3 the handshake is completely different</span>
<span class="gi">+        # (extensions go into different messages, format of messages is</span>
<span class="gi">+        # different, etc.)</span>
<span class="gi">+        if version &gt; (3, 3):</span>
<span class="gi">+            for result in self._serverTLS13Handshake(settings, clientHello,</span>
<span class="gi">+                                                     cipherSuite,</span>
<span class="gi">+                                                     privateKey, cert_chain,</span>
<span class="gi">+                                                     version, sig_scheme,</span>
<span class="gi">+                                                     alpn, reqCert):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+            if result == &quot;finished&quot;:</span>
<span class="gi">+                self._handshakeDone(resumed=False)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        #If not a resumption...</span>
<span class="gi">+</span>
<span class="gi">+        # Create the ServerHello message</span>
<span class="gi">+        if sessionCache:</span>
<span class="gi">+            sessionID = getRandomBytes(32)</span>
<span class="gi">+        else:</span>
<span class="gi">+            sessionID = bytearray(0)</span>
<span class="gi">+</span>
<span class="gi">+        if not clientHello.supports_npn:</span>
<span class="gi">+            nextProtos = None</span>
<span class="gi">+</span>
<span class="gi">+        alpnExt = clientHello.getExtension(ExtensionType.alpn)</span>
<span class="gi">+        if alpnExt and alpn:</span>
<span class="gi">+            # if there&#39;s ALPN, don&#39;t do NPN</span>
<span class="gi">+            nextProtos = None</span>
<span class="gi">+</span>
<span class="gi">+        # If not doing a certificate-based suite, discard the TACK</span>
<span class="gi">+        if not cipherSuite in CipherSuite.certAllSuites and \</span>
<span class="gi">+                not cipherSuite in CipherSuite.ecdheEcdsaSuites:</span>
<span class="gi">+            tacks = None</span>
<span class="gi">+</span>
<span class="gi">+        # Prepare a TACK Extension if requested</span>
<span class="gi">+        if clientHello.tack:</span>
<span class="gi">+            tackExt = TackExtension.create(tacks, activationFlags)</span>
<span class="gi">+        else:</span>
<span class="gi">+            tackExt = None</span>
<span class="gi">+</span>
<span class="gi">+        extensions = []</span>
<span class="gi">+        # Prepare other extensions if requested</span>
<span class="gi">+        if settings.useEncryptThenMAC and \</span>
<span class="gi">+                clientHello.getExtension(ExtensionType.encrypt_then_mac) and \</span>
<span class="gi">+                cipherSuite not in CipherSuite.streamSuites and \</span>
<span class="gi">+                cipherSuite not in CipherSuite.aeadSuites:</span>
<span class="gi">+            extensions.append(TLSExtension().create(ExtensionType.</span>
<span class="gi">+                                                    encrypt_then_mac,</span>
<span class="gi">+                                                    bytearray(0)))</span>
<span class="gi">+            self._recordLayer.encryptThenMAC = True</span>
<span class="gi">+</span>
<span class="gi">+        if settings.useExtendedMasterSecret:</span>
<span class="gi">+            if clientHello.getExtension(ExtensionType.extended_master_secret):</span>
<span class="gi">+                extensions.append(TLSExtension().create(ExtensionType.</span>
<span class="gi">+                                                        extended_master_secret,</span>
<span class="gi">+                                                        bytearray(0)))</span>
<span class="gi">+                self.extendedMasterSecret = True</span>
<span class="gi">+            elif settings.requireExtendedMasterSecret:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.insufficient_security,</span>
<span class="gi">+                        &quot;Failed to negotiate Extended Master Secret&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+        selectedALPN = None</span>
<span class="gi">+        if alpnExt and alpn:</span>
<span class="gi">+            for protoName in alpnExt.protocol_names:</span>
<span class="gi">+                if protoName in alpn:</span>
<span class="gi">+                    selectedALPN = protoName</span>
<span class="gi">+                    ext = ALPNExtension().create([protoName])</span>
<span class="gi">+                    extensions.append(ext)</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.no_application_protocol,</span>
<span class="gi">+                        &quot;No mutually supported application layer protocols&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+        # notify client that we understood its renegotiation info extension</span>
<span class="gi">+        # or SCSV</span>
<span class="gi">+        secureRenego = False</span>
<span class="gi">+        renegoExt = clientHello.getExtension(ExtensionType.renegotiation_info)</span>
<span class="gi">+        if renegoExt:</span>
<span class="gi">+            if renegoExt.renegotiated_connection:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.handshake_failure,</span>
<span class="gi">+                        &quot;Non empty renegotiation info extension in &quot;</span>
<span class="gi">+                        &quot;initial Client Hello&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            secureRenego = True</span>
<span class="gi">+        elif CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV in \</span>
<span class="gi">+                clientHello.cipher_suites:</span>
<span class="gi">+            secureRenego = True</span>
<span class="gi">+        if secureRenego:</span>
<span class="gi">+            extensions.append(RenegotiationInfoExtension()</span>
<span class="gi">+                              .create(bytearray(0)))</span>
<span class="gi">+</span>
<span class="gi">+        # tell the client what point formats we support</span>
<span class="gi">+        if clientHello.getExtension(ExtensionType.ec_point_formats):</span>
<span class="gi">+            # even though the selected cipher may not use ECC, client may want</span>
<span class="gi">+            # to send a CA certificate with ECDSA...</span>
<span class="gi">+            extensions.append(ECPointFormatsExtension().create(</span>
<span class="gi">+                [ECPointFormat.uncompressed]))</span>
<span class="gi">+</span>
<span class="gi">+        # if client sent Heartbeat extension</span>
<span class="gi">+        if clientHello.getExtension(ExtensionType.heartbeat):</span>
<span class="gi">+            # and we want to accept it</span>
<span class="gi">+            if settings.use_heartbeat_extension:</span>
<span class="gi">+                extensions.append(HeartbeatExtension().create(</span>
<span class="gi">+                    HeartbeatMode.PEER_ALLOWED_TO_SEND))</span>
<span class="gi">+</span>
<span class="gi">+        if clientHello.getExtension(ExtensionType.record_size_limit) and \</span>
<span class="gi">+                settings.record_size_limit:</span>
<span class="gi">+            # in TLS 1.2 and earlier we can select at most 2^14B records</span>
<span class="gi">+            extensions.append(RecordSizeLimitExtension().create(</span>
<span class="gi">+                min(2**14, settings.record_size_limit)))</span>
<span class="gi">+</span>
<span class="gi">+        # If the client indicates that it supports resumption using</span>
<span class="gi">+        # session_ticket extension, we send a zero len extension to indicate</span>
<span class="gi">+        # that we are going to</span>
<span class="gi">+        # send a new ticket in a NewSessionTicket message</span>
<span class="gi">+        send_session_ticket = False</span>
<span class="gi">+        session_ticket = clientHello.getExtension(ExtensionType.session_ticket)</span>
<span class="gi">+        enable_ticket = settings.ticket_count &gt; 0 and settings.ticketKeys</span>
<span class="gi">+        if session_ticket and len(session_ticket.ticket) == 0 \</span>
<span class="gi">+                and enable_ticket:</span>
<span class="gi">+            send_session_ticket = True</span>
<span class="gi">+            extensions.append(SessionTicketExtension().create(</span>
<span class="gi">+                bytearray(0)))</span>
<span class="gi">+</span>
<span class="gi">+        # don&#39;t send empty list of extensions</span>
<span class="gi">+        if not extensions:</span>
<span class="gi">+            extensions = None</span>
<span class="gi">+</span>
<span class="gi">+        serverHello = ServerHello()</span>
<span class="gi">+        # RFC 8446, section 4.1.3</span>
<span class="gi">+        random = getRandomBytes(32)</span>
<span class="gi">+        if version == (3, 3) and settings.maxVersion &gt; (3, 3):</span>
<span class="gi">+            random[-8:] = TLS_1_2_DOWNGRADE_SENTINEL</span>
<span class="gi">+        if version &lt; (3, 3) and settings.maxVersion &gt;= (3, 3):</span>
<span class="gi">+            random[-8:] = TLS_1_1_DOWNGRADE_SENTINEL</span>
<span class="gi">+        serverHello.create(self.version, random, sessionID,</span>
<span class="gi">+                           cipherSuite, CertificateType.x509, tackExt,</span>
<span class="gi">+                           nextProtos, extensions=extensions)</span>
<span class="gi">+</span>
<span class="gi">+        # Perform the SRP key exchange</span>
<span class="gi">+        clientCertChain = None</span>
<span class="gi">+        if cipherSuite in CipherSuite.srpAllSuites:</span>
<span class="gi">+            for result in self._serverSRPKeyExchange(clientHello, serverHello,</span>
<span class="gi">+                                                     verifierDB, cipherSuite,</span>
<span class="gi">+                                                     privateKey, cert_chain,</span>
<span class="gi">+                                                     settings):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            premasterSecret, privateKey, cert_chain = result</span>
<span class="gi">+</span>
<span class="gi">+        # Perform a certificate-based key exchange</span>
<span class="gi">+        elif (cipherSuite in CipherSuite.certSuites or</span>
<span class="gi">+              cipherSuite in CipherSuite.dheCertSuites or</span>
<span class="gi">+              cipherSuite in CipherSuite.dheDsaSuites or</span>
<span class="gi">+              cipherSuite in CipherSuite.ecdheCertSuites or</span>
<span class="gi">+              cipherSuite in CipherSuite.ecdheEcdsaSuites):</span>
<span class="gi">+            try:</span>
<span class="gi">+                sig_hash_alg, cert_chain, privateKey = \</span>
<span class="gi">+                    self._pickServerKeyExchangeSig(settings,</span>
<span class="gi">+                                                   clientHello,</span>
<span class="gi">+                                                   cert_chain,</span>
<span class="gi">+                                                   privateKey)</span>
<span class="gi">+            except TLSHandshakeFailure as alert:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.handshake_failure,</span>
<span class="gi">+                        str(alert)):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+            if cipherSuite in CipherSuite.certSuites:</span>
<span class="gi">+                keyExchange = RSAKeyExchange(cipherSuite,</span>
<span class="gi">+                                             clientHello,</span>
<span class="gi">+                                             serverHello,</span>
<span class="gi">+                                             privateKey)</span>
<span class="gi">+            elif cipherSuite in CipherSuite.dheCertSuites or \</span>
<span class="gi">+                    cipherSuite in CipherSuite.dheDsaSuites:</span>
<span class="gi">+                dhGroups = self._groupNamesToList(settings)</span>
<span class="gi">+                keyExchange = DHE_RSAKeyExchange(cipherSuite,</span>
<span class="gi">+                                                 clientHello,</span>
<span class="gi">+                                                 serverHello,</span>
<span class="gi">+                                                 privateKey,</span>
<span class="gi">+                                                 settings.dhParams,</span>
<span class="gi">+                                                 dhGroups)</span>
<span class="gi">+            elif cipherSuite in CipherSuite.ecdheCertSuites or \</span>
<span class="gi">+                    cipherSuite in CipherSuite.ecdheEcdsaSuites:</span>
<span class="gi">+                acceptedCurves = self._curveNamesToList(settings)</span>
<span class="gi">+                defaultCurve = getattr(GroupName, settings.defaultCurve)</span>
<span class="gi">+                keyExchange = ECDHE_RSAKeyExchange(cipherSuite,</span>
<span class="gi">+                                                   clientHello,</span>
<span class="gi">+                                                   serverHello,</span>
<span class="gi">+                                                   privateKey,</span>
<span class="gi">+                                                   acceptedCurves,</span>
<span class="gi">+                                                   defaultCurve)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert(False)</span>
<span class="gi">+            for result in self._serverCertKeyExchange(clientHello, serverHello,</span>
<span class="gi">+                                        sig_hash_alg, cert_chain, keyExchange,</span>
<span class="gi">+                                        reqCert, reqCAs, cipherSuite,</span>
<span class="gi">+                                        settings):</span>
<span class="gi">+                if result in (0,1): yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            (premasterSecret, clientCertChain) = result</span>
<span class="gi">+</span>
<span class="gi">+        # Perform anonymous Diffie Hellman key exchange</span>
<span class="gi">+        elif (cipherSuite in CipherSuite.anonSuites or</span>
<span class="gi">+              cipherSuite in CipherSuite.ecdhAnonSuites):</span>
<span class="gi">+            if cipherSuite in CipherSuite.anonSuites:</span>
<span class="gi">+                dhGroups = self._groupNamesToList(settings)</span>
<span class="gi">+                keyExchange = ADHKeyExchange(cipherSuite, clientHello,</span>
<span class="gi">+                                             serverHello, settings.dhParams,</span>
<span class="gi">+                                             dhGroups)</span>
<span class="gi">+            else:</span>
<span class="gi">+                acceptedCurves = self._curveNamesToList(settings)</span>
<span class="gi">+                defaultCurve = getattr(GroupName, settings.defaultCurve)</span>
<span class="gi">+                keyExchange = AECDHKeyExchange(cipherSuite, clientHello,</span>
<span class="gi">+                                               serverHello, acceptedCurves,</span>
<span class="gi">+                                               defaultCurve)</span>
<span class="gi">+            for result in self._serverAnonKeyExchange(serverHello, keyExchange,</span>
<span class="gi">+                                                      cipherSuite):</span>
<span class="gi">+                if result in (0,1): yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            premasterSecret = result</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert(False)</span>
<span class="gi">+</span>
<span class="gi">+        # Create the session object</span>
<span class="gi">+        self.session = Session()</span>
<span class="gi">+        if cipherSuite in CipherSuite.certAllSuites or \</span>
<span class="gi">+                cipherSuite in CipherSuite.ecdheEcdsaSuites:</span>
<span class="gi">+            serverCertChain = cert_chain</span>
<span class="gi">+        else:</span>
<span class="gi">+            serverCertChain = None</span>
<span class="gi">+        srpUsername = None</span>
<span class="gi">+        serverName = None</span>
<span class="gi">+        if clientHello.srp_username:</span>
<span class="gi">+            srpUsername = clientHello.srp_username.decode(&quot;utf-8&quot;)</span>
<span class="gi">+        if clientHello.server_name:</span>
<span class="gi">+            serverName = clientHello.server_name.decode(&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # We&#39;ll update the session master secret once it is calculated</span>
<span class="gi">+        # in _serverFinished</span>
<span class="gi">+        self.session.create(b&quot;&quot;, serverHello.session_id, cipherSuite,</span>
<span class="gi">+                            srpUsername, clientCertChain, serverCertChain,</span>
<span class="gi">+                            tackExt, (serverHello.tackExt is not None),</span>
<span class="gi">+                            serverName,</span>
<span class="gi">+                            encryptThenMAC=</span>
<span class="gi">+                            self._recordLayer._get_pending_state_etm(),</span>
<span class="gi">+                            extendedMasterSecret=self.extendedMasterSecret,</span>
<span class="gi">+                            appProto=selectedALPN,</span>
<span class="gi">+                            # NOTE it must be a reference, not a copy!</span>
<span class="gi">+                            tickets=self.tickets)</span>
<span class="gi">+</span>
<span class="gi">+        # Exchange Finished messages</span>
<span class="gi">+        for result in self._serverFinished(premasterSecret,</span>
<span class="gi">+                                clientHello.random, serverHello.random,</span>
<span class="gi">+                                cipherSuite, settings.cipherImplementations,</span>
<span class="gi">+                                nextProtos, settings, send_session_ticket,</span>
<span class="gi">+                                clientCertChain):</span>
<span class="gi">+                if result in (0,1): yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+</span>
<span class="gi">+        #Add the session object to the session cache</span>
<span class="gi">+        if sessionCache and sessionID:</span>
<span class="gi">+            sessionCache[sessionID] = self.session</span>
<span class="gi">+</span>
<span class="gi">+        self._handshakeDone(resumed=False)</span>
<span class="gi">+        self._serverRandom = serverHello.random</span>
<span class="gi">+        self._clientRandom = clientHello.random</span>

<span class="w"> </span>    def request_post_handshake_auth(self, settings=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -448,56 +2454,2309 @@ class TLSConnection(TLSRecordLayer):</span>
<span class="w"> </span>        will only request for the new identity of client, it will not wait for
<span class="w"> </span>        it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.version != (3, 4):</span>
<span class="gi">+            raise ValueError(&quot;PHA is supported only in TLS 1.3&quot;)</span>
<span class="gi">+        if self._client:</span>
<span class="gi">+            raise ValueError(&quot;PHA can only be requested by server&quot;)</span>
<span class="gi">+        if not self._pha_supported:</span>
<span class="gi">+            raise ValueError(&quot;PHA not supported by client&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        settings = settings or HandshakeSettings()</span>
<span class="gi">+        settings = settings.validate()</span>
<span class="gi">+</span>
<span class="gi">+        valid_sig_algs = self._sigHashesToList(settings)</span>
<span class="gi">+        if not valid_sig_algs:</span>
<span class="gi">+            raise ValueError(&quot;No signature algorithms enabled in &quot;</span>
<span class="gi">+                             &quot;HandshakeSettings&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        context = bytes(getRandomBytes(32))</span>
<span class="gi">+</span>
<span class="gi">+        certificate_request = CertificateRequest(self.version)</span>
<span class="gi">+        certificate_request.create(context=context, sig_algs=valid_sig_algs)</span>
<span class="gi">+</span>
<span class="gi">+        self._cert_requests[context] = certificate_request</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._sendMsg(certificate_request):</span>
<span class="gi">+            yield result</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _derive_key_iv(nonce, user_key, settings):
<span class="w"> </span>        &quot;&quot;&quot;Derive the IV and key for session ticket encryption.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if settings.ticketCipher == &quot;aes128gcm&quot;:</span>
<span class="gi">+            prf_name = &quot;sha256&quot;</span>
<span class="gi">+            prf_size = 32</span>
<span class="gi">+        else:</span>
<span class="gi">+            prf_name = &quot;sha384&quot;</span>
<span class="gi">+            prf_size = 48</span>
<span class="gi">+</span>
<span class="gi">+        # mix the nonce with the key set by user</span>
<span class="gi">+        secret = bytearray(prf_size)</span>
<span class="gi">+        secret = secureHMAC(secret, nonce, prf_name)</span>
<span class="gi">+        secret = derive_secret(secret, bytearray(b&#39;derived&#39;), None, prf_name)</span>
<span class="gi">+        secret = secureHMAC(secret, user_key, prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        ticket_secret = derive_secret(secret,</span>
<span class="gi">+                                      bytearray(b&#39;SessionTicket secret&#39;),</span>
<span class="gi">+                                      None, prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        key = HKDF_expand_label(ticket_secret, b&quot;key&quot;, b&quot;&quot;, len(user_key),</span>
<span class="gi">+                                prf_name)</span>
<span class="gi">+        # all AEADs use 12 byte long IV</span>
<span class="gi">+        iv = HKDF_expand_label(ticket_secret, b&quot;iv&quot;, b&quot;&quot;, 12, prf_name)</span>
<span class="gi">+        return key, iv</span>

<span class="w"> </span>    def _serverSendTickets(self, settings):
<span class="w"> </span>        &quot;&quot;&quot;Send session tickets to client.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not settings.ticketKeys:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self.version &lt; (3, 4):</span>
<span class="gi">+            secret = self.session.masterSecret</span>
<span class="gi">+        else:</span>
<span class="gi">+            secret = self.session.resumptionMasterSecret</span>
<span class="gi">+</span>
<span class="gi">+        # make sure we send at most one ticket in TLS 1.2 and earlier</span>
<span class="gi">+        for _ in range(settings.ticket_count if self.version &gt; (3, 3) else</span>
<span class="gi">+                       int(bool(settings.ticket_count))):</span>
<span class="gi">+            # prepare the ticket</span>
<span class="gi">+            ticket = SessionTicketPayload()</span>
<span class="gi">+            ticket.create(secret,</span>
<span class="gi">+                          self.version,</span>
<span class="gi">+                          self.session.cipherSuite,</span>
<span class="gi">+                          int(time.time()),</span>
<span class="gi">+                          getRandomBytes(len(settings.ticketKeys[0])),</span>
<span class="gi">+                          client_cert_chain=self.session.clientCertChain,</span>
<span class="gi">+                          encrypt_then_mac=</span>
<span class="gi">+                          self._recordLayer._get_pending_state_etm(),</span>
<span class="gi">+                          extended_master_secret=self.extendedMasterSecret,</span>
<span class="gi">+                          server_name=self.session.serverName.encode(&quot;utf-8&quot;)</span>
<span class="gi">+                          if self.session.serverName else bytearray())</span>
<span class="gi">+</span>
<span class="gi">+            # encrypt the ticket</span>
<span class="gi">+</span>
<span class="gi">+            # generate keys for the encryption</span>
<span class="gi">+            nonce = getRandomBytes(32)</span>
<span class="gi">+            key, iv = self._derive_key_iv(nonce, settings.ticketKeys[0],</span>
<span class="gi">+                                          settings)</span>
<span class="gi">+</span>
<span class="gi">+            if settings.ticketCipher in (&quot;aes128gcm&quot;, &quot;aes256gcm&quot;):</span>
<span class="gi">+                cipher = createAESGCM(key,</span>
<span class="gi">+                                      settings.cipherImplementations)</span>
<span class="gi">+            elif settings.ticketCipher in (&quot;aes128ccm&quot;, &quot;aes256ccm&quot;):</span>
<span class="gi">+                cipher = createAESCCM(key, settings.cipherImplementations)</span>
<span class="gi">+            elif settings.ticketCipher in (&quot;aes128ccm_8&quot;, &quot;aes256ccm_8&quot;):</span>
<span class="gi">+                cipher = createAESCCM_8(key, settings.cipherImplementations)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert settings.ticketCipher == &quot;chacha20-poly1305&quot;</span>
<span class="gi">+                cipher = createCHACHA20(key,</span>
<span class="gi">+                                        settings.cipherImplementations)</span>
<span class="gi">+</span>
<span class="gi">+            encrypted_ticket = cipher.seal(iv, ticket.write(), b&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            # encapsulate the ticket and send to client</span>
<span class="gi">+            if self.version &lt; (3, 4):</span>
<span class="gi">+                new_ticket = NewSessionTicket1_0()</span>
<span class="gi">+                new_ticket.create(settings.ticketLifetime,</span>
<span class="gi">+                                  nonce + encrypted_ticket)</span>
<span class="gi">+                self.tls_1_0_tickets.append(encrypted_ticket)</span>
<span class="gi">+            else:</span>
<span class="gi">+                new_ticket = NewSessionTicket()</span>
<span class="gi">+                new_ticket.create(settings.ticketLifetime,</span>
<span class="gi">+                                  getRandomNumber(1, 8**4),</span>
<span class="gi">+                                  ticket.nonce,</span>
<span class="gi">+                                  nonce + encrypted_ticket,</span>
<span class="gi">+                                  [])</span>
<span class="gi">+            self._queue_message(new_ticket)</span>
<span class="gi">+</span>
<span class="gi">+        # send tickets to client</span>
<span class="gi">+        if settings.ticket_count:</span>
<span class="gi">+            for result in self._queue_flush():</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+    def _tryDecrypt(self, settings, identity=None, ticket=None):</span>
<span class="gi">+        if not settings.ticketKeys:</span>
<span class="gi">+            return None, None</span>
<span class="gi">+</span>
<span class="gi">+        if self.version &lt; (3, 4):</span>
<span class="gi">+            assert ticket</span>
<span class="gi">+            nonce, encrypted_ticket = ticket[:32], ticket[32:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert identity</span>
<span class="gi">+            if len(identity.identity) &lt; 33:</span>
<span class="gi">+                # too small for an encrypted ticket</span>
<span class="gi">+                return None, None</span>
<span class="gi">+            nonce, encrypted_ticket = identity.identity[:32], identity.identity[32:]</span>
<span class="gi">+</span>
<span class="gi">+        for user_key in settings.ticketKeys:</span>
<span class="gi">+            key, iv = self._derive_key_iv(nonce, user_key, settings)</span>
<span class="gi">+            if settings.ticketCipher in (&quot;aes128gcm&quot;, &quot;aes256gcm&quot;):</span>
<span class="gi">+                cipher = createAESGCM(key, settings.cipherImplementations)</span>
<span class="gi">+            elif settings.ticketCipher in (&quot;aes128ccm&quot;, &quot;aes256ccm&quot;):</span>
<span class="gi">+                cipher = createAESCCM(key, settings.cipherImplementations)</span>
<span class="gi">+            elif settings.ticketCipher in (&quot;aes128ccm_8&quot;, &quot;aes256ccm_8&quot;):</span>
<span class="gi">+                cipher = createAESCCM_8(key, settings.cipherImplementations)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert settings.ticketCipher == &quot;chacha20-poly1305&quot;</span>
<span class="gi">+                cipher = createCHACHA20(key, settings.cipherImplementations)</span>
<span class="gi">+</span>
<span class="gi">+            ticket = cipher.open(iv, encrypted_ticket, b&#39;&#39;)</span>
<span class="gi">+            if not ticket:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            parser = Parser(ticket)</span>
<span class="gi">+            try:</span>
<span class="gi">+                ticket = SessionTicketPayload().parse(parser)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if self.version &lt; (3, 4):</span>
<span class="gi">+                return None, ticket</span>
<span class="gi">+</span>
<span class="gi">+            prf = &#39;sha384&#39; if ticket.cipher_suite \</span>
<span class="gi">+                in CipherSuite.sha384PrfSuites else &#39;sha256&#39;</span>
<span class="gi">+</span>
<span class="gi">+            new_sess_ticket = NewSessionTicket()</span>
<span class="gi">+            new_sess_ticket.ticket_nonce = ticket.nonce</span>
<span class="gi">+            new_sess_ticket.ticket = identity.identity</span>
<span class="gi">+</span>
<span class="gi">+            psk = HandshakeHelpers.calc_res_binder_psk(identity,</span>
<span class="gi">+                                                       ticket.master_secret,</span>
<span class="gi">+                                                       [new_sess_ticket])</span>
<span class="gi">+</span>
<span class="gi">+            return ((identity.identity, psk, prf), ticket)</span>
<span class="gi">+</span>
<span class="gi">+        # no working keys</span>
<span class="gi">+        return None, None</span>

<span class="w"> </span>    def _serverTLS13Handshake(self, settings, clientHello, cipherSuite,
<span class="gd">-        privateKey, serverCertChain, version, scheme, srv_alpns, reqCert):</span>
<span class="gi">+                              privateKey, serverCertChain, version, scheme,</span>
<span class="gi">+                              srv_alpns, reqCert):</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform a TLS 1.3 handshake&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prf_name, prf_size = self._getPRFParams(cipherSuite)</span>
<span class="gi">+</span>
<span class="gi">+        secret = bytearray(prf_size)</span>
<span class="gi">+</span>
<span class="gi">+        share = clientHello.getExtension(ExtensionType.key_share)</span>
<span class="gi">+        if share:</span>
<span class="gi">+            share_ids = [i.group for i in share.client_shares]</span>
<span class="gi">+            for group_name in chain(settings.keyShares, settings.eccCurves,</span>
<span class="gi">+                                    settings.dhGroups):</span>
<span class="gi">+                selected_group = getattr(GroupName, group_name)</span>
<span class="gi">+                if selected_group in share_ids:</span>
<span class="gi">+                    cl_key_share = next(i for i in share.client_shares</span>
<span class="gi">+                                        if i.group == selected_group)</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                for result in self._sendError(AlertDescription.internal_error,</span>
<span class="gi">+                                              &quot;HRR did not work?!&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+        psk = None</span>
<span class="gi">+        selected_psk = None</span>
<span class="gi">+        resumed_client_cert_chain = None</span>
<span class="gi">+        psks = clientHello.getExtension(ExtensionType.pre_shared_key)</span>
<span class="gi">+        psk_types = clientHello.getExtension(</span>
<span class="gi">+            ExtensionType.psk_key_exchange_modes)</span>
<span class="gi">+        if psks and (PskKeyExchangeMode.psk_dhe_ke in psk_types.modes or</span>
<span class="gi">+                     PskKeyExchangeMode.psk_ke in psk_types.modes) and \</span>
<span class="gi">+                (settings.pskConfigs or settings.ticketKeys):</span>
<span class="gi">+            for i, ident in enumerate(psks.identities):</span>
<span class="gi">+                ticket = None</span>
<span class="gi">+                external = True</span>
<span class="gi">+                match = [j for j in settings.pskConfigs</span>
<span class="gi">+                         if j[0] == ident.identity]</span>
<span class="gi">+                if not match:</span>
<span class="gi">+                    (match, ticket) = self._tryDecrypt(settings, ident)</span>
<span class="gi">+                    external = False</span>
<span class="gi">+                    if not match:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    match = [match]</span>
<span class="gi">+</span>
<span class="gi">+                # check if the ticket version matches</span>
<span class="gi">+                # but with PSK we don&#39;t have a ticket, but we still can have a</span>
<span class="gi">+                # binder value, so `match` will be non-null</span>
<span class="gi">+                if ticket and self.version != ticket.protocol_version:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # check if PSK can be used with selected cipher suite</span>
<span class="gi">+                psk_hash = match[0][2] if len(match[0]) &gt; 2 else &#39;sha256&#39;</span>
<span class="gi">+                if psk_hash != prf_name:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                psk = match[0][1]</span>
<span class="gi">+                selected_psk = i</span>
<span class="gi">+                if ticket:</span>
<span class="gi">+                    resumed_client_cert_chain = ticket.client_cert_chain</span>
<span class="gi">+                try:</span>
<span class="gi">+                    HandshakeHelpers.verify_binder(</span>
<span class="gi">+                        clientHello,</span>
<span class="gi">+                        self._pre_client_hello_handshake_hash,</span>
<span class="gi">+                        selected_psk,</span>
<span class="gi">+                        psk,</span>
<span class="gi">+                        psk_hash,</span>
<span class="gi">+                        external)</span>
<span class="gi">+                except TLSIllegalParameterException as e:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter,</span>
<span class="gi">+                            str(e)):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        sh_extensions = []</span>
<span class="gi">+</span>
<span class="gi">+        # we need to gen key share either when we selected psk_dhe_ke or</span>
<span class="gi">+        # regular certificate authenticated key exchange (the default)</span>
<span class="gi">+        if (psk and</span>
<span class="gi">+                PskKeyExchangeMode.psk_dhe_ke in psk_types.modes and</span>
<span class="gi">+                &quot;psk_dhe_ke&quot; in settings.psk_modes) or\</span>
<span class="gi">+                (psk is None and privateKey):</span>
<span class="gi">+            self.ecdhCurve = selected_group</span>
<span class="gi">+            kex = self._getKEX(selected_group, version)</span>
<span class="gi">+            key_share = self._genKeyShareEntry(selected_group, version)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                shared_sec = kex.calc_shared_key(key_share.private,</span>
<span class="gi">+                                                 cl_key_share.key_exchange)</span>
<span class="gi">+            except TLSIllegalParameterException as alert:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        str(alert)):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+            sh_extensions.append(ServerKeyShareExtension().create(key_share))</span>
<span class="gi">+        elif (psk is not None and</span>
<span class="gi">+              PskKeyExchangeMode.psk_ke in psk_types.modes and</span>
<span class="gi">+              &quot;psk_ke&quot; in settings.psk_modes):</span>
<span class="gi">+            shared_sec = bytearray(prf_size)</span>
<span class="gi">+        else:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.handshake_failure,</span>
<span class="gi">+                    &quot;Could not find acceptable PSK identity nor certificate&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        if psk is None:</span>
<span class="gi">+            psk = bytearray(prf_size)</span>
<span class="gi">+</span>
<span class="gi">+        sh_extensions.append(SrvSupportedVersionsExtension().create(version))</span>
<span class="gi">+        if selected_psk is not None:</span>
<span class="gi">+            sh_extensions.append(SrvPreSharedKeyExtension()</span>
<span class="gi">+                                 .create(selected_psk))</span>
<span class="gi">+</span>
<span class="gi">+        serverHello = ServerHello()</span>
<span class="gi">+        # in TLS1.3 the version selected is sent in extension, (3, 3) is</span>
<span class="gi">+        # just dummy value to workaround broken middleboxes</span>
<span class="gi">+        serverHello.create((3, 3), getRandomBytes(32),</span>
<span class="gi">+                           clientHello.session_id,</span>
<span class="gi">+                           cipherSuite, extensions=sh_extensions)</span>
<span class="gi">+</span>
<span class="gi">+        msgs = []</span>
<span class="gi">+        msgs.append(serverHello)</span>
<span class="gi">+        if not self._ccs_sent and clientHello.session_id:</span>
<span class="gi">+            ccs = ChangeCipherSpec().create()</span>
<span class="gi">+            msgs.append(ccs)</span>
<span class="gi">+        for result in self._sendMsgs(msgs):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+        # Early secret</span>
<span class="gi">+        secret = secureHMAC(secret, psk, prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        # Handshake Secret</span>
<span class="gi">+        secret = derive_secret(secret, bytearray(b&#39;derived&#39;), None, prf_name)</span>
<span class="gi">+        secret = secureHMAC(secret, shared_sec, prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        sr_handshake_traffic_secret = derive_secret(secret,</span>
<span class="gi">+                                                    bytearray(b&#39;s hs traffic&#39;),</span>
<span class="gi">+                                                    self._handshake_hash,</span>
<span class="gi">+                                                    prf_name)</span>
<span class="gi">+        cl_handshake_traffic_secret = derive_secret(secret,</span>
<span class="gi">+                                                    bytearray(b&#39;c hs traffic&#39;),</span>
<span class="gi">+                                                    self._handshake_hash,</span>
<span class="gi">+                                                    prf_name)</span>
<span class="gi">+        self.version = version</span>
<span class="gi">+        self._recordLayer.calcTLS1_3PendingState(</span>
<span class="gi">+            cipherSuite,</span>
<span class="gi">+            cl_handshake_traffic_secret,</span>
<span class="gi">+            sr_handshake_traffic_secret,</span>
<span class="gi">+            settings.cipherImplementations)</span>
<span class="gi">+</span>
<span class="gi">+        self._changeWriteState()</span>
<span class="gi">+</span>
<span class="gi">+        ee_extensions = []</span>
<span class="gi">+</span>
<span class="gi">+        if clientHello.getExtension(ExtensionType.record_size_limit) and \</span>
<span class="gi">+                settings.record_size_limit:</span>
<span class="gi">+            ee_extensions.append(RecordSizeLimitExtension().create(</span>
<span class="gi">+                min(2**14+1, settings.record_size_limit)))</span>
<span class="gi">+</span>
<span class="gi">+        # a bit of a hack to detect if the HRR was sent</span>
<span class="gi">+        # as that means that original key share didn&#39;t match what we wanted</span>
<span class="gi">+        # send the client updated list of shares we support,</span>
<span class="gi">+        # preferred ones first</span>
<span class="gi">+        if clientHello.getExtension(ExtensionType.cookie):</span>
<span class="gi">+            ext = SupportedGroupsExtension()</span>
<span class="gi">+            groups = [getattr(GroupName, i) for i in settings.keyShares]</span>
<span class="gi">+            groups += [getattr(GroupName, i) for i in settings.eccCurves</span>
<span class="gi">+                       if getattr(GroupName, i) not in groups]</span>
<span class="gi">+            groups += [getattr(GroupName, i) for i in settings.dhGroups</span>
<span class="gi">+                       if getattr(GroupName, i) not in groups]</span>
<span class="gi">+            if groups:</span>
<span class="gi">+                ext.create(groups)</span>
<span class="gi">+                ee_extensions.append(ext)</span>
<span class="gi">+</span>
<span class="gi">+        alpn_ext = clientHello.getExtension(ExtensionType.alpn)</span>
<span class="gi">+        if alpn_ext:</span>
<span class="gi">+            # error handling was done when receiving ClientHello</span>
<span class="gi">+            matched = [i for i in alpn_ext.protocol_names if i in srv_alpns]</span>
<span class="gi">+            if matched:</span>
<span class="gi">+                ext = ALPNExtension().create([matched[0]])</span>
<span class="gi">+                ee_extensions.append(ext)</span>
<span class="gi">+</span>
<span class="gi">+        if clientHello.getExtension(ExtensionType.heartbeat):</span>
<span class="gi">+            if settings.use_heartbeat_extension:</span>
<span class="gi">+                ee_extensions.append(HeartbeatExtension().create(</span>
<span class="gi">+                    HeartbeatMode.PEER_ALLOWED_TO_SEND))</span>
<span class="gi">+</span>
<span class="gi">+        encryptedExtensions = EncryptedExtensions().create(ee_extensions)</span>
<span class="gi">+        self._queue_message(encryptedExtensions)</span>
<span class="gi">+</span>
<span class="gi">+        if selected_psk is None:</span>
<span class="gi">+</span>
<span class="gi">+            # optionally send the client a certificate request</span>
<span class="gi">+            if reqCert:</span>
<span class="gi">+</span>
<span class="gi">+                # the context SHALL be zero length except in post-handshake</span>
<span class="gi">+                ctx = b&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+                # Get list of valid Signing Algorithms</span>
<span class="gi">+                # DSA is not supported for TLS 1.3</span>
<span class="gi">+                cr_settings = settings.validate()</span>
<span class="gi">+                cr_settings.dsaSigHashes = []</span>
<span class="gi">+                valid_sig_algs = self._sigHashesToList(cr_settings)</span>
<span class="gi">+                assert valid_sig_algs</span>
<span class="gi">+</span>
<span class="gi">+                certificate_request = CertificateRequest(self.version)</span>
<span class="gi">+                certificate_request.create(context=ctx, sig_algs=valid_sig_algs)</span>
<span class="gi">+                self._queue_message(certificate_request)</span>
<span class="gi">+</span>
<span class="gi">+            certificate = Certificate(CertificateType.x509, self.version)</span>
<span class="gi">+            certificate.create(serverCertChain, bytearray())</span>
<span class="gi">+            self._queue_message(certificate)</span>
<span class="gi">+</span>
<span class="gi">+            certificate_verify = CertificateVerify(self.version)</span>
<span class="gi">+</span>
<span class="gi">+            signature_scheme = getattr(SignatureScheme, scheme)</span>
<span class="gi">+</span>
<span class="gi">+            signature_context = \</span>
<span class="gi">+                KeyExchange.calcVerifyBytes((3, 4), self._handshake_hash,</span>
<span class="gi">+                                            signature_scheme, None, None, None,</span>
<span class="gi">+                                            prf_name, b&#39;server&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if signature_scheme in (SignatureScheme.ed25519,</span>
<span class="gi">+                    SignatureScheme.ed448):</span>
<span class="gi">+                hashName = &quot;intrinsic&quot;</span>
<span class="gi">+                padType = None</span>
<span class="gi">+                saltLen = None</span>
<span class="gi">+                sig_func = privateKey.hashAndSign</span>
<span class="gi">+                ver_func = privateKey.hashAndVerify</span>
<span class="gi">+            elif signature_scheme[1] == SignatureAlgorithm.ecdsa:</span>
<span class="gi">+                hashName = HashAlgorithm.toRepr(signature_scheme[0])</span>
<span class="gi">+                padType = None</span>
<span class="gi">+                saltLen = None</span>
<span class="gi">+                sig_func = privateKey.sign</span>
<span class="gi">+                ver_func = privateKey.verify</span>
<span class="gi">+            else:</span>
<span class="gi">+                padType = SignatureScheme.getPadding(scheme)</span>
<span class="gi">+                hashName = SignatureScheme.getHash(scheme)</span>
<span class="gi">+                saltLen = getattr(hashlib, hashName)().digest_size</span>
<span class="gi">+                sig_func = privateKey.sign</span>
<span class="gi">+                ver_func = privateKey.verify</span>
<span class="gi">+</span>
<span class="gi">+            signature = sig_func(signature_context,</span>
<span class="gi">+                                 padType,</span>
<span class="gi">+                                 hashName,</span>
<span class="gi">+                                 saltLen)</span>
<span class="gi">+            if not ver_func(signature, signature_context,</span>
<span class="gi">+                            padType,</span>
<span class="gi">+                            hashName,</span>
<span class="gi">+                            saltLen):</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.internal_error,</span>
<span class="gi">+                        &quot;Certificate Verify signature failed&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            certificate_verify.create(signature, signature_scheme)</span>
<span class="gi">+</span>
<span class="gi">+            self._queue_message(certificate_verify)</span>
<span class="gi">+</span>
<span class="gi">+        finished_key = HKDF_expand_label(sr_handshake_traffic_secret,</span>
<span class="gi">+                                         b&quot;finished&quot;, b&#39;&#39;, prf_size, prf_name)</span>
<span class="gi">+        verify_data = secureHMAC(finished_key,</span>
<span class="gi">+                                 self._handshake_hash.digest(prf_name),</span>
<span class="gi">+                                 prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        finished = Finished(self.version, prf_size).create(verify_data)</span>
<span class="gi">+</span>
<span class="gi">+        self._queue_message(finished)</span>
<span class="gi">+        for result in self._queue_flush():</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+        self._changeReadState()</span>
<span class="gi">+</span>
<span class="gi">+        # Master secret</span>
<span class="gi">+        secret = derive_secret(secret, bytearray(b&#39;derived&#39;), None, prf_name)</span>
<span class="gi">+        secret = secureHMAC(secret, bytearray(prf_size), prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        cl_app_traffic = derive_secret(secret, bytearray(b&#39;c ap traffic&#39;),</span>
<span class="gi">+                                       self._handshake_hash, prf_name)</span>
<span class="gi">+        sr_app_traffic = derive_secret(secret, bytearray(b&#39;s ap traffic&#39;),</span>
<span class="gi">+                                       self._handshake_hash, prf_name)</span>
<span class="gi">+        self._recordLayer.calcTLS1_3PendingState(serverHello.cipher_suite,</span>
<span class="gi">+                                                 cl_app_traffic,</span>
<span class="gi">+                                                 sr_app_traffic,</span>
<span class="gi">+                                                 settings</span>
<span class="gi">+                                                 .cipherImplementations)</span>
<span class="gi">+</span>
<span class="gi">+        # all the messages sent by the server after the Finished message</span>
<span class="gi">+        # MUST be encrypted with ap traffic secret, even if they regard</span>
<span class="gi">+        # problems in processing client Certificate, CertificateVerify or</span>
<span class="gi">+        # Finished messages</span>
<span class="gi">+        self._changeWriteState()</span>
<span class="gi">+</span>
<span class="gi">+        client_cert_chain = None</span>
<span class="gi">+        #Get [Certificate,] (if was requested)</span>
<span class="gi">+        if reqCert and selected_psk is None:</span>
<span class="gi">+            for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                       HandshakeType.certificate,</span>
<span class="gi">+                                       CertificateType.x509):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+            client_certificate = result</span>
<span class="gi">+            assert isinstance(client_certificate, Certificate)</span>
<span class="gi">+            client_cert_chain = client_certificate.cert_chain</span>
<span class="gi">+</span>
<span class="gi">+        #Get and check CertificateVerify, if relevant</span>
<span class="gi">+        cli_cert_verify_hh = self._handshake_hash.copy()</span>
<span class="gi">+        if client_cert_chain and client_cert_chain.getNumCerts():</span>
<span class="gi">+            for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                       HandshakeType.certificate_verify):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            certificate_verify = result</span>
<span class="gi">+            assert isinstance(certificate_verify, CertificateVerify)</span>
<span class="gi">+</span>
<span class="gi">+            signature_scheme = certificate_verify.signatureAlgorithm</span>
<span class="gi">+</span>
<span class="gi">+            valid_sig_algs = self._sigHashesToList(settings,</span>
<span class="gi">+                                                   certList=client_cert_chain,</span>
<span class="gi">+                                                   version=(3, 4))</span>
<span class="gi">+            if signature_scheme not in valid_sig_algs:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Invalid signature on Certificate Verify&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+            signature_context = \</span>
<span class="gi">+                KeyExchange.calcVerifyBytes((3, 4), cli_cert_verify_hh,</span>
<span class="gi">+                                            signature_scheme, None, None, None,</span>
<span class="gi">+                                            prf_name, b&#39;client&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            public_key = client_cert_chain.getEndEntityPublicKey()</span>
<span class="gi">+</span>
<span class="gi">+            if signature_scheme in (SignatureScheme.ed25519,</span>
<span class="gi">+                    SignatureScheme.ed448):</span>
<span class="gi">+                hash_name = &quot;intrinsic&quot;</span>
<span class="gi">+                pad_type = None</span>
<span class="gi">+                salt_len = None</span>
<span class="gi">+                ver_func = public_key.hashAndVerify</span>
<span class="gi">+            elif signature_scheme[1] == SignatureAlgorithm.ecdsa:</span>
<span class="gi">+                hash_name = HashAlgorithm.toRepr(signature_scheme[0])</span>
<span class="gi">+                pad_type = None</span>
<span class="gi">+                salt_len = None</span>
<span class="gi">+                ver_func = public_key.verify</span>
<span class="gi">+            else:</span>
<span class="gi">+                scheme = SignatureScheme.toRepr(signature_scheme)</span>
<span class="gi">+                pad_type = SignatureScheme.getPadding(scheme)</span>
<span class="gi">+                hash_name = SignatureScheme.getHash(scheme)</span>
<span class="gi">+                salt_len = getattr(hashlib, hash_name)().digest_size</span>
<span class="gi">+                ver_func = public_key.verify</span>
<span class="gi">+</span>
<span class="gi">+            if not ver_func(certificate_verify.signature,</span>
<span class="gi">+                            signature_context,</span>
<span class="gi">+                            pad_type,</span>
<span class="gi">+                            hash_name,</span>
<span class="gi">+                            salt_len):</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.decrypt_error,</span>
<span class="gi">+                        &quot;signature verification failed&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+        # as both exporter and resumption master secrets include handshake</span>
<span class="gi">+        # transcript, we need to derive them early</span>
<span class="gi">+        exporter_master_secret = derive_secret(secret,</span>
<span class="gi">+                                               bytearray(b&#39;exp master&#39;),</span>
<span class="gi">+                                               self._handshake_hash,</span>
<span class="gi">+                                               prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        # verify Finished of client</span>
<span class="gi">+        cl_finished_key = HKDF_expand_label(cl_handshake_traffic_secret,</span>
<span class="gi">+                                            b&quot;finished&quot;, b&#39;&#39;,</span>
<span class="gi">+                                            prf_size, prf_name)</span>
<span class="gi">+        cl_verify_data = secureHMAC(cl_finished_key,</span>
<span class="gi">+                                    self._handshake_hash.digest(prf_name),</span>
<span class="gi">+                                    prf_name)</span>
<span class="gi">+        for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                   HandshakeType.finished,</span>
<span class="gi">+                                   prf_size):</span>
<span class="gi">+            if result in (0, 1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        cl_finished = result</span>
<span class="gi">+        assert isinstance(cl_finished, Finished)</span>
<span class="gi">+        if cl_finished.verify_data != cl_verify_data:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.decrypt_error,</span>
<span class="gi">+                    &quot;Finished value is not valid&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # disallow CCS messages after handshake</span>
<span class="gi">+        self._middlebox_compat_mode = False</span>
<span class="gi">+</span>
<span class="gi">+        resumption_master_secret = derive_secret(secret,</span>
<span class="gi">+                                                 bytearray(b&#39;res master&#39;),</span>
<span class="gi">+                                                 self._handshake_hash,</span>
<span class="gi">+                                                 prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        self._first_handshake_hashes = self._handshake_hash.copy()</span>
<span class="gi">+</span>
<span class="gi">+        self.session = Session()</span>
<span class="gi">+        self.extendedMasterSecret = True</span>
<span class="gi">+        server_name = None</span>
<span class="gi">+        if clientHello.server_name:</span>
<span class="gi">+            server_name = clientHello.server_name.decode(&#39;utf-8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        app_proto = None</span>
<span class="gi">+        alpnExt = encryptedExtensions.getExtension(ExtensionType.alpn)</span>
<span class="gi">+        if alpnExt:</span>
<span class="gi">+            app_proto = alpnExt.protocol_names[0]</span>
<span class="gi">+</span>
<span class="gi">+        if not client_cert_chain and resumed_client_cert_chain:</span>
<span class="gi">+            client_cert_chain = resumed_client_cert_chain</span>
<span class="gi">+</span>
<span class="gi">+        self.session.create(secret,</span>
<span class="gi">+                            bytearray(b&#39;&#39;),  # no session_id</span>
<span class="gi">+                            serverHello.cipher_suite,</span>
<span class="gi">+                            bytearray(b&#39;&#39;),  # no SRP</span>
<span class="gi">+                            client_cert_chain,</span>
<span class="gi">+                            serverCertChain,</span>
<span class="gi">+                            None,</span>
<span class="gi">+                            False,</span>
<span class="gi">+                            server_name,</span>
<span class="gi">+                            encryptThenMAC=False,</span>
<span class="gi">+                            extendedMasterSecret=True,</span>
<span class="gi">+                            appProto=app_proto,</span>
<span class="gi">+                            cl_app_secret=cl_app_traffic,</span>
<span class="gi">+                            sr_app_secret=sr_app_traffic,</span>
<span class="gi">+                            exporterMasterSecret=exporter_master_secret,</span>
<span class="gi">+                            resumptionMasterSecret=resumption_master_secret,</span>
<span class="gi">+                            # NOTE it must be a reference, not a copy</span>
<span class="gi">+                            tickets=self.tickets)</span>
<span class="gi">+</span>
<span class="gi">+        # switch to application_traffic_secret for client packets</span>
<span class="gi">+        self._changeReadState()</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._serverSendTickets(settings):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+        yield &quot;finished&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _ticket_to_session(self, settings, ticket_ext):</span>
<span class="gi">+        if not ticket_ext.ticket:</span>
<span class="gi">+            return None</span>
<span class="gi">+        _, ticket = self._tryDecrypt(settings, ticket=ticket_ext.ticket)</span>
<span class="gi">+        if not ticket:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if ticket.creation_time + settings.ticketLifetime &lt; time.time():</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        session = Session()</span>
<span class="gi">+        session.create(ticket.master_secret,</span>
<span class="gi">+                       b&#39;&#39;,  # no session_id</span>
<span class="gi">+                       ticket.cipher_suite,</span>
<span class="gi">+                       &#39;&#39;,  # not SRP</span>
<span class="gi">+                       ticket.client_cert_chain,</span>
<span class="gi">+                       None,  # no server cert chain</span>
<span class="gi">+                       None,  # no TACK</span>
<span class="gi">+                       False,  # no TACK</span>
<span class="gi">+                       serverName=ticket.server_name.decode(&quot;utf-8&quot;) if</span>
<span class="gi">+                       ticket.server_name else &quot;&quot;,</span>
<span class="gi">+                       encryptThenMAC=ticket.encrypt_then_mac,</span>
<span class="gi">+                       extendedMasterSecret=ticket.extended_master_secret)</span>
<span class="gi">+        return session</span>
<span class="gi">+</span>
<span class="gi">+    def _serverGetClientHello(self, settings, private_key, cert_chain,</span>
<span class="gi">+                              verifierDB,</span>
<span class="gi">+                              sessionCache, anon, alpn, sni):</span>
<span class="gi">+        # Tentatively set version to most-desirable version, so if an error</span>
<span class="gi">+        # occurs parsing the ClientHello, this will be the version we&#39;ll use</span>
<span class="gi">+        # for the error alert</span>
<span class="gi">+        # If TLS 1.3 is enabled, use the &quot;compatible&quot; TLS 1.2 version</span>
<span class="gi">+        self.version = min(settings.maxVersion, (3, 3))</span>
<span class="gi">+</span>
<span class="gi">+        self._pre_client_hello_handshake_hash = self._handshake_hash.copy()</span>
<span class="gi">+        #Get ClientHello</span>
<span class="gi">+        for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                   HandshakeType.client_hello):</span>
<span class="gi">+            if result in (0,1): yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+        clientHello = result</span>
<span class="gi">+</span>
<span class="gi">+        # check if the ClientHello and its extensions are well-formed</span>
<span class="gi">+</span>
<span class="gi">+        #If client&#39;s version is too low, reject it</span>
<span class="gi">+        real_version = clientHello.client_version</span>
<span class="gi">+        if real_version &gt;= (3, 3):</span>
<span class="gi">+            ext = clientHello.getExtension(ExtensionType.supported_versions)</span>
<span class="gi">+            if ext:</span>
<span class="gi">+                for v in ext.versions:</span>
<span class="gi">+                    if v in KNOWN_VERSIONS and v &gt; real_version:</span>
<span class="gi">+                        real_version = v</span>
<span class="gi">+        if real_version &lt; settings.minVersion:</span>
<span class="gi">+            self.version = settings.minVersion</span>
<span class="gi">+            for result in self._sendError(\</span>
<span class="gi">+                  AlertDescription.protocol_version,</span>
<span class="gi">+                  &quot;Too old version: %s&quot; % str(clientHello.client_version)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # there MUST be at least one value in both of those</span>
<span class="gi">+        if not clientHello.cipher_suites or \</span>
<span class="gi">+                not clientHello.compression_methods:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.decode_error,</span>
<span class="gi">+                    &quot;Malformed Client Hello message&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # client hello MUST advertise uncompressed method</span>
<span class="gi">+        if 0 not in clientHello.compression_methods:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.illegal_parameter,</span>
<span class="gi">+                    &quot;Client Hello missing uncompressed method&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # the list of signatures methods is defined as &lt;2..2^16-2&gt;, which</span>
<span class="gi">+        # means it can&#39;t be empty, but it&#39;s only applicable to TLSv1.2 protocol</span>
<span class="gi">+        ext = clientHello.getExtension(ExtensionType.signature_algorithms)</span>
<span class="gi">+        if clientHello.client_version &gt;= (3, 3) and ext and not ext.sigalgs:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.decode_error,</span>
<span class="gi">+                    &quot;Malformed signature_algorithms extension&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # Sanity check the ALPN extension</span>
<span class="gi">+        alpnExt = clientHello.getExtension(ExtensionType.alpn)</span>
<span class="gi">+        if alpnExt:</span>
<span class="gi">+            if not alpnExt.protocol_names:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.decode_error,</span>
<span class="gi">+                        &quot;Client sent empty list of ALPN names&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            for protocolName in alpnExt.protocol_names:</span>
<span class="gi">+                if not protocolName:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.decode_error,</span>
<span class="gi">+                            &quot;Client sent empty name in ALPN extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+        # Sanity check the SNI extension</span>
<span class="gi">+        sniExt = clientHello.getExtension(ExtensionType.server_name)</span>
<span class="gi">+        # check if extension is well formed</span>
<span class="gi">+        if sniExt and (not sniExt.extData or not sniExt.serverNames):</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.decode_error,</span>
<span class="gi">+                    &quot;Recevived SNI extension is malformed&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        if sniExt and sniExt.hostNames:</span>
<span class="gi">+            # RFC 6066 limitation</span>
<span class="gi">+            if len(sniExt.hostNames) &gt; 1:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Client sent multiple host names in SNI extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if not sniExt.hostNames[0]:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.decode_error,</span>
<span class="gi">+                        &quot;Received SNI extension is malformed&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            try:</span>
<span class="gi">+                name = sniExt.hostNames[0].decode(&#39;ascii&#39;, &#39;strict&#39;)</span>
<span class="gi">+            except UnicodeDecodeError:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Host name in SNI is not valid ASCII&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if not is_valid_hostname(name):</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Host name in SNI is not valid DNS name&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+        # sanity check the EMS extension</span>
<span class="gi">+        emsExt = clientHello.getExtension(ExtensionType.extended_master_secret)</span>
<span class="gi">+        if emsExt and emsExt.extData:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.decode_error,</span>
<span class="gi">+                    &quot;Non empty payload of the Extended &quot;</span>
<span class="gi">+                    &quot;Master Secret extension&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # sanity check the TLS 1.3 extensions</span>
<span class="gi">+        ver_ext = clientHello.getExtension(ExtensionType.supported_versions)</span>
<span class="gi">+        if ver_ext and (3, 4) in ver_ext.versions:</span>
<span class="gi">+            psk = clientHello.getExtension(ExtensionType.pre_shared_key)</span>
<span class="gi">+            psk_modes = clientHello.getExtension(</span>
<span class="gi">+                ExtensionType.psk_key_exchange_modes)</span>
<span class="gi">+            key_share = clientHello.getExtension(ExtensionType.key_share)</span>
<span class="gi">+            sup_groups = clientHello.getExtension(</span>
<span class="gi">+                ExtensionType.supported_groups)</span>
<span class="gi">+</span>
<span class="gi">+            pha = clientHello.getExtension(ExtensionType.post_handshake_auth)</span>
<span class="gi">+            if pha:</span>
<span class="gi">+                if pha.extData:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.decode_error,</span>
<span class="gi">+                            &quot;Invalid encoding of post_handshake_auth extension&quot;</span>
<span class="gi">+                            ):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                self._pha_supported = True</span>
<span class="gi">+</span>
<span class="gi">+            key_exchange = None</span>
<span class="gi">+</span>
<span class="gi">+            if psk_modes:</span>
<span class="gi">+                if not psk_modes.modes:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.decode_error,</span>
<span class="gi">+                            &quot;Empty psk_key_exchange_modes extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+            # psk_ke</span>
<span class="gi">+            if psk:</span>
<span class="gi">+                if not psk.identities:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.decode_error,</span>
<span class="gi">+                            &quot;No identities in PSK extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if not psk.binders:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.decode_error,</span>
<span class="gi">+                            &quot;No binders in PSK extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if len(psk.identities) != len(psk.binders):</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter,</span>
<span class="gi">+                            &quot;Number of identities does not match number of &quot;</span>
<span class="gi">+                            &quot;binders in PSK extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if any(not i.identity for i in psk.identities):</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.decoder_error,</span>
<span class="gi">+                            &quot;Empty identity in PSK extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if any(not i for i in psk.binders):</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.decoder_error,</span>
<span class="gi">+                            &quot;Empty binder in PSK extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if psk is not clientHello.extensions[-1]:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter,</span>
<span class="gi">+                            &quot;PSK extension not last in client hello&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if not psk_modes:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.missing_extension,</span>
<span class="gi">+                            &quot;PSK extension without psk_key_exchange_modes &quot;</span>
<span class="gi">+                            &quot;extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                if PskKeyExchangeMode.psk_dhe_ke not in psk_modes.modes:</span>
<span class="gi">+                    key_exchange = &quot;psk_ke&quot;</span>
<span class="gi">+            # cert</span>
<span class="gi">+            if not key_exchange:</span>
<span class="gi">+                if not sup_groups:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.missing_extension,</span>
<span class="gi">+                            &quot;Missing supported_groups extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if not key_share:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.missing_extension,</span>
<span class="gi">+                            &quot;Missing key_share extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                if not sup_groups.groups:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.decode_error,</span>
<span class="gi">+                            &quot;Empty supported_groups extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if key_share.client_shares is None:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.decode_error,</span>
<span class="gi">+                            &quot;Empty key_share extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                # check supported_groups</span>
<span class="gi">+                if TLS_1_3_FORBIDDEN_GROUPS.intersection(sup_groups.groups):</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter,</span>
<span class="gi">+                            &quot;Client advertised in TLS 1.3 Client Hello a key &quot;</span>
<span class="gi">+                            &quot;exchange group forbidden in TLS 1.3&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                # Check key_share</span>
<span class="gi">+                mismatch = next((i for i in key_share.client_shares</span>
<span class="gi">+                                 if i.group not in sup_groups.groups), None)</span>
<span class="gi">+                if mismatch:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter,</span>
<span class="gi">+                            &quot;Client sent key share for &quot;</span>
<span class="gi">+                            &quot;group it did not advertise &quot;</span>
<span class="gi">+                            &quot;support for: {0}&quot;</span>
<span class="gi">+                            .format(GroupName.toStr(mismatch))):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                key_share_ids = [i.group for i in key_share.client_shares]</span>
<span class="gi">+                if len(set(key_share_ids)) != len(key_share_ids):</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter,</span>
<span class="gi">+                            &quot;Client sent multiple key shares for the same &quot;</span>
<span class="gi">+                            &quot;group&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                group_ids = sup_groups.groups</span>
<span class="gi">+                diff = set(group_ids) - set(key_share_ids)</span>
<span class="gi">+                if key_share_ids != [i for i in group_ids if i not in diff]:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter,</span>
<span class="gi">+                            &quot;Client sent key shares in different order than &quot;</span>
<span class="gi">+                            &quot;the advertised groups.&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                sig_algs = clientHello.getExtension(</span>
<span class="gi">+                    ExtensionType.signature_algorithms)</span>
<span class="gi">+                if (not psk_modes or not psk) and sig_algs:</span>
<span class="gi">+                    key_exchange = &quot;cert&quot;</span>
<span class="gi">+</span>
<span class="gi">+            # psk_dhe_ke</span>
<span class="gi">+            if not key_exchange and psk:</span>
<span class="gi">+                key_exchange = &quot;psk_dhe_ke&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if not key_exchange:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.missing_extension,</span>
<span class="gi">+                        &quot;Missing extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+            early_data = clientHello.getExtension(ExtensionType.early_data)</span>
<span class="gi">+            if early_data:</span>
<span class="gi">+                if early_data.extData:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.decode_error,</span>
<span class="gi">+                            &quot;malformed early_data extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if not psk:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter,</span>
<span class="gi">+                            &quot;early_data without PSK extension&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                # if early data comes from version we don&#39;t support, client</span>
<span class="gi">+                # MUST (section D.3 draft 28) abort the connection so we</span>
<span class="gi">+                # enable early data tolerance only when versions match</span>
<span class="gi">+                self._recordLayer.max_early_data = settings.max_early_data</span>
<span class="gi">+                self._recordLayer.early_data_ok = True</span>
<span class="gi">+</span>
<span class="gi">+        # negotiate the protocol version for the connection</span>
<span class="gi">+        high_ver = None</span>
<span class="gi">+        if ver_ext:</span>
<span class="gi">+            high_ver = getFirstMatching(settings.versions,</span>
<span class="gi">+                                        ver_ext.versions)</span>
<span class="gi">+            if not high_ver:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.protocol_version,</span>
<span class="gi">+                        &quot;supported_versions did not include version we &quot;</span>
<span class="gi">+                        &quot;support&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+        if high_ver:</span>
<span class="gi">+            # when we selected TLS 1.3, we cannot set the record layer to</span>
<span class="gi">+            # it as well as that also switches it to a mode where the</span>
<span class="gi">+            # content type is encrypted</span>
<span class="gi">+            # use the backwards compatible TLS 1.2 version instead</span>
<span class="gi">+            self.version = min((3, 3), high_ver)</span>
<span class="gi">+            version = high_ver</span>
<span class="gi">+        elif clientHello.client_version &gt; settings.maxVersion:</span>
<span class="gi">+            # in TLS 1.3 the version is negotiatied with extension,</span>
<span class="gi">+            # but the settings use the (3, 4) as the max version</span>
<span class="gi">+            self.version = min(settings.maxVersion, (3, 3))</span>
<span class="gi">+            version = self.version</span>
<span class="gi">+        else:</span>
<span class="gi">+            #Set the version to the client&#39;s version</span>
<span class="gi">+            self.version = min(clientHello.client_version, (3, 3))</span>
<span class="gi">+            version = self.version</span>
<span class="gi">+</span>
<span class="gi">+        #Detect if the client performed an inappropriate fallback.</span>
<span class="gi">+        if version &lt; settings.maxVersion and \</span>
<span class="gi">+                CipherSuite.TLS_FALLBACK_SCSV in clientHello.cipher_suites:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.inappropriate_fallback):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # TODO when TLS 1.3 is final, check the client hello random for</span>
<span class="gi">+        # downgrade too</span>
<span class="gi">+</span>
<span class="gi">+        # start negotiating the parameters of the connection</span>
<span class="gi">+</span>
<span class="gi">+        sni_ext = clientHello.getExtension(ExtensionType.server_name)</span>
<span class="gi">+        if sni_ext:</span>
<span class="gi">+            name = sni_ext.hostNames[0].decode(&#39;ascii&#39;, &#39;strict&#39;)</span>
<span class="gi">+            # warn the client if the name didn&#39;t match the expected value</span>
<span class="gi">+            if sni and sni != name:</span>
<span class="gi">+                alert = Alert().create(AlertDescription.unrecognized_name,</span>
<span class="gi">+                                       AlertLevel.warning)</span>
<span class="gi">+                for result in self._sendMsg(alert):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+        #Check if there&#39;s intersection between supported curves by client and</span>
<span class="gi">+        #server</span>
<span class="gi">+        clientGroups = clientHello.getExtension(ExtensionType.supported_groups)</span>
<span class="gi">+        # in case the client didn&#39;t advertise any curves, we can pick any so</span>
<span class="gi">+        # enable ECDHE</span>
<span class="gi">+        ecGroupIntersect = True</span>
<span class="gi">+        # if there is no extension, then enable DHE</span>
<span class="gi">+        ffGroupIntersect = True</span>
<span class="gi">+        if clientGroups is not None:</span>
<span class="gi">+            clientGroups = clientGroups.groups</span>
<span class="gi">+            if not clientGroups:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.decode_error,</span>
<span class="gi">+                        &quot;Received malformed supported_groups extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            serverGroups = self._curveNamesToList(settings)</span>
<span class="gi">+            ecGroupIntersect = getFirstMatching(clientGroups, serverGroups)</span>
<span class="gi">+            # RFC 7919 groups</span>
<span class="gi">+            serverGroups = self._groupNamesToList(settings)</span>
<span class="gi">+            ffGroupIntersect = getFirstMatching(clientGroups, serverGroups)</span>
<span class="gi">+            # if there is no overlap, but there are no FFDHE groups listed,</span>
<span class="gi">+            # allow DHE, prohibit otherwise</span>
<span class="gi">+            if not ffGroupIntersect:</span>
<span class="gi">+                if clientGroups and \</span>
<span class="gi">+                        any(i for i in clientGroups if i in range(256, 512)):</span>
<span class="gi">+                    ffGroupIntersect = False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ffGroupIntersect = True</span>
<span class="gi">+</span>
<span class="gi">+        # Check and save clients heartbeat extension mode</span>
<span class="gi">+        heartbeat_ext = clientHello.getExtension(ExtensionType.heartbeat)</span>
<span class="gi">+        if heartbeat_ext:</span>
<span class="gi">+            if heartbeat_ext.mode == HeartbeatMode.PEER_ALLOWED_TO_SEND:</span>
<span class="gi">+                if settings.heartbeat_response_callback:</span>
<span class="gi">+                    self.heartbeat_can_send = True</span>
<span class="gi">+                    self.heartbeat_response_callback = settings.\</span>
<span class="gi">+                        heartbeat_response_callback</span>
<span class="gi">+            elif heartbeat_ext.mode == HeartbeatMode.PEER_NOT_ALLOWED_TO_SEND:</span>
<span class="gi">+                self.heartbeat_can_send = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Received invalid value in Heartbeat extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            self.heartbeat_supported = True</span>
<span class="gi">+            self.heartbeat_can_receive = True</span>
<span class="gi">+</span>
<span class="gi">+        size_limit_ext = clientHello.getExtension(</span>
<span class="gi">+            ExtensionType.record_size_limit)</span>
<span class="gi">+        if size_limit_ext:</span>
<span class="gi">+            if size_limit_ext.record_size_limit is None:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.decode_error,</span>
<span class="gi">+                        &quot;Malformed record_size_limit extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if not 64 &lt;= size_limit_ext.record_size_limit:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Invalid value in record_size_limit extension&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if settings.record_size_limit:</span>
<span class="gi">+                # in TLS 1.3 handshake is encrypted so we need to switch</span>
<span class="gi">+                # to sending smaller messages right away</span>
<span class="gi">+                if version &gt;= (3, 4):</span>
<span class="gi">+                    # the client can send bigger values because it may</span>
<span class="gi">+                    # know protocol versions or extensions we don&#39;t know about</span>
<span class="gi">+                    # (but we need to still clamp it to protocol limit)</span>
<span class="gi">+                    self._send_record_limit = min(</span>
<span class="gi">+                        2**14, size_limit_ext.record_size_limit - 1)</span>
<span class="gi">+                    # the record layer excludes content type, extension doesn&#39;t</span>
<span class="gi">+                    # thus the &quot;-1)</span>
<span class="gi">+                    self._recv_record_limit = min(2**14,</span>
<span class="gi">+                        settings.record_size_limit - 1)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # but in TLS 1.2 and earlier we need to postpone it till</span>
<span class="gi">+                    # handling of Finished</span>
<span class="gi">+                    self._peer_record_size_limit = min(</span>
<span class="gi">+                        2**14, size_limit_ext.record_size_limit)</span>
<span class="gi">+</span>
<span class="gi">+        #Now that the version is known, limit to only the ciphers available to</span>
<span class="gi">+        #that version and client capabilities.</span>
<span class="gi">+        cipherSuites = []</span>
<span class="gi">+        if verifierDB:</span>
<span class="gi">+            if cert_chain:</span>
<span class="gi">+                cipherSuites += \</span>
<span class="gi">+                    CipherSuite.getSrpCertSuites(settings, version)</span>
<span class="gi">+            cipherSuites += CipherSuite.getSrpSuites(settings, version)</span>
<span class="gi">+        elif cert_chain:</span>
<span class="gi">+            if ecGroupIntersect or ffGroupIntersect:</span>
<span class="gi">+                cipherSuites += CipherSuite.getTLS13Suites(settings,</span>
<span class="gi">+                                                           version)</span>
<span class="gi">+            if ecGroupIntersect:</span>
<span class="gi">+                cipherSuites += CipherSuite.getEcdsaSuites(settings, version)</span>
<span class="gi">+                cipherSuites += CipherSuite.getEcdheCertSuites(settings,</span>
<span class="gi">+                                                               version)</span>
<span class="gi">+            if ffGroupIntersect:</span>
<span class="gi">+                cipherSuites += CipherSuite.getDheCertSuites(settings,</span>
<span class="gi">+                                                             version)</span>
<span class="gi">+                cipherSuites += CipherSuite.getDheDsaSuites(settings,</span>
<span class="gi">+                                                            version)</span>
<span class="gi">+            cipherSuites += CipherSuite.getCertSuites(settings, version)</span>
<span class="gi">+        elif anon:</span>
<span class="gi">+            cipherSuites += CipherSuite.getAnonSuites(settings, version)</span>
<span class="gi">+            cipherSuites += CipherSuite.getEcdhAnonSuites(settings,</span>
<span class="gi">+                                                          version)</span>
<span class="gi">+        elif settings.pskConfigs:</span>
<span class="gi">+            cipherSuites += CipherSuite.getTLS13Suites(settings,</span>
<span class="gi">+                                                       version)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert False</span>
<span class="gi">+        cipherSuites = CipherSuite.filterForVersion(cipherSuites,</span>
<span class="gi">+                                                    minVersion=version,</span>
<span class="gi">+                                                    maxVersion=version)</span>
<span class="gi">+</span>
<span class="gi">+        ticket_ext = clientHello.getExtension(ExtensionType.session_ticket)</span>
<span class="gi">+</span>
<span class="gi">+        # If resumption was requested and we have a session cache...</span>
<span class="gi">+        if (clientHello.session_id and sessionCache) or (</span>
<span class="gi">+                ticket_ext and ticket_ext.ticket):</span>
<span class="gi">+            session = None</span>
<span class="gi">+</span>
<span class="gi">+            # Check if the session there is good enough and consistent with</span>
<span class="gi">+            # new Client Hello</span>
<span class="gi">+            try:</span>
<span class="gi">+                if ticket_ext:</span>
<span class="gi">+                    session = self._ticket_to_session(settings, ticket_ext)</span>
<span class="gi">+                    # client MAY send a random session_id to easily tell</span>
<span class="gi">+                    # if the session is resumed, for that server has to</span>
<span class="gi">+                    # echo the session_ID back</span>
<span class="gi">+                    if session and clientHello.session_id:</span>
<span class="gi">+                        session.sessionID = clientHello.session_id</span>
<span class="gi">+                if not session and \</span>
<span class="gi">+                        (not ticket_ext or ticket_ext and not ticket_ext.ticket)\</span>
<span class="gi">+                        and sessionCache and clientHello.session_id:</span>
<span class="gi">+                    # Session ID resumption is allowed only if the client</span>
<span class="gi">+                    # didn&#39;t send a ticket</span>
<span class="gi">+                    session = sessionCache[clientHello.session_id]</span>
<span class="gi">+                if not session:</span>
<span class="gi">+                    raise KeyError()</span>
<span class="gi">+                if not session.resumable:</span>
<span class="gi">+                    raise AssertionError()</span>
<span class="gi">+                # Check if we are willing to use that old cipher still</span>
<span class="gi">+                if session.cipherSuite not in cipherSuites:</span>
<span class="gi">+                    session = None</span>
<span class="gi">+                    raise KeyError()</span>
<span class="gi">+                # Check for consistency with ClientHello</span>
<span class="gi">+                # see RFC 5246 section 7.4.1.2, description of</span>
<span class="gi">+                # cipher_suites</span>
<span class="gi">+                if session.cipherSuite not in clientHello.cipher_suites:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if clientHello.srp_username:</span>
<span class="gi">+                    if not session.srpUsername or \</span>
<span class="gi">+                            clientHello.srp_username != \</span>
<span class="gi">+                            bytearray(session.srpUsername, &quot;utf-8&quot;):</span>
<span class="gi">+                        for result in self._sendError(</span>
<span class="gi">+                                AlertDescription.handshake_failure):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                if clientHello.server_name:</span>
<span class="gi">+                    if not session.serverName or \</span>
<span class="gi">+                            clientHello.server_name != \</span>
<span class="gi">+                            bytearray(session.serverName, &quot;utf-8&quot;):</span>
<span class="gi">+                        for result in self._sendError(</span>
<span class="gi">+                                AlertDescription.handshake_failure):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                if session.encryptThenMAC and \</span>
<span class="gi">+                        not clientHello.getExtension(</span>
<span class="gi">+                                ExtensionType.encrypt_then_mac):</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                # if old session used EMS, new connection MUST use EMS</span>
<span class="gi">+                if session.extendedMasterSecret and \</span>
<span class="gi">+                        not clientHello.getExtension(</span>
<span class="gi">+                                ExtensionType.extended_master_secret):</span>
<span class="gi">+                    # RFC 7627, section 5.2 explicitly requires</span>
<span class="gi">+                    # handshake_failure</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.handshake_failure):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                # if old session didn&#39;t use EMS but new connection</span>
<span class="gi">+                # advertises EMS, create a new session</span>
<span class="gi">+                elif not session.extendedMasterSecret and \</span>
<span class="gi">+                        clientHello.getExtension(</span>
<span class="gi">+                                ExtensionType.extended_master_secret):</span>
<span class="gi">+                    session = None</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+            #If a session is found..</span>
<span class="gi">+            if session:</span>
<span class="gi">+                #Send ServerHello</span>
<span class="gi">+                extensions = []</span>
<span class="gi">+                if session.encryptThenMAC:</span>
<span class="gi">+                    self._recordLayer.encryptThenMAC = True</span>
<span class="gi">+                    etm = TLSExtension().create(ExtensionType.encrypt_then_mac,</span>
<span class="gi">+                                                bytearray(0))</span>
<span class="gi">+                    extensions.append(etm)</span>
<span class="gi">+                if session.extendedMasterSecret:</span>
<span class="gi">+                    ems = TLSExtension().create(ExtensionType.</span>
<span class="gi">+                                                extended_master_secret,</span>
<span class="gi">+                                                bytearray(0))</span>
<span class="gi">+                    extensions.append(ems)</span>
<span class="gi">+                secureRenego = False</span>
<span class="gi">+                renegoExt = clientHello.\</span>
<span class="gi">+                    getExtension(ExtensionType.renegotiation_info)</span>
<span class="gi">+                if renegoExt:</span>
<span class="gi">+                    if renegoExt.renegotiated_connection:</span>
<span class="gi">+                        for result in self._sendError(</span>
<span class="gi">+                                AlertDescription.handshake_failure):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                    secureRenego = True</span>
<span class="gi">+                elif CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV in \</span>
<span class="gi">+                        clientHello.cipher_suites:</span>
<span class="gi">+                    secureRenego = True</span>
<span class="gi">+                if secureRenego:</span>
<span class="gi">+                    extensions.append(RenegotiationInfoExtension()</span>
<span class="gi">+                                      .create(bytearray(0)))</span>
<span class="gi">+                selectedALPN = None</span>
<span class="gi">+                if alpn:</span>
<span class="gi">+                    alpnExt = clientHello.getExtension(ExtensionType.alpn)</span>
<span class="gi">+                    if alpnExt:</span>
<span class="gi">+                        for protocolName in alpnExt.protocol_names:</span>
<span class="gi">+                            if protocolName in alpn:</span>
<span class="gi">+                                ext = ALPNExtension().create([protocolName])</span>
<span class="gi">+                                extensions.append(ext)</span>
<span class="gi">+                                selectedALPN = protocolName</span>
<span class="gi">+                                break</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            for result in self._sendError(</span>
<span class="gi">+                                    AlertDescription.no_application_protocol,</span>
<span class="gi">+                                    &quot;No commonly supported application layer&quot;</span>
<span class="gi">+                                    &quot;protocol supported&quot;):</span>
<span class="gi">+                                yield result</span>
<span class="gi">+</span>
<span class="gi">+                heartbeat_ext = clientHello.getExtension(</span>
<span class="gi">+                    ExtensionType.heartbeat)</span>
<span class="gi">+                if heartbeat_ext:</span>
<span class="gi">+                    if heartbeat_ext.mode == HeartbeatMode.PEER_ALLOWED_TO_SEND:</span>
<span class="gi">+                        self.heartbeat_can_send = True</span>
<span class="gi">+                    elif heartbeat_ext.mode == \</span>
<span class="gi">+                            HeartbeatMode.PEER_NOT_ALLOWED_TO_SEND:</span>
<span class="gi">+                        self.heartbeat_can_send = False</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        for result in self._sendError(</span>
<span class="gi">+                                AlertDescription.illegal_parameter,</span>
<span class="gi">+                                &quot;Client sent invalid Heartbeat extension&quot;):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                    heartbeat = HeartbeatExtension().create(</span>
<span class="gi">+                        HeartbeatMode.PEER_ALLOWED_TO_SEND)</span>
<span class="gi">+                    self.heartbeat_can_receive = True</span>
<span class="gi">+                    self.heartbeat_supported = True</span>
<span class="gi">+                    extensions.append(heartbeat)</span>
<span class="gi">+                record_limit = clientHello.getExtension(</span>
<span class="gi">+                    ExtensionType.record_size_limit)</span>
<span class="gi">+                if record_limit and settings.record_size_limit:</span>
<span class="gi">+                    extensions.append(RecordSizeLimitExtension().create(</span>
<span class="gi">+                        min(2**14, settings.record_size_limit)))</span>
<span class="gi">+</span>
<span class="gi">+                # don&#39;t send empty extensions</span>
<span class="gi">+                if not extensions:</span>
<span class="gi">+                    extensions = None</span>
<span class="gi">+                serverHello = ServerHello()</span>
<span class="gi">+                serverHello.create(version, getRandomBytes(32),</span>
<span class="gi">+                                   session.sessionID, session.cipherSuite,</span>
<span class="gi">+                                   CertificateType.x509, None, None,</span>
<span class="gi">+                                   extensions=extensions)</span>
<span class="gi">+                for result in self._sendMsg(serverHello):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+                #Calculate pending connection states</span>
<span class="gi">+                self._calcPendingStates(session.cipherSuite,</span>
<span class="gi">+                                        session.masterSecret,</span>
<span class="gi">+                                        clientHello.random,</span>
<span class="gi">+                                        serverHello.random,</span>
<span class="gi">+                                        settings.cipherImplementations)</span>
<span class="gi">+</span>
<span class="gi">+                #Exchange ChangeCipherSpec and Finished messages</span>
<span class="gi">+                for result in self._sendFinished(session.masterSecret,</span>
<span class="gi">+                                                 session.cipherSuite,</span>
<span class="gi">+                                                 settings=settings):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                for result in self._getFinished(session.masterSecret,</span>
<span class="gi">+                                                session.cipherSuite):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+                #Set the session</span>
<span class="gi">+                self.session = session</span>
<span class="gi">+                self._clientRandom = clientHello.random</span>
<span class="gi">+                self._serverRandom = serverHello.random</span>
<span class="gi">+                self.session.appProto = selectedALPN</span>
<span class="gi">+                yield None # Handshake done!</span>
<span class="gi">+</span>
<span class="gi">+        #Calculate the first cipher suite intersection.</span>
<span class="gi">+        #This is the &#39;privileged&#39; ciphersuite.  We&#39;ll use it if we&#39;re</span>
<span class="gi">+        #doing a new negotiation.  In fact,</span>
<span class="gi">+        #the only time we won&#39;t use it is if we&#39;re resuming a</span>
<span class="gi">+        #session, in which case we use the ciphersuite from the session.</span>
<span class="gi">+        #</span>
<span class="gi">+        #Given the current ciphersuite ordering, this means we prefer SRP</span>
<span class="gi">+        #over non-SRP.</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            cipherSuite, sig_scheme, cert_chain, private_key = \</span>
<span class="gi">+                    self._server_select_certificate(settings, clientHello,</span>
<span class="gi">+                                                    cipherSuites, cert_chain,</span>
<span class="gi">+                                                    private_key, version)</span>
<span class="gi">+        except TLSHandshakeFailure as err:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.handshake_failure,</span>
<span class="gi">+                    str(err)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSInsufficientSecurity as err:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.insufficient_security,</span>
<span class="gi">+                    str(err)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSIllegalParameterException as err:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.illegal_parameter,</span>
<span class="gi">+                    str(err)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        #If an RSA suite is chosen, check for certificate type intersection</span>
<span class="gi">+        if (cipherSuite in CipherSuite.certAllSuites or</span>
<span class="gi">+            cipherSuite in CipherSuite.ecdheEcdsaSuites) \</span>
<span class="gi">+                    and CertificateType.x509 \</span>
<span class="gi">+                    not in clientHello.certificate_types:</span>
<span class="gi">+            for result in self._sendError(\</span>
<span class="gi">+                    AlertDescription.handshake_failure,</span>
<span class="gi">+                    &quot;the client doesn&#39;t support my certificate type&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # when we have selected TLS 1.3, check if we don&#39;t have to ask for</span>
<span class="gi">+        # a new client hello</span>
<span class="gi">+        if version &gt; (3, 3):</span>
<span class="gi">+            self.version = version</span>
<span class="gi">+            hrr_ext = []</span>
<span class="gi">+</span>
<span class="gi">+            # check if we have good key share</span>
<span class="gi">+            share = clientHello.getExtension(ExtensionType.key_share)</span>
<span class="gi">+            if share:</span>
<span class="gi">+                share_ids = [i.group for i in share.client_shares]</span>
<span class="gi">+                acceptable_ids = [getattr(GroupName, i) for i in</span>
<span class="gi">+                                  chain(settings.keyShares, settings.eccCurves,</span>
<span class="gi">+                                        settings.dhGroups)]</span>
<span class="gi">+                for selected_group in acceptable_ids:</span>
<span class="gi">+                    if selected_group in share_ids:</span>
<span class="gi">+                        cl_key_share = next(i for i in share.client_shares</span>
<span class="gi">+                                            if i.group == selected_group)</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # if no key share is acceptable, pick one of the supported</span>
<span class="gi">+                    # groups that we support</span>
<span class="gi">+                    supported = clientHello.getExtension(ExtensionType</span>
<span class="gi">+                                                         .supported_groups)</span>
<span class="gi">+                    supported_ids = supported.groups</span>
<span class="gi">+                    selected_group = next((i for i in acceptable_ids</span>
<span class="gi">+                                           if i in supported_ids), None)</span>
<span class="gi">+                    if not selected_group:</span>
<span class="gi">+                        for result in self._sendError(AlertDescription</span>
<span class="gi">+                                                      .handshake_failure,</span>
<span class="gi">+                                                      &quot;No acceptable group &quot;</span>
<span class="gi">+                                                      &quot;advertised by client&quot;):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                    hrr_ks = HRRKeyShareExtension().create(selected_group)</span>
<span class="gi">+                    hrr_ext.append(hrr_ks)</span>
<span class="gi">+</span>
<span class="gi">+            if hrr_ext:</span>
<span class="gi">+                cookie = TLSExtension(extType=ExtensionType.cookie)</span>
<span class="gi">+                cookie = cookie.create(bytearray(b&#39;\x00\x20&#39;) +</span>
<span class="gi">+                                       getRandomBytes(32))</span>
<span class="gi">+                hrr_ext.append(cookie)</span>
<span class="gi">+</span>
<span class="gi">+            if hrr_ext:</span>
<span class="gi">+                clientHello1 = clientHello</span>
<span class="gi">+</span>
<span class="gi">+                # create synthetic handshake hash of the first Client Hello</span>
<span class="gi">+                prf_name, prf_size = self._getPRFParams(cipherSuite)</span>
<span class="gi">+</span>
<span class="gi">+                client_hello_hash = self._handshake_hash.digest(prf_name)</span>
<span class="gi">+                self._handshake_hash = HandshakeHashes()</span>
<span class="gi">+                writer = Writer()</span>
<span class="gi">+                writer.add(HandshakeType.message_hash, 1)</span>
<span class="gi">+                writer.addVarSeq(client_hello_hash, 1, 3)</span>
<span class="gi">+                self._handshake_hash.update(writer.bytes)</span>
<span class="gi">+</span>
<span class="gi">+                # send the version that was really selected</span>
<span class="gi">+                vers = SrvSupportedVersionsExtension().create(version)</span>
<span class="gi">+                hrr_ext.append(vers)</span>
<span class="gi">+</span>
<span class="gi">+                # send the HRR</span>
<span class="gi">+                hrr = ServerHello()</span>
<span class="gi">+                # version is hardcoded in TLS 1.3, and real version</span>
<span class="gi">+                # is sent as extension</span>
<span class="gi">+                hrr.create((3, 3), TLS_1_3_HRR, clientHello.session_id,</span>
<span class="gi">+                           cipherSuite, extensions=hrr_ext)</span>
<span class="gi">+</span>
<span class="gi">+                msgs = [hrr]</span>
<span class="gi">+                if clientHello.session_id:</span>
<span class="gi">+                    ccs = ChangeCipherSpec().create()</span>
<span class="gi">+                    msgs.append(ccs)</span>
<span class="gi">+                for result in self._sendMsgs(msgs):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                self._ccs_sent = True</span>
<span class="gi">+</span>
<span class="gi">+                # copy for calculating PSK binders</span>
<span class="gi">+                self._pre_client_hello_handshake_hash = \</span>
<span class="gi">+                    self._handshake_hash.copy()</span>
<span class="gi">+</span>
<span class="gi">+                for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                           HandshakeType.client_hello):</span>
<span class="gi">+                    if result in (0, 1):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        break</span>
<span class="gi">+                clientHello = result</span>
<span class="gi">+</span>
<span class="gi">+                # verify that the new key share is present</span>
<span class="gi">+                ext = clientHello.getExtension(ExtensionType.key_share)</span>
<span class="gi">+                if not ext:</span>
<span class="gi">+                    for result in self._sendError(AlertDescription</span>
<span class="gi">+                                                  .missing_extension,</span>
<span class="gi">+                                                  &quot;Key share missing in &quot;</span>
<span class="gi">+                                                  &quot;Client Hello&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                # here we&#39;re assuming that the HRR was sent because of</span>
<span class="gi">+                # missing key share, that may not always be the case</span>
<span class="gi">+                if len(ext.client_shares) != 1:</span>
<span class="gi">+                    for result in self._sendError(AlertDescription</span>
<span class="gi">+                                                  .illegal_parameter,</span>
<span class="gi">+                                                  &quot;Multiple key shares in &quot;</span>
<span class="gi">+                                                  &quot;second Client Hello&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                if ext.client_shares[0].group != selected_group:</span>
<span class="gi">+                    for result in self._sendError(AlertDescription</span>
<span class="gi">+                                                  .illegal_parameter,</span>
<span class="gi">+                                                  &quot;Client key share does not &quot;</span>
<span class="gi">+                                                  &quot;match Hello Retry Request&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                # here we&#39;re assuming no 0-RTT and possibly no session</span>
<span class="gi">+                # resumption</span>
<span class="gi">+                # verify that new client hello is like the old client hello</span>
<span class="gi">+                # with the exception of changes requested in HRR</span>
<span class="gi">+                old_ext = clientHello1.getExtension(ExtensionType.key_share)</span>
<span class="gi">+                new_ext = clientHello.getExtension(ExtensionType.key_share)</span>
<span class="gi">+                old_ext.client_shares = new_ext.client_shares</span>
<span class="gi">+</span>
<span class="gi">+                # TODO when 0-RTT supported, remove early_data from old hello</span>
<span class="gi">+</span>
<span class="gi">+                if cookie:</span>
<span class="gi">+                    # insert the extension at the same place in the old hello</span>
<span class="gi">+                    # as it is in the new hello so that later binary compare</span>
<span class="gi">+                    # works</span>
<span class="gi">+                    for i, ext in enumerate(clientHello.extensions):</span>
<span class="gi">+                        if ext.extType == ExtensionType.cookie:</span>
<span class="gi">+                            if ext.extData != cookie.extData:</span>
<span class="gi">+                                eType = AlertDescription.illegal_parameter</span>
<span class="gi">+                                eText = &quot;Malformed cookie extension&quot;</span>
<span class="gi">+                                for result in self._sendError(eType, eText):</span>
<span class="gi">+                                    yield result</span>
<span class="gi">+                            clientHello1.extensions.insert(i, ext)</span>
<span class="gi">+                            break</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        for result in self._sendError(AlertDescription</span>
<span class="gi">+                                                      .missing_extension,</span>
<span class="gi">+                                                      &quot;Second client hello &quot;</span>
<span class="gi">+                                                      &quot;does not contain &quot;</span>
<span class="gi">+                                                      &quot;cookie extension&quot;):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+</span>
<span class="gi">+                # also padding extension may change</span>
<span class="gi">+                old_ext = clientHello1.getExtension(</span>
<span class="gi">+                    ExtensionType.client_hello_padding)</span>
<span class="gi">+                new_ext = clientHello.getExtension(</span>
<span class="gi">+                    ExtensionType.client_hello_padding)</span>
<span class="gi">+                if old_ext != new_ext:</span>
<span class="gi">+                    if old_ext is None and new_ext:</span>
<span class="gi">+                        for i, ext in enumerate(clientHello.extensions):</span>
<span class="gi">+                            if ext.extType == \</span>
<span class="gi">+                                    ExtensionType.client_hello_padding:</span>
<span class="gi">+                                clientHello1.extensions.insert(i, ext)</span>
<span class="gi">+                                break</span>
<span class="gi">+                    elif old_ext and new_ext is None:</span>
<span class="gi">+                        # extension was removed, so remove it here too</span>
<span class="gi">+                        clientHello1.extensions[:] = \</span>
<span class="gi">+                            (i for i in clientHello1.extensions</span>
<span class="gi">+                             if i.extType !=</span>
<span class="gi">+                             ExtensionType.client_hello_padding)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        old_ext.paddingData = new_ext.paddingData</span>
<span class="gi">+</span>
<span class="gi">+                # PSKs not compatible with cipher suite MAY</span>
<span class="gi">+                # be removed, but must have updated obfuscated ticket age</span>
<span class="gi">+                # and binders</span>
<span class="gi">+                old_ext = clientHello1.getExtension(</span>
<span class="gi">+                    ExtensionType.pre_shared_key)</span>
<span class="gi">+                new_ext = clientHello.getExtension(</span>
<span class="gi">+                    ExtensionType.pre_shared_key)</span>
<span class="gi">+                if new_ext and old_ext:</span>
<span class="gi">+                    clientHello1.extensions[-1] = new_ext</span>
<span class="gi">+                    if clientHello.extensions[-1] is not new_ext:</span>
<span class="gi">+                        for result in self._sendError(</span>
<span class="gi">+                                AlertDescription.illegal_parameter,</span>
<span class="gi">+                                &quot;PSK extension not last in client hello&quot;):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                # early_data extension MUST be dropped</span>
<span class="gi">+                old_ext = clientHello1.getExtension(ExtensionType.early_data)</span>
<span class="gi">+                if old_ext:</span>
<span class="gi">+                    clientHello1.extensions.remove(old_ext)</span>
<span class="gi">+</span>
<span class="gi">+                if clientHello1 != clientHello:</span>
<span class="gi">+                    for result in self._sendError(AlertDescription</span>
<span class="gi">+                                                  .illegal_parameter,</span>
<span class="gi">+                                                  &quot;Old Client Hello does not &quot;</span>
<span class="gi">+                                                  &quot;match the updated Client &quot;</span>
<span class="gi">+                                                  &quot;Hello&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+        # If resumption was not requested, or</span>
<span class="gi">+        # we have no session cache, or</span>
<span class="gi">+        # the client&#39;s session_id was not found in cache:</span>
<span class="gi">+#pylint: disable = undefined-loop-variable</span>
<span class="gi">+        yield (clientHello, version, cipherSuite, sig_scheme, private_key,</span>
<span class="gi">+               cert_chain)</span>
<span class="gi">+#pylint: enable = undefined-loop-variable</span>

<span class="w"> </span>    def _serverSRPKeyExchange(self, clientHello, serverHello, verifierDB,
<span class="gd">-        cipherSuite, privateKey, serverCertChain, settings):</span>
<span class="gi">+                              cipherSuite, privateKey, serverCertChain,</span>
<span class="gi">+                              settings):</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform the server side of SRP key exchange&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            sigHash, serverCertChain, privateKey = \</span>
<span class="gi">+                self._pickServerKeyExchangeSig(settings, clientHello,</span>
<span class="gi">+                                               serverCertChain,</span>
<span class="gi">+                                               privateKey)</span>
<span class="gi">+        except TLSHandshakeFailure as alert:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.handshake_failure,</span>
<span class="gi">+                    str(alert)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        keyExchange = SRPKeyExchange(cipherSuite,</span>
<span class="gi">+                                     clientHello,</span>
<span class="gi">+                                     serverHello,</span>
<span class="gi">+                                     privateKey,</span>
<span class="gi">+                                     verifierDB)</span>
<span class="gi">+</span>
<span class="gi">+        #Create ServerKeyExchange, signing it if necessary</span>
<span class="gi">+        try:</span>
<span class="gi">+            serverKeyExchange = keyExchange.makeServerKeyExchange(sigHash)</span>
<span class="gi">+        except TLSUnknownPSKIdentity:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.unknown_psk_identity):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSInsufficientSecurity:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.insufficient_security):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        #Send ServerHello[, Certificate], ServerKeyExchange,</span>
<span class="gi">+        #ServerHelloDone</span>
<span class="gi">+        msgs = []</span>
<span class="gi">+        msgs.append(serverHello)</span>
<span class="gi">+        if cipherSuite in CipherSuite.srpCertSuites:</span>
<span class="gi">+            certificateMsg = Certificate(CertificateType.x509)</span>
<span class="gi">+            certificateMsg.create(serverCertChain)</span>
<span class="gi">+            msgs.append(certificateMsg)</span>
<span class="gi">+        msgs.append(serverKeyExchange)</span>
<span class="gi">+        msgs.append(ServerHelloDone())</span>
<span class="gi">+        for result in self._sendMsgs(msgs):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+        #Get and check ClientKeyExchange</span>
<span class="gi">+        for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                  HandshakeType.client_key_exchange,</span>
<span class="gi">+                                  cipherSuite):</span>
<span class="gi">+            if result in (0,1): yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+        try:</span>
<span class="gi">+            premasterSecret = keyExchange.processClientKeyExchange(result)</span>
<span class="gi">+        except TLSIllegalParameterException:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.illegal_parameter,</span>
<span class="gi">+                                          &quot;Suspicious A value&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSDecodeError as alert:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.decode_error,</span>
<span class="gi">+                                          str(alert)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        yield premasterSecret, privateKey, serverCertChain</span>

<span class="w"> </span>    def _server_select_certificate(self, settings, client_hello,
<span class="gd">-        cipher_suites, cert_chain, private_key, version):</span>
<span class="gi">+                                   cipher_suites, cert_chain,</span>
<span class="gi">+                                   private_key, version):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This method makes the decision on which certificate/key pair,
<span class="w"> </span>        signature algorithm and cipher to use based on the certificate.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        last_cert = False</span>
<span class="gi">+        possible_certs = []</span>
<span class="gi">+</span>
<span class="gi">+        # Get client groups</span>
<span class="gi">+        client_groups = client_hello. \</span>
<span class="gi">+                getExtension(ExtensionType.supported_groups)</span>
<span class="gi">+        if client_groups is not None:</span>
<span class="gi">+            client_groups = client_groups.groups</span>
<span class="gi">+</span>
<span class="gi">+        # If client did send signature_algorithms_cert use it,</span>
<span class="gi">+        # otherwise fallback to signature_algorithms.</span>
<span class="gi">+        # Client can also decide not to send sigalg extension</span>
<span class="gi">+        client_sigalgs = \</span>
<span class="gi">+                client_hello. \</span>
<span class="gi">+                getExtension(ExtensionType.signature_algorithms_cert)</span>
<span class="gi">+        if client_sigalgs is not None:</span>
<span class="gi">+            client_sigalgs = \</span>
<span class="gi">+                    client_hello. \</span>
<span class="gi">+                    getExtension(ExtensionType.signature_algorithms_cert). \</span>
<span class="gi">+                    sigalgs</span>
<span class="gi">+        else:</span>
<span class="gi">+            client_sigalgs = \</span>
<span class="gi">+                    client_hello. \</span>
<span class="gi">+                    getExtension(ExtensionType.signature_algorithms)</span>
<span class="gi">+            if client_sigalgs is not None:</span>
<span class="gi">+                client_sigalgs = \</span>
<span class="gi">+                        client_hello. \</span>
<span class="gi">+                        getExtension(ExtensionType.signature_algorithms). \</span>
<span class="gi">+                        sigalgs</span>
<span class="gi">+            else:</span>
<span class="gi">+                client_sigalgs = []</span>
<span class="gi">+</span>
<span class="gi">+        client_psks = client_hello.getExtension(ExtensionType.pre_shared_key)</span>
<span class="gi">+</span>
<span class="gi">+        # Get all the certificates we can offer</span>
<span class="gi">+        alt_certs = ((X509CertChain(i.certificates), i.key) for vh in</span>
<span class="gi">+                     settings.virtual_hosts for i in vh.keys)</span>
<span class="gi">+        certs = [(cert, key)</span>
<span class="gi">+                 for cert, key in chain([(cert_chain, private_key)], alt_certs)]</span>
<span class="gi">+</span>
<span class="gi">+        for cert, key in certs:</span>
<span class="gi">+            # Check if this is the last (cert, key) pair we have to check</span>
<span class="gi">+            if (cert, key) == certs[-1]:</span>
<span class="gi">+                last_cert = True</span>
<span class="gi">+</span>
<span class="gi">+            # Mandatory checks. If any one of these checks fail, the certificate</span>
<span class="gi">+            # is not usuable.</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Find a suitable ciphersuite based on the certificate</span>
<span class="gi">+                ciphers = CipherSuite.filter_for_certificate(cipher_suites, cert)</span>
<span class="gi">+                # but if we have matching PSKs, prefer those</span>
<span class="gi">+                if settings.pskConfigs and client_psks:</span>
<span class="gi">+                    client_identities = [</span>
<span class="gi">+                        i.identity for i in client_psks.identities]</span>
<span class="gi">+                    psks_prfs = [i[2] if len(i) == 3 else None for i in</span>
<span class="gi">+                                 settings.pskConfigs if</span>
<span class="gi">+                                 i[0] in client_identities]</span>
<span class="gi">+                    if psks_prfs:</span>
<span class="gi">+                        ciphers = CipherSuite.filter_for_prfs(ciphers,</span>
<span class="gi">+                                                              psks_prfs)</span>
<span class="gi">+                for cipher in ciphers:</span>
<span class="gi">+                    # select first mutually supported</span>
<span class="gi">+                    if cipher in client_hello.cipher_suites:</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # abort with context-specific alert if client indicated</span>
<span class="gi">+                    # support for FFDHE groups</span>
<span class="gi">+                    if client_groups and \</span>
<span class="gi">+                        any(i in range(256, 512) for i in client_groups) and \</span>
<span class="gi">+                        any(i in CipherSuite.dhAllSuites</span>
<span class="gi">+                            for i in client_hello.cipher_suites):</span>
<span class="gi">+                            raise TLSInsufficientSecurity(</span>
<span class="gi">+                                    &quot;FFDHE groups not acceptable and no other common &quot;</span>
<span class="gi">+                                    &quot;ciphers&quot;)</span>
<span class="gi">+                    raise TLSHandshakeFailure(&quot;No mutual ciphersuite&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                # Find a signature algorithm based on the certificate</span>
<span class="gi">+                try:</span>
<span class="gi">+                    sig_scheme, _, _ = \</span>
<span class="gi">+                        self._pickServerKeyExchangeSig(settings,</span>
<span class="gi">+                                                       client_hello,</span>
<span class="gi">+                                                       cert,</span>
<span class="gi">+                                                       key,</span>
<span class="gi">+                                                       version,</span>
<span class="gi">+                                                       False)</span>
<span class="gi">+                except TLSHandshakeFailure:</span>
<span class="gi">+                    raise TLSHandshakeFailure(</span>
<span class="gi">+                        &quot;No common signature algorithms&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                # If the certificate is ECDSA, we must check curve compatibility</span>
<span class="gi">+                if cert and cert.x509List[0].certAlg == &#39;ecdsa&#39; and \</span>
<span class="gi">+                        client_groups and client_sigalgs:</span>
<span class="gi">+                    public_key = cert.getEndEntityPublicKey()</span>
<span class="gi">+                    curve = public_key.curve_name</span>
<span class="gi">+                    for name, aliases in CURVE_ALIASES.items():</span>
<span class="gi">+                        if curve in aliases:</span>
<span class="gi">+                            curve = getattr(GroupName, name)</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+                    if version &lt;= (3, 3) and curve not in client_groups:</span>
<span class="gi">+                        raise TLSHandshakeFailure(</span>
<span class="gi">+                            &quot;The curve in the public key is not &quot;</span>
<span class="gi">+                            &quot;supported by the client: {0}&quot; \</span>
<span class="gi">+                                    .format(GroupName.toRepr(curve)))</span>
<span class="gi">+</span>
<span class="gi">+                    if version &gt;= (3, 4):</span>
<span class="gi">+                        if GroupName.toRepr(curve) not in \</span>
<span class="gi">+                                (&#39;secp256r1&#39;, &#39;secp384r1&#39;, &#39;secp521r1&#39;):</span>
<span class="gi">+                            raise TLSIllegalParameterException(</span>
<span class="gi">+                                    &quot;Curve in public key is not supported &quot;</span>
<span class="gi">+                                    &quot;in TLS1.3&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                # If all mandatory checks passed add</span>
<span class="gi">+                # this as possible certificate we can use.</span>
<span class="gi">+                possible_certs.append((cipher, sig_scheme, cert, key))</span>
<span class="gi">+</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                if last_cert and not possible_certs:</span>
<span class="gi">+                    raise</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Non-mandatory checks, if these fail the certificate is still usable</span>
<span class="gi">+            # but we should try to find one that passes all the checks</span>
<span class="gi">+</span>
<span class="gi">+            # Check if every certificate(except the self-signed root CA)</span>
<span class="gi">+            # in the certificate chain is signed with a signature algorithm</span>
<span class="gi">+            # supported by the client.</span>
<span class="gi">+            if cert:</span>
<span class="gi">+                cert_chain_ok = True</span>
<span class="gi">+                for i in range(len(cert.x509List)):</span>
<span class="gi">+                    if cert.x509List[i].issuer != cert.x509List[i].subject:</span>
<span class="gi">+                        if cert.x509List[i].sigalg not in client_sigalgs:</span>
<span class="gi">+                            cert_chain_ok = False</span>
<span class="gi">+                            break</span>
<span class="gi">+                if not cert_chain_ok:</span>
<span class="gi">+                    if not last_cert:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            # If all mandatory and non-mandatory checks passed</span>
<span class="gi">+            # return the (cert, key) pair, cipher and sig_scheme</span>
<span class="gi">+            return cipher, sig_scheme, cert, key</span>
<span class="gi">+</span>
<span class="gi">+        # If we can&#39;t find cert that passed all the checks, return the first usable one.</span>
<span class="gi">+        return possible_certs[0]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def _serverCertKeyExchange(self, clientHello, serverHello, sigHashAlg,</span>
<span class="gi">+                                serverCertChain, keyExchange,</span>
<span class="gi">+                                reqCert, reqCAs, cipherSuite,</span>
<span class="gi">+                                settings):</span>
<span class="gi">+        #Send ServerHello, Certificate[, ServerKeyExchange]</span>
<span class="gi">+        #[, CertificateRequest], ServerHelloDone</span>
<span class="gi">+        msgs = []</span>
<span class="gi">+</span>
<span class="gi">+        # If we verify a client cert chain, return it</span>
<span class="gi">+        clientCertChain = None</span>
<span class="gi">+</span>
<span class="gi">+        msgs.append(serverHello)</span>
<span class="gi">+        msgs.append(Certificate(CertificateType.x509).create(serverCertChain))</span>
<span class="gi">+        try:</span>
<span class="gi">+            serverKeyExchange = keyExchange.makeServerKeyExchange(sigHashAlg)</span>
<span class="gi">+        except TLSInternalError as alert:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.internal_error,</span>
<span class="gi">+                    str(alert)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSInsufficientSecurity as alert:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.insufficient_security,</span>
<span class="gi">+                    str(alert)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        if serverKeyExchange is not None:</span>
<span class="gi">+            msgs.append(serverKeyExchange)</span>
<span class="gi">+        if reqCert:</span>
<span class="gi">+            certificateRequest = CertificateRequest(self.version)</span>
<span class="gi">+            if not reqCAs:</span>
<span class="gi">+                reqCAs = []</span>
<span class="gi">+            cr_settings = settings.validate()</span>
<span class="gi">+            valid_sig_algs = self._sigHashesToList(cr_settings)</span>
<span class="gi">+</span>
<span class="gi">+            cert_types = []</span>
<span class="gi">+            if cr_settings.rsaSigHashes:</span>
<span class="gi">+                cert_types.append(ClientCertificateType.rsa_sign)</span>
<span class="gi">+            if cr_settings.ecdsaSigHashes or cr_settings.more_sig_schemes:</span>
<span class="gi">+                cert_types.append(ClientCertificateType.ecdsa_sign)</span>
<span class="gi">+            if cr_settings.dsaSigHashes:</span>
<span class="gi">+                cert_types.append(ClientCertificateType.dss_sign)</span>
<span class="gi">+</span>
<span class="gi">+            certificateRequest.create(cert_types,</span>
<span class="gi">+                                      reqCAs,</span>
<span class="gi">+                                      valid_sig_algs)</span>
<span class="gi">+            msgs.append(certificateRequest)</span>
<span class="gi">+        msgs.append(ServerHelloDone())</span>
<span class="gi">+        for result in self._sendMsgs(msgs):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+        #Get [Certificate,] (if was requested)</span>
<span class="gi">+        if reqCert:</span>
<span class="gi">+            if self.version == (3,0):</span>
<span class="gi">+                for result in self._getMsg((ContentType.handshake,</span>
<span class="gi">+                                           ContentType.alert),</span>
<span class="gi">+                                           HandshakeType.certificate,</span>
<span class="gi">+                                           CertificateType.x509):</span>
<span class="gi">+                    if result in (0,1): yield result</span>
<span class="gi">+                    else: break</span>
<span class="gi">+                msg = result</span>
<span class="gi">+</span>
<span class="gi">+                if isinstance(msg, Alert):</span>
<span class="gi">+                    #If it&#39;s not a no_certificate alert, re-raise</span>
<span class="gi">+                    alert = msg</span>
<span class="gi">+                    if alert.description != \</span>
<span class="gi">+                            AlertDescription.no_certificate:</span>
<span class="gi">+                        self._shutdown(False)</span>
<span class="gi">+                        raise TLSRemoteAlert(alert)</span>
<span class="gi">+                elif isinstance(msg, Certificate):</span>
<span class="gi">+                    clientCertificate = msg</span>
<span class="gi">+                    if clientCertificate.cert_chain and \</span>
<span class="gi">+                            clientCertificate.cert_chain.getNumCerts() != 0:</span>
<span class="gi">+                        clientCertChain = clientCertificate.cert_chain</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise AssertionError()</span>
<span class="gi">+            elif self.version in ((3,1), (3,2), (3,3)):</span>
<span class="gi">+                for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                          HandshakeType.certificate,</span>
<span class="gi">+                                          CertificateType.x509):</span>
<span class="gi">+                    if result in (0,1): yield result</span>
<span class="gi">+                    else: break</span>
<span class="gi">+                clientCertificate = result</span>
<span class="gi">+                if clientCertificate.cert_chain and \</span>
<span class="gi">+                        clientCertificate.cert_chain.getNumCerts() != 0:</span>
<span class="gi">+                    clientCertChain = clientCertificate.cert_chain</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise AssertionError()</span>
<span class="gi">+</span>
<span class="gi">+        #Get ClientKeyExchange</span>
<span class="gi">+        for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                  HandshakeType.client_key_exchange,</span>
<span class="gi">+                                  cipherSuite):</span>
<span class="gi">+            if result in (0,1): yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+        clientKeyExchange = result</span>
<span class="gi">+</span>
<span class="gi">+        #Process ClientKeyExchange</span>
<span class="gi">+        try:</span>
<span class="gi">+            premasterSecret = \</span>
<span class="gi">+                keyExchange.processClientKeyExchange(clientKeyExchange)</span>
<span class="gi">+        except TLSIllegalParameterException as alert:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.illegal_parameter,</span>
<span class="gi">+                                          str(alert)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSDecodeError as alert:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.decode_error,</span>
<span class="gi">+                                          str(alert)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        #Get and check CertificateVerify, if relevant</span>
<span class="gi">+        self._certificate_verify_handshake_hash = self._handshake_hash.copy()</span>
<span class="gi">+        if clientCertChain:</span>
<span class="gi">+            for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                       HandshakeType.certificate_verify):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            certificateVerify = result</span>
<span class="gi">+            signatureAlgorithm = None</span>
<span class="gi">+            if self.version == (3, 3):</span>
<span class="gi">+                valid_sig_algs = \</span>
<span class="gi">+                    self._sigHashesToList(settings,</span>
<span class="gi">+                                          certList=clientCertChain)</span>
<span class="gi">+                if certificateVerify.signatureAlgorithm not in valid_sig_algs:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.illegal_parameter,</span>
<span class="gi">+                            &quot;Invalid signature algorithm in Certificate &quot;</span>
<span class="gi">+                            &quot;Verify&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                signatureAlgorithm = certificateVerify.signatureAlgorithm</span>
<span class="gi">+            if not signatureAlgorithm and \</span>
<span class="gi">+                    clientCertChain.x509List[0].certAlg == &quot;ecdsa&quot;:</span>
<span class="gi">+                signatureAlgorithm = (HashAlgorithm.sha1,</span>
<span class="gi">+                                      SignatureAlgorithm.ecdsa)</span>
<span class="gi">+</span>
<span class="gi">+            cvhh = self._certificate_verify_handshake_hash</span>
<span class="gi">+            verify_bytes = KeyExchange.calcVerifyBytes(</span>
<span class="gi">+                self.version,</span>
<span class="gi">+                cvhh,</span>
<span class="gi">+                signatureAlgorithm,</span>
<span class="gi">+                premasterSecret,</span>
<span class="gi">+                clientHello.random,</span>
<span class="gi">+                serverHello.random,</span>
<span class="gi">+                key_type=clientCertChain.x509List[0].certAlg)</span>
<span class="gi">+</span>
<span class="gi">+            for result in self._check_certchain_with_settings(</span>
<span class="gi">+                    clientCertChain,</span>
<span class="gi">+                    settings):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else: break</span>
<span class="gi">+            public_key = result</span>
<span class="gi">+</span>
<span class="gi">+            if signatureAlgorithm and signatureAlgorithm in (</span>
<span class="gi">+                    SignatureScheme.ed25519, SignatureScheme.ed448):</span>
<span class="gi">+                hash_name = &quot;intrinsic&quot;</span>
<span class="gi">+                salt_len = None</span>
<span class="gi">+                padding = None</span>
<span class="gi">+                ver_func = public_key.hashAndVerify</span>
<span class="gi">+            elif signatureAlgorithm and \</span>
<span class="gi">+                    signatureAlgorithm[1] == SignatureAlgorithm.dsa:</span>
<span class="gi">+                padding = None</span>
<span class="gi">+                hash_name = HashAlgorithm.toRepr(signatureAlgorithm[0])</span>
<span class="gi">+                salt_len = None</span>
<span class="gi">+                ver_func = public_key.verify</span>
<span class="gi">+            elif not signatureAlgorithm or \</span>
<span class="gi">+                    signatureAlgorithm[1] != SignatureAlgorithm.ecdsa:</span>
<span class="gi">+                scheme = SignatureScheme.toRepr(signatureAlgorithm)</span>
<span class="gi">+                # for pkcs1 signatures hash is used to add PKCS#1 prefix, but</span>
<span class="gi">+                # that was already done by calcVerifyBytes</span>
<span class="gi">+                hash_name = None</span>
<span class="gi">+                salt_len = 0</span>
<span class="gi">+                if scheme is None:</span>
<span class="gi">+                    padding = &#39;pkcs1&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    padding = SignatureScheme.getPadding(scheme)</span>
<span class="gi">+                    if padding == &#39;pss&#39;:</span>
<span class="gi">+                        hash_name = SignatureScheme.getHash(scheme)</span>
<span class="gi">+                        salt_len = getattr(hashlib, hash_name)().digest_size</span>
<span class="gi">+                ver_func = public_key.verify</span>
<span class="gi">+            else:</span>
<span class="gi">+                hash_name = HashAlgorithm.toStr(signatureAlgorithm[0])</span>
<span class="gi">+                verify_bytes = verify_bytes[</span>
<span class="gi">+                    :public_key.public_key.curve.baselen]</span>
<span class="gi">+                padding = None</span>
<span class="gi">+                salt_len = None</span>
<span class="gi">+                ver_func = public_key.verify</span>
<span class="gi">+</span>
<span class="gi">+            if not ver_func(certificateVerify.signature,</span>
<span class="gi">+                            verify_bytes,</span>
<span class="gi">+                            padding,</span>
<span class="gi">+                            hash_name,</span>
<span class="gi">+                            salt_len):</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.decrypt_error,</span>
<span class="gi">+                        &quot;Signature failed to verify&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+        yield (premasterSecret, clientCertChain)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def _serverAnonKeyExchange(self, serverHello, keyExchange, cipherSuite):</span>
<span class="gi">+</span>
<span class="gi">+        # Create ServerKeyExchange</span>
<span class="gi">+        serverKeyExchange = keyExchange.makeServerKeyExchange()</span>
<span class="gi">+</span>
<span class="gi">+        # Send ServerHello[, Certificate], ServerKeyExchange,</span>
<span class="gi">+        # ServerHelloDone</span>
<span class="gi">+        msgs = []</span>
<span class="gi">+        msgs.append(serverHello)</span>
<span class="gi">+        msgs.append(serverKeyExchange)</span>
<span class="gi">+        msgs.append(ServerHelloDone())</span>
<span class="gi">+        for result in self._sendMsgs(msgs):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+        # Get and check ClientKeyExchange</span>
<span class="gi">+        for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                   HandshakeType.client_key_exchange,</span>
<span class="gi">+                                   cipherSuite):</span>
<span class="gi">+            if result in (0,1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        cke = result</span>
<span class="gi">+        try:</span>
<span class="gi">+            premasterSecret = keyExchange.processClientKeyExchange(cke)</span>
<span class="gi">+        except TLSIllegalParameterException as alert:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.illegal_parameter,</span>
<span class="gi">+                                          str(alert)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSDecodeError as alert:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.decode_error,</span>
<span class="gi">+                                          str(alert)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        yield premasterSecret</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def _serverFinished(self, premasterSecret, clientRandom, serverRandom,</span>
<span class="gi">+                        cipherSuite, cipherImplementations, nextProtos,</span>
<span class="gi">+                        settings, send_session_ticket=False,</span>
<span class="gi">+                        client_cert_chain=None):</span>
<span class="gi">+</span>
<span class="gi">+        masterSecret = self._calculate_master_secret(premasterSecret,</span>
<span class="gi">+                                                     cipherSuite,</span>
<span class="gi">+                                                     clientRandom,</span>
<span class="gi">+                                                     serverRandom)</span>
<span class="gi">+        self.session.masterSecret = masterSecret</span>
<span class="gi">+</span>
<span class="gi">+        #Calculate pending connection states</span>
<span class="gi">+        self._calcPendingStates(cipherSuite, masterSecret,</span>
<span class="gi">+                                clientRandom, serverRandom,</span>
<span class="gi">+                                cipherImplementations)</span>
<span class="gi">+</span>
<span class="gi">+        #Exchange ChangeCipherSpec and Finished messages</span>
<span class="gi">+        for result in self._getFinished(masterSecret,</span>
<span class="gi">+                                        cipherSuite,</span>
<span class="gi">+                                   expect_next_protocol=nextProtos is not None):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._sendFinished(masterSecret, cipherSuite,</span>
<span class="gi">+                                         settings=settings,</span>
<span class="gi">+                                         send_session_ticket=send_session_ticket,</span>
<span class="gi">+                                         client_cert_chain=client_cert_chain):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+    #*********************************************************</span>
<span class="gi">+    # Shared Handshake Functions</span>
<span class="gi">+    #*********************************************************</span>
<span class="gi">+</span>
<span class="gi">+    def _sendFinished(self, masterSecret, cipherSuite=None, nextProto=None,</span>
<span class="gi">+            settings=None, send_session_ticket=False, client_cert_chain=None):</span>
<span class="gi">+        if send_session_ticket:</span>
<span class="gi">+            for result in self._serverSendTickets(settings):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # send the CCS and Finished in single TCP packet</span>
<span class="gi">+        self.sock.buffer_writes = True</span>
<span class="gi">+        #Send ChangeCipherSpec</span>
<span class="gi">+        for result in self._sendMsg(ChangeCipherSpec()):</span>
<span class="gi">+            yield result</span>
<span class="gi">+</span>
<span class="gi">+        #Switch to pending write state</span>
<span class="gi">+        self._changeWriteState()</span>
<span class="gi">+</span>
<span class="gi">+        if self._peer_record_size_limit:</span>
<span class="gi">+            self._send_record_limit = self._peer_record_size_limit</span>
<span class="gi">+            # this is TLS 1.2 and earlier method, so the real limit may be</span>
<span class="gi">+            # lower that what&#39;s in the settings</span>
<span class="gi">+            self._recv_record_limit = min(2**14, settings.record_size_limit)</span>
<span class="gi">+</span>
<span class="gi">+        if nextProto is not None:</span>
<span class="gi">+            nextProtoMsg = NextProtocol().create(nextProto)</span>
<span class="gi">+            for result in self._sendMsg(nextProtoMsg):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        #Figure out the correct label to use</span>
<span class="gi">+        if self._client:</span>
<span class="gi">+            label = b&quot;client finished&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            label = b&quot;server finished&quot;</span>
<span class="gi">+        #Calculate verification data</span>
<span class="gi">+        verifyData = calc_key(self.version, masterSecret,</span>
<span class="gi">+                              cipherSuite, label,</span>
<span class="gi">+                              handshake_hashes=self._handshake_hash,</span>
<span class="gi">+                              output_length=12)</span>
<span class="gi">+        if self.fault == Fault.badFinished:</span>
<span class="gi">+            verifyData[0] = (verifyData[0]+1)%256</span>
<span class="gi">+</span>
<span class="gi">+        #Send Finished message under new state</span>
<span class="gi">+        finished = Finished(self.version).create(verifyData)</span>
<span class="gi">+        for result in self._sendMsg(finished):</span>
<span class="gi">+            yield result</span>
<span class="gi">+        self.sock.flush()</span>
<span class="gi">+        self.sock.buffer_writes = False</span>
<span class="gi">+</span>
<span class="gi">+    def _getFinished(self, masterSecret, cipherSuite=None,</span>
<span class="gi">+                     expect_next_protocol=False, nextProto=None):</span>
<span class="gi">+</span>
<span class="gi">+        expect_ccs_message = True</span>
<span class="gi">+        # If we use SessionTicket resumption on client side, there are multiple</span>
<span class="gi">+        # situations where the server has the option to send new ticket</span>
<span class="gi">+        for result in self._getMsg(</span>
<span class="gi">+                (ContentType.handshake, ContentType.change_cipher_spec),</span>
<span class="gi">+                HandshakeType.new_session_ticket):</span>
<span class="gi">+            if result in (0,1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            else: break</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(result, NewSessionTicket1_0):</span>
<span class="gi">+            session_ticket = result</span>
<span class="gi">+            # If we receive new ticket we clear the old ones</span>
<span class="gi">+            del self.tls_1_0_tickets[:]</span>
<span class="gi">+            self.tls_1_0_tickets.append(Ticket(session_ticket.ticket,</span>
<span class="gi">+                                        session_ticket.ticket_lifetime,</span>
<span class="gi">+                                        masterSecret, cipherSuite))</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert isinstance(result, ChangeCipherSpec)</span>
<span class="gi">+            expect_ccs_message = False</span>
<span class="gi">+</span>
<span class="gi">+            changeCipherSpec = result</span>
<span class="gi">+            if changeCipherSpec.type != 1:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;ChangeCipherSpec type incorrect&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+        if expect_ccs_message:</span>
<span class="gi">+            for result in self._getMsg(ContentType.change_cipher_spec):</span>
<span class="gi">+                if result in (0,1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            changeCipherSpec = result</span>
<span class="gi">+</span>
<span class="gi">+            if changeCipherSpec.type != 1:</span>
<span class="gi">+                for result in self._sendError(AlertDescription.illegal_parameter,</span>
<span class="gi">+                                             &quot;ChangeCipherSpec type incorrect&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+        #Switch to pending read state</span>
<span class="gi">+        self._changeReadState()</span>
<span class="gi">+</span>
<span class="gi">+        #Server Finish - Are we waiting for a next protocol echo?</span>
<span class="gi">+        if expect_next_protocol:</span>
<span class="gi">+            for result in self._getMsg(ContentType.handshake, HandshakeType.next_protocol):</span>
<span class="gi">+                if result in (0,1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            if result is None:</span>
<span class="gi">+                for result in self._sendError(AlertDescription.unexpected_message,</span>
<span class="gi">+                                             &quot;Didn&#39;t get NextProtocol message&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+</span>
<span class="gi">+            self.next_proto = result.next_proto</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.next_proto = None</span>
<span class="gi">+</span>
<span class="gi">+        #Client Finish - Only set the next_protocol selected in the connection</span>
<span class="gi">+        if nextProto:</span>
<span class="gi">+            self.next_proto = nextProto</span>
<span class="gi">+</span>
<span class="gi">+        #Figure out which label to use.</span>
<span class="gi">+        if self._client:</span>
<span class="gi">+            label = b&quot;server finished&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            label = b&quot;client finished&quot;</span>
<span class="gi">+</span>
<span class="gi">+        #Calculate verification data</span>
<span class="gi">+        verifyData = calc_key(self.version, masterSecret,</span>
<span class="gi">+                              cipherSuite, label,</span>
<span class="gi">+                              handshake_hashes=self._handshake_hash,</span>
<span class="gi">+                              output_length=12)</span>
<span class="gi">+</span>
<span class="gi">+        #Get and check Finished message under new state</span>
<span class="gi">+        for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                  HandshakeType.finished):</span>
<span class="gi">+            if result in (0,1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        finished = result</span>
<span class="gi">+        if finished.verify_data != verifyData:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.decrypt_error,</span>
<span class="gi">+                                         &quot;Finished message is incorrect&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+    def _handshakeWrapperAsync(self, handshaker, checker):</span>
<span class="gi">+        try:</span>
<span class="gi">+            for result in handshaker:</span>
<span class="gi">+                yield result</span>
<span class="gi">+            if checker:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    checker(self)</span>
<span class="gi">+                except TLSAuthenticationError:</span>
<span class="gi">+                    alert = Alert().create(AlertDescription.close_notify,</span>
<span class="gi">+                                           AlertLevel.fatal)</span>
<span class="gi">+                    for result in self._sendMsg(alert):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                    raise</span>
<span class="gi">+        except GeneratorExit:</span>
<span class="gi">+            raise</span>
<span class="gi">+        except TLSAlert as alert:</span>
<span class="gi">+            if not self.fault:</span>
<span class="gi">+                raise</span>
<span class="gi">+            if alert.description not in Fault.faultAlerts[self.fault]:</span>
<span class="gi">+                raise TLSFaultError(str(alert))</span>
<span class="gi">+            else:</span>
<span class="gi">+                pass</span>
<span class="gi">+        except:</span>
<span class="gi">+            self._shutdown(False)</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def _calculate_master_secret(self, premaster_secret, cipher_suite,</span>
<span class="gi">+                                 client_random, server_random):</span>
<span class="gi">+        if self.extendedMasterSecret:</span>
<span class="gi">+            cvhh = self._certificate_verify_handshake_hash</span>
<span class="gi">+            # in case of resumption or lack of certificate authentication,</span>
<span class="gi">+            # the CVHH won&#39;t be initialised, but then it would also be equal</span>
<span class="gi">+            # to regular handshake hash</span>
<span class="gi">+            if not cvhh:</span>
<span class="gi">+                cvhh = self._handshake_hash</span>
<span class="gi">+            secret = calc_key(self.version, premaster_secret,</span>
<span class="gi">+                              cipher_suite, b&quot;extended master secret&quot;,</span>
<span class="gi">+                              handshake_hashes=cvhh,</span>
<span class="gi">+                              output_length=48)</span>
<span class="gi">+        else:</span>
<span class="gi">+            secret = calc_key(self.version, premaster_secret,</span>
<span class="gi">+                              cipher_suite, b&quot;master secret&quot;,</span>
<span class="gi">+                              client_random=client_random,</span>
<span class="gi">+                              server_random=server_random,</span>
<span class="gi">+                              output_length=48)</span>
<span class="gi">+        return secret</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _pickServerKeyExchangeSig(settings, clientHello, certList=None,
<span class="gd">-        private_key=None, version=(3, 3), check_alt=True):</span>
<span class="gi">+                                  private_key=None,</span>
<span class="gi">+                                  version=(3, 3), check_alt=True):</span>
<span class="w"> </span>        &quot;&quot;&quot;Pick a hash that matches most closely the supported ones&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hashAndAlgsExt = clientHello.getExtension(</span>
<span class="gi">+            ExtensionType.signature_algorithms)</span>
<span class="gi">+</span>
<span class="gi">+        if version &gt; (3, 3):</span>
<span class="gi">+            if not hashAndAlgsExt:</span>
<span class="gi">+                # the error checking was done before hand, likely we&#39;re</span>
<span class="gi">+                # doing PSK key exchange</span>
<span class="gi">+                return None, certList, private_key</span>
<span class="gi">+</span>
<span class="gi">+        if hashAndAlgsExt is None or hashAndAlgsExt.sigalgs is None:</span>
<span class="gi">+            # RFC 5246 states that if there are no hashes advertised,</span>
<span class="gi">+            # sha1 should be picked</span>
<span class="gi">+            return &quot;sha1&quot;, certList, private_key</span>
<span class="gi">+</span>
<span class="gi">+        if check_alt:</span>
<span class="gi">+            alt_certs = ((X509CertChain(i.certificates), i.key) for vh in</span>
<span class="gi">+                         settings.virtual_hosts for i in vh.keys)</span>
<span class="gi">+        else:</span>
<span class="gi">+            alt_certs = ()</span>
<span class="gi">+</span>
<span class="gi">+        for certs, key in chain([(certList, private_key)], alt_certs):</span>
<span class="gi">+            supported = TLSConnection._sigHashesToList(settings,</span>
<span class="gi">+                                                       certList=certs,</span>
<span class="gi">+                                                       version=version)</span>
<span class="gi">+</span>
<span class="gi">+            for schemeID in supported:</span>
<span class="gi">+                if schemeID in hashAndAlgsExt.sigalgs:</span>
<span class="gi">+                    name = SignatureScheme.toRepr(schemeID)</span>
<span class="gi">+                    if not name and schemeID[1] in (SignatureAlgorithm.rsa,</span>
<span class="gi">+                                                    SignatureAlgorithm.ecdsa,</span>
<span class="gi">+                                                    SignatureAlgorithm.dsa):</span>
<span class="gi">+                        name = HashAlgorithm.toRepr(schemeID[0])</span>
<span class="gi">+</span>
<span class="gi">+                    if name:</span>
<span class="gi">+                        return name, certs, key</span>
<span class="gi">+</span>
<span class="gi">+        # if no match, we must abort per RFC 5246</span>
<span class="gi">+        raise TLSHandshakeFailure(&quot;No common signature algorithms&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _sigHashesToList(settings, privateKey=None, certList=None, version=</span>
<span class="gd">-        (3, 3)):</span>
<span class="gi">+    def _sigHashesToList(settings, privateKey=None, certList=None,</span>
<span class="gi">+                         version=(3, 3)):</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert list of valid signature hashes to array of tuples&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        certType = None</span>
<span class="gi">+        publicKey = None</span>
<span class="gi">+        if certList and certList.x509List:</span>
<span class="gi">+            certType = certList.x509List[0].certAlg</span>
<span class="gi">+            publicKey = certList.x509List[0].publicKey</span>
<span class="gi">+</span>
<span class="gi">+        sigAlgs = []</span>
<span class="gi">+</span>
<span class="gi">+        if not certType or certType == &quot;Ed25519&quot; or certType == &quot;Ed448&quot;:</span>
<span class="gi">+            for sig_scheme in settings.more_sig_schemes:</span>
<span class="gi">+                if version &lt; (3, 3):</span>
<span class="gi">+                    # EdDSA is supported only in TLS 1.2 and 1.3</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if certType and sig_scheme != certType:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                sigAlgs.append(getattr(SignatureScheme, sig_scheme.lower()))</span>
<span class="gi">+</span>
<span class="gi">+        if not certType or certType == &quot;ecdsa&quot;:</span>
<span class="gi">+            for hashName in settings.ecdsaSigHashes:</span>
<span class="gi">+                # only SHA256, SHA384 and SHA512 are allowed in TLS 1.3</span>
<span class="gi">+                if version &gt; (3, 3) and hashName in (&quot;sha1&quot;, &quot;sha224&quot;):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # in TLS 1.3 ECDSA key curve is bound to hash</span>
<span class="gi">+                if publicKey and version &gt; (3, 3):</span>
<span class="gi">+                    curve = publicKey.curve_name</span>
<span class="gi">+                    matching_hash = TLSConnection._curve_name_to_hash_name(</span>
<span class="gi">+                        curve)</span>
<span class="gi">+                    if hashName != matching_hash:</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                sigAlgs.append((getattr(HashAlgorithm, hashName),</span>
<span class="gi">+                                SignatureAlgorithm.ecdsa))</span>
<span class="gi">+</span>
<span class="gi">+        if not certType or certType == &quot;dsa&quot;:</span>
<span class="gi">+            for hashName in settings.dsaSigHashes:</span>
<span class="gi">+                if version &gt; (3, 3):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                sigAlgs.append((getattr(HashAlgorithm, hashName),</span>
<span class="gi">+                                SignatureAlgorithm.dsa))</span>
<span class="gi">+</span>
<span class="gi">+        if not certType or certType in (&quot;rsa&quot;, &quot;rsa-pss&quot;):</span>
<span class="gi">+            for schemeName in settings.rsaSchemes:</span>
<span class="gi">+                # pkcs#1 v1.5 signatures are not allowed in TLS 1.3</span>
<span class="gi">+                if version &gt; (3, 3) and schemeName == &quot;pkcs1&quot;:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                for hashName in settings.rsaSigHashes:</span>
<span class="gi">+                    # rsa-pss certificates can&#39;t be used to make PKCS#1 v1.5</span>
<span class="gi">+                    # signatures</span>
<span class="gi">+                    if certType == &quot;rsa-pss&quot; and schemeName == &quot;pkcs1&quot;:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        # 1024 bit keys are too small to create valid</span>
<span class="gi">+                        # rsa-pss-SHA512 signatures</span>
<span class="gi">+                        if schemeName == &#39;pss&#39; and hashName == &#39;sha512&#39;\</span>
<span class="gi">+                                and privateKey and privateKey.n &lt; 2**2047:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        # advertise support for both rsaEncryption and RSA-PSS OID</span>
<span class="gi">+                        # key type</span>
<span class="gi">+                        if certType != &#39;rsa-pss&#39;:</span>
<span class="gi">+                            sigAlgs.append(getattr(SignatureScheme,</span>
<span class="gi">+                                                   &quot;rsa_{0}_rsae_{1}&quot;</span>
<span class="gi">+                                                   .format(schemeName, hashName)))</span>
<span class="gi">+                        if certType != &#39;rsa&#39;:</span>
<span class="gi">+                            sigAlgs.append(getattr(SignatureScheme,</span>
<span class="gi">+                                                   &quot;rsa_{0}_pss_{1}&quot;</span>
<span class="gi">+                                                   .format(schemeName, hashName)))</span>
<span class="gi">+                    except AttributeError:</span>
<span class="gi">+                        if schemeName == &#39;pkcs1&#39;:</span>
<span class="gi">+                            sigAlgs.append((getattr(HashAlgorithm, hashName),</span>
<span class="gi">+                                            SignatureAlgorithm.rsa))</span>
<span class="gi">+                        continue</span>
<span class="gi">+        return sigAlgs</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _curveNamesToList(settings):
<span class="w"> </span>        &quot;&quot;&quot;Convert list of acceptable curves to array identifiers&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [getattr(GroupName, val) for val in settings.eccCurves]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _groupNamesToList(settings):
<span class="w"> </span>        &quot;&quot;&quot;Convert list of acceptable ff groups to TLS identifiers.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [getattr(GroupName, val) for val in settings.dhGroups]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _curve_name_to_hash_name(curve_name):
<span class="gu">@@ -505,4 +4764,11 @@ class TLSConnection(TLSRecordLayer):</span>

<span class="w"> </span>        expects the python-ecdsa curve names as parameter
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if curve_name == &quot;NIST256p&quot;:</span>
<span class="gi">+            return &quot;sha256&quot;</span>
<span class="gi">+        if curve_name == &quot;NIST384p&quot;:</span>
<span class="gi">+            return &quot;sha384&quot;</span>
<span class="gi">+        if curve_name == &quot;NIST521p&quot;:</span>
<span class="gi">+            return &quot;sha512&quot;</span>
<span class="gi">+        raise TLSIllegalParameterException(</span>
<span class="gi">+            &quot;Curve {0} is not supported in TLS 1.3&quot;.format(curve_name))</span>
<span class="gh">diff --git a/tlslite/tlsrecordlayer.py b/tlslite/tlsrecordlayer.py</span>
<span class="gh">index 01f1c67..0cd31f2 100644</span>
<span class="gd">--- a/tlslite/tlsrecordlayer.py</span>
<span class="gi">+++ b/tlslite/tlsrecordlayer.py</span>
<span class="gu">@@ -1,8 +1,20 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Google (adapted by Sam Rushing) - NPN support</span>
<span class="gi">+#   Google - minimal padding</span>
<span class="gi">+#   Martin von Loewis - python 3 port</span>
<span class="gi">+#   Yngve Pettersen (ported by Paul Sokolovsky) - TLS 1.2</span>
<span class="gi">+#   Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Helper class for TLSConnection.&quot;&quot;&quot;
<span class="w"> </span>from __future__ import generators
<span class="gi">+</span>
<span class="w"> </span>import io
<span class="w"> </span>import time
<span class="w"> </span>import socket
<span class="gi">+</span>
<span class="w"> </span>from .utils.compat import *
<span class="w"> </span>from .utils.cryptomath import *
<span class="w"> </span>from .utils.codec import Parser, BadCertificateError
<span class="gu">@@ -18,7 +30,6 @@ from .bufferedsocket import BufferedSocket</span>
<span class="w"> </span>from .handshakesettings import HandshakeSettings
<span class="w"> </span>from .keyexchange import KeyExchange

<span class="gd">-</span>
<span class="w"> </span>class TLSRecordLayer(object):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    This class handles data transmission for a TLS connection.
<span class="gu">@@ -111,81 +122,137 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>        sock = BufferedSocket(sock)
<span class="w"> </span>        self.sock = sock
<span class="w"> </span>        self._recordLayer = RecordLayer(sock)
<span class="gi">+</span>
<span class="gi">+        #My session object (Session instance; read-only)</span>
<span class="w"> </span>        self.session = None
<span class="gi">+</span>
<span class="gi">+        #Buffers for processing messages</span>
<span class="w"> </span>        self._defragmenter = Defragmenter()
<span class="w"> </span>        self._defragmenter.add_static_size(ContentType.change_cipher_spec, 1)
<span class="w"> </span>        self._defragmenter.add_static_size(ContentType.alert, 2)
<span class="w"> </span>        self._defragmenter.add_dynamic_size(ContentType.handshake, 1, 3)
<span class="w"> </span>        self.clearReadBuffer()
<span class="w"> </span>        self.clearWriteBuffer()
<span class="gi">+</span>
<span class="gi">+        #Handshake digests</span>
<span class="w"> </span>        self._handshake_hash = HandshakeHashes()
<span class="gi">+        # Handshake digest used for Certificate Verify signature and</span>
<span class="gi">+        # also for EMS calculation, in practice, it excludes</span>
<span class="gi">+        # CertificateVerify and all following messages (Finished)</span>
<span class="w"> </span>        self._certificate_verify_handshake_hash = None
<span class="gi">+        # for PSK binders we need to be able to calculate the hash of all</span>
<span class="gi">+        # echanged messages and a _truncated_ ClientHello message so we</span>
<span class="gi">+        # need a copy of those hashes before CH was received</span>
<span class="w"> </span>        self._pre_client_hello_handshake_hash = None
<span class="gd">-        self.closed = True</span>
<span class="gd">-        self._refCount = 0</span>
<span class="gd">-        self.resumed = False</span>
<span class="gi">+</span>
<span class="gi">+        #Is the connection open?</span>
<span class="gi">+        self.closed = True #read-only</span>
<span class="gi">+        self._refCount = 0 #Used to trigger closure</span>
<span class="gi">+</span>
<span class="gi">+        #Is this a resumed session?</span>
<span class="gi">+        self.resumed = False #read-only</span>
<span class="gi">+</span>
<span class="gi">+        #What username did the client claim in his handshake?</span>
<span class="w"> </span>        self.allegedSrpUsername = None
<span class="gi">+</span>
<span class="gi">+        #On a call to close(), do we close the socket? (writeable)</span>
<span class="w"> </span>        self.closeSocket = True
<span class="gi">+</span>
<span class="gi">+        #If the socket is abruptly closed, do we ignore it</span>
<span class="gi">+        #and pretend the connection was shut down properly? (writeable)</span>
<span class="w"> </span>        self.ignoreAbruptClose = False
<span class="gi">+</span>
<span class="gi">+        #Fault we will induce, for testing purposes</span>
<span class="w"> </span>        self.fault = None
<span class="gd">-        self._user_record_limit = 16384</span>
<span class="gi">+</span>
<span class="gi">+        # Temporarily limit the size of outgoing records to following size</span>
<span class="gi">+        self._user_record_limit = 16384  # 2**14</span>
<span class="gi">+</span>
<span class="gi">+        # NewSessionTickets received from server</span>
<span class="w"> </span>        self.tickets = []
<span class="gi">+        # TLS 1.2 and earlier tickets received from server</span>
<span class="w"> </span>        self.tls_1_0_tickets = []
<span class="gi">+</span>
<span class="gi">+        # Indicator for heartbeat extension mode, if we can receive</span>
<span class="gi">+        # heartbeat requests</span>
<span class="w"> </span>        self.heartbeat_can_receive = False
<span class="gi">+</span>
<span class="gi">+        # Indicator for heartbeat extension mode, if we can send</span>
<span class="gi">+        # heartbeat requests</span>
<span class="w"> </span>        self.heartbeat_can_send = False
<span class="gi">+</span>
<span class="gi">+        # Indicator, that both sides want use heartbeat extension</span>
<span class="w"> </span>        self.heartbeat_supported = False
<span class="gi">+</span>
<span class="gi">+        # Callback function for handling responses to heartbeat requests</span>
<span class="gi">+        # we sent</span>
<span class="w"> </span>        self.heartbeat_response_callback = None
<span class="gi">+</span>
<span class="w"> </span>        self._buffer_content_type = None
<span class="w"> </span>        self._buffer = bytearray()
<span class="gi">+</span>
<span class="gi">+        # tuple with list of certificates and the private key that will be</span>
<span class="gi">+        # used for post handshake authentication in TLS 1.3</span>
<span class="w"> </span>        self._client_keypair = None
<span class="gi">+</span>
<span class="gi">+        # dictionary with CertificateRequest messages we (as a server) have</span>
<span class="gi">+        # sent, the keys are the &quot;certificate request context&quot; from the</span>
<span class="gi">+        # messages (which are the values)</span>
<span class="w"> </span>        self._cert_requests = {}
<span class="gi">+</span>
<span class="gi">+        # boolean to control if PHA needs to be aborted when the client</span>
<span class="gi">+        # doesn&#39;t provide a certificate</span>
<span class="w"> </span>        self.client_cert_required = False
<span class="gi">+</span>
<span class="gi">+        # boolean to control if ChangeCipherSpec in TLS1.3 is allowed or not</span>
<span class="gi">+        # we start with True, as peers MUST always processe the messages</span>
<span class="gi">+        # before the handshake is done, only then we disable it (for PHA)</span>
<span class="w"> </span>        self._middlebox_compat_mode = True

<span class="w"> </span>    @property
<span class="w"> </span>    def _send_record_limit(self):
<span class="w"> </span>        &quot;&quot;&quot;Maximum size of payload that can be sent.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._recordLayer.send_record_limit</span>

<span class="w"> </span>    @_send_record_limit.setter
<span class="w"> </span>    def _send_record_limit(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Maximum size of payload that can be sent.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._recordLayer.send_record_limit = value</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _recv_record_limit(self):
<span class="w"> </span>        &quot;&quot;&quot;Maximum size of payload that can be received.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._recordLayer.recv_record_limit</span>

<span class="w"> </span>    @_recv_record_limit.setter
<span class="w"> </span>    def _recv_record_limit(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Maximum size of payload that can be received.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._recordLayer.recv_record_limit = value</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def recordSize(self):
<span class="w"> </span>        &quot;&quot;&quot;Maximum size of the records that will be sent out.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return min(self._user_record_limit, self._send_record_limit)</span>

<span class="w"> </span>    @recordSize.setter
<span class="w"> </span>    def recordSize(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Size to automatically fragment records to.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._user_record_limit = value</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _client(self):
<span class="w"> </span>        &quot;&quot;&quot;Boolean stating if the endpoint acts as a client&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._recordLayer.client</span>

<span class="w"> </span>    @_client.setter
<span class="w"> </span>    def _client(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Set the endpoint to act as a client or not&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._recordLayer.client = value</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def version(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the SSL protocol version of connection&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._recordLayer.version</span>

<span class="w"> </span>    @version.setter
<span class="w"> </span>    def version(self, value):
<span class="gu">@@ -196,12 +263,25 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>        Don&#39;t use it! See at HandshakeSettings for options to set desired
<span class="w"> </span>        protocol version.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._recordLayer.version = value</span>
<span class="gi">+        if value &gt; (3, 3):</span>
<span class="gi">+            self._recordLayer.tls13record = True</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def encryptThenMAC(self):
<span class="w"> </span>        &quot;&quot;&quot;Whether the connection uses Encrypt Then MAC (RFC 7366)&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._recordLayer.encryptThenMAC</span>
<span class="gi">+</span>
<span class="gi">+    def clearReadBuffer(self):</span>
<span class="gi">+        self._readBuffer = b&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def clearWriteBuffer(self):</span>
<span class="gi">+        self._send_writer = None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    #*********************************************************</span>
<span class="gi">+    # Public Functions START</span>
<span class="gi">+    #*********************************************************</span>

<span class="w"> </span>    def read(self, max=None, min=1):
<span class="w"> </span>        &quot;&quot;&quot;Read some data from the TLS connection.
<span class="gu">@@ -228,7 +308,9 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>            without a preceding alert.
<span class="w"> </span>        :raises tlslite.errors.TLSAlert: If a TLS alert is signalled.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for result in self.readAsync(max, min):</span>
<span class="gi">+            pass</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def readAsync(self, max=None, min=1):
<span class="w"> </span>        &quot;&quot;&quot;Start a read operation on the TLS connection.
<span class="gu">@@ -242,7 +324,79 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>        :rtype: iterable
<span class="w"> </span>        :returns: A generator; see above for details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        constructor_type = None</span>
<span class="gi">+        if self.version &gt; (3, 3):</span>
<span class="gi">+            allowedTypes = (ContentType.application_data,</span>
<span class="gi">+                            ContentType.handshake)</span>
<span class="gi">+            if self._client_keypair:</span>
<span class="gi">+                allowedHsTypes = (HandshakeType.new_session_ticket,</span>
<span class="gi">+                                  HandshakeType.key_update,</span>
<span class="gi">+                                  HandshakeType.certificate_request)</span>
<span class="gi">+            elif self._cert_requests:</span>
<span class="gi">+                allowedHsTypes = (HandshakeType.new_session_ticket,</span>
<span class="gi">+                                  HandshakeType.key_update,</span>
<span class="gi">+                                  HandshakeType.certificate)</span>
<span class="gi">+                constructor_type = CertificateType.x509</span>
<span class="gi">+            else:</span>
<span class="gi">+                allowedHsTypes = (HandshakeType.new_session_ticket,</span>
<span class="gi">+                                  HandshakeType.key_update)</span>
<span class="gi">+        else:</span>
<span class="gi">+            allowedTypes = ContentType.application_data</span>
<span class="gi">+            allowedHsTypes = None</span>
<span class="gi">+        try:</span>
<span class="gi">+            try_once = True</span>
<span class="gi">+            # perform a read even if we were asked to read 0 bytes, but only</span>
<span class="gi">+            # if the buffer is empty; this is used to trigger</span>
<span class="gi">+            # processing of NST, KeyUpdate and PHA</span>
<span class="gi">+            while (len(self._readBuffer) &lt; min or</span>
<span class="gi">+                    (not self._readBuffer and try_once)) \</span>
<span class="gi">+                    and not self.closed:</span>
<span class="gi">+                try_once = False</span>
<span class="gi">+                try:</span>
<span class="gi">+                    for result in self._getMsg(allowedTypes,</span>
<span class="gi">+                                               allowedHsTypes,</span>
<span class="gi">+                                               constructor_type):</span>
<span class="gi">+                        if result in (0, 1):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                    if isinstance(result, NewSessionTicket):</span>
<span class="gi">+                        result.time = time.time()</span>
<span class="gi">+                        self.tickets.append(result)</span>
<span class="gi">+                    elif isinstance(result, KeyUpdate):</span>
<span class="gi">+                        for result in self._handle_keyupdate_request(result):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                        # KeyUpdate messages are not solicited, while call with</span>
<span class="gi">+                        # min==0 are done to perform PHA</span>
<span class="gi">+                        try_once = True</span>
<span class="gi">+                    elif isinstance(result, Certificate):</span>
<span class="gi">+                        for result in self._handle_srv_pha(result):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                    elif isinstance(result, CertificateRequest):</span>
<span class="gi">+                        for result in self._handle_pha(result):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        assert isinstance(result, ApplicationData)</span>
<span class="gi">+                        applicationData = result</span>
<span class="gi">+                        self._readBuffer += applicationData.write()</span>
<span class="gi">+                except TLSRemoteAlert as alert:</span>
<span class="gi">+                    if alert.description != AlertDescription.close_notify:</span>
<span class="gi">+                        raise</span>
<span class="gi">+                except TLSAbruptCloseError:</span>
<span class="gi">+                    if not self.ignoreAbruptClose:</span>
<span class="gi">+                        raise</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self._shutdown(True)</span>
<span class="gi">+</span>
<span class="gi">+            if max == None:</span>
<span class="gi">+                max = len(self._readBuffer)</span>
<span class="gi">+</span>
<span class="gi">+            returnBytes = self._readBuffer[:max]</span>
<span class="gi">+            self._readBuffer = self._readBuffer[max:]</span>
<span class="gi">+            yield bytes(returnBytes)</span>
<span class="gi">+        except GeneratorExit:</span>
<span class="gi">+            raise</span>
<span class="gi">+        except:</span>
<span class="gi">+            self._shutdown(False)</span>
<span class="gi">+            raise</span>

<span class="w"> </span>    def unread(self, b):
<span class="w"> </span>        &quot;&quot;&quot;Add bytes to the front of the socket read buffer for future
<span class="gu">@@ -250,7 +404,7 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>        unread the last data from a socket, that won&#39;t wake up selected waiters,
<span class="w"> </span>        and those waiters may hang forever.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._readBuffer = b + self._readBuffer</span>

<span class="w"> </span>    def write(self, s):
<span class="w"> </span>        &quot;&quot;&quot;Write some data to the TLS connection.
<span class="gu">@@ -265,7 +419,8 @@ class TLSRecordLayer(object):</span>

<span class="w"> </span>        :raises socket.error: If a socket error occurs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for result in self.writeAsync(s):</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    def writeAsync(self, s):
<span class="w"> </span>        &quot;&quot;&quot;Start a write operation on the TLS connection.
<span class="gu">@@ -278,7 +433,21 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>        :rtype: iterable
<span class="w"> </span>        :returns: A generator; see above for details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.closed:</span>
<span class="gi">+                raise TLSClosedConnectionError(&quot;attempt to write to closed connection&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            applicationData = ApplicationData().create(bytearray(s))</span>
<span class="gi">+            for result in self._sendMsg(applicationData, \</span>
<span class="gi">+                                        randomizeFirstBlock=True):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except GeneratorExit:</span>
<span class="gi">+            raise</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # Don&#39;t invalidate the session on write failure if abrupt closes are</span>
<span class="gi">+            # okay.</span>
<span class="gi">+            self._shutdown(self.ignoreAbruptClose)</span>
<span class="gi">+            raise</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Close the TLS connection.
<span class="gu">@@ -301,7 +470,11 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>            without a preceding alert.
<span class="w"> </span>        :raises tlslite.errors.TLSAlert: If a TLS alert is signalled.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.closed:</span>
<span class="gi">+            for result in self._decrefAsync():</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+    # Python 3 callback</span>
<span class="w"> </span>    _decref_socketios = close

<span class="w"> </span>    def closeAsync(self):
<span class="gu">@@ -316,7 +489,44 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>        :rtype: iterable
<span class="w"> </span>        :returns: A generator; see above for details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.closed:</span>
<span class="gi">+            for result in self._decrefAsync():</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+    def _decrefAsync(self):</span>
<span class="gi">+        self._refCount -= 1</span>
<span class="gi">+        if self._refCount == 0 and not self.closed:</span>
<span class="gi">+            try:</span>
<span class="gi">+                for result in self._sendMsg(Alert().create(\</span>
<span class="gi">+                        AlertDescription.close_notify, AlertLevel.warning)):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                alert = None</span>
<span class="gi">+                # By default close the socket, since it&#39;s been observed</span>
<span class="gi">+                # that some other libraries will not respond to the </span>
<span class="gi">+                # close_notify alert, thus leaving us hanging if we&#39;re</span>
<span class="gi">+                # expecting it</span>
<span class="gi">+                if self.closeSocket:</span>
<span class="gi">+                    self._shutdown(True)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    while not alert:</span>
<span class="gi">+                        for result in self._getMsg((ContentType.alert, \</span>
<span class="gi">+                                                  ContentType.application_data)):</span>
<span class="gi">+                            if result in (0,1):</span>
<span class="gi">+                                yield result</span>
<span class="gi">+                        if result.contentType == ContentType.alert:</span>
<span class="gi">+                            alert = result</span>
<span class="gi">+                    if alert.description == AlertDescription.close_notify:</span>
<span class="gi">+                        self._shutdown(True)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise TLSRemoteAlert(alert)</span>
<span class="gi">+            except (socket.error, TLSAbruptCloseError):</span>
<span class="gi">+                #If the other side closes the socket, that&#39;s okay</span>
<span class="gi">+                self._shutdown(True)</span>
<span class="gi">+            except GeneratorExit:</span>
<span class="gi">+                raise</span>
<span class="gi">+            except:</span>
<span class="gi">+                self._shutdown(False)</span>
<span class="gi">+                raise</span>

<span class="w"> </span>    def getVersionName(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the name of this TLS version.
<span class="gu">@@ -326,7 +536,12 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>            Either None, &#39;SSL 3.0&#39;, &#39;TLS 1.0&#39;, &#39;TLS 1.1&#39;, &#39;TLS 1.2&#39; or
<span class="w"> </span>            &#39;TLS 1.3&#39;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ver = {(3, 0): &quot;SSL 3.0&quot;,</span>
<span class="gi">+               (3, 1): &quot;TLS 1.0&quot;,</span>
<span class="gi">+               (3, 2): &quot;TLS 1.1&quot;,</span>
<span class="gi">+               (3, 3): &quot;TLS 1.2&quot;,</span>
<span class="gi">+               (3, 4): &quot;TLS 1.3&quot;}</span>
<span class="gi">+        return ver.get(self.version)</span>

<span class="w"> </span>    def getCipherName(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the name of the cipher used with this connection.
<span class="gu">@@ -335,7 +550,7 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>        :returns: The name of the cipher used with this connection.
<span class="w"> </span>            Either &#39;aes128&#39;, &#39;aes256&#39;, &#39;rc4&#39;, or &#39;3des&#39;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._recordLayer.getCipherName()</span>

<span class="w"> </span>    def getCipherImplementation(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the name of the cipher implementation used with
<span class="gu">@@ -345,21 +560,23 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>        :returns: The name of the cipher implementation used with
<span class="w"> </span>            this connection.  Either &#39;python&#39;, &#39;openssl&#39;, or &#39;pycrypto&#39;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._recordLayer.getCipherImplementation()</span>

<span class="gi">+    #Emulate a socket, somewhat -</span>
<span class="w"> </span>    def send(self, s):
<span class="w"> </span>        &quot;&quot;&quot;Send data to the TLS connection (socket emulation).

<span class="w"> </span>        :raises socket.error: If a socket error occurs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write(s)</span>
<span class="gi">+        return len(s)</span>

<span class="w"> </span>    def sendall(self, s):
<span class="w"> </span>        &quot;&quot;&quot;Send data to the TLS connection (socket emulation).

<span class="w"> </span>        :raises socket.error: If a socket error occurs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write(s)</span>

<span class="w"> </span>    def recv(self, bufsize):
<span class="w"> </span>        &quot;&quot;&quot;Get some data from the TLS connection (socket emulation).
<span class="gu">@@ -369,72 +586,815 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>            without a preceding alert.
<span class="w"> </span>        :raises tlslite.errors.TLSAlert: If a TLS alert is signalled.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.read(bufsize)</span>

<span class="gi">+    def recv_into(self, b):</span>
<span class="gi">+        # XXX doc string</span>
<span class="gi">+        data = self.read(len(b))</span>
<span class="gi">+        if not data:</span>
<span class="gi">+            return None</span>
<span class="gi">+        b[:len(data)] = data</span>
<span class="gi">+        return len(data)</span>
<span class="gi">+</span>
<span class="gi">+    # while the SocketIO and _fileobject in socket is private we really need</span>
<span class="gi">+    # to use it as it&#39;s what the real socket does internally</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable=no-member,protected-access</span>
<span class="w"> </span>    def makefile(self, mode=&#39;r&#39;, bufsize=-1):
<span class="w"> </span>        &quot;&quot;&quot;Create a file object for the TLS connection (socket emulation).

<span class="w"> </span>        :rtype: socket._fileobject
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._refCount += 1</span>
<span class="gi">+        # So, it is pretty fragile to be using Python internal objects</span>
<span class="gi">+        # like this, but it is probably the best/easiest way to provide</span>
<span class="gi">+        # matching behavior for socket emulation purposes.  The &#39;close&#39;</span>
<span class="gi">+        # argument is nice, its apparently a recent addition to this</span>
<span class="gi">+        # class, so that when fileobject.close() gets called, it will</span>
<span class="gi">+        # close() us, causing the refcount to be decremented (decrefAsync).</span>
<span class="gi">+        #</span>
<span class="gi">+        # If this is the last close() on the outstanding fileobjects / </span>
<span class="gi">+        # TLSConnection, then the &quot;actual&quot; close alerts will be sent,</span>
<span class="gi">+        # socket closed, etc.</span>
<span class="gi">+</span>
<span class="gi">+        # for writes, we MUST buffer otherwise the lengths of headers leak</span>
<span class="gi">+        # through record layer boundaries</span>
<span class="gi">+        if &#39;w&#39; in mode and bufsize &lt;= 0:</span>
<span class="gi">+            bufsize = 2**14</span>
<span class="gi">+</span>
<span class="gi">+        if sys.version_info &lt; (3,):</span>
<span class="gi">+            return socket._fileobject(self, mode, bufsize, close=True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if &#39;w&#39; in mode:</span>
<span class="gi">+                return io.BufferedWriter(socket.SocketIO(self, mode), bufsize)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return socket.SocketIO(self, mode)</span>
<span class="gi">+    # pylint: enable=no-member,protected-access</span>

<span class="w"> </span>    def getsockname(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the socket&#39;s own address (socket emulation).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sock.getsockname()</span>

<span class="w"> </span>    def getpeername(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the remote address to which the socket is connected
<span class="w"> </span>        (socket emulation).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sock.getpeername()</span>

<span class="w"> </span>    def settimeout(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Set a timeout on blocking socket operations (socket emulation).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sock.settimeout(value)</span>

<span class="w"> </span>    def gettimeout(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the timeout associated with socket operations (socket
<span class="w"> </span>        emulation).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sock.gettimeout()</span>

<span class="w"> </span>    def setsockopt(self, level, optname, value):
<span class="w"> </span>        &quot;&quot;&quot;Set the value of the given socket option (socket emulation).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sock.setsockopt(level, optname, value)</span>

<span class="w"> </span>    def shutdown(self, how):
<span class="w"> </span>        &quot;&quot;&quot;Shutdown the underlying socket.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        return self.sock.shutdown(how)</span>
<span class="gi">+       </span>
<span class="w"> </span>    def fileno(self):
<span class="w"> </span>        &quot;&quot;&quot;Not implement in TLS Lite.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+       </span>
<span class="gi">+</span>
<span class="gi">+     #*********************************************************</span>
<span class="gi">+     # Public Functions END</span>
<span class="gi">+     #*********************************************************</span>
<span class="gi">+</span>
<span class="gi">+    def _handle_pha(self, cert_request):</span>
<span class="gi">+        cert, p_key = self._client_keypair</span>
<span class="gi">+</span>
<span class="gi">+        handshake_context = self._first_handshake_hashes.copy()</span>
<span class="gi">+        handshake_context.update(cert_request.write())</span>
<span class="gi">+</span>
<span class="gi">+        prf_name = &#39;sha256&#39;</span>
<span class="gi">+        prf_size = 32</span>
<span class="gi">+        if self.session.cipherSuite in CipherSuite.sha384PrfSuites:</span>
<span class="gi">+            prf_name = &#39;sha384&#39;</span>
<span class="gi">+            prf_size = 48</span>
<span class="gi">+</span>
<span class="gi">+        msgs = []</span>
<span class="gi">+        msgs.append(Certificate(CertificateType.x509, self.version)</span>
<span class="gi">+                    .create(cert, cert_request.certificate_request_context))</span>
<span class="gi">+        handshake_context.update(msgs[0].write())</span>
<span class="gi">+        if cert.x509List and p_key:</span>
<span class="gi">+            # sign the CertificateVerify only when we have a private key to do</span>
<span class="gi">+            # that</span>
<span class="gi">+            valid_sig_algs = cert_request.supported_signature_algs</span>
<span class="gi">+            if not valid_sig_algs:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.missing_extension,</span>
<span class="gi">+                        &quot;No signature algorithms found in CertificateRequest&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            avail_sig_algs = self._sigHashesToList(HandshakeSettings(), p_key,</span>
<span class="gi">+                                                   cert, version=(3, 4))</span>
<span class="gi">+            sig_scheme = getFirstMatching(avail_sig_algs, valid_sig_algs)</span>
<span class="gi">+            scheme = SignatureScheme.toRepr(sig_scheme)</span>
<span class="gi">+            sig_scheme = getattr(SignatureScheme, scheme)</span>
<span class="gi">+</span>
<span class="gi">+            signature_context = \</span>
<span class="gi">+                KeyExchange.calcVerifyBytes((3, 4),</span>
<span class="gi">+                                            handshake_context,</span>
<span class="gi">+                                            sig_scheme, None, None, None,</span>
<span class="gi">+                                            prf_name, b&#39;client&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if sig_scheme in (SignatureScheme.ed25519, SignatureScheme.ed448):</span>
<span class="gi">+                pad_type = None</span>
<span class="gi">+                hash_name = &quot;intrinsic&quot;</span>
<span class="gi">+                salt_len = None</span>
<span class="gi">+                sig_func = p_key.hashAndSign</span>
<span class="gi">+                ver_func = p_key.hashAndVerify</span>
<span class="gi">+            elif sig_scheme[1] == SignatureAlgorithm.ecdsa:</span>
<span class="gi">+                pad_type = None</span>
<span class="gi">+                hash_name = HashAlgorithm.toRepr(sig_scheme[0])</span>
<span class="gi">+                salt_len = None</span>
<span class="gi">+                sig_func = p_key.sign</span>
<span class="gi">+                ver_func = p_key.verify</span>
<span class="gi">+            else:</span>
<span class="gi">+                pad_type = SignatureScheme.getPadding(scheme)</span>
<span class="gi">+                hash_name = SignatureScheme.getHash(scheme)</span>
<span class="gi">+                salt_len = getattr(hashlib, hash_name)().digest_size</span>
<span class="gi">+                sig_func = p_key.sign</span>
<span class="gi">+                ver_func = p_key.verify</span>
<span class="gi">+</span>
<span class="gi">+            signature = sig_func(signature_context,</span>
<span class="gi">+                                 pad_type,</span>
<span class="gi">+                                 hash_name,</span>
<span class="gi">+                                 salt_len)</span>
<span class="gi">+            if not ver_func(signature, signature_context,</span>
<span class="gi">+                            pad_type,</span>
<span class="gi">+                            hash_name,</span>
<span class="gi">+                            salt_len):</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.internal_error,</span>
<span class="gi">+                        &quot;Certificate Verify signature failed&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            certificate_verify = CertificateVerify(self.version)</span>
<span class="gi">+            certificate_verify.create(signature, sig_scheme)</span>
<span class="gi">+</span>
<span class="gi">+            msgs.append(certificate_verify)</span>
<span class="gi">+            handshake_context.update(certificate_verify.write())</span>
<span class="gi">+</span>
<span class="gi">+        finished_key = HKDF_expand_label(self.session.cl_app_secret,</span>
<span class="gi">+                                         b&quot;finished&quot;, b&quot;&quot;,</span>
<span class="gi">+                                         prf_size, prf_name)</span>
<span class="gi">+        verify_data = secureHMAC(finished_key,</span>
<span class="gi">+                                 handshake_context.digest(prf_name),</span>
<span class="gi">+                                 prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        finished = Finished((3, 4), prf_size)</span>
<span class="gi">+        finished.create(verify_data)</span>
<span class="gi">+        msgs.append(finished)</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._sendMsgs(msgs):</span>
<span class="gi">+            yield result</span>

<span class="w"> </span>    def _handle_srv_pha(self, cert):
<span class="w"> </span>        &quot;&quot;&quot;Process the post-handshake authentication from client.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prf_name = &#39;sha256&#39;</span>
<span class="gi">+        prf_size = 32</span>
<span class="gi">+        if self.session.cipherSuite in CipherSuite.sha384PrfSuites:</span>
<span class="gi">+            prf_name = &#39;sha384&#39;</span>
<span class="gi">+            prf_size = 48</span>
<span class="gi">+</span>
<span class="gi">+        cr_context = cert.certificate_request_context</span>
<span class="gi">+        if not cr_context:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.illegal_parameter,</span>
<span class="gi">+                    &quot;Certificate Request context missing in Certificate &quot;</span>
<span class="gi">+                    &quot;message from client&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            cr = self._cert_requests.pop(bytes(cr_context))</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.illegal_parameter,</span>
<span class="gi">+                    &quot;Certificiate Request context is incorrect or was already &quot;</span>
<span class="gi">+                    &quot;handled previously&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        # TODO: verify that the extensions used by client were sent by us in</span>
<span class="gi">+        # CertificateReuest</span>
<span class="gi">+</span>
<span class="gi">+        handshake_context = self._first_handshake_hashes.copy()</span>
<span class="gi">+        handshake_context.update(cr.write())</span>
<span class="gi">+        handshake_context.update(cert.write())</span>
<span class="gi">+</span>
<span class="gi">+        if cert.cert_chain:</span>
<span class="gi">+            for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                       HandshakeType.certificate_verify):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+            assert isinstance(result, CertificateVerify)</span>
<span class="gi">+            cert_verify = result</span>
<span class="gi">+</span>
<span class="gi">+            valid_sig_algs = cr.supported_signature_algs</span>
<span class="gi">+            if cert_verify.signatureAlgorithm not in valid_sig_algs:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Client selected signature algorithm we didn&#39;t &quot;</span>
<span class="gi">+                        &quot;advertise&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            avail_sig_algs = self._sigHashesToList(HandshakeSettings(), None,</span>
<span class="gi">+                                                   cert.cert_chain,</span>
<span class="gi">+                                                   version=(3, 4))</span>
<span class="gi">+            if cert_verify.signatureAlgorithm not in avail_sig_algs:</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.illegal_parameter,</span>
<span class="gi">+                        &quot;Client selected signature algorithm not consistent &quot;</span>
<span class="gi">+                        &quot;with public key in its certificate&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            scheme = SignatureScheme.toRepr(cert_verify.signatureAlgorithm)</span>
<span class="gi">+            sig_scheme = getattr(SignatureScheme, scheme)</span>
<span class="gi">+</span>
<span class="gi">+            signature_context = \</span>
<span class="gi">+                KeyExchange.calcVerifyBytes((3, 4),</span>
<span class="gi">+                                            handshake_context,</span>
<span class="gi">+                                            sig_scheme, None, None, None,</span>
<span class="gi">+                                            prf_name, b&#39;client&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if sig_scheme in (SignatureScheme.ed25519, SignatureScheme.ed448):</span>
<span class="gi">+                pad_type = None</span>
<span class="gi">+                hash_name = &quot;intrinsic&quot;</span>
<span class="gi">+                salt_len = None</span>
<span class="gi">+                ver_func = cert.cert_chain.getEndEntityPublicKey().hashAndVerify</span>
<span class="gi">+            elif sig_scheme[1] == SignatureAlgorithm.ecdsa:</span>
<span class="gi">+                pad_type = None</span>
<span class="gi">+                hash_name = HashAlgorithm.toRepr(sig_scheme[0])</span>
<span class="gi">+                salt_len = None</span>
<span class="gi">+                ver_func = cert.cert_chain.getEndEntityPublicKey().verify</span>
<span class="gi">+            else:</span>
<span class="gi">+                pad_type = SignatureScheme.getPadding(scheme)</span>
<span class="gi">+                hash_name = SignatureScheme.getHash(scheme)</span>
<span class="gi">+                salt_len = getattr(hashlib, hash_name)().digest_size</span>
<span class="gi">+                ver_func = cert.cert_chain.getEndEntityPublicKey().verify</span>
<span class="gi">+</span>
<span class="gi">+            if not ver_func(</span>
<span class="gi">+                    cert_verify.signature, signature_context, pad_type,</span>
<span class="gi">+                    hash_name, salt_len):</span>
<span class="gi">+                for result in self._sendError(</span>
<span class="gi">+                        AlertDescription.decrypt_error,</span>
<span class="gi">+                        &quot;Signature verification failed&quot;):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+            handshake_context.update(cert_verify.write())</span>
<span class="gi">+        elif self.client_cert_required:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.certificate_required,</span>
<span class="gi">+                    &quot;Client did not provide a certificate in post-handshake &quot;</span>
<span class="gi">+                    &quot;authentication&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        finished_key = HKDF_expand_label(self.session.cl_app_secret,</span>
<span class="gi">+                                         b&#39;finished&#39;, b&#39;&#39;,</span>
<span class="gi">+                                         prf_size, prf_name)</span>
<span class="gi">+        verify_data = secureHMAC(finished_key,</span>
<span class="gi">+                                 handshake_context.digest(prf_name),</span>
<span class="gi">+                                 prf_name)</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._getMsg(ContentType.handshake,</span>
<span class="gi">+                                   HandshakeType.finished,</span>
<span class="gi">+                                   prf_size):</span>
<span class="gi">+            if result in (0, 1):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        assert isinstance(result, Finished)</span>
<span class="gi">+</span>
<span class="gi">+        finished = result</span>
<span class="gi">+</span>
<span class="gi">+        if finished.verify_data != verify_data:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.decrypt_error,</span>
<span class="gi">+                    &quot;Invalid Finished verify_data from client&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        self.session.clientCertChain = cert.cert_chain</span>
<span class="gi">+</span>
<span class="gi">+    def _shutdown(self, resumable):</span>
<span class="gi">+        self._recordLayer.shutdown()</span>
<span class="gi">+        self.version = (0,0)</span>
<span class="gi">+        self.closed = True</span>
<span class="gi">+        if self.closeSocket:</span>
<span class="gi">+            self.sock.close()</span>
<span class="gi">+</span>
<span class="gi">+        #Even if resumable is False, we&#39;ll never toggle this on</span>
<span class="gi">+        if not resumable and self.session:</span>
<span class="gi">+            self.session.resumable = False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def _sendError(self, alertDescription, errorStr=None):</span>
<span class="gi">+        # make sure that the message goes out</span>
<span class="gi">+        self.sock.flush()</span>
<span class="gi">+        self.sock.buffer_writes = False</span>
<span class="gi">+        alert = Alert().create(alertDescription, AlertLevel.fatal)</span>
<span class="gi">+        for result in self._sendMsg(alert):</span>
<span class="gi">+            yield result</span>
<span class="gi">+        self._shutdown(False)</span>
<span class="gi">+        raise TLSLocalAlert(alert, errorStr)</span>
<span class="gi">+</span>
<span class="gi">+    def _sendMsgs(self, msgs):</span>
<span class="gi">+        # send messages together in a single TCP write</span>
<span class="gi">+        self.sock.buffer_writes = True</span>
<span class="gi">+        randomizeFirstBlock = True</span>
<span class="gi">+        for msg in msgs:</span>
<span class="gi">+            for result in self._sendMsg(msg, randomizeFirstBlock):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            randomizeFirstBlock = True</span>
<span class="gi">+        self.sock.flush()</span>
<span class="gi">+        self.sock.buffer_writes = False</span>

<span class="w"> </span>    def _sendMsg(self, msg, randomizeFirstBlock=True, update_hashes=True):
<span class="w"> </span>        &quot;&quot;&quot;Fragment and send message through socket&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        #Whenever we&#39;re connected and asked to send an app data message,</span>
<span class="gi">+        #we first send the first byte of the message.  This prevents</span>
<span class="gi">+        #an attacker from launching a chosen-plaintext attack based on</span>
<span class="gi">+        #knowing the next IV (a la BEAST).</span>
<span class="gi">+        if randomizeFirstBlock and self.version &lt;= (3, 1) \</span>
<span class="gi">+                and self._recordLayer.isCBCMode() \</span>
<span class="gi">+                and msg.contentType == ContentType.application_data:</span>
<span class="gi">+            msgFirstByte = msg.splitFirstByte()</span>
<span class="gi">+            for result in self._sendMsgThroughSocket(msgFirstByte):</span>
<span class="gi">+                yield result</span>
<span class="gi">+            if len(msg.write()) == 0:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        buf = msg.write()</span>
<span class="gi">+        contentType = msg.contentType</span>
<span class="gi">+        #Update handshake hashes</span>
<span class="gi">+        if update_hashes and contentType == ContentType.handshake:</span>
<span class="gi">+            self._handshake_hash.update(buf)</span>
<span class="gi">+</span>
<span class="gi">+        #Fragment big messages</span>
<span class="gi">+        while len(buf) &gt; self.recordSize:</span>
<span class="gi">+            newB = buf[:self.recordSize]</span>
<span class="gi">+            buf = buf[self.recordSize:]</span>
<span class="gi">+</span>
<span class="gi">+            msgFragment = Message(contentType, newB)</span>
<span class="gi">+            for result in self._sendMsgThroughSocket(msgFragment):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        msgFragment = Message(contentType, buf)</span>
<span class="gi">+        for result in self._sendMsgThroughSocket(msgFragment):</span>
<span class="gi">+            yield result</span>

<span class="w"> </span>    def _queue_message(self, msg):
<span class="w"> </span>        &quot;&quot;&quot;Just queue message for sending, for record layer coalescing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._buffer_content_type is not None and \</span>
<span class="gi">+                self._buffer_content_type != msg.contentType:</span>
<span class="gi">+            raise ValueError(&quot;Queuing of wrong message types&quot;)</span>
<span class="gi">+        if self._buffer_content_type is None:</span>
<span class="gi">+            self._buffer_content_type = msg.contentType</span>
<span class="gi">+</span>
<span class="gi">+        serialised_msg = msg.write()</span>
<span class="gi">+        self._buffer += serialised_msg</span>
<span class="gi">+        if msg.contentType == ContentType.handshake:</span>
<span class="gi">+            self._handshake_hash.update(serialised_msg)</span>

<span class="w"> </span>    def _queue_flush(self):
<span class="w"> </span>        &quot;&quot;&quot;Send the queued messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        msg = Message(self._buffer_content_type, self._buffer)</span>
<span class="gi">+        for result in self._sendMsg(msg, update_hashes=False):</span>
<span class="gi">+            yield result</span>
<span class="gi">+        self._buffer_content_type = None</span>
<span class="gi">+        self._buffer = bytearray()</span>

<span class="w"> </span>    def _sendMsgThroughSocket(self, msg):
<span class="w"> </span>        &quot;&quot;&quot;Send message, handle errors&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gi">+        try:</span>
<span class="gi">+            for result in self._recordLayer.sendRecord(msg):</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+        except socket.error:</span>
<span class="gi">+            # The socket was unexpectedly closed.  The tricky part</span>
<span class="gi">+            # is that there may be an alert sent by the other party</span>
<span class="gi">+            # sitting in the read buffer.  So, if we get here after</span>
<span class="gi">+            # handshaking, we will just raise the error and let the</span>
<span class="gi">+            # caller read more data if it would like, thus stumbling</span>
<span class="gi">+            # upon the error.</span>
<span class="gi">+            #</span>
<span class="gi">+            # However, if we get here DURING handshaking, we take</span>
<span class="gi">+            # it upon ourselves to see if the next message is an</span>
<span class="gi">+            # Alert.</span>
<span class="gi">+            if msg.contentType == ContentType.handshake:</span>
<span class="gi">+</span>
<span class="gi">+                # See if there&#39;s an alert record</span>
<span class="gi">+                # Could raise socket.error or TLSAbruptCloseError</span>
<span class="gi">+                for result in self._getNextRecord():</span>
<span class="gi">+                    if result in (0, 1):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+                # Closes the socket</span>
<span class="gi">+                self._shutdown(False)</span>
<span class="gi">+</span>
<span class="gi">+                # If we got an alert, raise it</span>
<span class="gi">+                recordHeader, p = result</span>
<span class="gi">+                if recordHeader.type == ContentType.alert:</span>
<span class="gi">+                    alert = Alert().parse(p)</span>
<span class="gi">+                    raise TLSRemoteAlert(alert)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # If we got some other message who know what</span>
<span class="gi">+                # the remote side is doing, just go ahead and</span>
<span class="gi">+                # raise the socket.error</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+    def _getMsg(self, expectedType, secondaryType=None, constructorType=None):</span>
<span class="gi">+        try:</span>
<span class="gi">+            if not isinstance(expectedType, tuple):</span>
<span class="gi">+                expectedType = (expectedType,)</span>
<span class="gi">+</span>
<span class="gi">+            #Spin in a loop, until we&#39;ve got a non-empty record of a type we</span>
<span class="gi">+            #expect.  The loop will be repeated if:</span>
<span class="gi">+            #  - we receive a renegotiation attempt; we send no_renegotiation,</span>
<span class="gi">+            #    then try again</span>
<span class="gi">+            #  - we receive an empty application-data fragment; we try again</span>
<span class="gi">+            while 1:</span>
<span class="gi">+                for result in self._getNextRecord():</span>
<span class="gi">+                    if result in (0,1):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        break</span>
<span class="gi">+                recordHeader, p = result</span>
<span class="gi">+</span>
<span class="gi">+                # if this is a CCS message in TLS 1.3, sanity check and</span>
<span class="gi">+                # continue</span>
<span class="gi">+                if self.version &gt; (3, 3) and \</span>
<span class="gi">+                        ContentType.handshake in expectedType and \</span>
<span class="gi">+                        self._middlebox_compat_mode and \</span>
<span class="gi">+                        recordHeader.type == ContentType.change_cipher_spec:</span>
<span class="gi">+                    ccs = ChangeCipherSpec().parse(p)</span>
<span class="gi">+                    if ccs.type != 1:</span>
<span class="gi">+                        for result in self._sendError(</span>
<span class="gi">+                                AlertDescription.unexpected_message,</span>
<span class="gi">+                                &quot;Invalid CCS message received&quot;):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                    # ignore the message</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # TLS 1.3 Handshake messages MUST NOT be interleaved with</span>
<span class="gi">+                # other messages, Section 5.1 RFC 8446</span>
<span class="gi">+                if self.version &gt; (3, 3) and \</span>
<span class="gi">+                        recordHeader.type != ContentType.handshake and \</span>
<span class="gi">+                        self._defragmenter.buffers[ContentType.handshake]:</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.unexpected_message,</span>
<span class="gi">+                            &quot;Interleaved Handshake and &quot;</span>
<span class="gi">+                            &quot;non-handshake messages&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                #If we received an unexpected record type...</span>
<span class="gi">+                if recordHeader.type not in expectedType:</span>
<span class="gi">+</span>
<span class="gi">+                    #If we received an alert...</span>
<span class="gi">+                    if recordHeader.type == ContentType.alert:</span>
<span class="gi">+                        alert = Alert().parse(p)</span>
<span class="gi">+</span>
<span class="gi">+                        #We either received a fatal error, a warning, or a</span>
<span class="gi">+                        #close_notify.  In any case, we&#39;re going to close the</span>
<span class="gi">+                        #connection.  In the latter two cases we respond with</span>
<span class="gi">+                        #a close_notify, but ignore any socket errors, since</span>
<span class="gi">+                        #the other side might have already closed the socket.</span>
<span class="gi">+                        if alert.level == AlertLevel.warning or \</span>
<span class="gi">+                           alert.description == AlertDescription.close_notify:</span>
<span class="gi">+</span>
<span class="gi">+                            #If the sendMsg() call fails because the socket has</span>
<span class="gi">+                            #already been closed, we will be forgiving and not</span>
<span class="gi">+                            #report the error nor invalidate the &quot;resumability&quot;</span>
<span class="gi">+                            #of the session.</span>
<span class="gi">+                            try:</span>
<span class="gi">+                                alertMsg = Alert()</span>
<span class="gi">+                                alertMsg.create(AlertDescription.close_notify,</span>
<span class="gi">+                                                AlertLevel.warning)</span>
<span class="gi">+                                for result in self._sendMsg(alertMsg):</span>
<span class="gi">+                                    yield result</span>
<span class="gi">+                            except socket.error:</span>
<span class="gi">+                                pass</span>
<span class="gi">+</span>
<span class="gi">+                            if alert.description == \</span>
<span class="gi">+                                   AlertDescription.close_notify:</span>
<span class="gi">+                                self._shutdown(True)</span>
<span class="gi">+                            elif alert.level == AlertLevel.warning:</span>
<span class="gi">+                                self._shutdown(False)</span>
<span class="gi">+</span>
<span class="gi">+                        else: #Fatal alert:</span>
<span class="gi">+                            self._shutdown(False)</span>
<span class="gi">+</span>
<span class="gi">+                        #Raise the alert as an exception</span>
<span class="gi">+                        raise TLSRemoteAlert(alert)</span>
<span class="gi">+</span>
<span class="gi">+                    #If we received a renegotiation attempt...</span>
<span class="gi">+                    if recordHeader.type == ContentType.handshake:</span>
<span class="gi">+                        subType = p.get(1)</span>
<span class="gi">+                        reneg = False</span>
<span class="gi">+                        if self._client:</span>
<span class="gi">+                            if subType == HandshakeType.hello_request:</span>
<span class="gi">+                                reneg = True</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            if subType == HandshakeType.client_hello:</span>
<span class="gi">+                                reneg = True</span>
<span class="gi">+                        # Send no_renegotiation if we&#39;re not negotiating</span>
<span class="gi">+                        # a connection now, then try again</span>
<span class="gi">+                        if reneg and self.session:</span>
<span class="gi">+                            alertMsg = Alert()</span>
<span class="gi">+                            alertMsg.create(AlertDescription.no_renegotiation,</span>
<span class="gi">+                                            AlertLevel.warning)</span>
<span class="gi">+                            for result in self._sendMsg(alertMsg):</span>
<span class="gi">+                                yield result</span>
<span class="gi">+                            continue</span>
<span class="gi">+</span>
<span class="gi">+                    # If we received a heartbeat request and heartbeat</span>
<span class="gi">+                    # extension was negotiated</span>
<span class="gi">+                    if recordHeader.type == ContentType.heartbeat and \</span>
<span class="gi">+                            self.heartbeat_supported:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            heartbeat_message = Heartbeat().parse(p)</span>
<span class="gi">+                            # If we received heartbeat request, then we</span>
<span class="gi">+                            # response with response create from request</span>
<span class="gi">+                            if heartbeat_message.message_type == \</span>
<span class="gi">+                                    HeartbeatMessageType.heartbeat_request:</span>
<span class="gi">+                                if not self.heartbeat_can_receive:</span>
<span class="gi">+                                    for result in self._sendError(</span>
<span class="gi">+                                            AlertDescription.</span>
<span class="gi">+                                            unexpected_message,</span>
<span class="gi">+                                            &quot;Received heartbeat_request to &quot;</span>
<span class="gi">+                                            &quot;peer_not_allowed_to_send mode&quot;):</span>
<span class="gi">+                                        yield result</span>
<span class="gi">+                                if len(heartbeat_message.padding) &lt; 16:</span>
<span class="gi">+                                    # per RFC, silently ignore if the message</span>
<span class="gi">+                                    # is malformed</span>
<span class="gi">+                                    continue</span>
<span class="gi">+                                heartbeat_response = heartbeat_message.\</span>
<span class="gi">+                                    create_response()</span>
<span class="gi">+                                for result in self._sendMsg(</span>
<span class="gi">+                                        heartbeat_response):</span>
<span class="gi">+                                    yield result</span>
<span class="gi">+                            # If we received heartbeat response, then we</span>
<span class="gi">+                            # check, if its payload is same as payload of</span>
<span class="gi">+                            # request we sent</span>
<span class="gi">+                            elif heartbeat_message.message_type == \</span>
<span class="gi">+                                    HeartbeatMessageType.heartbeat_response \</span>
<span class="gi">+                                    and self.heartbeat_response_callback:</span>
<span class="gi">+                                self.heartbeat_response_callback(</span>
<span class="gi">+                                    heartbeat_message)</span>
<span class="gi">+                        except (socket.error, SyntaxError):</span>
<span class="gi">+                            pass</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    #Otherwise: this is an unexpected record, but neither an</span>
<span class="gi">+                    #alert nor renegotiation</span>
<span class="gi">+                    for result in self._sendError(\</span>
<span class="gi">+                            AlertDescription.unexpected_message,</span>
<span class="gi">+                            &quot;received type=%d&quot; % recordHeader.type):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                #If this is an empty application-data fragment, try again</span>
<span class="gi">+                if recordHeader.type == ContentType.application_data:</span>
<span class="gi">+                    if p.index == len(p.bytes):</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            #Parse based on content_type</span>
<span class="gi">+            if recordHeader.type == ContentType.change_cipher_spec:</span>
<span class="gi">+                yield ChangeCipherSpec().parse(p)</span>
<span class="gi">+            elif recordHeader.type == ContentType.alert:</span>
<span class="gi">+                yield Alert().parse(p)</span>
<span class="gi">+            elif recordHeader.type == ContentType.application_data:</span>
<span class="gi">+                yield ApplicationData().parse(p)</span>
<span class="gi">+            elif recordHeader.type == ContentType.handshake:</span>
<span class="gi">+                #Convert secondaryType to tuple, if it isn&#39;t already</span>
<span class="gi">+                if not isinstance(secondaryType, tuple):</span>
<span class="gi">+                    secondaryType = (secondaryType,)</span>
<span class="gi">+</span>
<span class="gi">+                #If it&#39;s a handshake message, check handshake header</span>
<span class="gi">+                if recordHeader.ssl2:</span>
<span class="gi">+                    subType = p.get(1)</span>
<span class="gi">+                    if subType != HandshakeType.client_hello:</span>
<span class="gi">+                        for result in self._sendError(\</span>
<span class="gi">+                                AlertDescription.unexpected_message,</span>
<span class="gi">+                                &quot;Can only handle SSLv2 ClientHello messages&quot;):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                    if HandshakeType.client_hello not in secondaryType:</span>
<span class="gi">+                        for result in self._sendError(\</span>
<span class="gi">+                                AlertDescription.unexpected_message):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+                    subType = HandshakeType.client_hello</span>
<span class="gi">+                else:</span>
<span class="gi">+                    subType = p.get(1)</span>
<span class="gi">+                    if subType not in secondaryType:</span>
<span class="gi">+                        exp = to_str_delimiter(HandshakeType.toStr(i) for i in</span>
<span class="gi">+                                               secondaryType)</span>
<span class="gi">+                        rec = HandshakeType.toStr(subType)</span>
<span class="gi">+                        for result in self._sendError(AlertDescription</span>
<span class="gi">+                                                      .unexpected_message,</span>
<span class="gi">+                                                      &quot;Expecting {0}, got {1}&quot;</span>
<span class="gi">+                                                      .format(exp, rec)):</span>
<span class="gi">+                            yield result</span>
<span class="gi">+</span>
<span class="gi">+                # in TLS 1.3 some Handshake messages MUST NOT span key changes</span>
<span class="gi">+                if self.version &gt; (3, 3) and \</span>
<span class="gi">+                        subType in (HandshakeType.client_hello,</span>
<span class="gi">+                                    HandshakeType.end_of_early_data,</span>
<span class="gi">+                                    HandshakeType.server_hello,</span>
<span class="gi">+                                    HandshakeType.finished,</span>
<span class="gi">+                                    HandshakeType.key_update) and \</span>
<span class="gi">+                        not self._defragmenter.is_empty():</span>
<span class="gi">+                    for result in self._sendError(</span>
<span class="gi">+                            AlertDescription.unexpected_message,</span>
<span class="gi">+                            &quot;CH, EOED, SH, Finished, or KU not aligned with &quot;</span>
<span class="gi">+                            &quot;record boundary&quot;):</span>
<span class="gi">+                        yield result</span>
<span class="gi">+</span>
<span class="gi">+                #Update handshake hashes</span>
<span class="gi">+                self._handshake_hash.update(p.bytes)</span>
<span class="gi">+</span>
<span class="gi">+                #Parse based on handshake type</span>
<span class="gi">+                if subType == HandshakeType.client_hello:</span>
<span class="gi">+                    yield ClientHello(recordHeader.ssl2).parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.server_hello:</span>
<span class="gi">+                    yield ServerHello().parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.certificate:</span>
<span class="gi">+                    yield Certificate(constructorType, self.version).parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.certificate_request:</span>
<span class="gi">+                    yield CertificateRequest(self.version).parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.certificate_verify:</span>
<span class="gi">+                    yield CertificateVerify(self.version).parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.server_key_exchange:</span>
<span class="gi">+                    yield ServerKeyExchange(constructorType,</span>
<span class="gi">+                                            self.version).parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.server_hello_done:</span>
<span class="gi">+                    yield ServerHelloDone().parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.client_key_exchange:</span>
<span class="gi">+                    yield ClientKeyExchange(constructorType, \</span>
<span class="gi">+                                            self.version).parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.finished:</span>
<span class="gi">+                    yield Finished(self.version, constructorType).parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.next_protocol:</span>
<span class="gi">+                    yield NextProtocol().parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.encrypted_extensions:</span>
<span class="gi">+                    yield EncryptedExtensions().parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.new_session_ticket:</span>
<span class="gi">+                    if self.version &lt; (3, 4):</span>
<span class="gi">+                        yield NewSessionTicket1_0().parse(p)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield NewSessionTicket().parse(p)</span>
<span class="gi">+                elif subType == HandshakeType.key_update:</span>
<span class="gi">+                    yield KeyUpdate().parse(p)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise AssertionError()</span>
<span class="gi">+</span>
<span class="gi">+        #If an exception was raised by a Parser or Message instance:</span>
<span class="gi">+        except BadCertificateError as e:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.bad_certificate,</span>
<span class="gi">+                                          formatExceptionTrace(e)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except SyntaxError as e:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.decode_error,</span>
<span class="gi">+                                          formatExceptionTrace(e)):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+    #Returns next record or next handshake message</span>
<span class="w"> </span>    def _getNextRecord(self):
<span class="w"> </span>        &quot;&quot;&quot;read next message from socket, defragment message&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            # support for fragmentation</span>
<span class="gi">+            # (RFC 5246 Section 6.2.1)</span>
<span class="gi">+            # Because the Record Layer is completely separate from the messages</span>
<span class="gi">+            # that traverse it, it should handle both application data and</span>
<span class="gi">+            # hadshake data in the same way. For that we buffer the handshake</span>
<span class="gi">+            # messages until they are completely read.</span>
<span class="gi">+            # This makes it possible to handle both handshake data not aligned</span>
<span class="gi">+            # to record boundary as well as handshakes longer than single</span>
<span class="gi">+            # record.</span>
<span class="gi">+            while True:</span>
<span class="gi">+                # empty message buffer</span>
<span class="gi">+                ret = self._defragmenter.get_message()</span>
<span class="gi">+                if ret is None:</span>
<span class="gi">+                    break</span>
<span class="gi">+                header = RecordHeader3().create(self.version, ret[0], 0)</span>
<span class="gi">+                yield header, Parser(ret[1])</span>
<span class="gi">+</span>
<span class="gi">+            # CCS can be sent before early_data but processing it will</span>
<span class="gi">+            # remove the flag from record layer, so reset it</span>
<span class="gi">+            early_data_ok = self._recordLayer.early_data_ok</span>
<span class="gi">+</span>
<span class="gi">+            # when the message buffer is empty, read next record from socket</span>
<span class="gi">+            for result in self._getNextRecordFromSocket():</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            header, parser = result</span>
<span class="gi">+</span>
<span class="gi">+            # application data (and CCS in TLS1.3) isn&#39;t made out of messages,</span>
<span class="gi">+            # pass it through</span>
<span class="gi">+            if header.type == ContentType.application_data or \</span>
<span class="gi">+                    (self.version &gt; (3, 3) and</span>
<span class="gi">+                     header.type == ContentType.change_cipher_spec):</span>
<span class="gi">+                # CCS doesn&#39;t change the status of undecryptable</span>
<span class="gi">+                # records</span>
<span class="gi">+                if header.type == ContentType.change_cipher_spec:</span>
<span class="gi">+                    self._recordLayer.early_data_ok = early_data_ok</span>
<span class="gi">+                yield (header, parser)</span>
<span class="gi">+            # heartbeat message isn&#39;t made out of messages, too</span>
<span class="gi">+            elif header.type == ContentType.heartbeat:</span>
<span class="gi">+                yield (header, parser)</span>
<span class="gi">+            # If it&#39;s an SSLv2 ClientHello, we can return it as well, since</span>
<span class="gi">+            # it&#39;s the only ssl2 type we support</span>
<span class="gi">+            elif header.ssl2:</span>
<span class="gi">+                yield (header, parser)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # other types need to be put into buffers</span>
<span class="gi">+                self._defragmenter.add_data(header.type, parser.bytes)</span>

<span class="w"> </span>    def _getNextRecordFromSocket(self):
<span class="w"> </span>        &quot;&quot;&quot;Read a record, handle errors&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            # otherwise... read the next record</span>
<span class="gi">+            for result in self._recordLayer.recvRecord():</span>
<span class="gi">+                if result in (0, 1):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+        except TLSUnexpectedMessage:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.unexpected_message):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSRecordOverflow:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.record_overflow):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSIllegalParameterException:</span>
<span class="gi">+            for result in self._sendError(AlertDescription.illegal_parameter):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSDecryptionFailed:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.decryption_failed,</span>
<span class="gi">+                    &quot;Encrypted data not a multiple of blocksize&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+        except TLSBadRecordMAC:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.bad_record_mac,</span>
<span class="gi">+                    &quot;MAC failure (or padding failure)&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        header, parser = result</span>
<span class="gi">+</span>
<span class="gi">+        # RFC5246 section 6.2.1: Implementations MUST NOT send</span>
<span class="gi">+        # zero-length fragments of content types other than Application</span>
<span class="gi">+        # Data.</span>
<span class="gi">+        if header.type != ContentType.application_data \</span>
<span class="gi">+                and parser.getRemainingLength() == 0:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.unexpected_message,</span>
<span class="gi">+                    &quot;Received empty non-application data record&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        if header.type not in ContentType.all:</span>
<span class="gi">+            for result in self._sendError(\</span>
<span class="gi">+                    AlertDescription.unexpected_message, \</span>
<span class="gi">+                    &quot;Received record with unknown ContentType&quot;):</span>
<span class="gi">+                yield result</span>
<span class="gi">+</span>
<span class="gi">+        yield (header, parser)</span>
<span class="gi">+</span>
<span class="gi">+    def _handshakeStart(self, client):</span>
<span class="gi">+        if not self.closed:</span>
<span class="gi">+            raise ValueError(&quot;Renegotiation disallowed for security reasons&quot;)</span>
<span class="gi">+        self._client = client</span>
<span class="gi">+        self._handshake_hash = HandshakeHashes()</span>
<span class="gi">+        self._certificate_verify_handshake_hash = None</span>
<span class="gi">+        self._pre_client_hello_handshake_hash = None</span>
<span class="gi">+        self._defragmenter.clear_buffers()</span>
<span class="gi">+        self.allegedSrpUsername = None</span>
<span class="gi">+        self._refCount = 1</span>
<span class="gi">+</span>
<span class="gi">+    def _handshakeDone(self, resumed):</span>
<span class="gi">+        self.resumed = resumed</span>
<span class="gi">+        self.closed = False</span>
<span class="gi">+</span>
<span class="gi">+    def _calcPendingStates(self, cipherSuite, masterSecret,</span>
<span class="gi">+                           clientRandom, serverRandom, implementations):</span>
<span class="gi">+        self._recordLayer.calcPendingStates(cipherSuite, masterSecret,</span>
<span class="gi">+                                            clientRandom, serverRandom,</span>
<span class="gi">+                                            implementations)</span>
<span class="gi">+</span>
<span class="gi">+    def _changeWriteState(self):</span>
<span class="gi">+        self._recordLayer.changeWriteState()</span>
<span class="gi">+</span>
<span class="gi">+    def _changeReadState(self):</span>
<span class="gi">+        self._recordLayer.changeReadState()</span>

<span class="w"> </span>    def write_heartbeat(self, payload, padding_length):
<span class="w"> </span>        &quot;&quot;&quot;Start a write operation of heartbeat_request.
<span class="gu">@@ -448,7 +1408,18 @@ class TLSRecordLayer(object):</span>

<span class="w"> </span>        :raise socket.error: If a socket error occurs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.closed:</span>
<span class="gi">+            raise TLSClosedConnectionError(</span>
<span class="gi">+                &quot;attempt to write to closed connection&quot;)</span>
<span class="gi">+        if not self.heartbeat_supported or not self.heartbeat_can_send:</span>
<span class="gi">+            raise TLSInternalError(&quot;attempt to send Heartbeat request when &quot;</span>
<span class="gi">+                                   &quot;we cant send it to other side&quot;)</span>
<span class="gi">+        heartbeat_request = Heartbeat().create(</span>
<span class="gi">+            HeartbeatMessageType.heartbeat_request, payload, padding_length)</span>
<span class="gi">+</span>
<span class="gi">+        for result in self._sendMsg(heartbeat_request,</span>
<span class="gi">+                                    randomizeFirstBlock=False):</span>
<span class="gi">+            yield result</span>

<span class="w"> </span>    def send_heartbeat_request(self, payload, padding_length):
<span class="w"> </span>        &quot;&quot;&quot;Synchronous version of write_heartbeat function.
<span class="gu">@@ -462,7 +1433,8 @@ class TLSRecordLayer(object):</span>

<span class="w"> </span>        :raise socket.error: If a socket error occurs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for _ in self.write_heartbeat(payload, padding_length):</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    def _handle_keyupdate_request(self, request):
<span class="w"> </span>        &quot;&quot;&quot;Process the KeyUpdate request.
<span class="gu">@@ -470,7 +1442,22 @@ class TLSRecordLayer(object):</span>
<span class="w"> </span>        :type request: KeyUpdate
<span class="w"> </span>        :param request: Recieved KeyUpdate message.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if request.message_type == KeyUpdateMessageType.update_not_requested or\</span>
<span class="gi">+                request.message_type == KeyUpdateMessageType.update_requested:</span>
<span class="gi">+            self.session.cl_app_secret, self.session.sr_app_secret = self._recordLayer.\</span>
<span class="gi">+                calcTLS1_3KeyUpdate_sender(</span>
<span class="gi">+                    self.session.cipherSuite,</span>
<span class="gi">+                    self.session.cl_app_secret,</span>
<span class="gi">+                    self.session.sr_app_secret)</span>
<span class="gi">+            if request.message_type == KeyUpdateMessageType.update_requested:</span>
<span class="gi">+                for result in self.send_keyupdate_request(</span>
<span class="gi">+                        KeyUpdateMessageType.update_not_requested):</span>
<span class="gi">+                    yield result</span>
<span class="gi">+        else:</span>
<span class="gi">+            for result in self._sendError(</span>
<span class="gi">+                    AlertDescription.illegal_parameter,</span>
<span class="gi">+                    &quot;Received KeyUpdate request with unknown message_type&quot;):</span>
<span class="gi">+                yield result</span>

<span class="w"> </span>    def send_keyupdate_request(self, message_type):
<span class="w"> </span>        &quot;&quot;&quot;Send a KeyUpdate message.
<span class="gu">@@ -480,4 +1467,18 @@ class TLSRecordLayer(object):</span>

<span class="w"> </span>        :raise socket.error: If a socket error occurs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.closed:</span>
<span class="gi">+            raise TLSClosedConnectionError(</span>
<span class="gi">+                &quot;attempt to write to closed connection&quot;)</span>
<span class="gi">+        if self.version != (3, 4):</span>
<span class="gi">+            raise TLSIllegalParameterException(&quot;KeyUpdate is a TLS 1.3 specific&quot;</span>
<span class="gi">+                                               &quot; feature&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        keyupdate_request = KeyUpdate().create(message_type)</span>
<span class="gi">+        for result in self._sendMsg(keyupdate_request):</span>
<span class="gi">+            yield result</span>
<span class="gi">+        self.session.cl_app_secret, self.session.sr_app_secret = \</span>
<span class="gi">+            self._recordLayer.calcTLS1_3KeyUpdate_reciever(</span>
<span class="gi">+                    self.session.cipherSuite,</span>
<span class="gi">+                    self.session.cl_app_secret,</span>
<span class="gi">+                    self.session.sr_app_secret)</span>
<span class="gh">diff --git a/tlslite/utils/aes.py b/tlslite/utils/aes.py</span>
<span class="gh">index b15fe4c..830ff37 100644</span>
<span class="gd">--- a/tlslite/utils/aes.py</span>
<span class="gi">+++ b/tlslite/utils/aes.py</span>
<span class="gu">@@ -1,8 +1,9 @@</span>
<span class="gd">-&quot;&quot;&quot;Abstract class for AES.&quot;&quot;&quot;</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>

<span class="gi">+&quot;&quot;&quot;Abstract class for AES.&quot;&quot;&quot;</span>

<span class="w"> </span>class AES(object):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, key, mode, IV, implementation):
<span class="w"> </span>        if len(key) not in (16, 24, 32):
<span class="w"> </span>            raise AssertionError()
<span class="gu">@@ -18,11 +19,21 @@ class AES(object):</span>
<span class="w"> </span>        self.isAEAD = False
<span class="w"> </span>        self.block_size = 16
<span class="w"> </span>        self.implementation = implementation
<span class="gd">-        if len(key) == 16:</span>
<span class="gd">-            self.name = &#39;aes128&#39;</span>
<span class="gd">-        elif len(key) == 24:</span>
<span class="gd">-            self.name = &#39;aes192&#39;</span>
<span class="gd">-        elif len(key) == 32:</span>
<span class="gd">-            self.name = &#39;aes256&#39;</span>
<span class="gi">+        if len(key)==16:</span>
<span class="gi">+            self.name = &quot;aes128&quot;</span>
<span class="gi">+        elif len(key)==24:</span>
<span class="gi">+            self.name = &quot;aes192&quot;</span>
<span class="gi">+        elif len(key)==32:</span>
<span class="gi">+            self.name = &quot;aes256&quot;</span>
<span class="w"> </span>        else:
<span class="w"> </span>            raise AssertionError()
<span class="gi">+</span>
<span class="gi">+    #CBC-Mode encryption, returns ciphertext</span>
<span class="gi">+    #WARNING: *MAY* modify the input as well</span>
<span class="gi">+    def encrypt(self, plaintext):</span>
<span class="gi">+        assert(len(plaintext) % 16 == 0)</span>
<span class="gi">+</span>
<span class="gi">+    #CBC-Mode decryption, returns plaintext</span>
<span class="gi">+    #WARNING: *MAY* modify the input as well</span>
<span class="gi">+    def decrypt(self, ciphertext):</span>
<span class="gi">+        assert(len(ciphertext) % 16 == 0)</span>
<span class="gh">diff --git a/tlslite/utils/aesccm.py b/tlslite/utils/aesccm.py</span>
<span class="gh">index fccfb40..9c76962 100644</span>
<span class="gd">--- a/tlslite/utils/aesccm.py</span>
<span class="gi">+++ b/tlslite/utils/aesccm.py</span>
<span class="gu">@@ -1,9 +1,15 @@</span>
<span class="gi">+# Copyright (c) 2019 Ivan Nikolchev</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import division
<span class="w"> </span>from tlslite.utils.cryptomath import numberToByteArray
<span class="w"> </span>from tlslite.utils import python_aes


<span class="w"> </span>class AESCCM(object):
<span class="gi">+    # AES-CCM implementation per RFC3610</span>

<span class="w"> </span>    def __init__(self, key, implementation, rawAesEncrypt, tag_length=16):
<span class="w"> </span>        self.isBlockCipher = False
<span class="gu">@@ -12,14 +18,138 @@ class AESCCM(object):</span>
<span class="w"> </span>        self.tagLength = tag_length
<span class="w"> </span>        self.nonceLength = 12
<span class="w"> </span>        self.implementation = implementation
<span class="gi">+</span>
<span class="w"> </span>        if len(self.key) == 16 and self.tagLength == 8:
<span class="gd">-            self.name = &#39;aes128ccm_8&#39;</span>
<span class="gi">+            self.name = &quot;aes128ccm_8&quot;</span>
<span class="w"> </span>        elif len(self.key) == 16 and self.tagLength == 16:
<span class="gd">-            self.name = &#39;aes128ccm&#39;</span>
<span class="gi">+            self.name = &quot;aes128ccm&quot;</span>
<span class="w"> </span>        elif len(self.key) == 32 and self.tagLength == 8:
<span class="gd">-            self.name = &#39;aes256ccm_8&#39;</span>
<span class="gi">+            self.name = &quot;aes256ccm_8&quot;</span>
<span class="w"> </span>        else:
<span class="w"> </span>            assert len(self.key) == 32 and self.tagLength == 16
<span class="gd">-            self.name = &#39;aes256ccm&#39;</span>
<span class="gi">+            self.name = &quot;aes256ccm&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        self._ctr = python_aes.new(self.key, 6, bytearray(b&#39;\x00&#39; * 16))
<span class="w"> </span>        self._cbc = python_aes.new(self.key, 2, bytearray(b&#39;\x00&#39; * 16))
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def _cbcmac_calc(self, nonce, aad, msg):</span>
<span class="gi">+        L = 15 - len(nonce)</span>
<span class="gi">+        mac_data = bytearray()</span>
<span class="gi">+</span>
<span class="gi">+        # Flags constructed as in section 2.2 in the rfc</span>
<span class="gi">+        flags = 64 * (len(aad) &gt; 0)</span>
<span class="gi">+        flags += 8 * ((self.tagLength - 2) // 2)</span>
<span class="gi">+        flags += 1 * (L - 1)</span>
<span class="gi">+</span>
<span class="gi">+        # Construct B_0</span>
<span class="gi">+        b_0 = bytearray([flags]) + nonce + numberToByteArray(len(msg), L)</span>
<span class="gi">+</span>
<span class="gi">+        aad_len_encoded = bytearray()</span>
<span class="gi">+        if len(aad) &gt; 0:</span>
<span class="gi">+            if len(aad) &lt; (2 ** 16 - 2 ** 8):</span>
<span class="gi">+                oct_size = 2</span>
<span class="gi">+            elif len(aad) &lt; (2 ** 32):</span>
<span class="gi">+                oct_size = 4</span>
<span class="gi">+                aad_len_encoded = b&#39;\xFF\xFE&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                oct_size = 8</span>
<span class="gi">+                aad_len_encoded = b&#39;\xFF\xFF&#39;</span>
<span class="gi">+</span>
<span class="gi">+            aad_len_encoded += numberToByteArray(len(aad), oct_size)</span>
<span class="gi">+</span>
<span class="gi">+        # Construct the bytearray that goes into the MAC</span>
<span class="gi">+        mac_data += b_0</span>
<span class="gi">+        mac_data += aad_len_encoded</span>
<span class="gi">+        mac_data += aad</span>
<span class="gi">+</span>
<span class="gi">+        # We need to pad with zeroes before and after msg blocks are added</span>
<span class="gi">+        self._pad_with_zeroes(mac_data, 16)</span>
<span class="gi">+        if msg != b&#39;&#39;:</span>
<span class="gi">+            mac_data += msg</span>
<span class="gi">+            self._pad_with_zeroes(mac_data, 16)</span>
<span class="gi">+</span>
<span class="gi">+        # The mac data is now constructed and</span>
<span class="gi">+        # we need to run in through AES-CBC with 0 IV</span>
<span class="gi">+</span>
<span class="gi">+        self._cbc.IV = bytearray(b&#39;\x00&#39; * 16)</span>
<span class="gi">+        cbcmac = self._cbc.encrypt(mac_data)</span>
<span class="gi">+</span>
<span class="gi">+        # If the tagLength has default value 16, we return</span>
<span class="gi">+        # the whole last block. Otherwise we return only</span>
<span class="gi">+        # the first tagLength bytes from the last block</span>
<span class="gi">+        if self.tagLength == 16:</span>
<span class="gi">+            t = cbcmac[-16:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            t = cbcmac[-16:-(16-self.tagLength)]</span>
<span class="gi">+        return t</span>
<span class="gi">+</span>
<span class="gi">+    def seal(self, nonce, msg, aad):</span>
<span class="gi">+</span>
<span class="gi">+        if len(nonce) != 12:</span>
<span class="gi">+            raise ValueError(&quot;Bad nonce length&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        L = 15 - len(nonce)</span>
<span class="gi">+</span>
<span class="gi">+        # We construct the key stream blocks.</span>
<span class="gi">+        # S_0 is not used for encrypting the message, it is only used</span>
<span class="gi">+        # to compute the authentication value.</span>
<span class="gi">+        # S_1..S_n are used to encrypt the message.</span>
<span class="gi">+</span>
<span class="gi">+        flags = L - 1</span>
<span class="gi">+        s_0 = bytearray([flags]) + nonce + numberToByteArray(0, L)</span>
<span class="gi">+</span>
<span class="gi">+        mac = self._cbcmac_calc(nonce, aad, msg)</span>
<span class="gi">+        self._ctr.counter = s_0</span>
<span class="gi">+        if self.tagLength == 16:</span>
<span class="gi">+            auth_value = self._ctr.encrypt(mac)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert self.tagLength == 8</span>
<span class="gi">+            self._pad_with_zeroes(mac, 16)</span>
<span class="gi">+            auth_value = self._ctr.encrypt(mac)[:8]</span>
<span class="gi">+        enc_msg = self._ctr.encrypt(msg)</span>
<span class="gi">+</span>
<span class="gi">+        ciphertext = enc_msg + auth_value</span>
<span class="gi">+        return ciphertext</span>
<span class="gi">+</span>
<span class="gi">+    def open(self, nonce, ciphertext, aad):</span>
<span class="gi">+</span>
<span class="gi">+        if len(nonce) != 12:</span>
<span class="gi">+            raise ValueError(&quot;Bad nonce length&quot;)</span>
<span class="gi">+        if self.tagLength == 16 and len(ciphertext) &lt; 16:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if self.tagLength == 8 and len(ciphertext) &lt; 8:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        L = 15 - len(nonce)</span>
<span class="gi">+        flags = L - 1</span>
<span class="gi">+</span>
<span class="gi">+        # Same construction as in seal function</span>
<span class="gi">+</span>
<span class="gi">+        s_0 = bytearray([flags]) + nonce + numberToByteArray(0, L)</span>
<span class="gi">+</span>
<span class="gi">+        auth_value = ciphertext[-self.tagLength:]</span>
<span class="gi">+</span>
<span class="gi">+        # We decrypt the auth value</span>
<span class="gi">+        self._ctr.counter = s_0</span>
<span class="gi">+        if self.tagLength == 16:</span>
<span class="gi">+            received_mac = self._ctr.decrypt(auth_value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert self.tagLength == 8</span>
<span class="gi">+            self._pad_with_zeroes(auth_value, 16)</span>
<span class="gi">+            received_mac = self._ctr.decrypt(auth_value)[:8]</span>
<span class="gi">+        msg = self._ctr.decrypt(ciphertext)</span>
<span class="gi">+        msg = msg[:-self.tagLength]</span>
<span class="gi">+        computed_mac = self._cbcmac_calc(nonce, aad, msg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+        # Compare the mac vlaue is the same as the one we computed</span>
<span class="gi">+        if received_mac != computed_mac:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return msg</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _pad_with_zeroes(data, size):</span>
<span class="gi">+        if len(data) % size != 0:</span>
<span class="gi">+            zeroes_to_add = size - (len(data) % size)</span>
<span class="gi">+            data += b&#39;\x00&#39; * zeroes_to_add</span>
<span class="gh">diff --git a/tlslite/utils/aesgcm.py b/tlslite/utils/aesgcm.py</span>
<span class="gh">index 37d5518..34e7738 100644</span>
<span class="gd">--- a/tlslite/utils/aesgcm.py</span>
<span class="gi">+++ b/tlslite/utils/aesgcm.py</span>
<span class="gu">@@ -1,9 +1,23 @@</span>
<span class="gi">+# Author: Google</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="gi">+# GCM derived from Go&#39;s implementation in crypto/cipher.</span>
<span class="gi">+#</span>
<span class="gi">+# https://golang.org/src/crypto/cipher/gcm.go</span>
<span class="gi">+</span>
<span class="gi">+# GCM works over elements of the field GF(2^128), each of which is a 128-bit</span>
<span class="gi">+# polynomial. Throughout this implementation, polynomials are represented as</span>
<span class="gi">+# Python integers with the low-order terms at the most significant bits. So a</span>
<span class="gi">+# 128-bit polynomial is an integer from 0 to 2^128-1 with the most significant</span>
<span class="gi">+# bit representing the x^0 term and the least significant bit representing the</span>
<span class="gi">+# x^127 term. This bit reversal also applies to polynomials used as indices in a</span>
<span class="gi">+# look-up table.</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import division
<span class="w"> </span>from tlslite.utils import python_aes
<span class="w"> </span>from .constanttime import ct_compare_digest
<span class="w"> </span>from .cryptomath import bytesToNumber, numberToByteArray

<span class="gd">-</span>
<span class="w"> </span>class AESGCM(object):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    AES-GCM implementation. Note: this implementation does not attempt
<span class="gu">@@ -17,33 +31,97 @@ class AESGCM(object):</span>
<span class="w"> </span>        self.tagLength = 16
<span class="w"> </span>        self.implementation = implementation
<span class="w"> </span>        if len(key) == 16:
<span class="gd">-            self.name = &#39;aes128gcm&#39;</span>
<span class="gi">+            self.name = &quot;aes128gcm&quot;</span>
<span class="w"> </span>        elif len(key) == 32:
<span class="gd">-            self.name = &#39;aes256gcm&#39;</span>
<span class="gi">+            self.name = &quot;aes256gcm&quot;</span>
<span class="w"> </span>        else:
<span class="w"> </span>            raise AssertionError()
<span class="w"> </span>        self.key = key
<span class="gi">+</span>
<span class="w"> </span>        self._rawAesEncrypt = rawAesEncrypt
<span class="w"> </span>        self._ctr = python_aes.new(self.key, 6, bytearray(b&#39;\x00&#39; * 16))
<span class="gi">+</span>
<span class="gi">+        # The GCM key is AES(0).</span>
<span class="w"> </span>        h = bytesToNumber(self._rawAesEncrypt(bytearray(16)))
<span class="gi">+</span>
<span class="gi">+        # Pre-compute all 4-bit multiples of h. Note that bits are reversed</span>
<span class="gi">+        # because our polynomial representation places low-order terms at the</span>
<span class="gi">+        # most significant bit. Thus x^0 * h = h is at index 0b1000 = 8 and</span>
<span class="gi">+        # x^1 * h is at index 0b0100 = 4.</span>
<span class="w"> </span>        self._productTable = [0] * 16
<span class="w"> </span>        self._productTable[self._reverseBits(1)] = h
<span class="w"> </span>        for i in range(2, 16, 2):
<span class="gd">-            self._productTable[self._reverseBits(i)] = self._gcmShift(self.</span>
<span class="gd">-                _productTable[self._reverseBits(i // 2)])</span>
<span class="gd">-            self._productTable[self._reverseBits(i + 1)] = self._gcmAdd(self</span>
<span class="gd">-                ._productTable[self._reverseBits(i)], h)</span>
<span class="gi">+            self._productTable[self._reverseBits(i)] = \</span>
<span class="gi">+                self._gcmShift(self._productTable[self._reverseBits(i//2)])</span>
<span class="gi">+            self._productTable[self._reverseBits(i+1)] = \</span>
<span class="gi">+                self._gcmAdd(self._productTable[self._reverseBits(i)], h)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def _auth(self, ciphertext, ad, tagMask):</span>
<span class="gi">+        y = 0</span>
<span class="gi">+        y = self._update(y, ad)</span>
<span class="gi">+        y = self._update(y, ciphertext)</span>
<span class="gi">+        y ^= (len(ad) &lt;&lt; (3 + 64)) | (len(ciphertext) &lt;&lt; 3)</span>
<span class="gi">+        y = self._mul(y)</span>
<span class="gi">+        y ^= bytesToNumber(tagMask)</span>
<span class="gi">+        return numberToByteArray(y, 16)</span>
<span class="gi">+</span>
<span class="gi">+    def _update(self, y, data):</span>
<span class="gi">+        for i in range(0, len(data) // 16):</span>
<span class="gi">+            y ^= bytesToNumber(data[16*i:16*i+16])</span>
<span class="gi">+            y = self._mul(y)</span>
<span class="gi">+        extra = len(data) % 16</span>
<span class="gi">+        if extra != 0:</span>
<span class="gi">+            block = bytearray(16)</span>
<span class="gi">+            block[:extra] = data[-extra:]</span>
<span class="gi">+            y ^= bytesToNumber(block)</span>
<span class="gi">+            y = self._mul(y)</span>
<span class="gi">+        return y</span>

<span class="w"> </span>    def _mul(self, y):
<span class="w"> </span>        &quot;&quot;&quot; Returns y*H, where H is the GCM key. &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = 0</span>
<span class="gi">+        # Multiply H by y 4 bits at a time, starting with the highest power</span>
<span class="gi">+        # terms.</span>
<span class="gi">+        for i in range(0, 128, 4):</span>
<span class="gi">+            # Multiply by x^4. The reduction for the top four terms is</span>
<span class="gi">+            # precomputed.</span>
<span class="gi">+            retHigh = ret &amp; 0xf</span>
<span class="gi">+            ret &gt;&gt;= 4</span>
<span class="gi">+            ret ^= (AESGCM._gcmReductionTable[retHigh] &lt;&lt; (128-16))</span>
<span class="gi">+</span>
<span class="gi">+            # Add in y&#39; * H where y&#39; are the next four terms of y, shifted down</span>
<span class="gi">+            # to the x^0..x^4. This is one of the pre-computed multiples of</span>
<span class="gi">+            # H. The multiplication by x^4 shifts them back into place.</span>
<span class="gi">+            ret ^= self._productTable[y &amp; 0xf]</span>
<span class="gi">+            y &gt;&gt;= 4</span>
<span class="gi">+        assert y == 0</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def seal(self, nonce, plaintext, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Encrypts and authenticates plaintext using nonce and data. Returns the
<span class="w"> </span>        ciphertext, consisting of the encrypted plaintext and tag concatenated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if len(nonce) != 12:</span>
<span class="gi">+            raise ValueError(&quot;Bad nonce length&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # The initial counter value is the nonce, followed by a 32-bit counter</span>
<span class="gi">+        # that starts at 1. It&#39;s used to compute the tag mask.</span>
<span class="gi">+        counter = bytearray(16)</span>
<span class="gi">+        counter[:12] = nonce</span>
<span class="gi">+        counter[-1] = 1</span>
<span class="gi">+        tagMask = self._rawAesEncrypt(counter)</span>
<span class="gi">+</span>
<span class="gi">+        # The counter starts at 2 for the actual encryption.</span>
<span class="gi">+        counter[-1] = 2</span>
<span class="gi">+        self._ctr.counter = counter</span>
<span class="gi">+        ciphertext = self._ctr.encrypt(plaintext)</span>
<span class="gi">+</span>
<span class="gi">+        tag = self._auth(ciphertext, data, tagMask)</span>
<span class="gi">+</span>
<span class="gi">+        return ciphertext + tag</span>

<span class="w"> </span>    def open(self, nonce, ciphertext, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -51,6 +129,65 @@ class AESGCM(object):</span>
<span class="w"> </span>        tag is valid, the plaintext is returned. If the tag is invalid,
<span class="w"> </span>        returns None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    _gcmReductionTable = [0, 7200, 14400, 9312, 28800, 27808, 18624, 21728,</span>
<span class="gd">-        57600, 64800, 55616, 50528, 37248, 36256, 43456, 46560]</span>
<span class="gi">+</span>
<span class="gi">+        if len(nonce) != 12:</span>
<span class="gi">+            raise ValueError(&quot;Bad nonce length&quot;)</span>
<span class="gi">+        if len(ciphertext) &lt; 16:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        tag = ciphertext[-16:]</span>
<span class="gi">+        ciphertext = ciphertext[:-16]</span>
<span class="gi">+</span>
<span class="gi">+        # The initial counter value is the nonce, followed by a 32-bit counter</span>
<span class="gi">+        # that starts at 1. It&#39;s used to compute the tag mask.</span>
<span class="gi">+        counter = bytearray(16)</span>
<span class="gi">+        counter[:12] = nonce</span>
<span class="gi">+        counter[-1] = 1</span>
<span class="gi">+        tagMask = self._rawAesEncrypt(counter)</span>
<span class="gi">+</span>
<span class="gi">+        if not ct_compare_digest(tag, self._auth(ciphertext, data, tagMask)):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # The counter starts at 2 for the actual decryption.</span>
<span class="gi">+        counter[-1] = 2</span>
<span class="gi">+        self._ctr.counter = counter</span>
<span class="gi">+        return self._ctr.decrypt(ciphertext)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _reverseBits(i):</span>
<span class="gi">+        assert i &lt; 16</span>
<span class="gi">+        i = ((i &lt;&lt; 2) &amp; 0xc) | ((i &gt;&gt; 2) &amp; 0x3)</span>
<span class="gi">+        i = ((i &lt;&lt; 1) &amp; 0xa) | ((i &gt;&gt; 1) &amp; 0x5)</span>
<span class="gi">+        return i</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _gcmAdd(x, y):</span>
<span class="gi">+        return x ^ y</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _gcmShift(x):</span>
<span class="gi">+        # Multiplying by x is a right shift, due to bit order.</span>
<span class="gi">+        highTermSet = x &amp; 1</span>
<span class="gi">+        x &gt;&gt;= 1</span>
<span class="gi">+        if highTermSet:</span>
<span class="gi">+            # The x^127 term was shifted up to x^128, so subtract a 1+x+x^2+x^7</span>
<span class="gi">+            # term. This is 0b11100001 or 0xe1 when represented as an 8-bit</span>
<span class="gi">+            # polynomial.</span>
<span class="gi">+            x ^= 0xe1 &lt;&lt; (128-8)</span>
<span class="gi">+        return x</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _inc32(counter):</span>
<span class="gi">+        for i in range(len(counter)-1, len(counter)-5, -1):</span>
<span class="gi">+            counter[i] = (counter[i] + 1) % 256</span>
<span class="gi">+            if counter[i] != 0:</span>
<span class="gi">+                break</span>
<span class="gi">+        return counter</span>
<span class="gi">+</span>
<span class="gi">+    # _gcmReductionTable[i] is i * (1+x+x^2+x^7) for all 4-bit polynomials i. The</span>
<span class="gi">+    # result is stored as a 16-bit polynomial. This is used in the reduction step to</span>
<span class="gi">+    # multiply elements of GF(2^128) by x^4.</span>
<span class="gi">+    _gcmReductionTable = [</span>
<span class="gi">+        0x0000, 0x1c20, 0x3840, 0x2460, 0x7080, 0x6ca0, 0x48c0, 0x54e0,</span>
<span class="gi">+        0xe100, 0xfd20, 0xd940, 0xc560, 0x9180, 0x8da0, 0xa9c0, 0xb5e0,</span>
<span class="gi">+    ]</span>
<span class="gh">diff --git a/tlslite/utils/asn1parser.py b/tlslite/utils/asn1parser.py</span>
<span class="gh">index 126a3ff..6edfa7e 100644</span>
<span class="gd">--- a/tlslite/utils/asn1parser.py</span>
<span class="gi">+++ b/tlslite/utils/asn1parser.py</span>
<span class="gu">@@ -1,4 +1,10 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# Patch from Google adding getChildBytes()</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Abstract Syntax Notation One (ASN.1) parsing&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .codec import Parser


<span class="gu">@@ -45,8 +51,14 @@ class ASN1Parser(object):</span>
<span class="w"> </span>        :param bytes: DER encoded ASN.1 object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        p = Parser(bytes)
<span class="gi">+</span>
<span class="gi">+        # Get Type</span>
<span class="w"> </span>        self.type = self._parse_type(p)
<span class="gi">+</span>
<span class="gi">+        #Get Length</span>
<span class="w"> </span>        self.length = self._getASN1Length(p)
<span class="gi">+</span>
<span class="gi">+        #Get Value</span>
<span class="w"> </span>        self.value = p.getFixBytes(self.length)

<span class="w"> </span>    def getChild(self, which):
<span class="gu">@@ -59,7 +71,7 @@ class ASN1Parser(object):</span>
<span class="w"> </span>        :rtype: ASN1Parser
<span class="w"> </span>        :returns: decoded child object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ASN1Parser(self.getChildBytes(which))</span>

<span class="w"> </span>    def getChildCount(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -68,7 +80,16 @@ class ASN1Parser(object):</span>
<span class="w"> </span>        :rtype: int
<span class="w"> </span>        :returns: number of children in the object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        p = Parser(self.value)</span>
<span class="gi">+        count = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if p.getRemainingLength() == 0:</span>
<span class="gi">+                break</span>
<span class="gi">+            p.skip_bytes(1)  # skip Type</span>
<span class="gi">+            length = self._getASN1Length(p)</span>
<span class="gi">+            p.skip_bytes(length)  # skip value</span>
<span class="gi">+            count += 1</span>
<span class="gi">+        return count</span>

<span class="w"> </span>    def getChildBytes(self, which):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -80,14 +101,40 @@ class ASN1Parser(object):</span>
<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        :returns: raw child object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        p = Parser(self.value)</span>
<span class="gi">+        for _ in range(which+1):</span>
<span class="gi">+            markIndex = p.index</span>
<span class="gi">+            p.skip_bytes(1)  # skip Type</span>
<span class="gi">+            length = self._getASN1Length(p)</span>
<span class="gi">+            p.skip_bytes(length)</span>
<span class="gi">+        return p.bytes[markIndex : p.index]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _getASN1Length(p):
<span class="w"> </span>        &quot;&quot;&quot;Decode the ASN.1 DER length field&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        firstLength = p.get(1)</span>
<span class="gi">+        if firstLength &lt;= 127:</span>
<span class="gi">+            return firstLength</span>
<span class="gi">+        else:</span>
<span class="gi">+            lengthLength = firstLength &amp; 0x7F</span>
<span class="gi">+            return p.get(lengthLength)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _parse_type(parser):
<span class="w"> </span>        &quot;&quot;&quot;Decode the ASN.1 DER type field&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        header = parser.get(1)</span>
<span class="gi">+        tag_class = (header &amp; 0xc0) &gt;&gt; 6</span>
<span class="gi">+        tag_is_primitive = (header &amp; 0x20) &gt;&gt; 5</span>
<span class="gi">+        tag_id = header &amp; 0x1f</span>
<span class="gi">+</span>
<span class="gi">+        if tag_id == 0x1f:</span>
<span class="gi">+            tag_id = 0</span>
<span class="gi">+            while True:</span>
<span class="gi">+                value = parser.get(1)</span>
<span class="gi">+                tag_id += value &amp; 0x7f</span>
<span class="gi">+                if not value &amp; 0x80:</span>
<span class="gi">+                    break</span>
<span class="gi">+                tag_id &lt;&lt;= 7</span>
<span class="gi">+</span>
<span class="gi">+        asn1type = ASN1Type(tag_class, tag_is_primitive, tag_id)</span>
<span class="gi">+        return asn1type</span>
<span class="gh">diff --git a/tlslite/utils/chacha.py b/tlslite/utils/chacha.py</span>
<span class="gh">index e370972..ac6e94c 100644</span>
<span class="gd">--- a/tlslite/utils/chacha.py</span>
<span class="gi">+++ b/tlslite/utils/chacha.py</span>
<span class="gu">@@ -1,70 +1,157 @@</span>
<span class="gi">+# Copyright (c) 2015, Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="w"> </span>&quot;&quot;&quot;Pure Python implementation of ChaCha cipher

<span class="w"> </span>Implementation that follows RFC 7539 closely.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import division
<span class="w"> </span>from .compat import compat26Str
<span class="w"> </span>import copy
<span class="w"> </span>import struct
<span class="w"> </span>try:
<span class="gi">+    # in Python 3 the native zip returns iterator</span>
<span class="w"> </span>    from itertools import izip
<span class="w"> </span>except ImportError:
<span class="w"> </span>    izip = zip

<span class="gd">-</span>
<span class="w"> </span>class ChaCha(object):
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;Pure python implementation of ChaCha cipher&quot;&quot;&quot;
<span class="gd">-    constants = [1634760805, 857760878, 2036477234, 1797285236]</span>
<span class="gi">+</span>
<span class="gi">+    constants = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def rotl32(v, c):
<span class="w"> </span>        &quot;&quot;&quot;Rotate left a 32 bit integer v by c bits&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ((v &lt;&lt; c) &amp; 0xffffffff) | (v &gt;&gt; (32 - c))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def quarter_round(x, a, b, c, d):
<span class="w"> </span>        &quot;&quot;&quot;Perform a ChaCha quarter round&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    _round_mixup_box = [(0, 4, 8, 12), (1, 5, 9, 13), (2, 6, 10, 14), (3, 7,</span>
<span class="gd">-        11, 15), (0, 5, 10, 15), (1, 6, 11, 12), (2, 7, 8, 13), (3, 4, 9, 14)]</span>
<span class="gi">+        xa = x[a]</span>
<span class="gi">+        xb = x[b]</span>
<span class="gi">+        xc = x[c]</span>
<span class="gi">+        xd = x[d]</span>
<span class="gi">+</span>
<span class="gi">+        xa = (xa + xb) &amp; 0xffffffff</span>
<span class="gi">+        xd = xd ^ xa</span>
<span class="gi">+        xd = ((xd &lt;&lt; 16) &amp; 0xffffffff | (xd &gt;&gt; 16))</span>
<span class="gi">+</span>
<span class="gi">+        xc = (xc + xd) &amp; 0xffffffff</span>
<span class="gi">+        xb = xb ^ xc</span>
<span class="gi">+        xb = ((xb &lt;&lt; 12) &amp; 0xffffffff | (xb &gt;&gt; 20))</span>
<span class="gi">+</span>
<span class="gi">+        xa = (xa + xb) &amp; 0xffffffff</span>
<span class="gi">+        xd = xd ^ xa</span>
<span class="gi">+        xd = ((xd &lt;&lt; 8) &amp; 0xffffffff | (xd &gt;&gt; 24))</span>
<span class="gi">+</span>
<span class="gi">+        xc = (xc + xd) &amp; 0xffffffff</span>
<span class="gi">+        xb = xb ^ xc</span>
<span class="gi">+        xb = ((xb &lt;&lt; 7) &amp; 0xffffffff | (xb &gt;&gt; 25))</span>
<span class="gi">+</span>
<span class="gi">+        x[a] = xa</span>
<span class="gi">+        x[b] = xb</span>
<span class="gi">+        x[c] = xc</span>
<span class="gi">+        x[d] = xd</span>
<span class="gi">+</span>
<span class="gi">+    _round_mixup_box = [(0, 4, 8, 12),</span>
<span class="gi">+                        (1, 5, 9, 13),</span>
<span class="gi">+                        (2, 6, 10, 14),</span>
<span class="gi">+                        (3, 7, 11, 15),</span>
<span class="gi">+                        (0, 5, 10, 15),</span>
<span class="gi">+                        (1, 6, 11, 12),</span>
<span class="gi">+                        (2, 7, 8, 13),</span>
<span class="gi">+                        (3, 4, 9, 14)]</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def double_round(cls, x):
<span class="w"> </span>        &quot;&quot;&quot;Perform two rounds of ChaCha cipher&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for a, b, c, d in cls._round_mixup_box:</span>
<span class="gi">+            xa = x[a]</span>
<span class="gi">+            xb = x[b]</span>
<span class="gi">+            xc = x[c]</span>
<span class="gi">+            xd = x[d]</span>
<span class="gi">+</span>
<span class="gi">+            xa = (xa + xb) &amp; 0xffffffff</span>
<span class="gi">+            xd = xd ^ xa</span>
<span class="gi">+            xd = ((xd &lt;&lt; 16) &amp; 0xffffffff | (xd &gt;&gt; 16))</span>
<span class="gi">+</span>
<span class="gi">+            xc = (xc + xd) &amp; 0xffffffff</span>
<span class="gi">+            xb = xb ^ xc</span>
<span class="gi">+            xb = ((xb &lt;&lt; 12) &amp; 0xffffffff | (xb &gt;&gt; 20))</span>
<span class="gi">+</span>
<span class="gi">+            xa = (xa + xb) &amp; 0xffffffff</span>
<span class="gi">+            xd = xd ^ xa</span>
<span class="gi">+            xd = ((xd &lt;&lt; 8) &amp; 0xffffffff | (xd &gt;&gt; 24))</span>
<span class="gi">+</span>
<span class="gi">+            xc = (xc + xd) &amp; 0xffffffff</span>
<span class="gi">+            xb = xb ^ xc</span>
<span class="gi">+            xb = ((xb &lt;&lt; 7) &amp; 0xffffffff | (xb &gt;&gt; 25))</span>
<span class="gi">+</span>
<span class="gi">+            x[a] = xa</span>
<span class="gi">+            x[b] = xb</span>
<span class="gi">+            x[c] = xc</span>
<span class="gi">+            x[d] = xd</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def chacha_block(key, counter, nonce, rounds):
<span class="w"> </span>        &quot;&quot;&quot;Generate a state of a single block&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        state = ChaCha.constants + key + [counter] + nonce</span>
<span class="gi">+</span>
<span class="gi">+        working_state = state[:]</span>
<span class="gi">+        dbl_round = ChaCha.double_round</span>
<span class="gi">+        for _ in range(0, rounds // 2):</span>
<span class="gi">+            dbl_round(working_state)</span>
<span class="gi">+</span>
<span class="gi">+        return [(st + wrkSt) &amp; 0xffffffff for st, wrkSt</span>
<span class="gi">+                in izip(state, working_state)]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def word_to_bytearray(state):
<span class="w"> </span>        &quot;&quot;&quot;Convert state to little endian bytestream&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bytearray(struct.pack(&#39;&lt;LLLLLLLLLLLLLLLL&#39;, *state))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _bytearray_to_words(data):
<span class="w"> </span>        &quot;&quot;&quot;Convert a bytearray to array of word sized ints&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        for i in range(0, len(data)//4):</span>
<span class="gi">+            ret.extend(struct.unpack(&#39;&lt;L&#39;,</span>
<span class="gi">+                                     compat26Str(data[i*4:(i+1)*4])))</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def __init__(self, key, nonce, counter=0, rounds=20):
<span class="w"> </span>        &quot;&quot;&quot;Set the initial state for the ChaCha cipher&quot;&quot;&quot;
<span class="w"> </span>        if len(key) != 32:
<span class="gd">-            raise ValueError(&#39;Key must be 256 bit long&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Key must be 256 bit long&quot;)</span>
<span class="w"> </span>        if len(nonce) != 12:
<span class="gd">-            raise ValueError(&#39;Nonce must be 96 bit long&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Nonce must be 96 bit long&quot;)</span>
<span class="w"> </span>        self.key = []
<span class="w"> </span>        self.nonce = []
<span class="w"> </span>        self.counter = counter
<span class="w"> </span>        self.rounds = rounds
<span class="gi">+</span>
<span class="gi">+        # convert bytearray key and nonce to little endian 32 bit unsigned ints</span>
<span class="w"> </span>        self.key = ChaCha._bytearray_to_words(key)
<span class="w"> </span>        self.nonce = ChaCha._bytearray_to_words(nonce)

<span class="w"> </span>    def encrypt(self, plaintext):
<span class="w"> </span>        &quot;&quot;&quot;Encrypt the data&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        encrypted_message = bytearray()</span>
<span class="gi">+        for i, block in enumerate(plaintext[i:i+64] for i</span>
<span class="gi">+                                  in range(0, len(plaintext), 64)):</span>
<span class="gi">+            key_stream = ChaCha.chacha_block(self.key,</span>
<span class="gi">+                                             self.counter + i,</span>
<span class="gi">+                                             self.nonce,</span>
<span class="gi">+                                             self.rounds)</span>
<span class="gi">+            key_stream = ChaCha.word_to_bytearray(key_stream)</span>
<span class="gi">+            encrypted_message += bytearray(x ^ y for x, y</span>
<span class="gi">+                                           in izip(key_stream, block))</span>
<span class="gi">+</span>
<span class="gi">+        return encrypted_message</span>

<span class="w"> </span>    def decrypt(self, ciphertext):
<span class="w"> </span>        &quot;&quot;&quot;Decrypt the data&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.encrypt(ciphertext)</span>
<span class="gh">diff --git a/tlslite/utils/chacha20_poly1305.py b/tlslite/utils/chacha20_poly1305.py</span>
<span class="gh">index 0268f68..bed7178 100644</span>
<span class="gd">--- a/tlslite/utils/chacha20_poly1305.py</span>
<span class="gi">+++ b/tlslite/utils/chacha20_poly1305.py</span>
<span class="gu">@@ -1,47 +1,69 @@</span>
<span class="gi">+# Copyright (c) 2015, Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="w"> </span>&quot;&quot;&quot;Pure Python implementation of ChaCha20/Poly1305 AEAD cipher

<span class="w"> </span>Implementation that follows RFC 7539 and draft-ietf-tls-chacha20-poly1305-00
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import division
<span class="w"> </span>from .constanttime import ct_compare_digest
<span class="w"> </span>from .chacha import ChaCha
<span class="w"> </span>from .poly1305 import Poly1305
<span class="w"> </span>import struct

<span class="gd">-</span>
<span class="w"> </span>class CHACHA20_POLY1305(object):
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;Pure python implementation of ChaCha20/Poly1305 AEAD cipher&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, key, implementation):
<span class="w"> </span>        &quot;&quot;&quot;Set the initial state for the ChaCha20 AEAD&quot;&quot;&quot;
<span class="w"> </span>        if len(key) != 32:
<span class="gd">-            raise ValueError(&#39;Key must be 256 bit long&#39;)</span>
<span class="gd">-        if implementation != &#39;python&#39;:</span>
<span class="gd">-            raise ValueError(&#39;Implementations other then python unsupported&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Key must be 256 bit long&quot;)</span>
<span class="gi">+        if implementation != &quot;python&quot;:</span>
<span class="gi">+            raise ValueError(&quot;Implementations other then python unsupported&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.isBlockCipher = False
<span class="w"> </span>        self.isAEAD = True
<span class="w"> </span>        self.nonceLength = 12
<span class="w"> </span>        self.tagLength = 16
<span class="w"> </span>        self.implementation = implementation
<span class="gd">-        self.name = &#39;chacha20-poly1305&#39;</span>
<span class="gi">+        self.name = &quot;chacha20-poly1305&quot;</span>
<span class="w"> </span>        self.key = key

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def poly1305_key_gen(key, nonce):
<span class="w"> </span>        &quot;&quot;&quot;Generate the key for the Poly1305 authenticator&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        poly = ChaCha(key, nonce)</span>
<span class="gi">+        return poly.encrypt(bytearray(32))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def pad16(data):
<span class="w"> </span>        &quot;&quot;&quot;Return padding for the Associated Authenticated Data&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(data) % 16 == 0:</span>
<span class="gi">+            return bytearray(0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return bytearray(16-(len(data)%16))</span>

<span class="w"> </span>    def seal(self, nonce, plaintext, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Encrypts and authenticates plaintext using nonce and data. Returns the
<span class="w"> </span>        ciphertext, consisting of the encrypted plaintext and tag concatenated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(nonce) != 12:</span>
<span class="gi">+            raise ValueError(&quot;Nonce must be 96 bit large&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        otk = self.poly1305_key_gen(self.key, nonce)</span>
<span class="gi">+</span>
<span class="gi">+        ciphertext = ChaCha(self.key, nonce, counter=1).encrypt(plaintext)</span>
<span class="gi">+</span>
<span class="gi">+        mac_data = data + self.pad16(data)</span>
<span class="gi">+        mac_data += ciphertext + self.pad16(ciphertext)</span>
<span class="gi">+        mac_data += struct.pack(&#39;&lt;Q&#39;, len(data))</span>
<span class="gi">+        mac_data += struct.pack(&#39;&lt;Q&#39;, len(ciphertext))</span>
<span class="gi">+        tag = Poly1305(otk).create_tag(mac_data)</span>
<span class="gi">+</span>
<span class="gi">+        return ciphertext + tag</span>

<span class="w"> </span>    def open(self, nonce, ciphertext, data):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -49,4 +71,24 @@ class CHACHA20_POLY1305(object):</span>
<span class="w"> </span>        tag is valid, the plaintext is returned. If the tag is invalid,
<span class="w"> </span>        returns None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(nonce) != 12:</span>
<span class="gi">+            raise ValueError(&quot;Nonce must be 96 bit long&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if len(ciphertext) &lt; 16:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        expected_tag = ciphertext[-16:]</span>
<span class="gi">+        ciphertext = ciphertext[:-16]</span>
<span class="gi">+</span>
<span class="gi">+        otk = self.poly1305_key_gen(self.key, nonce)</span>
<span class="gi">+</span>
<span class="gi">+        mac_data = data + self.pad16(data)</span>
<span class="gi">+        mac_data += ciphertext + self.pad16(ciphertext)</span>
<span class="gi">+        mac_data += struct.pack(&#39;&lt;Q&#39;, len(data))</span>
<span class="gi">+        mac_data += struct.pack(&#39;&lt;Q&#39;, len(ciphertext))</span>
<span class="gi">+        tag = Poly1305(otk).create_tag(mac_data)</span>
<span class="gi">+</span>
<span class="gi">+        if not ct_compare_digest(tag, expected_tag):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        return ChaCha(self.key, nonce, counter=1).decrypt(ciphertext)</span>
<span class="gh">diff --git a/tlslite/utils/cipherfactory.py b/tlslite/utils/cipherfactory.py</span>
<span class="gh">index 02b959f..076ad56 100644</span>
<span class="gd">--- a/tlslite/utils/cipherfactory.py</span>
<span class="gi">+++ b/tlslite/utils/cipherfactory.py</span>
<span class="gu">@@ -1,5 +1,10 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Factory functions for symmetric cryptography.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>from tlslite.utils import python_aes
<span class="w"> </span>from tlslite.utils import python_aesgcm
<span class="w"> </span>from tlslite.utils import python_aesccm
<span class="gu">@@ -8,19 +13,26 @@ from tlslite.utils import python_rc4</span>
<span class="w"> </span>from tlslite.utils import python_tripledes
<span class="w"> </span>from tlslite.utils import openssl_aesccm
<span class="w"> </span>from tlslite.utils import openssl_aesgcm
<span class="gi">+</span>
<span class="w"> </span>from tlslite.utils import cryptomath
<span class="gi">+</span>
<span class="w"> </span>tripleDESPresent = True
<span class="w"> </span>&quot;&quot;&quot;Inform if the 3DES algorithm is supported.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>if cryptomath.m2cryptoLoaded:
<span class="w"> </span>    from tlslite.utils import openssl_aes
<span class="w"> </span>    from tlslite.utils import openssl_rc4
<span class="w"> </span>    from tlslite.utils import openssl_tripledes
<span class="gi">+</span>
<span class="w"> </span>if cryptomath.pycryptoLoaded:
<span class="w"> </span>    from tlslite.utils import pycrypto_aes
<span class="w"> </span>    from tlslite.utils import pycrypto_aesgcm
<span class="w"> </span>    from tlslite.utils import pycrypto_rc4
<span class="w"> </span>    from tlslite.utils import pycrypto_tripledes

<span class="gi">+# **************************************************************************</span>
<span class="gi">+# Factory Functions for AES</span>
<span class="gi">+# **************************************************************************</span>

<span class="w"> </span>def createAES(key, IV, implList=None):
<span class="w"> </span>    &quot;&quot;&quot;Create a new AES object.
<span class="gu">@@ -34,8 +46,17 @@ def createAES(key, IV, implList=None):</span>
<span class="w"> </span>    :rtype: tlslite.utils.AES
<span class="w"> </span>    :returns: An AES object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    if implList is None:</span>
<span class="gi">+        implList = [&quot;openssl&quot;, &quot;pycrypto&quot;, &quot;python&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    for impl in implList:</span>
<span class="gi">+        if impl == &quot;openssl&quot; and cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            return openssl_aes.new(key, 2, IV)</span>
<span class="gi">+        elif impl == &quot;pycrypto&quot; and cryptomath.pycryptoLoaded:</span>
<span class="gi">+            return pycrypto_aes.new(key, 2, IV)</span>
<span class="gi">+        elif impl == &quot;python&quot;:</span>
<span class="gi">+                return python_aes.new(key, 2, IV)</span>
<span class="gi">+    raise NotImplementedError()</span>

<span class="w"> </span>def createAESCTR(key, IV, implList=None):
<span class="w"> </span>    &quot;&quot;&quot;Create a new AESCTR object.
<span class="gu">@@ -49,8 +70,13 @@ def createAESCTR(key, IV, implList=None):</span>
<span class="w"> </span>    :rtype: tlslite.utils.AES
<span class="w"> </span>    :returns: An AES object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if implList is None:</span>
<span class="gi">+        implList = [&quot;python&quot;]</span>

<span class="gi">+    for impl in implList:</span>
<span class="gi">+        if impl == &quot;python&quot;:</span>
<span class="gi">+            return python_aes.new(key, 6, IV)</span>
<span class="gi">+    raise NotImplementedError()</span>

<span class="w"> </span>def createAESGCM(key, implList=None):
<span class="w"> </span>    &quot;&quot;&quot;Create a new AESGCM object.
<span class="gu">@@ -61,8 +87,17 @@ def createAESGCM(key, implList=None):</span>
<span class="w"> </span>    :rtype: tlslite.utils.AESGCM
<span class="w"> </span>    :returns: An AESGCM object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    if implList is None:</span>
<span class="gi">+        implList = [&quot;openssl&quot;, &quot;pycrypto&quot;, &quot;python&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    for impl in implList:</span>
<span class="gi">+        if impl == &quot;openssl&quot; and cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            return openssl_aesgcm.new(key)</span>
<span class="gi">+        if impl == &quot;pycrypto&quot; and cryptomath.pycryptoLoaded:</span>
<span class="gi">+            return pycrypto_aesgcm.new(key)</span>
<span class="gi">+        if impl == &quot;python&quot;:</span>
<span class="gi">+            return python_aesgcm.new(key)</span>
<span class="gi">+    raise NotImplementedError()</span>

<span class="w"> </span>def createAESCCM(key, implList=None):
<span class="w"> </span>    &quot;&quot;&quot; Create a new AESCCM object.
<span class="gu">@@ -73,8 +108,17 @@ def createAESCCM(key, implList=None):</span>
<span class="w"> </span>    :rtype: tlslite.utils.AESCCM
<span class="w"> </span>    :returns: An AESCCM object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if implList is None:</span>
<span class="gi">+        implList = [&quot;openssl&quot;, &quot;python&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    for impl in implList:</span>
<span class="gi">+        if impl == &quot;openssl&quot; and cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            return openssl_aesccm.new(key)</span>
<span class="gi">+        if impl == &quot;python&quot;:</span>
<span class="gi">+            return python_aesccm.new(key)</span>
<span class="gi">+</span>
<span class="gi">+    raise NotImplementedError()</span>

<span class="w"> </span>def createAESCCM_8(key, implList=None):
<span class="w"> </span>    &quot;&quot;&quot; Create a new AESCCM object with truncated tag.
<span class="gu">@@ -85,8 +129,17 @@ def createAESCCM_8(key, implList=None):</span>
<span class="w"> </span>    :rtype: tlslite.utils.AESCCM
<span class="w"> </span>    :returns: An AESCCM object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if implList is None:</span>
<span class="gi">+        implList = [&quot;openssl&quot;, &quot;python&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    for impl in implList:</span>
<span class="gi">+        if impl == &quot;openssl&quot; and cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            return openssl_aesccm.new(key, 8)</span>
<span class="gi">+        if impl == &quot;python&quot;:</span>
<span class="gi">+            return python_aesccm.new(key, 8)</span>
<span class="gi">+</span>
<span class="gi">+    raise NotImplementedError()</span>

<span class="w"> </span>def createCHACHA20(key, implList=None):
<span class="w"> </span>    &quot;&quot;&quot;Create a new CHACHA20_POLY1305 object.
<span class="gu">@@ -97,8 +150,13 @@ def createCHACHA20(key, implList=None):</span>
<span class="w"> </span>    :rtype: tlslite.utils.CHACHA20_POLY1305
<span class="w"> </span>    :returns: A ChaCha20/Poly1305 object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if implList is None:</span>
<span class="gi">+        implList = [&quot;python&quot;]</span>

<span class="gi">+    for impl in implList:</span>
<span class="gi">+        if impl == &quot;python&quot;:</span>
<span class="gi">+            return python_chacha20_poly1305.new(key)</span>
<span class="gi">+    raise NotImplementedError()</span>

<span class="w"> </span>def createRC4(key, IV, implList=None):
<span class="w"> </span>    &quot;&quot;&quot;Create a new RC4 object.
<span class="gu">@@ -112,9 +170,21 @@ def createRC4(key, IV, implList=None):</span>
<span class="w"> </span>    :rtype: tlslite.utils.RC4
<span class="w"> </span>    :returns: An RC4 object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    if implList is None:</span>
<span class="gi">+        implList = [&quot;openssl&quot;, &quot;pycrypto&quot;, &quot;python&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    if len(IV) != 0:</span>
<span class="gi">+        raise AssertionError()</span>
<span class="gi">+    for impl in implList:</span>
<span class="gi">+        if impl == &quot;openssl&quot; and cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            return openssl_rc4.new(key)</span>
<span class="gi">+        elif impl == &quot;pycrypto&quot; and cryptomath.pycryptoLoaded:</span>
<span class="gi">+            return pycrypto_rc4.new(key)</span>
<span class="gi">+        elif impl == &quot;python&quot;:</span>
<span class="gi">+            return python_rc4.new(key)</span>
<span class="gi">+    raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+#Create a new TripleDES instance</span>
<span class="w"> </span>def createTripleDES(key, IV, implList=None):
<span class="w"> </span>    &quot;&quot;&quot;Create a new 3DES object.

<span class="gu">@@ -127,4 +197,14 @@ def createTripleDES(key, IV, implList=None):</span>
<span class="w"> </span>    :rtype: tlslite.utils.TripleDES
<span class="w"> </span>    :returns: A 3DES object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if implList is None:</span>
<span class="gi">+        implList = [&quot;openssl&quot;, &quot;pycrypto&quot;, &quot;python&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    for impl in implList:</span>
<span class="gi">+        if impl == &quot;openssl&quot; and cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            return openssl_tripledes.new(key, 2, IV)</span>
<span class="gi">+        elif impl == &quot;pycrypto&quot; and cryptomath.pycryptoLoaded:</span>
<span class="gi">+            return pycrypto_tripledes.new(key, 2, IV)</span>
<span class="gi">+        elif impl == &quot;python&quot;:</span>
<span class="gi">+            return python_tripledes.new(key, IV)</span>
<span class="gi">+    raise NotImplementedError()</span>
<span class="gh">diff --git a/tlslite/utils/codec.py b/tlslite/utils/codec.py</span>
<span class="gh">index bd40984..71fb306 100644</span>
<span class="gd">--- a/tlslite/utils/codec.py</span>
<span class="gi">+++ b/tlslite/utils/codec.py</span>
<span class="gu">@@ -1,5 +1,10 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Classes for reading/writing binary data (such as TLS records).&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import division
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import struct
<span class="w"> </span>from struct import pack
<span class="gu">@@ -25,35 +30,53 @@ class Writer(object):</span>

<span class="w"> </span>    def addOne(self, val):
<span class="w"> </span>        &quot;&quot;&quot;Add a single-byte wide element to buffer, see add().&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    if sys.version_info &lt; (2, 7):</span>
<span class="gi">+        self.bytes.append(val)</span>

<span class="gi">+    if sys.version_info &lt; (2, 7):</span>
<span class="gi">+        # struct.pack on Python2.6 does not raise exception if the value</span>
<span class="gi">+        # is larger than can fit inside the specified size</span>
<span class="w"> </span>        def addTwo(self, val):
<span class="w"> </span>            &quot;&quot;&quot;Add a double-byte wide element to buffer, see add().&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if not 0 &lt;= val &lt;= 0xffff:</span>
<span class="gi">+                raise ValueError(&quot;Can&#39;t represent value in specified length&quot;)</span>
<span class="gi">+            self.bytes += pack(&#39;&gt;H&#39;, val)</span>

<span class="w"> </span>        def addThree(self, val):
<span class="w"> </span>            &quot;&quot;&quot;Add a three-byte wide element to buffer, see add().&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if not 0 &lt;= val &lt;= 0xffffff:</span>
<span class="gi">+                raise ValueError(&quot;Can&#39;t represent value in specified length&quot;)</span>
<span class="gi">+            self.bytes += pack(&#39;&gt;BH&#39;, val &gt;&gt; 16, val &amp; 0xffff)</span>

<span class="w"> </span>        def addFour(self, val):
<span class="w"> </span>            &quot;&quot;&quot;Add a four-byte wide element to buffer, see add().&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if not 0 &lt;= val &lt;= 0xffffffff:</span>
<span class="gi">+                raise ValueError(&quot;Can&#39;t represent value in specified length&quot;)</span>
<span class="gi">+            self.bytes += pack(&#39;&gt;I&#39;, val)</span>
<span class="w"> </span>    else:
<span class="gd">-</span>
<span class="w"> </span>        def addTwo(self, val):
<span class="w"> </span>            &quot;&quot;&quot;Add a double-byte wide element to buffer, see add().&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.bytes += pack(&#39;&gt;H&#39;, val)</span>
<span class="gi">+            except struct.error:</span>
<span class="gi">+                raise ValueError(&quot;Can&#39;t represent value in specified length&quot;)</span>

<span class="w"> </span>        def addThree(self, val):
<span class="w"> </span>            &quot;&quot;&quot;Add a three-byte wide element to buffer, see add().&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.bytes += pack(&#39;&gt;BH&#39;, val &gt;&gt; 16, val &amp; 0xffff)</span>
<span class="gi">+            except struct.error:</span>
<span class="gi">+                raise ValueError(&quot;Can&#39;t represent value in specified length&quot;)</span>

<span class="w"> </span>        def addFour(self, val):
<span class="w"> </span>            &quot;&quot;&quot;Add a four-byte wide element to buffer, see add().&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gd">-    if sys.version_info &gt;= (3, 0):</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.bytes += pack(&#39;&gt;I&#39;, val)</span>
<span class="gi">+            except struct.error:</span>
<span class="gi">+                raise ValueError(&quot;Can&#39;t represent value in specified length&quot;)</span>

<span class="gi">+    if sys.version_info &gt;= (3, 0):</span>
<span class="gi">+        # the method is called thousands of times, so it&#39;s better to extern</span>
<span class="gi">+        # the version info check</span>
<span class="w"> </span>        def add(self, x, length):
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            Add a single positive integer value x, encode it in length bytes
<span class="gu">@@ -67,9 +90,12 @@ class Writer(object):</span>
<span class="w"> </span>            :type length: int
<span class="w"> </span>            :param length: number of bytes to use for encoding the value
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.bytes += x.to_bytes(length, &#39;big&#39;)</span>
<span class="gi">+            except OverflowError:</span>
<span class="gi">+                raise ValueError(&quot;Can&#39;t represent value in specified length&quot;)</span>
<span class="w"> </span>    else:
<span class="gd">-        _addMethods = {(1): addOne, (2): addTwo, (3): addThree, (4): addFour}</span>
<span class="gi">+        _addMethods = {1: addOne, 2: addTwo, 3: addThree, 4: addFour}</span>

<span class="w"> </span>        def add(self, x, length):
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gu">@@ -84,7 +110,17 @@ class Writer(object):</span>
<span class="w"> </span>            :type length: int
<span class="w"> </span>            :param length: number of bytes to use for encoding the value
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._addMethods[length](self, x)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                self.bytes += bytearray(length)</span>
<span class="gi">+                newIndex = len(self.bytes) - 1</span>
<span class="gi">+                for i in range(newIndex, newIndex - length, -1):</span>
<span class="gi">+                    self.bytes[i] = x &amp; 0xFF</span>
<span class="gi">+                    x &gt;&gt;= 8</span>
<span class="gi">+                if x != 0:</span>
<span class="gi">+                    raise ValueError(&quot;Can&#39;t represent value in specified &quot;</span>
<span class="gi">+                                     &quot;length&quot;)</span>

<span class="w"> </span>    def addFixSeq(self, seq, length):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -99,12 +135,18 @@ class Writer(object):</span>
<span class="w"> </span>        :type length: int
<span class="w"> </span>        :param length: number of bytes to which encode every element
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    if sys.version_info &lt; (2, 7):</span>
<span class="gi">+        for e in seq:</span>
<span class="gi">+            self.add(e, length)</span>

<span class="gi">+    if sys.version_info &lt; (2, 7):</span>
<span class="gi">+        # struct.pack on Python2.6 does not raise exception if the value</span>
<span class="gi">+        # is larger than can fit inside the specified size</span>
<span class="w"> </span>        def _addVarSeqTwo(self, seq):
<span class="w"> </span>            &quot;&quot;&quot;Helper method for addVarSeq&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if not all(0 &lt;= i &lt;= 0xffff for i in seq):</span>
<span class="gi">+                raise ValueError(&quot;Can&#39;t represent value in specified &quot;</span>
<span class="gi">+                                 &quot;length&quot;)</span>
<span class="gi">+            self.bytes += pack(&#39;&gt;&#39; + &#39;H&#39; * len(seq), *seq)</span>

<span class="w"> </span>        def addVarSeq(self, seq, length, lengthLength):
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gu">@@ -123,9 +165,15 @@ class Writer(object):</span>
<span class="w"> </span>            :param lengthLength: amount of bytes in which to encode the overall
<span class="w"> </span>                length of the array
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            self.add(len(seq)*length, lengthLength)</span>
<span class="gi">+            if length == 1:</span>
<span class="gi">+                self.bytes.extend(seq)</span>
<span class="gi">+            elif length == 2:</span>
<span class="gi">+                self._addVarSeqTwo(seq)</span>
<span class="gi">+            else:</span>
<span class="gi">+                for i in seq:</span>
<span class="gi">+                    self.add(i, length)</span>
<span class="w"> </span>    else:
<span class="gd">-</span>
<span class="w"> </span>        def addVarSeq(self, seq, length, lengthLength):
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            Add a bounded list of same-sized values
<span class="gu">@@ -143,7 +191,19 @@ class Writer(object):</span>
<span class="w"> </span>            :param lengthLength: amount of bytes in which to encode the overall
<span class="w"> </span>                length of the array
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            seqLen = len(seq)</span>
<span class="gi">+            self.add(seqLen*length, lengthLength)</span>
<span class="gi">+            if length == 1:</span>
<span class="gi">+                self.bytes.extend(seq)</span>
<span class="gi">+            elif length == 2:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self.bytes += pack(&#39;&gt;&#39; + &#39;H&#39; * seqLen, *seq)</span>
<span class="gi">+                except struct.error:</span>
<span class="gi">+                    raise ValueError(&quot;Can&#39;t represent value in specified &quot;</span>
<span class="gi">+                                     &quot;length&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                for i in seq:</span>
<span class="gi">+                    self.add(i, length)</span>

<span class="w"> </span>    def addVarTupleSeq(self, seq, length, lengthLength):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -162,7 +222,23 @@ class Writer(object):</span>
<span class="w"> </span>        :type lengthLength: int
<span class="w"> </span>        :param lengthLength: length in bytes of overall length field
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not seq:</span>
<span class="gi">+            self.add(0, lengthLength)</span>
<span class="gi">+        else:</span>
<span class="gi">+            startPos = len(self.bytes)</span>
<span class="gi">+            dataLength = len(seq) * len(seq[0]) * length</span>
<span class="gi">+            self.add(dataLength, lengthLength)</span>
<span class="gi">+            # since at the time of writing, all the calls encode single byte</span>
<span class="gi">+            # elements, and it&#39;s very easy to speed up that case, give it</span>
<span class="gi">+            # special case</span>
<span class="gi">+            if length == 1:</span>
<span class="gi">+                for elemTuple in seq:</span>
<span class="gi">+                    self.bytes.extend(elemTuple)</span>
<span class="gi">+            else:</span>
<span class="gi">+                for elemTuple in seq:</span>
<span class="gi">+                    self.addFixSeq(elemTuple, length)</span>
<span class="gi">+            if startPos + dataLength + lengthLength != len(self.bytes):</span>
<span class="gi">+                raise ValueError(&quot;Tuples of different lengths&quot;)</span>

<span class="w"> </span>    def add_var_bytes(self, data, length_length):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -176,7 +252,9 @@ class Writer(object):</span>
<span class="w"> </span>        :param int length_length: size of the field to represent the length
<span class="w"> </span>            of the data string
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        length = len(data)</span>
<span class="gi">+        self.add(length, length_length)</span>
<span class="gi">+        self.bytes += data</span>


<span class="w"> </span>class Parser(object):
<span class="gu">@@ -228,7 +306,8 @@ class Parser(object):</span>

<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = self.getFixBytes(length)</span>
<span class="gi">+        return bytes_to_int(ret, &#39;big&#39;)</span>

<span class="w"> </span>    def getFixBytes(self, lengthBytes):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -239,11 +318,18 @@ class Parser(object):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        end = self.index + lengthBytes</span>
<span class="gi">+        if end &gt; len(self.bytes):</span>
<span class="gi">+            raise DecodeError(&quot;Read past end of buffer&quot;)</span>
<span class="gi">+        ret = self.bytes[self.index : end]</span>
<span class="gi">+        self.index += lengthBytes</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def skip_bytes(self, length):
<span class="w"> </span>        &quot;&quot;&quot;Move the internal pointer ahead length bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.index + length &gt; len(self.bytes):</span>
<span class="gi">+            raise DecodeError(&quot;Read past end of buffer&quot;)</span>
<span class="gi">+        self.index += length</span>

<span class="w"> </span>    def getVarBytes(self, lengthLength):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -257,7 +343,8 @@ class Parser(object):</span>

<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lengthBytes = self.get(lengthLength)</span>
<span class="gi">+        return self.getFixBytes(lengthBytes)</span>

<span class="w"> </span>    def getFixList(self, length, lengthList):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -271,7 +358,10 @@ class Parser(object):</span>

<span class="w"> </span>        :rtype: list of int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        l = [0] * lengthList</span>
<span class="gi">+        for x in range(lengthList):</span>
<span class="gi">+            l[x] = self.get(length)</span>
<span class="gi">+        return l</span>

<span class="w"> </span>    def getVarList(self, length, lengthLength):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -285,7 +375,15 @@ class Parser(object):</span>

<span class="w"> </span>        :rtype: list of int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lengthList = self.get(lengthLength)</span>
<span class="gi">+        if lengthList % length != 0:</span>
<span class="gi">+            raise DecodeError(&quot;Encoded length not a multiple of element &quot;</span>
<span class="gi">+                              &quot;length&quot;)</span>
<span class="gi">+        lengthList = lengthList // length</span>
<span class="gi">+        l = [0] * lengthList</span>
<span class="gi">+        for x in range(lengthList):</span>
<span class="gi">+            l[x] = self.get(length)</span>
<span class="gi">+        return l</span>

<span class="w"> </span>    def getVarTupleList(self, elemLength, elemNum, lengthLength):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -302,7 +400,18 @@ class Parser(object):</span>

<span class="w"> </span>        :rtype: list of tuple of int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lengthList = self.get(lengthLength)</span>
<span class="gi">+        if lengthList % (elemLength * elemNum) != 0:</span>
<span class="gi">+            raise DecodeError(&quot;Encoded length not a multiple of element &quot;</span>
<span class="gi">+                              &quot;length&quot;)</span>
<span class="gi">+        tupleCount = lengthList // (elemLength * elemNum)</span>
<span class="gi">+        tupleList = []</span>
<span class="gi">+        for _ in range(tupleCount):</span>
<span class="gi">+            currentTuple = []</span>
<span class="gi">+            for _ in range(elemNum):</span>
<span class="gi">+                currentTuple.append(self.get(elemLength))</span>
<span class="gi">+            tupleList.append(tuple(currentTuple))</span>
<span class="gi">+        return tupleList</span>

<span class="w"> </span>    def startLengthCheck(self, lengthLength):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -311,7 +420,8 @@ class Parser(object):</span>
<span class="w"> </span>        :type lengthLength: int
<span class="w"> </span>        :param lengthLength: number of bytes in which the length is encoded
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.lengthCheck = self.get(lengthLength)</span>
<span class="gi">+        self.indexCheck = self.index</span>

<span class="w"> </span>    def setLengthCheck(self, length):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -320,7 +430,8 @@ class Parser(object):</span>
<span class="w"> </span>        :type length: int
<span class="w"> </span>        :param length: expected size of parsed struct in bytes
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.lengthCheck = length</span>
<span class="gi">+        self.indexCheck = self.index</span>

<span class="w"> </span>    def stopLengthCheck(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -329,7 +440,8 @@ class Parser(object):</span>
<span class="w"> </span>        In case the expected length was mismatched with actual length of
<span class="w"> </span>        processed data, raises an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (self.index - self.indexCheck) != self.lengthCheck:</span>
<span class="gi">+            raise DecodeError(&quot;Under- or over-flow while reading buffer&quot;)</span>

<span class="w"> </span>    def atLengthCheck(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -341,8 +453,13 @@ class Parser(object):</span>
<span class="w"> </span>        Will raise an exception if overflow occured (amount of data read was
<span class="w"> </span>        greater than expected size)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (self.index - self.indexCheck) &lt; self.lengthCheck:</span>
<span class="gi">+            return False</span>
<span class="gi">+        elif (self.index - self.indexCheck) == self.lengthCheck:</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise DecodeError(&quot;Read past end of buffer&quot;)</span>

<span class="w"> </span>    def getRemainingLength(self):
<span class="w"> </span>        &quot;&quot;&quot;Return amount of data remaining in struct being parsed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.bytes) - self.index</span>
<span class="gh">diff --git a/tlslite/utils/compat.py b/tlslite/utils/compat.py</span>
<span class="gh">index 103b51c..542c3b0 100644</span>
<span class="gd">--- a/tlslite/utils/compat.py</span>
<span class="gi">+++ b/tlslite/utils/compat.py</span>
<span class="gu">@@ -1,4 +1,8 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Miscellaneous functions to mask Python version differences.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import re
<span class="w"> </span>import os
<span class="gu">@@ -8,100 +12,218 @@ import binascii</span>
<span class="w"> </span>import traceback
<span class="w"> </span>import time
<span class="w"> </span>import ecdsa
<span class="gd">-if sys.version_info &gt;= (3, 0):</span>
<span class="gd">-    if sys.version_info &lt; (3, 4):</span>

<span class="gi">+if sys.version_info &gt;= (3,0):</span>
<span class="gi">+</span>
<span class="gi">+    def compat26Str(x): return x</span>
<span class="gi">+</span>
<span class="gi">+    # Python 3.3 requires bytes instead of bytearrays for HMAC</span>
<span class="gi">+    # So, python 2.6 requires strings, python 3 requires &#39;bytes&#39;,</span>
<span class="gi">+    # and python 2.7 and 3.5 can handle bytearrays...</span>
<span class="gi">+    # pylint: disable=invalid-name</span>
<span class="gi">+    # we need to keep compatHMAC and `x` for API compatibility</span>
<span class="gi">+    if sys.version_info &lt; (3, 4):</span>
<span class="w"> </span>        def compatHMAC(x):
<span class="w"> </span>            &quot;&quot;&quot;Convert bytes-like input to format acceptable for HMAC.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return bytes(x)</span>
<span class="w"> </span>    else:
<span class="gd">-</span>
<span class="w"> </span>        def compatHMAC(x):
<span class="w"> </span>            &quot;&quot;&quot;Convert bytes-like input to format acceptable for HMAC.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return x</span>
<span class="gi">+    # pylint: enable=invalid-name</span>

<span class="w"> </span>    def compatAscii2Bytes(val):
<span class="w"> </span>        &quot;&quot;&quot;Convert ASCII string to bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(val, str):</span>
<span class="gi">+            return bytes(val, &#39;ascii&#39;)</span>
<span class="gi">+        return val</span>

<span class="w"> </span>    def compat_b2a(val):
<span class="w"> </span>        &quot;&quot;&quot;Convert an ASCII bytes string to string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return str(val, &#39;ascii&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def raw_input(s):</span>
<span class="gi">+        return input(s)</span>
<span class="gi">+    </span>
<span class="gi">+    # So, the python3 binascii module deals with bytearrays, and python2</span>
<span class="gi">+    # deals with strings...  I would rather deal with the &quot;a&quot; part as</span>
<span class="gi">+    # strings, and the &quot;b&quot; part as bytearrays, regardless of python version,</span>
<span class="gi">+    # so...</span>
<span class="gi">+    def a2b_hex(s):</span>
<span class="gi">+        try:</span>
<span class="gi">+            b = bytearray(binascii.a2b_hex(bytearray(s, &quot;ascii&quot;)))</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise SyntaxError(&quot;base16 error: %s&quot; % e) </span>
<span class="gi">+        return b  </span>
<span class="gi">+</span>
<span class="gi">+    def a2b_base64(s):</span>
<span class="gi">+        try:</span>
<span class="gi">+            if isinstance(s, str):</span>
<span class="gi">+                s = bytearray(s, &quot;ascii&quot;)</span>
<span class="gi">+            b = bytearray(binascii.a2b_base64(s))</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise SyntaxError(&quot;base64 error: %s&quot; % e)</span>
<span class="gi">+        return b</span>
<span class="gi">+</span>
<span class="gi">+    def b2a_hex(b):</span>
<span class="gi">+        return binascii.b2a_hex(b).decode(&quot;ascii&quot;)    </span>
<span class="gi">+            </span>
<span class="gi">+    def b2a_base64(b):</span>
<span class="gi">+        return binascii.b2a_base64(b).decode(&quot;ascii&quot;) </span>
<span class="gi">+</span>
<span class="gi">+    def readStdinBinary():</span>
<span class="gi">+        return sys.stdin.buffer.read()        </span>
<span class="gi">+</span>
<span class="gi">+    def compatLong(num):</span>
<span class="gi">+        return int(num)</span>
<span class="gi">+</span>
<span class="w"> </span>    int_types = tuple([int])

<span class="w"> </span>    def formatExceptionTrace(e):
<span class="w"> </span>        &quot;&quot;&quot;Return exception information formatted as string&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return str(e)</span>

<span class="w"> </span>    def time_stamp():
<span class="w"> </span>        &quot;&quot;&quot;Returns system time as a float&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if sys.version_info &gt;= (3, 3):</span>
<span class="gi">+            return time.perf_counter()</span>
<span class="gi">+        return time.clock()</span>

<span class="w"> </span>    def remove_whitespace(text):
<span class="w"> </span>        &quot;&quot;&quot;Removes all whitespace from passed in string&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return re.sub(r&quot;\s+&quot;, &quot;&quot;, text, flags=re.UNICODE)</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable=invalid-name</span>
<span class="gi">+    # pylint is stupid here and deson&#39;t notice it&#39;s a function, not</span>
<span class="gi">+    # constant</span>
<span class="w"> </span>    bytes_to_int = int.from_bytes
<span class="gi">+    # pylint: enable=invalid-name</span>

<span class="w"> </span>    def bit_length(val):
<span class="w"> </span>        &quot;&quot;&quot;Return number of bits necessary to represent an integer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return val.bit_length()</span>

<span class="gd">-    def int_to_bytes(val, length=None, byteorder=&#39;big&#39;):</span>
<span class="gi">+    def int_to_bytes(val, length=None, byteorder=&quot;big&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Return number converted to bytes&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            length = byte_length(val)</span>
<span class="gi">+        # for gmpy we need to convert back to native int</span>
<span class="gi">+        if type(val) != int:</span>
<span class="gi">+            val = int(val)</span>
<span class="gi">+        return bytearray(val.to_bytes(length=length, byteorder=byteorder))</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="gd">-    if sys.version_info &lt; (2, 7) or sys.version_info &lt; (2, 7, 4</span>
<span class="gd">-        ) or platform.system() == &#39;Java&#39;:</span>
<span class="gi">+    # Python 2.6 requires strings instead of bytearrays in a couple places,</span>
<span class="gi">+    # so we define this function so it does the conversion if needed.</span>
<span class="gi">+    # same thing with very old 2.7 versions</span>
<span class="gi">+    # or on Jython</span>
<span class="gi">+    if sys.version_info &lt; (2, 7) or sys.version_info &lt; (2, 7, 4) \</span>
<span class="gi">+            or platform.system() == &#39;Java&#39;:</span>
<span class="gi">+        def compat26Str(x): return str(x)</span>

<span class="w"> </span>        def remove_whitespace(text):
<span class="w"> </span>            &quot;&quot;&quot;Removes all whitespace from passed in string&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return re.sub(r&quot;\s+&quot;, &quot;&quot;, text)</span>

<span class="w"> </span>        def bit_length(val):
<span class="w"> </span>            &quot;&quot;&quot;Return number of bits necessary to represent an integer.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if val == 0:</span>
<span class="gi">+                return 0</span>
<span class="gi">+            return len(bin(val))-2</span>
<span class="w"> </span>    else:
<span class="gi">+        def compat26Str(x): return x</span>

<span class="w"> </span>        def remove_whitespace(text):
<span class="w"> </span>            &quot;&quot;&quot;Removes all whitespace from passed in string&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return re.sub(r&quot;\s+&quot;, &quot;&quot;, text, flags=re.UNICODE)</span>

<span class="w"> </span>        def bit_length(val):
<span class="w"> </span>            &quot;&quot;&quot;Return number of bits necessary to represent an integer.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return val.bit_length()</span>

<span class="w"> </span>    def compatAscii2Bytes(val):
<span class="w"> </span>        &quot;&quot;&quot;Convert ASCII string to bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return val</span>

<span class="w"> </span>    def compat_b2a(val):
<span class="w"> </span>        &quot;&quot;&quot;Convert an ASCII bytes string to string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    int_types = int, long</span>
<span class="gd">-</span>
<span class="gi">+        return str(val)</span>
<span class="gi">+</span>
<span class="gi">+    # So, python 2.6 requires strings, python 3 requires &#39;bytes&#39;,</span>
<span class="gi">+    # and python 2.7 can handle bytearrays...     </span>
<span class="gi">+    def compatHMAC(x): return compat26Str(x)</span>
<span class="gi">+</span>
<span class="gi">+    def a2b_hex(s):</span>
<span class="gi">+        try:</span>
<span class="gi">+            b = bytearray(binascii.a2b_hex(s))</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise SyntaxError(&quot;base16 error: %s&quot; % e)</span>
<span class="gi">+        return b</span>
<span class="gi">+</span>
<span class="gi">+    def a2b_base64(s):</span>
<span class="gi">+        try:</span>
<span class="gi">+            b = bytearray(binascii.a2b_base64(s))</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise SyntaxError(&quot;base64 error: %s&quot; % e)</span>
<span class="gi">+        return b</span>
<span class="gi">+        </span>
<span class="gi">+    def b2a_hex(b):</span>
<span class="gi">+        return binascii.b2a_hex(compat26Str(b))</span>
<span class="gi">+        </span>
<span class="gi">+    def b2a_base64(b):</span>
<span class="gi">+        return binascii.b2a_base64(compat26Str(b))</span>
<span class="gi">+</span>
<span class="gi">+    def compatLong(num):</span>
<span class="gi">+        return long(num)</span>
<span class="gi">+</span>
<span class="gi">+    int_types = (int, long)</span>
<span class="gi">+</span>
<span class="gi">+    # pylint on Python3 goes nuts for the sys dereferences...</span>
<span class="gi">+</span>
<span class="gi">+    #pylint: disable=no-member</span>
<span class="w"> </span>    def formatExceptionTrace(e):
<span class="w"> </span>        &quot;&quot;&quot;Return exception information formatted as string&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        newStr = &quot;&quot;.join(traceback.format_exception(sys.exc_type,</span>
<span class="gi">+                                                    sys.exc_value,</span>
<span class="gi">+                                                    sys.exc_traceback))</span>
<span class="gi">+        return newStr</span>
<span class="gi">+    #pylint: enable=no-member</span>

<span class="w"> </span>    def time_stamp():
<span class="w"> </span>        &quot;&quot;&quot;Returns system time as a float&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return time.clock()</span>

<span class="w"> </span>    def bytes_to_int(val, byteorder):
<span class="w"> </span>        &quot;&quot;&quot;Convert bytes to an int.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def int_to_bytes(val, length=None, byteorder=&#39;big&#39;):</span>
<span class="gi">+        if not val:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        if byteorder == &quot;big&quot;:</span>
<span class="gi">+            return int(b2a_hex(val), 16)</span>
<span class="gi">+        if byteorder == &quot;little&quot;:</span>
<span class="gi">+            return int(b2a_hex(val[::-1]), 16)</span>
<span class="gi">+        raise ValueError(&quot;Only &#39;big&#39; and &#39;little&#39; endian supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def int_to_bytes(val, length=None, byteorder=&quot;big&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Return number converted to bytes&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            length = byte_length(val)</span>
<span class="gi">+        if byteorder == &quot;big&quot;:</span>
<span class="gi">+            return bytearray((val &gt;&gt; i) &amp; 0xff</span>
<span class="gi">+                             for i in reversed(range(0, length*8, 8)))</span>
<span class="gi">+        if byteorder == &quot;little&quot;:</span>
<span class="gi">+            return bytearray((val &gt;&gt; i) &amp; 0xff</span>
<span class="gi">+                             for i in range(0, length*8, 8))</span>
<span class="gi">+        raise ValueError(&quot;Only &#39;big&#39; or &#39;little&#39; endian supported&quot;)</span>


<span class="w"> </span>def byte_length(val):
<span class="w"> </span>    &quot;&quot;&quot;Return number of bytes necessary to represent an integer.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    length = bit_length(val)</span>
<span class="gi">+    return (length + 7) // 8</span>


<span class="w"> </span>try:
<span class="gi">+    # Fedora and Red Hat Enterprise Linux versions have small curves removed</span>
<span class="w"> </span>    getattr(ecdsa, &#39;NIST192p&#39;)
<span class="w"> </span>except AttributeError:
<span class="w"> </span>    ecdsaAllCurves = False
<span class="gh">diff --git a/tlslite/utils/constanttime.py b/tlslite/utils/constanttime.py</span>
<span class="gh">index e520a94..8d4541e 100644</span>
<span class="gd">--- a/tlslite/utils/constanttime.py</span>
<span class="gi">+++ b/tlslite/utils/constanttime.py</span>
<span class="gu">@@ -1,9 +1,13 @@</span>
<span class="gi">+# Copyright (c) 2015, Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="w"> </span>&quot;&quot;&quot;Various constant time functions for processing sensitive data&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import division
<span class="gi">+</span>
<span class="w"> </span>from .compat import compatHMAC
<span class="w"> </span>import hmac

<span class="gd">-</span>
<span class="w"> </span>def ct_lt_u32(val_a, val_b):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns 1 if val_a &lt; val_b, 0 otherwise. Constant time.
<span class="gu">@@ -14,7 +18,10 @@ def ct_lt_u32(val_a, val_b):</span>
<span class="w"> </span>    :param val_b: an unsigned integer representable as a 32 bit value
<span class="w"> </span>    :rtype: int
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    val_a &amp;= 0xffffffff</span>
<span class="gi">+    val_b &amp;= 0xffffffff</span>
<span class="gi">+</span>
<span class="gi">+    return (val_a^((val_a^val_b)|(((val_a-val_b)&amp;0xffffffff)^val_b)))&gt;&gt;31</span>


<span class="w"> </span>def ct_gt_u32(val_a, val_b):
<span class="gu">@@ -27,7 +34,7 @@ def ct_gt_u32(val_a, val_b):</span>
<span class="w"> </span>    :param val_b: an unsigned integer representable as a 32 bit value
<span class="w"> </span>    :rtype: int
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return ct_lt_u32(val_b, val_a)</span>


<span class="w"> </span>def ct_le_u32(val_a, val_b):
<span class="gu">@@ -40,17 +47,26 @@ def ct_le_u32(val_a, val_b):</span>
<span class="w"> </span>    :param val_b: an unsigned integer representable as a 32 bit value
<span class="w"> </span>    :rtype: int
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return 1 ^ ct_gt_u32(val_a, val_b)</span>


<span class="w"> </span>def ct_lsb_prop_u8(val):
<span class="w"> </span>    &quot;&quot;&quot;Propagate LSB to all 8 bits of the returned int. Constant time.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    val &amp;= 0x01</span>
<span class="gi">+    val |= val &lt;&lt; 1</span>
<span class="gi">+    val |= val &lt;&lt; 2</span>
<span class="gi">+    val |= val &lt;&lt; 4</span>
<span class="gi">+    return val</span>


<span class="w"> </span>def ct_lsb_prop_u16(val):
<span class="w"> </span>    &quot;&quot;&quot;Propagate LSB to all 16 bits of the returned int. Constant time.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    val &amp;= 0x01</span>
<span class="gi">+    val |= val &lt;&lt; 1</span>
<span class="gi">+    val |= val &lt;&lt; 2</span>
<span class="gi">+    val |= val &lt;&lt; 4</span>
<span class="gi">+    val |= val &lt;&lt; 8</span>
<span class="gi">+    return val</span>


<span class="w"> </span>def ct_isnonzero_u32(val):
<span class="gu">@@ -61,7 +77,8 @@ def ct_isnonzero_u32(val):</span>
<span class="w"> </span>    :param val: an unsigned integer representable as a 32 bit value
<span class="w"> </span>    :rtype: int
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    val &amp;= 0xffffffff</span>
<span class="gi">+    return (val|(-val&amp;0xffffffff)) &gt;&gt; 31</span>


<span class="w"> </span>def ct_neq_u32(val_a, val_b):
<span class="gu">@@ -74,8 +91,10 @@ def ct_neq_u32(val_a, val_b):</span>
<span class="w"> </span>    :param val_b: an unsigned integer representable as a 32 bit value
<span class="w"> </span>    :rtype: int
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    val_a &amp;= 0xffffffff</span>
<span class="gi">+    val_b &amp;= 0xffffffff</span>

<span class="gi">+    return (((val_a-val_b)&amp;0xffffffff) | ((val_b-val_a)&amp;0xffffffff)) &gt;&gt; 31</span>

<span class="w"> </span>def ct_eq_u32(val_a, val_b):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -87,11 +106,10 @@ def ct_eq_u32(val_a, val_b):</span>
<span class="w"> </span>    :param val_b: an unsigned integer representable as a 32 bit value
<span class="w"> </span>    :rtype: int
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    return 1 ^ ct_neq_u32(val_a, val_b)</span>

<span class="w"> </span>def ct_check_cbc_mac_and_pad(data, mac, seqnumBytes, contentType, version,
<span class="gd">-    block_size=16):</span>
<span class="gi">+                             block_size=16):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check CBC cipher HMAC and padding. Close to constant time.

<span class="gu">@@ -114,13 +132,87 @@ def ct_check_cbc_mac_and_pad(data, mac, seqnumBytes, contentType, version,</span>
<span class="w"> </span>    :rtype: boolean
<span class="w"> </span>    :returns: True if MAC and pad is ok, False otherwise
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    assert version in ((3, 0), (3, 1), (3, 2), (3, 3))</span>
<span class="gi">+</span>
<span class="gi">+    data_len = len(data)</span>
<span class="gi">+    if mac.digest_size + 1 &gt; data_len: # data_len is public</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # 0 - OK</span>
<span class="gi">+    result = 0x00</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # check padding</span>
<span class="gi">+    #</span>
<span class="gi">+    pad_length = data[data_len-1]</span>
<span class="gi">+    pad_start = data_len - pad_length - 1</span>
<span class="gi">+    pad_start = max(0, pad_start)</span>
<span class="gi">+</span>
<span class="gi">+    if version == (3, 0): # version is public</span>
<span class="gi">+        # in SSLv3 we can only check if pad is not longer than the cipher</span>
<span class="gi">+        # block size</span>
<span class="gi">+</span>
<span class="gi">+        # subtract 1 for the pad length byte</span>
<span class="gi">+        mask = ct_lsb_prop_u8(ct_lt_u32(block_size, pad_length))</span>
<span class="gi">+        result |= mask</span>
<span class="gi">+    else:</span>
<span class="gi">+        start_pos = max(0, data_len - 256)</span>
<span class="gi">+        for i in range(start_pos, data_len):</span>
<span class="gi">+            # if pad_start &lt; i: mask = 0xff; else: mask = 0x00</span>
<span class="gi">+            mask = ct_lsb_prop_u8(ct_le_u32(pad_start, i))</span>
<span class="gi">+            # if data[i] != pad_length and &quot;inside_pad&quot;: result = False</span>
<span class="gi">+            result |= (data[i] ^ pad_length) &amp; mask</span>
<span class="gi">+</span>
<span class="gi">+    #</span>
<span class="gi">+    # check MAC</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="gi">+    # real place where mac starts and data ends</span>
<span class="gi">+    mac_start = pad_start - mac.digest_size</span>
<span class="gi">+    mac_start = max(0, mac_start)</span>
<span class="gi">+</span>
<span class="gi">+    # place to start processing</span>
<span class="gi">+    start_pos = max(0, data_len - (256 + mac.digest_size)) // mac.block_size</span>
<span class="gi">+    start_pos *= mac.block_size</span>
<span class="gi">+</span>
<span class="gi">+    # add start data</span>
<span class="gi">+    data_mac = mac.copy()</span>
<span class="gi">+    data_mac.update(compatHMAC(seqnumBytes))</span>
<span class="gi">+    data_mac.update(compatHMAC(bytearray([contentType])))</span>
<span class="gi">+    if version != (3, 0): # version is public</span>
<span class="gi">+        data_mac.update(compatHMAC(bytearray([version[0]])))</span>
<span class="gi">+        data_mac.update(compatHMAC(bytearray([version[1]])))</span>
<span class="gi">+    data_mac.update(compatHMAC(bytearray([mac_start &gt;&gt; 8])))</span>
<span class="gi">+    data_mac.update(compatHMAC(bytearray([mac_start &amp; 0xff])))</span>
<span class="gi">+    data_mac.update(compatHMAC(data[:start_pos]))</span>
<span class="gi">+</span>
<span class="gi">+    # don&#39;t check past the array end (already checked to be &gt;= zero)</span>
<span class="gi">+    end_pos = data_len - mac.digest_size</span>
<span class="gi">+</span>
<span class="gi">+    # calculate all possible</span>
<span class="gi">+    for i in range(start_pos, end_pos): # constant for given overall length</span>
<span class="gi">+        cur_mac = data_mac.copy()</span>
<span class="gi">+        cur_mac.update(compatHMAC(data[start_pos:i]))</span>
<span class="gi">+        mac_compare = bytearray(cur_mac.digest())</span>
<span class="gi">+        # compare the hash for real only if it&#39;s the place where mac is</span>
<span class="gi">+        # supposed to be</span>
<span class="gi">+        mask = ct_lsb_prop_u8(ct_eq_u32(i, mac_start))</span>
<span class="gi">+        for j in range(0, mac.digest_size): # digest_size is public</span>
<span class="gi">+            result |= (data[i+j] ^ mac_compare[j]) &amp; mask</span>
<span class="gi">+</span>
<span class="gi">+    # return python boolean</span>
<span class="gi">+    return result == 0</span>

<span class="w"> </span>if hasattr(hmac, &#39;compare_digest&#39;):
<span class="w"> </span>    ct_compare_digest = hmac.compare_digest
<span class="w"> </span>else:
<span class="gd">-</span>
<span class="w"> </span>    def ct_compare_digest(val_a, val_b):
<span class="w"> </span>        &quot;&quot;&quot;Compares if string like objects are equal. Constant time.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(val_a) != len(val_b):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        result = 0</span>
<span class="gi">+        for x, y in zip(val_a, val_b):</span>
<span class="gi">+            result |= x ^ y</span>
<span class="gi">+</span>
<span class="gi">+        return result == 0</span>
<span class="gh">diff --git a/tlslite/utils/cryptomath.py b/tlslite/utils/cryptomath.py</span>
<span class="gh">index 24564a0..0ab0362 100644</span>
<span class="gd">--- a/tlslite/utils/cryptomath.py</span>
<span class="gi">+++ b/tlslite/utils/cryptomath.py</span>
<span class="gu">@@ -1,3 +1,10 @@</span>
<span class="gi">+# Authors: </span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Martin von Loewis - python 3 port</span>
<span class="gi">+#   Yngve Pettersen (ported by Paul Sokolovsky) - TLS 1.2</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;cryptomath module

<span class="w"> </span>This module has basic math/crypto code.&quot;&quot;&quot;
<span class="gu">@@ -6,74 +13,144 @@ import os</span>
<span class="w"> </span>import math
<span class="w"> </span>import base64
<span class="w"> </span>import binascii
<span class="gd">-from .compat import compat26Str, compatHMAC, compatLong, bytes_to_int, int_to_bytes, bit_length, byte_length</span>
<span class="gi">+</span>
<span class="gi">+from .compat import compat26Str, compatHMAC, compatLong, \</span>
<span class="gi">+        bytes_to_int, int_to_bytes, bit_length, byte_length</span>
<span class="w"> </span>from .codec import Writer
<span class="gi">+</span>
<span class="w"> </span>from . import tlshashlib as hashlib
<span class="w"> </span>from . import tlshmac as hmac
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# **************************************************************************</span>
<span class="gi">+# Load Optional Modules</span>
<span class="gi">+# **************************************************************************</span>
<span class="gi">+</span>
<span class="gi">+# Try to load M2Crypto/OpenSSL</span>
<span class="gi">+# pylint: disable=invalid-name</span>
<span class="w"> </span>try:
<span class="w"> </span>    from M2Crypto import m2
<span class="w"> </span>    m2cryptoLoaded = True
<span class="w"> </span>    M2CRYPTO_AES_CTR = False
<span class="w"> </span>    if hasattr(m2, &#39;aes_192_ctr&#39;):
<span class="w"> </span>        M2CRYPTO_AES_CTR = True
<span class="gi">+</span>
<span class="w"> </span>    try:
<span class="w"> </span>        with open(&#39;/proc/sys/crypto/fips_enabled&#39;, &#39;r&#39;) as fipsFile:
<span class="w"> </span>            if &#39;1&#39; in fipsFile.read():
<span class="w"> </span>                m2cryptoLoaded = False
<span class="w"> </span>    except (IOError, OSError):
<span class="gi">+        # looks like we&#39;re running in container, likely not FIPS mode</span>
<span class="w"> </span>        m2cryptoLoaded = True
<span class="gi">+</span>
<span class="gi">+    # If AES-CBC is not available, don&#39;t use m2crypto</span>
<span class="w"> </span>    if not hasattr(m2, &#39;aes_192_cbc&#39;):
<span class="w"> </span>        m2cryptoLoaded = False
<span class="gi">+</span>
<span class="w"> </span>except ImportError:
<span class="w"> </span>    m2cryptoLoaded = False
<span class="gi">+# pylint: enable=invalid-name</span>
<span class="gi">+</span>
<span class="gi">+#Try to load GMPY</span>
<span class="w"> </span>try:
<span class="w"> </span>    import gmpy
<span class="w"> </span>    gmpy.mpz
<span class="w"> </span>    gmpyLoaded = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    gmpyLoaded = False
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Try to load GMPY2</span>
<span class="w"> </span>try:
<span class="w"> </span>    from gmpy2 import powmod
<span class="w"> </span>    GMPY2_LOADED = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    GMPY2_LOADED = False
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Use the faster mpz</span>
<span class="w"> </span>if GMPY2_LOADED:
<span class="w"> </span>    from gmpy2 import mpz
<span class="w"> </span>elif gmpyLoaded:
<span class="w"> </span>    from gmpy import mpz
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#Try to load pycrypto</span>
<span class="gi">+# pylint: disable=invalid-name</span>
<span class="w"> </span>try:
<span class="w"> </span>    import Crypto.Cipher.AES
<span class="gi">+    # check if we&#39;re not using pycryptodome</span>
<span class="w"> </span>    try:
<span class="gd">-        Crypto.Cipher.AES.AESCipher(b&#39;2&#39; * (128 // 8))</span>
<span class="gi">+        # pycrypto defaults to ECB when just key is provided</span>
<span class="gi">+        # pycryptodome requires specifying the mode of operation</span>
<span class="gi">+        Crypto.Cipher.AES.AESCipher(b&#39;2&#39; * (128//8))</span>
<span class="w"> </span>        pycryptoLoaded = True
<span class="w"> </span>    except AttributeError:
<span class="w"> </span>        pycryptoLoaded = False
<span class="w"> </span>except ImportError:
<span class="w"> </span>    pycryptoLoaded = False
<span class="gi">+# pylint: enable=invalid-name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# **************************************************************************</span>
<span class="gi">+# PRNG Functions</span>
<span class="gi">+# **************************************************************************</span>
<span class="gi">+</span>
<span class="gi">+# Check that os.urandom works</span>
<span class="w"> </span>import zlib
<span class="w"> </span>assert len(zlib.compress(os.urandom(1000))) &gt; 900
<span class="gd">-prngName = &#39;os.urandom&#39;</span>

<span class="gi">+def getRandomBytes(howMany):</span>
<span class="gi">+    b = bytearray(os.urandom(howMany))</span>
<span class="gi">+    assert(len(b) == howMany)</span>
<span class="gi">+    return b</span>
<span class="gi">+</span>
<span class="gi">+prngName = &quot;os.urandom&quot;</span>
<span class="gi">+</span>
<span class="gi">+# **************************************************************************</span>
<span class="gi">+# Simple hash functions</span>
<span class="gi">+# **************************************************************************</span>

<span class="w"> </span>def MD5(b):
<span class="w"> </span>    &quot;&quot;&quot;Return a MD5 digest of data&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    return secureHash(b, &#39;md5&#39;)</span>

<span class="w"> </span>def SHA1(b):
<span class="w"> </span>    &quot;&quot;&quot;Return a SHA1 digest of data&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    return secureHash(b, &#39;sha1&#39;)</span>

<span class="w"> </span>def secureHash(data, algorithm):
<span class="w"> </span>    &quot;&quot;&quot;Return a digest of `data` using `algorithm`&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    hashInstance = hashlib.new(algorithm)</span>
<span class="gi">+    hashInstance.update(compat26Str(data))</span>
<span class="gi">+    return bytearray(hashInstance.digest())</span>

<span class="w"> </span>def secureHMAC(k, b, algorithm):
<span class="w"> </span>    &quot;&quot;&quot;Return a HMAC using `b` and `k` using `algorithm`&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    k = compatHMAC(k)</span>
<span class="gi">+    b = compatHMAC(b)</span>
<span class="gi">+    return bytearray(hmac.new(k, b, getattr(hashlib, algorithm)).digest())</span>

<span class="gi">+def HMAC_MD5(k, b):</span>
<span class="gi">+    return secureHMAC(k, b, &#39;md5&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def HMAC_SHA1(k, b):</span>
<span class="gi">+    return secureHMAC(k, b, &#39;sha1&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def HMAC_SHA256(k, b):</span>
<span class="gi">+    return secureHMAC(k, b, &#39;sha256&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def HMAC_SHA384(k, b):</span>
<span class="gi">+    return secureHMAC(k, b, &#39;sha384&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def HKDF_expand(PRK, info, L, algorithm):</span>
<span class="gi">+    N = divceil(L, getattr(hashlib, algorithm)().digest_size)</span>
<span class="gi">+    T = bytearray()</span>
<span class="gi">+    Titer = bytearray()</span>
<span class="gi">+    for x in range(1, N+2):</span>
<span class="gi">+        T += Titer</span>
<span class="gi">+        Titer = secureHMAC(PRK, Titer + info + bytearray([x]), algorithm)</span>
<span class="gi">+    return T[:L]</span>

<span class="w"> </span>def HKDF_expand_label(secret, label, hashValue, length, algorithm):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -88,8 +165,12 @@ def HKDF_expand_label(secret, label, hashValue, length, algorithm):</span>
<span class="w"> </span>        basis of the HKDF
<span class="w"> </span>    :rtype: bytearray
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hkdfLabel = Writer()</span>
<span class="gi">+    hkdfLabel.addTwo(length)</span>
<span class="gi">+    hkdfLabel.addVarSeq(bytearray(b&quot;tls13 &quot;) + label, 1, 1)</span>
<span class="gi">+    hkdfLabel.addVarSeq(hashValue, 1, 1)</span>

<span class="gi">+    return HKDF_expand(secret, hkdfLabel.bytes, length, algorithm)</span>

<span class="w"> </span>def derive_secret(secret, label, handshake_hashes, algorithm):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -105,19 +186,28 @@ def derive_secret(secret, label, handshake_hashes, algorithm):</span>
<span class="w"> </span>        be generated
<span class="w"> </span>    :rtype: bytearray
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def bytesToNumber(b, endian=&#39;big&#39;):</span>
<span class="gi">+    if handshake_hashes is None:</span>
<span class="gi">+        hs_hash = secureHash(bytearray(b&#39;&#39;), algorithm)</span>
<span class="gi">+    else:</span>
<span class="gi">+        hs_hash = handshake_hashes.digest(algorithm)</span>
<span class="gi">+    return HKDF_expand_label(secret, label, hs_hash,</span>
<span class="gi">+                             getattr(hashlib, algorithm)().digest_size,</span>
<span class="gi">+                             algorithm)</span>
<span class="gi">+</span>
<span class="gi">+# **************************************************************************</span>
<span class="gi">+# Converter Functions</span>
<span class="gi">+# **************************************************************************</span>
<span class="gi">+</span>
<span class="gi">+def bytesToNumber(b, endian=&quot;big&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert a number stored in bytearray to an integer.

<span class="w"> </span>    By default assumes big-endian encoding of the number.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return bytes_to_int(b, endian)</span>


<span class="gd">-def numberToByteArray(n, howManyBytes=None, endian=&#39;big&#39;):</span>
<span class="gi">+def numberToByteArray(n, howManyBytes=None, endian=&quot;big&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert an integer into a bytearray, zero-pad to howManyBytes.

<span class="gu">@@ -125,34 +215,161 @@ def numberToByteArray(n, howManyBytes=None, endian=&#39;big&#39;):</span>
<span class="w"> </span>    not be larger.  The returned bytearray will contain a big- or little-endian
<span class="w"> </span>    encoding of the input integer (n). Big endian encoding is used by default.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if howManyBytes is not None:</span>
<span class="gi">+        length = byte_length(n)</span>
<span class="gi">+        if howManyBytes &lt; length:</span>
<span class="gi">+            ret = int_to_bytes(n, length, endian)</span>
<span class="gi">+            if endian == &quot;big&quot;:</span>
<span class="gi">+                return ret[length-howManyBytes:length]</span>
<span class="gi">+            return ret[:howManyBytes]</span>
<span class="gi">+    return int_to_bytes(n, howManyBytes, endian)</span>


<span class="w"> </span>def mpiToNumber(mpi):
<span class="w"> </span>    &quot;&quot;&quot;Convert a MPI (OpenSSL bignum string) to an integer.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    byte = bytearray(mpi)</span>
<span class="gi">+    if byte[4] &amp; 0x80:</span>
<span class="gi">+        raise ValueError(&quot;Input must be a positive integer&quot;)</span>
<span class="gi">+    return bytesToNumber(byte[4:])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def numberToMPI(n):</span>
<span class="gi">+    b = numberToByteArray(n)</span>
<span class="gi">+    ext = 0</span>
<span class="gi">+    #If the high-order bit is going to be set,</span>
<span class="gi">+    #add an extra byte of zeros</span>
<span class="gi">+    if (numBits(n) &amp; 0x7)==0:</span>
<span class="gi">+        ext = 1</span>
<span class="gi">+    length = numBytes(n) + ext</span>
<span class="gi">+    b = bytearray(4+ext) + b</span>
<span class="gi">+    b[0] = (length &gt;&gt; 24) &amp; 0xFF</span>
<span class="gi">+    b[1] = (length &gt;&gt; 16) &amp; 0xFF</span>
<span class="gi">+    b[2] = (length &gt;&gt; 8) &amp; 0xFF</span>
<span class="gi">+    b[3] = length &amp; 0xFF</span>
<span class="gi">+    return bytes(b)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# **************************************************************************</span>
<span class="gi">+# Misc. Utility Functions</span>
<span class="gi">+# **************************************************************************</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=invalid-name</span>
<span class="gi">+# pylint recognises them as constants, not function names, also</span>
<span class="gi">+# we can&#39;t change their names without API change</span>
<span class="gi">+numBits = bit_length</span>


<span class="gd">-numBits = bit_length</span>
<span class="w"> </span>numBytes = byte_length
<span class="gi">+# pylint: enable=invalid-name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# **************************************************************************</span>
<span class="gi">+# Big Number Math</span>
<span class="gi">+# **************************************************************************</span>
<span class="gi">+</span>
<span class="gi">+def getRandomNumber(low, high):</span>
<span class="gi">+    assert low &lt; high</span>
<span class="gi">+    howManyBits = numBits(high)</span>
<span class="gi">+    howManyBytes = numBytes(high)</span>
<span class="gi">+    lastBits = howManyBits % 8</span>
<span class="gi">+    while 1:</span>
<span class="gi">+        bytes = getRandomBytes(howManyBytes)</span>
<span class="gi">+        if lastBits:</span>
<span class="gi">+            bytes[0] = bytes[0] % (1 &lt;&lt; lastBits)</span>
<span class="gi">+        n = bytesToNumber(bytes)</span>
<span class="gi">+        if n &gt;= low and n &lt; high:</span>
<span class="gi">+            return n</span>
<span class="gi">+</span>
<span class="gi">+def gcd(a,b):</span>
<span class="gi">+    a, b = max(a,b), min(a,b)</span>
<span class="gi">+    while b:</span>
<span class="gi">+        a, b = b, a % b</span>
<span class="gi">+    return a</span>
<span class="gi">+</span>
<span class="gi">+def lcm(a, b):</span>
<span class="gi">+    return (a * b) // gcd(a, b)</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=invalid-name</span>
<span class="gi">+# disable pylint check as the (a, b) are part of the API</span>
<span class="w"> </span>if GMPY2_LOADED:
<span class="gd">-</span>
<span class="w"> </span>    def invMod(a, b):
<span class="w"> </span>        &quot;&quot;&quot;Return inverse of a mod b, zero if none.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if a == 0:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        return powmod(a, -1, b)</span>
<span class="w"> </span>else:
<span class="gd">-</span>
<span class="gi">+    # Use Extended Euclidean Algorithm</span>
<span class="w"> </span>    def invMod(a, b):
<span class="w"> </span>        &quot;&quot;&quot;Return inverse of a mod b, zero if none.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        c, d = a, b</span>
<span class="gi">+        uc, ud = 1, 0</span>
<span class="gi">+        while c != 0:</span>
<span class="gi">+            q = d // c</span>
<span class="gi">+            c, d = d-(q*c), c</span>
<span class="gi">+            uc, ud = ud - (q * uc), uc</span>
<span class="gi">+        if d == 1:</span>
<span class="gi">+            return ud % b</span>
<span class="gi">+        return 0</span>
<span class="gi">+# pylint: enable=invalid-name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if gmpyLoaded or GMPY2_LOADED:
<span class="gi">+    def powMod(base, power, modulus):</span>
<span class="gi">+        base = mpz(base)</span>
<span class="gi">+        power = mpz(power)</span>
<span class="gi">+        modulus = mpz(modulus)</span>
<span class="gi">+        result = pow(base, power, modulus)</span>
<span class="gi">+        return compatLong(result)</span>
<span class="w"> </span>else:
<span class="w"> </span>    powMod = pow


<span class="w"> </span>def divceil(divident, divisor):
<span class="w"> </span>    &quot;&quot;&quot;Integer division with rounding up&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    quot, r = divmod(divident, divisor)</span>
<span class="gi">+    return quot + int(bool(r))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#Pre-calculate a sieve of the ~100 primes &lt; 1000:</span>
<span class="gi">+def makeSieve(n):</span>
<span class="gi">+    sieve = list(range(n))</span>
<span class="gi">+    for count in range(2, int(math.sqrt(n))+1):</span>
<span class="gi">+        if sieve[count] == 0:</span>
<span class="gi">+            continue</span>
<span class="gi">+        x = sieve[count] * 2</span>
<span class="gi">+        while x &lt; len(sieve):</span>
<span class="gi">+            sieve[x] = 0</span>
<span class="gi">+            x += sieve[count]</span>
<span class="gi">+    sieve = [x for x in sieve[2:] if x]</span>
<span class="gi">+    return sieve</span>
<span class="gi">+</span>
<span class="gi">+def isPrime(n, iterations=5, display=False, sieve=makeSieve(1000)):</span>
<span class="gi">+    #Trial division with sieve</span>
<span class="gi">+    for x in sieve:</span>
<span class="gi">+        if x &gt;= n: return True</span>
<span class="gi">+        if n % x == 0: return False</span>
<span class="gi">+    #Passed trial division, proceed to Rabin-Miller</span>
<span class="gi">+    #Rabin-Miller implemented per Ferguson &amp; Schneier</span>
<span class="gi">+    #Compute s, t for Rabin-Miller</span>
<span class="gi">+    if display: print(&quot;*&quot;, end=&#39; &#39;)</span>
<span class="gi">+    s, t = n-1, 0</span>
<span class="gi">+    while s % 2 == 0:</span>
<span class="gi">+        s, t = s//2, t+1</span>
<span class="gi">+    #Repeat Rabin-Miller x times</span>
<span class="gi">+    a = 2 #Use 2 as a base for first iteration speedup, per HAC</span>
<span class="gi">+    for count in range(iterations):</span>
<span class="gi">+        v = powMod(a, s, n)</span>
<span class="gi">+        if v==1:</span>
<span class="gi">+            continue</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        while v != n-1:</span>
<span class="gi">+            if i == t-1:</span>
<span class="gi">+                return False</span>
<span class="gi">+            else:</span>
<span class="gi">+                v, i = powMod(v, 2, n), i+1</span>
<span class="gi">+        a = getRandomNumber(2, n)</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def getRandomPrime(bits, display=False):
<span class="gu">@@ -162,13 +379,52 @@ def getRandomPrime(bits, display=False):</span>
<span class="w"> </span>    the number will be &#39;bits&#39; bits long (i.e. generated number will be
<span class="w"> </span>    larger than `(2^(bits-1) * 3 ) / 2` but smaller than 2^bits.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    assert bits &gt;= 10</span>
<span class="gi">+    #The 1.5 ensures the 2 MSBs are set</span>
<span class="gi">+    #Thus, when used for p,q in RSA, n will have its MSB set</span>
<span class="gi">+    #</span>
<span class="gi">+    #Since 30 is lcm(2,3,5), we&#39;ll set our test numbers to</span>
<span class="gi">+    #29 % 30 and keep them there</span>
<span class="gi">+    low = ((2 ** (bits-1)) * 3) // 2</span>
<span class="gi">+    high = 2 ** bits - 30</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if display:</span>
<span class="gi">+            print(&quot;.&quot;, end=&#39; &#39;)</span>
<span class="gi">+        cand_p = getRandomNumber(low, high)</span>
<span class="gi">+        # make odd</span>
<span class="gi">+        if cand_p % 2 == 0:</span>
<span class="gi">+            cand_p += 1</span>
<span class="gi">+        if isPrime(cand_p, display=display):</span>
<span class="gi">+            return cand_p</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#Unused at the moment...</span>
<span class="w"> </span>def getRandomSafePrime(bits, display=False):
<span class="w"> </span>    &quot;&quot;&quot;Generate a random safe prime.

<span class="w"> </span>    Will generate a prime `bits` bits long (see getRandomPrime) such that
<span class="w"> </span>    the (p-1)/2 will also be prime.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert bits &gt;= 10</span>
<span class="gi">+    #The 1.5 ensures the 2 MSBs are set</span>
<span class="gi">+    #Thus, when used for p,q in RSA, n will have its MSB set</span>
<span class="gi">+    #</span>
<span class="gi">+    #Since 30 is lcm(2,3,5), we&#39;ll set our test numbers to</span>
<span class="gi">+    #29 % 30 and keep them there</span>
<span class="gi">+    low = (2 ** (bits-2)) * 3//2</span>
<span class="gi">+    high = (2 ** (bits-1)) - 30</span>
<span class="gi">+    q = getRandomNumber(low, high)</span>
<span class="gi">+    q += 29 - (q % 30)</span>
<span class="gi">+    while 1:</span>
<span class="gi">+        if display: print(&quot;.&quot;, end=&#39; &#39;)</span>
<span class="gi">+        q += 30</span>
<span class="gi">+        if (q &gt;= high):</span>
<span class="gi">+            q = getRandomNumber(low, high)</span>
<span class="gi">+            q += 29 - (q % 30)</span>
<span class="gi">+        #Ideas from Tom Wu&#39;s SRP code</span>
<span class="gi">+        #Do trial division on p and q before Rabin-Miller</span>
<span class="gi">+        if isPrime(q, 0, display=display):</span>
<span class="gi">+            p = (2 * q) + 1</span>
<span class="gi">+            if isPrime(p, display=display):</span>
<span class="gi">+                if isPrime(q, display=display):</span>
<span class="gi">+                    return p</span>
<span class="gh">diff --git a/tlslite/utils/datefuncs.py b/tlslite/utils/datefuncs.py</span>
<span class="gh">index 07fc72b..d8f0d24 100644</span>
<span class="gd">--- a/tlslite/utils/datefuncs.py</span>
<span class="gi">+++ b/tlslite/utils/datefuncs.py</span>
<span class="gu">@@ -1,6 +1,77 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="gd">-if os.name != &#39;java&#39;:</span>
<span class="gi">+</span>
<span class="gi">+#Functions for manipulating datetime objects</span>
<span class="gi">+#CCYY-MM-DDThh:mm:ssZ</span>
<span class="gi">+def parseDateClass(s):</span>
<span class="gi">+    year, month, day = s.split(&quot;-&quot;)</span>
<span class="gi">+    day, tail = day[:2], day[2:]</span>
<span class="gi">+    hour, minute, second = tail[1:].split(&quot;:&quot;)</span>
<span class="gi">+    second = second[:2]</span>
<span class="gi">+    year, month, day = int(year), int(month), int(day)</span>
<span class="gi">+    hour, minute, second = int(hour), int(minute), int(second)</span>
<span class="gi">+    return createDateClass(year, month, day, hour, minute, second)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if os.name != &quot;java&quot;:</span>
<span class="w"> </span>    from datetime import datetime, timedelta
<span class="gi">+</span>
<span class="gi">+    #Helper functions for working with a date/time class</span>
<span class="gi">+    def createDateClass(year, month, day, hour, minute, second):</span>
<span class="gi">+        return datetime(year, month, day, hour, minute, second)</span>
<span class="gi">+</span>
<span class="gi">+    def printDateClass(d):</span>
<span class="gi">+        #Split off fractional seconds, append &#39;Z&#39;</span>
<span class="gi">+        return d.isoformat().split(&quot;.&quot;)[0]+&quot;Z&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def getNow():</span>
<span class="gi">+        return datetime.utcnow()</span>
<span class="gi">+</span>
<span class="gi">+    def getHoursFromNow(hours):</span>
<span class="gi">+        return datetime.utcnow() + timedelta(hours=hours)</span>
<span class="gi">+</span>
<span class="gi">+    def getMinutesFromNow(minutes):</span>
<span class="gi">+        return datetime.utcnow() + timedelta(minutes=minutes)</span>
<span class="gi">+</span>
<span class="gi">+    def isDateClassExpired(d):</span>
<span class="gi">+        return d &lt; datetime.utcnow()</span>
<span class="gi">+</span>
<span class="gi">+    def isDateClassBefore(d1, d2):</span>
<span class="gi">+        return d1 &lt; d2</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="gi">+    #Jython 2.1 is missing lots of python 2.3 stuff,</span>
<span class="gi">+    #which we have to emulate here:</span>
<span class="w"> </span>    import java
<span class="w"> </span>    import jarray
<span class="gi">+</span>
<span class="gi">+    def createDateClass(year, month, day, hour, minute, second):</span>
<span class="gi">+        c = java.util.Calendar.getInstance()</span>
<span class="gi">+        c.setTimeZone(java.util.TimeZone.getTimeZone(&quot;UTC&quot;))</span>
<span class="gi">+        c.set(year, month-1, day, hour, minute, second)</span>
<span class="gi">+        return c</span>
<span class="gi">+</span>
<span class="gi">+    def printDateClass(d):</span>
<span class="gi">+        return &quot;%04d-%02d-%02dT%02d:%02d:%02dZ&quot; % \</span>
<span class="gi">+        (d.get(d.YEAR), d.get(d.MONTH)+1, d.get(d.DATE), \</span>
<span class="gi">+        d.get(d.HOUR_OF_DAY), d.get(d.MINUTE), d.get(d.SECOND))</span>
<span class="gi">+</span>
<span class="gi">+    def getNow():</span>
<span class="gi">+        c = java.util.Calendar.getInstance()</span>
<span class="gi">+        c.setTimeZone(java.util.TimeZone.getTimeZone(&quot;UTC&quot;))</span>
<span class="gi">+        c.get(c.HOUR) #force refresh?</span>
<span class="gi">+        return c</span>
<span class="gi">+</span>
<span class="gi">+    def getHoursFromNow(hours):</span>
<span class="gi">+        d = getNow()</span>
<span class="gi">+        d.add(d.HOUR, hours)</span>
<span class="gi">+        return d</span>
<span class="gi">+</span>
<span class="gi">+    def isDateClassExpired(d):</span>
<span class="gi">+        n = getNow()</span>
<span class="gi">+        return d.before(n)</span>
<span class="gi">+</span>
<span class="gi">+    def isDateClassBefore(d1, d2):</span>
<span class="gi">+        return d1.before(d2)</span>
<span class="gh">diff --git a/tlslite/utils/deprecations.py b/tlslite/utils/deprecations.py</span>
<span class="gh">index e4f676c..b5a9175 100644</span>
<span class="gd">--- a/tlslite/utils/deprecations.py</span>
<span class="gi">+++ b/tlslite/utils/deprecations.py</span>
<span class="gu">@@ -1,11 +1,15 @@</span>
<span class="gi">+# Copyright (c) 2018 Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="w"> </span>&quot;&quot;&quot;Methods for deprecating old names for arguments or attributes.&quot;&quot;&quot;
<span class="w"> </span>import warnings
<span class="w"> </span>import inspect
<span class="w"> </span>from functools import wraps


<span class="gd">-def deprecated_class_name(old_name, warn=</span>
<span class="gd">-    &quot;Class name &#39;{old_name}&#39; is deprecated, please use &#39;{new_name}&#39;&quot;):</span>
<span class="gi">+def deprecated_class_name(old_name,</span>
<span class="gi">+                          warn=&quot;Class name &#39;{old_name}&#39; is deprecated, &quot;</span>
<span class="gi">+                          &quot;please use &#39;{new_name}&#39;&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Class decorator to deprecate a use of class.

<span class="gu">@@ -17,11 +21,53 @@ def deprecated_class_name(old_name, warn=</span>
<span class="w"> </span>       keyword name and the &#39;new_name&#39; for the current one.
<span class="w"> </span>       Example: &quot;Old name: {old_nam}, use &#39;{new_name}&#39; instead&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def deprecated_params(names, warn=</span>
<span class="gd">-    &quot;Param name &#39;{old_name}&#39; is deprecated, please use &#39;{new_name}&#39;&quot;):</span>
<span class="gi">+    def _wrap(obj):</span>
<span class="gi">+        assert callable(obj)</span>
<span class="gi">+</span>
<span class="gi">+        def _warn():</span>
<span class="gi">+            warnings.warn(warn.format(old_name=old_name,</span>
<span class="gi">+                                      new_name=obj.__name__),</span>
<span class="gi">+                          DeprecationWarning,</span>
<span class="gi">+                          stacklevel=3)</span>
<span class="gi">+</span>
<span class="gi">+        def _wrap_with_warn(func, is_inspect):</span>
<span class="gi">+            @wraps(func)</span>
<span class="gi">+            def _func(*args, **kwargs):</span>
<span class="gi">+                if is_inspect:</span>
<span class="gi">+                    # XXX: If use another name to call,</span>
<span class="gi">+                    # you will not get the warning.</span>
<span class="gi">+                    # we do this instead of subclassing or metaclass as</span>
<span class="gi">+                    # we want to isinstance(new_name(), old_name) and</span>
<span class="gi">+                    # isinstance(old_name(), new_name) to work</span>
<span class="gi">+                    frame = inspect.currentframe().f_back</span>
<span class="gi">+                    code = inspect.getframeinfo(frame).code_context</span>
<span class="gi">+                    if [line for line in code</span>
<span class="gi">+                            if &#39;{0}(&#39;.format(old_name) in line]:</span>
<span class="gi">+                        _warn()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    _warn()</span>
<span class="gi">+                return func(*args, **kwargs)</span>
<span class="gi">+            return _func</span>
<span class="gi">+</span>
<span class="gi">+        # Make old name available.</span>
<span class="gi">+        frame = inspect.currentframe().f_back</span>
<span class="gi">+        if old_name in frame.f_globals:</span>
<span class="gi">+            raise NameError(&quot;Name &#39;{0}&#39; already in use.&quot;.format(old_name))</span>
<span class="gi">+</span>
<span class="gi">+        if inspect.isclass(obj):</span>
<span class="gi">+            obj.__init__ = _wrap_with_warn(obj.__init__, True)</span>
<span class="gi">+            placeholder = obj</span>
<span class="gi">+        else:</span>
<span class="gi">+            placeholder = _wrap_with_warn(obj, False)</span>
<span class="gi">+</span>
<span class="gi">+        frame.f_globals[old_name] = placeholder</span>
<span class="gi">+</span>
<span class="gi">+        return obj</span>
<span class="gi">+    return _wrap</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def deprecated_params(names, warn=&quot;Param name &#39;{old_name}&#39; is deprecated, &quot;</span>
<span class="gi">+                                  &quot;please use &#39;{new_name}&#39;&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator to translate obsolete names and warn about their use.

<span class="w"> </span>    :param dict names: dictionary with pairs of new_name: old_name
<span class="gu">@@ -32,11 +78,27 @@ def deprecated_params(names, warn=</span>
<span class="w"> </span>        deprecated keyword name and &#39;new_name&#39; for the current one.
<span class="w"> </span>        Example: &quot;Old name: {old_name}, use {new_name} instead&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def deprecated_instance_attrs(names, warn=</span>
<span class="gd">-    &quot;Attribute &#39;{old_name}&#39; is deprecated, please use &#39;{new_name}&#39;&quot;):</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        @wraps(func)</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            for new_name, old_name in names.items():</span>
<span class="gi">+                if old_name in kwargs:</span>
<span class="gi">+                    if new_name in kwargs:</span>
<span class="gi">+                        raise TypeError(&quot;got multiple values for keyword &quot;</span>
<span class="gi">+                                        &quot;argument &#39;{0}&#39;&quot;.format(new_name))</span>
<span class="gi">+                    warnings.warn(warn.format(old_name=old_name,</span>
<span class="gi">+                                              new_name=new_name),</span>
<span class="gi">+                                  DeprecationWarning,</span>
<span class="gi">+                                  stacklevel=2)</span>
<span class="gi">+                    kwargs[new_name] = kwargs.pop(old_name)</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def deprecated_instance_attrs(names,</span>
<span class="gi">+                              warn=&quot;Attribute &#39;{old_name}&#39; is deprecated, &quot;</span>
<span class="gi">+                                   &quot;please use &#39;{new_name}&#39;&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator to deprecate class instance attributes.

<span class="w"> </span>    Translates all names in `names` to use new names and emits warnings
<span class="gu">@@ -51,11 +113,59 @@ def deprecated_instance_attrs(names, warn=</span>
<span class="w"> </span>        deprecated keyword name and &#39;new_name&#39; for the current one.
<span class="w"> </span>        Example: &quot;Old name: {old_name}, use {new_name} instead&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def deprecated_attrs(names, warn=</span>
<span class="gd">-    &quot;Attribute &#39;{old_name}&#39; is deprecated, please use &#39;{new_name}&#39;&quot;):</span>
<span class="gi">+    # reverse the dict as we&#39;re looking for old attributes, not new ones</span>
<span class="gi">+    names = dict((j, i) for i, j in names.items())</span>
<span class="gi">+</span>
<span class="gi">+    def decorator(clazz):</span>
<span class="gi">+        def getx(self, name, __old_getx=getattr(clazz, &quot;__getattr__&quot;, None)):</span>
<span class="gi">+            if name in names:</span>
<span class="gi">+                warnings.warn(warn.format(old_name=name,</span>
<span class="gi">+                                          new_name=names[name]),</span>
<span class="gi">+                              DeprecationWarning,</span>
<span class="gi">+                              stacklevel=2)</span>
<span class="gi">+                return getattr(self, names[name])</span>
<span class="gi">+            if __old_getx:</span>
<span class="gi">+                if hasattr(__old_getx, &quot;__func__&quot;):</span>
<span class="gi">+                    return __old_getx.__func__(self, name)</span>
<span class="gi">+                return __old_getx(self, name)</span>
<span class="gi">+            raise AttributeError(&quot;&#39;{0}&#39; object has no attribute &#39;{1}&#39;&quot;</span>
<span class="gi">+                                 .format(clazz.__name__, name))</span>
<span class="gi">+</span>
<span class="gi">+        getx.__name__ = &quot;__getattr__&quot;</span>
<span class="gi">+        clazz.__getattr__ = getx</span>
<span class="gi">+</span>
<span class="gi">+        def setx(self, name, value, __old_setx=getattr(clazz, &quot;__setattr__&quot;)):</span>
<span class="gi">+            if name in names:</span>
<span class="gi">+                warnings.warn(warn.format(old_name=name,</span>
<span class="gi">+                                          new_name=names[name]),</span>
<span class="gi">+                              DeprecationWarning,</span>
<span class="gi">+                              stacklevel=2)</span>
<span class="gi">+                setattr(self, names[name], value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                __old_setx(self, name, value)</span>
<span class="gi">+</span>
<span class="gi">+        setx.__name__ = &quot;__setattr__&quot;</span>
<span class="gi">+        clazz.__setattr__ = setx</span>
<span class="gi">+</span>
<span class="gi">+        def delx(self, name, __old_delx=getattr(clazz, &quot;__delattr__&quot;)):</span>
<span class="gi">+            if name in names:</span>
<span class="gi">+                warnings.warn(warn.format(old_name=name,</span>
<span class="gi">+                                          new_name=names[name]),</span>
<span class="gi">+                              DeprecationWarning,</span>
<span class="gi">+                              stacklevel=2)</span>
<span class="gi">+                delattr(self, names[name])</span>
<span class="gi">+            else:</span>
<span class="gi">+                __old_delx(self, name)</span>
<span class="gi">+</span>
<span class="gi">+        delx.__name__ = &quot;__delattr__&quot;</span>
<span class="gi">+        clazz.__delattr__ = delx</span>
<span class="gi">+</span>
<span class="gi">+        return clazz</span>
<span class="gi">+    return decorator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def deprecated_attrs(names, warn=&quot;Attribute &#39;{old_name}&#39; is deprecated, &quot;</span>
<span class="gi">+                                 &quot;please use &#39;{new_name}&#39;&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator to deprecate all specified attributes in class.

<span class="w"> </span>    Translates all names in `names` to use new names and emits warnings
<span class="gu">@@ -70,12 +180,39 @@ def deprecated_attrs(names, warn=</span>
<span class="w"> </span>        deprecated keyword name and &#39;new_name&#39; for the current one.
<span class="w"> </span>        Example: &quot;Old name: {old_name}, use {new_name} instead&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    # prepare metaclass for handling all the class methods, class variables</span>
<span class="gi">+    # and static methods (as they don&#39;t go through instance&#39;s __getattr__)</span>
<span class="gi">+    class DeprecatedProps(type):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    metaclass = deprecated_instance_attrs(names, warn)(DeprecatedProps)</span>
<span class="gi">+</span>
<span class="gi">+    def wrapper(cls):</span>
<span class="gi">+        cls = deprecated_instance_attrs(names, warn)(cls)</span>
<span class="gi">+</span>
<span class="gi">+        # apply metaclass</span>
<span class="gi">+        orig_vars = cls.__dict__.copy()</span>
<span class="gi">+        slots = orig_vars.get(&#39;__slots__&#39;)</span>
<span class="gi">+        if slots is not None:</span>
<span class="gi">+            if isinstance(slots, str):</span>
<span class="gi">+                slots = [slots]</span>
<span class="gi">+            for slots_var in slots:</span>
<span class="gi">+                orig_vars.pop(slots_var)</span>
<span class="gi">+        orig_vars.pop(&#39;__dict__&#39;, None)</span>
<span class="gi">+        orig_vars.pop(&#39;__weakref__&#39;, None)</span>
<span class="gi">+        return metaclass(cls.__name__, cls.__bases__, orig_vars)</span>
<span class="gi">+    return wrapper</span>

<span class="w"> </span>def deprecated_method(message):
<span class="w"> </span>    &quot;&quot;&quot;Decorator for deprecating methods.

<span class="w"> </span>    :param ste message: The message you want to display.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func):</span>
<span class="gi">+        @wraps(func)</span>
<span class="gi">+        def wrapper(*args, **kwargs):</span>
<span class="gi">+            warnings.warn(&quot;{0} is a deprecated method. {1}&quot;.format(func.__name__, message),</span>
<span class="gi">+                          DeprecationWarning, stacklevel=2)</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>
<span class="gh">diff --git a/tlslite/utils/dns_utils.py b/tlslite/utils/dns_utils.py</span>
<span class="gh">index 40e08e5..1c4fa29 100644</span>
<span class="gd">--- a/tlslite/utils/dns_utils.py</span>
<span class="gi">+++ b/tlslite/utils/dns_utils.py</span>
<span class="gu">@@ -1,4 +1,9 @@</span>
<span class="gi">+# Copyright (c) 2017 Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities for handling DNS hostnames&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import re


<span class="gu">@@ -10,4 +15,28 @@ def is_valid_hostname(hostname):</span>
<span class="w"> </span>    :param hostname: string to check
<span class="w"> </span>    :rtype: boolean
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if not isinstance(hostname, str):</span>
<span class="gi">+            hostname = hostname.decode(&#39;ascii&#39;, &#39;strict&#39;)</span>
<span class="gi">+    except UnicodeDecodeError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if hostname[-1] == &quot;.&quot;:</span>
<span class="gi">+        # strip exactly one dot from the right, if present</span>
<span class="gi">+        hostname = hostname[:-1]</span>
<span class="gi">+    # the maximum length of the domain name is 255 bytes, but because they</span>
<span class="gi">+    # are encoded as labels (which is a length byte and an up to 63 character</span>
<span class="gi">+    # ascii string), you change the dots to the length bytes, but the</span>
<span class="gi">+    # host element of the FQDN doesn&#39;t start with a dot and the name doesn&#39;t</span>
<span class="gi">+    # end with a dot (specification of a root label), we need to subtract 2</span>
<span class="gi">+    # bytes from the 255 byte maximum when looking at dot-deliminated FQDN</span>
<span class="gi">+    # with the trailing dot removed</span>
<span class="gi">+    # see RFC 1035</span>
<span class="gi">+    if len(hostname) &gt; 253:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # must not be all-numeric, so that it can&#39;t be confused with an ip-address</span>
<span class="gi">+    if re.match(r&quot;[\d.]+$&quot;, hostname):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    allowed = re.compile(r&quot;(?!-)[A-Z\d-]{1,63}(?&lt;!-)$&quot;, re.IGNORECASE)</span>
<span class="gi">+    return all(allowed.match(x) for x in hostname.split(&quot;.&quot;))</span>
<span class="gh">diff --git a/tlslite/utils/dsakey.py b/tlslite/utils/dsakey.py</span>
<span class="gh">index a9aea75..2a12b10 100644</span>
<span class="gd">--- a/tlslite/utils/dsakey.py</span>
<span class="gi">+++ b/tlslite/utils/dsakey.py</span>
<span class="gu">@@ -1,6 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Abstract class for DSA.&quot;&quot;&quot;

<span class="gd">-</span>
<span class="w"> </span>class DSAKey(object):
<span class="w"> </span>    &quot;&quot;&quot;This is an abstract base class for DSA keys.

<span class="gu">@@ -41,7 +40,7 @@ class DSAKey(object):</span>

<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    def hashAndSign(self, data, hAlg):
<span class="w"> </span>        &quot;&quot;&quot;Hash and sign the passed-in bytes.
<span class="gu">@@ -59,9 +58,12 @@ class DSAKey(object):</span>
<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        :returns: An DSA signature on the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def sign(self, data):</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def hashAndVerify(self, signature, data, hAlg=&#39;sha1&#39;):</span>
<span class="gi">+    def hashAndVerify(self, signature, data, hAlg=&quot;sha1&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Hash and verify the passed-in bytes with signature.

<span class="w"> </span>        :type signature: ASN1 bytearray
<span class="gu">@@ -76,7 +78,7 @@ class DSAKey(object):</span>
<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        :returns: return True if verification is OK.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def generate(L, N):
<span class="gu">@@ -91,7 +93,7 @@ class DSAKey(object):</span>
<span class="w"> </span>        :rtype: DSAkey
<span class="w"> </span>        :returns: DSAkey(domain parameters, private key, public key)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def generate_qp(L, N):
<span class="gu">@@ -106,4 +108,4 @@ class DSAKey(object):</span>
<span class="w"> </span>        :rtype: (int, int)
<span class="w"> </span>        :returns: new p and q key parameters
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gh">diff --git a/tlslite/utils/ecc.py b/tlslite/utils/ecc.py</span>
<span class="gh">index 85dd043..1b02685 100644</span>
<span class="gd">--- a/tlslite/utils/ecc.py</span>
<span class="gi">+++ b/tlslite/utils/ecc.py</span>
<span class="gu">@@ -1,13 +1,46 @@</span>
<span class="gi">+# Copyright (c) 2015, Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="w"> </span>&quot;&quot;&quot;Methods for dealing with ECC points&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import ecdsa
<span class="w"> </span>from .compat import ecdsaAllCurves


<span class="w"> </span>def getCurveByName(curveName):
<span class="w"> </span>    &quot;&quot;&quot;Return curve identified by curveName&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    curveMap = {&#39;secp256r1&#39;:ecdsa.NIST256p,</span>
<span class="gi">+                &#39;secp384r1&#39;:ecdsa.NIST384p,</span>
<span class="gi">+                &#39;secp521r1&#39;:ecdsa.NIST521p,</span>
<span class="gi">+                &#39;secp256k1&#39;:ecdsa.SECP256k1,</span>
<span class="gi">+                &#39;brainpoolP256r1&#39;: ecdsa.BRAINPOOLP256r1,</span>
<span class="gi">+                &#39;brainpoolP384r1&#39;: ecdsa.BRAINPOOLP384r1,</span>
<span class="gi">+                &#39;brainpoolP512r1&#39;: ecdsa.BRAINPOOLP512r1}</span>
<span class="gi">+    if ecdsaAllCurves:</span>
<span class="gi">+        curveMap[&#39;secp224r1&#39;] = ecdsa.NIST224p</span>
<span class="gi">+        curveMap[&#39;secp192r1&#39;] = ecdsa.NIST192p</span>

<span class="gi">+    if curveName in curveMap:</span>
<span class="gi">+        return curveMap[curveName]</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Curve of name &#39;{0}&#39; unknown&quot;.format(curveName))</span>

<span class="w"> </span>def getPointByteSize(point):
<span class="w"> </span>    &quot;&quot;&quot;Convert the point or curve bit size to bytes&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    curveMap = {ecdsa.NIST256p.curve: 256//8,</span>
<span class="gi">+                ecdsa.NIST384p.curve: 384//8,</span>
<span class="gi">+                ecdsa.NIST521p.curve: (521+7)//8,</span>
<span class="gi">+                ecdsa.SECP256k1.curve: 256//8,</span>
<span class="gi">+                ecdsa.BRAINPOOLP256r1.curve: 256//8,</span>
<span class="gi">+                ecdsa.BRAINPOOLP384r1.curve: 384//8,</span>
<span class="gi">+                ecdsa.BRAINPOOLP512r1.curve: 512//8}</span>
<span class="gi">+    if ecdsaAllCurves:</span>
<span class="gi">+        curveMap[ecdsa.NIST224p.curve] = 224//8</span>
<span class="gi">+        curveMap[ecdsa.NIST192p.curve] = 192//8</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(point, &#39;curve&#39;):</span>
<span class="gi">+        if callable(point.curve):</span>
<span class="gi">+            return curveMap[point.curve()]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return curveMap[point.curve]</span>
<span class="gi">+    raise ValueError(&quot;Parameter must be a curve or point on curve&quot;)</span>
<span class="gh">diff --git a/tlslite/utils/ecdsakey.py b/tlslite/utils/ecdsakey.py</span>
<span class="gh">index 794305d..5fd8989 100644</span>
<span class="gd">--- a/tlslite/utils/ecdsakey.py</span>
<span class="gi">+++ b/tlslite/utils/ecdsakey.py</span>
<span class="gu">@@ -1,4 +1,8 @@</span>
<span class="gi">+# Author: Stanislav Zidek</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Abstract class for ECDSA.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import secureHash


<span class="gu">@@ -39,7 +43,16 @@ class ECDSAKey(object):</span>

<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _sign(self, data, hash_alg):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _hashAndSign(self, data, hAlg):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _verify(self, signature, hash_bytes):</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    def hashAndSign(self, bytes, rsaScheme=None, hAlg=&#39;sha1&#39;, sLen=None):
<span class="w"> </span>        &quot;&quot;&quot;Hash and sign the passed-in bytes.
<span class="gu">@@ -62,10 +75,13 @@ class ECDSAKey(object):</span>
<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        :returns: An ECDSA signature on the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hAlg = hAlg.lower()</span>
<span class="gi">+        hashBytes = secureHash(bytearray(bytes), hAlg)</span>
<span class="gi">+        return self.sign(hashBytes, padding=rsaScheme, hashAlg=hAlg,</span>
<span class="gi">+                         saltLen=sLen)</span>

<span class="w"> </span>    def hashAndVerify(self, sigBytes, bytes, rsaScheme=None, hAlg=&#39;sha1&#39;,
<span class="gd">-        sLen=None):</span>
<span class="gi">+                      sLen=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Hash and verify the passed-in bytes with the signature.

<span class="w"> </span>        This verifies an ECDSA signature on the passed-in data
<span class="gu">@@ -89,9 +105,12 @@ class ECDSAKey(object):</span>
<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        :returns: Whether the signature matches the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hAlg = hAlg.lower()</span>
<span class="gi">+</span>
<span class="gi">+        hashBytes = secureHash(bytearray(bytes), hAlg)</span>
<span class="gi">+        return self.verify(sigBytes, hashBytes, rsaScheme, hAlg, sLen)</span>

<span class="gd">-    def sign(self, bytes, padding=None, hashAlg=&#39;sha1&#39;, saltLen=None):</span>
<span class="gi">+    def sign(self, bytes, padding=None, hashAlg=&quot;sha1&quot;, saltLen=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Sign the passed-in bytes.

<span class="w"> </span>        This requires the key to have a private component.  It performs
<span class="gu">@@ -113,10 +132,11 @@ class ECDSAKey(object):</span>
<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        :returns: An ECDSA signature on the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sigBytes = self._sign(bytes, hashAlg)</span>
<span class="gi">+        return sigBytes</span>

<span class="gd">-    def verify(self, sigBytes, bytes, padding=None, hashAlg=None, saltLen=None</span>
<span class="gd">-        ):</span>
<span class="gi">+    def verify(self, sigBytes, bytes, padding=None, hashAlg=None,</span>
<span class="gi">+               saltLen=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify the passed-in bytes with the signature.

<span class="w"> </span>        This verifies a PKCS1 signature on the passed-in data.
<span class="gu">@@ -133,7 +153,7 @@ class ECDSAKey(object):</span>
<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        :returns: Whether the signature matches the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._verify(sigBytes, bytes)</span>

<span class="w"> </span>    def acceptsPassword(self):
<span class="w"> </span>        &quot;&quot;&quot;Return True if the write() method accepts a password for use
<span class="gu">@@ -141,7 +161,7 @@ class ECDSAKey(object):</span>

<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    def write(self, password=None):
<span class="w"> </span>        &quot;&quot;&quot;Return a string containing the key.
<span class="gu">@@ -150,7 +170,7 @@ class ECDSAKey(object):</span>
<span class="w"> </span>        :returns: A string describing the key, in whichever format (PEM)
<span class="w"> </span>            is native to the implementation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def generate(bits):
<span class="gu">@@ -158,4 +178,4 @@ class ECDSAKey(object):</span>

<span class="w"> </span>        :rtype: ~tlslite.utils.ECDSAKey.ECDSAKey
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gh">diff --git a/tlslite/utils/eddsakey.py b/tlslite/utils/eddsakey.py</span>
<span class="gh">index f9ddd18..7754319 100644</span>
<span class="gd">--- a/tlslite/utils/eddsakey.py</span>
<span class="gi">+++ b/tlslite/utils/eddsakey.py</span>
<span class="gu">@@ -1,3 +1,6 @@</span>
<span class="gi">+# Author: Hubert Kario</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Abstract class for EdDSA.&quot;&quot;&quot;


<span class="gu">@@ -13,7 +16,6 @@ class EdDSAKey(object):</span>
<span class="w"> </span>    directly.  Instead, use the factory functions in
<span class="w"> </span>    :py:class:`~tlslite.utils.keyfactory`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the size of the order of the curve of this key, in bits.

<span class="gu">@@ -26,7 +28,13 @@ class EdDSAKey(object):</span>

<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _hashAndSign(self, data):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _hashAndVerify(self, signature, data):</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    def hashAndSign(self, data, rsaScheme=None, hAlg=None, sLen=None):
<span class="w"> </span>        &quot;&quot;&quot;Hash and sign the passed-in bytes.
<span class="gu">@@ -49,10 +57,10 @@ class EdDSAKey(object):</span>
<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        :returns: An EdDSA signature on the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._hashAndSign(data)</span>

<span class="w"> </span>    def hashAndVerify(self, sig_bytes, data, rsaScheme=None, hAlg=None,
<span class="gd">-        sLen=None):</span>
<span class="gi">+                      sLen=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Hash and verify the passed-in bytes with the signature.

<span class="w"> </span>        This verifies an EdDSA signature on the passed-in data
<span class="gu">@@ -76,10 +84,10 @@ class EdDSAKey(object):</span>
<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        :returns: Whether the signature matches the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._hashAndVerify(sig_bytes, data)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def sign(self, bytes, padding=None, hashAlg=&#39;sha1&#39;, saltLen=None):</span>
<span class="gi">+    def sign(self, bytes, padding=None, hashAlg=&quot;sha1&quot;, saltLen=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Sign the passed-in bytes.

<span class="w"> </span>        Note: this method is unsupported for EdDSA keys, as pre-hash
<span class="gu">@@ -98,11 +106,12 @@ class EdDSAKey(object):</span>
<span class="w"> </span>        :type saltLen: int
<span class="w"> </span>        :param saltLen: Ignored
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise TypeError(&quot;Only Pure EdDSA signatures are supported, use &quot;</span>
<span class="gi">+                        &quot;hashAndSign() instead.&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def verify(self, sigBytes, bytes, padding=None, hashAlg=None, saltLen=None</span>
<span class="gd">-        ):</span>
<span class="gi">+    def verify(self, sigBytes, bytes, padding=None, hashAlg=None,</span>
<span class="gi">+               saltLen=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify the passed-in bytes with the signature.

<span class="w"> </span>        Note: this method is unsupported for EdDSA keys, as pre-hash
<span class="gu">@@ -118,7 +127,8 @@ class EdDSAKey(object):</span>
<span class="w"> </span>        :type padding: str
<span class="w"> </span>        :param padding: Ignored
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise TypeError(&quot;Only Pure EdDSA signatures are supported, use &quot;</span>
<span class="gi">+                        &quot;hashAndVerify() instead.&quot;)</span>

<span class="w"> </span>    def acceptsPassword(self):
<span class="w"> </span>        &quot;&quot;&quot;Return True if the write() method accepts a password for use
<span class="gu">@@ -126,7 +136,7 @@ class EdDSAKey(object):</span>

<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    def write(self, password=None):
<span class="w"> </span>        &quot;&quot;&quot;Return a string containing the key.
<span class="gu">@@ -135,7 +145,7 @@ class EdDSAKey(object):</span>
<span class="w"> </span>        :returns: A string describing the key, in whichever format (PEM)
<span class="w"> </span>            is native to the implementation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def generate(bits):
<span class="gu">@@ -143,4 +153,4 @@ class EdDSAKey(object):</span>

<span class="w"> </span>        :rtype: ~tlslite.utils.EdDSAKey.EdDSAKey
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gh">diff --git a/tlslite/utils/format_output.py b/tlslite/utils/format_output.py</span>
<span class="gh">index 76c5157..161633e 100644</span>
<span class="gd">--- a/tlslite/utils/format_output.py</span>
<span class="gi">+++ b/tlslite/utils/format_output.py</span>
<span class="gu">@@ -1,3 +1,7 @@</span>
<span class="gi">+# Author: Milan Lysonek</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Helper functions for output formatting&quot;&quot;&quot;


<span class="gu">@@ -10,4 +14,6 @@ def none_as_unknown(text, number):</span>
<span class="w"> </span>    :type number: int
<span class="w"> </span>    :param number: number used in text
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not text:</span>
<span class="gi">+        text = &quot;unknown({0})&quot;.format(number)</span>
<span class="gi">+    return text</span>
<span class="gh">diff --git a/tlslite/utils/keyfactory.py b/tlslite/utils/keyfactory.py</span>
<span class="gh">index 10fe885..eca8f91 100644</span>
<span class="gd">--- a/tlslite/utils/keyfactory.py</span>
<span class="gi">+++ b/tlslite/utils/keyfactory.py</span>
<span class="gu">@@ -1,18 +1,28 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Factory functions for asymmetric cryptography.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .compat import *
<span class="gi">+</span>
<span class="w"> </span>from .rsakey import RSAKey
<span class="w"> </span>from .python_rsakey import Python_RSAKey
<span class="w"> </span>from .python_ecdsakey import Python_ECDSAKey
<span class="w"> </span>from .python_dsakey import Python_DSAKey
<span class="w"> </span>from .python_eddsakey import Python_EdDSAKey
<span class="w"> </span>from tlslite.utils import cryptomath
<span class="gi">+</span>
<span class="w"> </span>if cryptomath.m2cryptoLoaded:
<span class="w"> </span>    from .openssl_rsakey import OpenSSL_RSAKey
<span class="gi">+</span>
<span class="w"> </span>if cryptomath.pycryptoLoaded:
<span class="w"> </span>    from .pycrypto_rsakey import PyCrypto_RSAKey

<span class="gi">+# **************************************************************************</span>
<span class="gi">+# Factory Functions for RSA Keys</span>
<span class="gi">+# **************************************************************************</span>

<span class="gd">-def generateRSAKey(bits, implementations=[&#39;openssl&#39;, &#39;python&#39;]):</span>
<span class="gi">+def generateRSAKey(bits, implementations=[&quot;openssl&quot;, &quot;python&quot;]):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate an RSA key with the specified bit length.

<span class="w"> </span>    :type bits: int
<span class="gu">@@ -21,11 +31,16 @@ def generateRSAKey(bits, implementations=[&#39;openssl&#39;, &#39;python&#39;]):</span>
<span class="w"> </span>    :rtype: ~tlslite.utils.rsakey.RSAKey
<span class="w"> </span>    :returns: A new RSA private key.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    for implementation in implementations:</span>
<span class="gi">+        if implementation == &quot;openssl&quot; and cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            return OpenSSL_RSAKey.generate(bits)</span>
<span class="gi">+        elif implementation == &quot;python&quot;:</span>
<span class="gi">+            return Python_RSAKey.generate(bits)</span>
<span class="gi">+    raise ValueError(&quot;No acceptable implementations&quot;)</span>
<span class="gi">+</span>
<span class="gi">+#Parse as an OpenSSL or Python key</span>
<span class="w"> </span>def parsePEMKey(s, private=False, public=False, passwordCallback=None,
<span class="gd">-    implementations=[&#39;openssl&#39;, &#39;python&#39;]):</span>
<span class="gi">+                implementations=[&quot;openssl&quot;, &quot;python&quot;]):</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a PEM-format key.

<span class="w"> </span>    The PEM format is used by OpenSSL and other tools.  The
<span class="gu">@@ -81,7 +96,48 @@ def parsePEMKey(s, private=False, public=False, passwordCallback=None,</span>

<span class="w"> </span>    :raises SyntaxError: If the key is not properly formatted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # as old versions of openssl can&#39;t handle RSA-PSS or ECDSA keys, first</span>
<span class="gi">+    # try to detect what kind of key it is (we ignore errors as the python</span>
<span class="gi">+    # code can&#39;t handle encrypted key files while m2crypto/openssl can)</span>
<span class="gi">+    key_type = &quot;rsa&quot;</span>
<span class="gi">+    try:</span>
<span class="gi">+        key = Python_RSAKey.parsePEM(s)</span>
<span class="gi">+        key_type = key.key_type</span>
<span class="gi">+        del key</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    for implementation in implementations:</span>
<span class="gi">+        if implementation == &quot;openssl&quot; and cryptomath.m2cryptoLoaded \</span>
<span class="gi">+                and key_type == &quot;rsa&quot;:</span>
<span class="gi">+            key = OpenSSL_RSAKey.parse(s, passwordCallback)</span>
<span class="gi">+            break</span>
<span class="gi">+        elif implementation == &quot;python&quot;:</span>
<span class="gi">+            key = Python_RSAKey.parsePEM(s)</span>
<span class="gi">+            break</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;No acceptable implementations&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return _parseKeyHelper(key, private, public)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parseKeyHelper(key, private, public):</span>
<span class="gi">+    if private and not key.hasPrivateKey():</span>
<span class="gi">+        raise SyntaxError(&quot;Not a private key!&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if public:</span>
<span class="gi">+        return _createPublicKey(key)</span>
<span class="gi">+</span>
<span class="gi">+    if private:</span>
<span class="gi">+        if cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            if type(key) == Python_RSAKey:</span>
<span class="gi">+                return _createPrivateKey(key)</span>
<span class="gi">+            assert type(key) in (OpenSSL_RSAKey, Python_ECDSAKey,</span>
<span class="gi">+                Python_DSAKey, Python_EdDSAKey), type(key)</span>
<span class="gi">+            return key</span>
<span class="gi">+        elif hasattr(key, &quot;d&quot;):</span>
<span class="gi">+            return _createPrivateKey(key)</span>
<span class="gi">+    return key</span>


<span class="w"> </span>def parseAsPublicKey(s):
<span class="gu">@@ -95,8 +151,7 @@ def parseAsPublicKey(s):</span>

<span class="w"> </span>    :raises SyntaxError: If the key is not properly formatted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    return parsePEMKey(s, public=True)</span>

<span class="w"> </span>def parsePrivateKey(s):
<span class="w"> </span>    &quot;&quot;&quot;Parse a PEM-formatted private key.
<span class="gu">@@ -109,26 +164,57 @@ def parsePrivateKey(s):</span>

<span class="w"> </span>    :raises SyntaxError: If the key is not properly formatted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    return parsePEMKey(s, private=True)</span>

<span class="w"> </span>def _createPublicKey(key):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a new public key.  Discard any private component,
<span class="w"> </span>    and return the most efficient key possible.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    if not isinstance(key, RSAKey):</span>
<span class="gi">+        raise AssertionError()</span>
<span class="gi">+    return _createPublicRSAKey(key.n, key.e, key.key_type)</span>

<span class="w"> </span>def _createPrivateKey(key):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a new private key.  Return the most efficient key possible.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _create_public_ecdsa_key(point_x, point_y, curve_name, implementations=</span>
<span class="gd">-    (&#39;python&#39;,)):</span>
<span class="gi">+    if not isinstance(key, RSAKey):</span>
<span class="gi">+        raise AssertionError()</span>
<span class="gi">+    if not key.hasPrivateKey():</span>
<span class="gi">+        raise AssertionError()</span>
<span class="gi">+    return _createPrivateRSAKey(key.n, key.e, key.d, key.p, key.q, key.dP,</span>
<span class="gi">+                                key.dQ, key.qInv, key.key_type)</span>
<span class="gi">+</span>
<span class="gi">+# n, e, d, etc. are the names used in mathematical proofs for the variables</span>
<span class="gi">+# so using so short names makes it actually more readable</span>
<span class="gi">+# pylint: disable=invalid-name</span>
<span class="gi">+def _createPublicRSAKey(n, e, key_type,</span>
<span class="gi">+                        implementations=(&quot;openssl&quot;, &quot;pycrypto&quot;, &quot;python&quot;)):</span>
<span class="gi">+    for implementation in implementations:</span>
<span class="gi">+        if implementation == &quot;openssl&quot; and cryptomath.m2cryptoLoaded:</span>
<span class="gi">+            return OpenSSL_RSAKey(n, e, key_type=key_type)</span>
<span class="gi">+        elif implementation == &quot;pycrypto&quot; and cryptomath.pycryptoLoaded:</span>
<span class="gi">+            return PyCrypto_RSAKey(n, e, key_type=key_type)</span>
<span class="gi">+        elif implementation == &quot;python&quot;:</span>
<span class="gi">+            return Python_RSAKey(n, e, key_type=key_type)</span>
<span class="gi">+    raise ValueError(&quot;No acceptable implementations&quot;)</span>
<span class="gi">+</span>
<span class="gi">+def _createPrivateRSAKey(n, e, d, p, q, dP, dQ, qInv, key_type,</span>
<span class="gi">+                         implementations=(&quot;pycrypto&quot;, &quot;python&quot;)):</span>
<span class="gi">+    for implementation in implementations:</span>
<span class="gi">+        if implementation == &quot;pycrypto&quot; and cryptomath.pycryptoLoaded:</span>
<span class="gi">+            return PyCrypto_RSAKey(n, e, d, p, q, dP, dQ, qInv,</span>
<span class="gi">+                                   key_type=key_type)</span>
<span class="gi">+        elif implementation == &quot;python&quot;:</span>
<span class="gi">+            return Python_RSAKey(n, e, d, p, q, dP, dQ, qInv,</span>
<span class="gi">+                                 key_type=key_type)</span>
<span class="gi">+    raise ValueError(&quot;No acceptable implementations&quot;)</span>
<span class="gi">+# pylint: enable=invalid-name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_public_ecdsa_key(point_x, point_y, curve_name,</span>
<span class="gi">+                             implementations=(&quot;python&quot;,)):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert public key parameters into concrete implementation of verifier.

<span class="gu">@@ -148,18 +234,26 @@ def _create_public_ecdsa_key(point_x, point_y, curve_name, implementations=</span>
<span class="w"> </span>        concrete implementation of the verifying key (only &#39;python&#39; is
<span class="w"> </span>        supported currently)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for impl in implementations:</span>
<span class="gi">+        if impl == &quot;python&quot;:</span>
<span class="gi">+            return Python_ECDSAKey(point_x, point_y, curve_name)</span>
<span class="gi">+    raise ValueError(&quot;No acceptable implementation&quot;)</span>


<span class="gd">-def _create_public_eddsa_key(public_key, implementations=(&#39;python&#39;,)):</span>
<span class="gi">+def _create_public_eddsa_key(public_key,</span>
<span class="gi">+                             implementations=(&quot;python&quot;,)):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert the python-ecdsa public key into concrete implementation of
<span class="w"> </span>    verifier.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for impl in implementations:</span>
<span class="gi">+        if impl == &quot;python&quot;:</span>
<span class="gi">+            return Python_EdDSAKey(public_key)</span>
<span class="gi">+    raise ValueError(&quot;No acceptable implementation&quot;)</span>


<span class="gd">-def _create_public_dsa_key(p, q, g, y, implementations=(&#39;python&#39;,)):</span>
<span class="gi">+def _create_public_dsa_key(p, q, g, y,</span>
<span class="gi">+                           implementations=(&quot;python&quot;,)):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert public key parameters into concrete implementation of verifier.

<span class="gu">@@ -178,4 +272,7 @@ def _create_public_dsa_key(p, q, g, y, implementations=(&#39;python&#39;,)):</span>
<span class="w"> </span>        concrete implementation of the verifying key (only &#39;python&#39; is
<span class="w"> </span>        supported currently)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for impl in implementations:</span>
<span class="gi">+        if impl == &quot;python&quot;:</span>
<span class="gi">+            return Python_DSAKey(p=p, q=q, g=g, y=y)</span>
<span class="gi">+    raise ValueError(&quot;No acceptable implementation&quot;)</span>
<span class="gh">diff --git a/tlslite/utils/lists.py b/tlslite/utils/lists.py</span>
<span class="gh">index 021c4ba..d8f2bab 100644</span>
<span class="gd">--- a/tlslite/utils/lists.py</span>
<span class="gi">+++ b/tlslite/utils/lists.py</span>
<span class="gu">@@ -1,4 +1,10 @@</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Hubert Kario (2016)</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Helper functions for handling lists&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from itertools import chain


<span class="gu">@@ -15,10 +21,13 @@ def getFirstMatching(values, matches):</span>
<span class="w"> </span>    :type matches: collections.abc.Container
<span class="w"> </span>    :param matches: list of items to check against
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert matches is not None</span>
<span class="gi">+    if not values:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return next((i for i in values if i in matches), None)</span>


<span class="gd">-def to_str_delimiter(values, delim=&#39;, &#39;, last_delim=&#39; or &#39;):</span>
<span class="gi">+def to_str_delimiter(values, delim=&quot;, &quot;, last_delim=&quot; or &quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Format the list as a human readable string.

<span class="gu">@@ -34,4 +43,7 @@ def to_str_delimiter(values, delim=&#39;, &#39;, last_delim=&#39; or &#39;):</span>
<span class="w"> </span>    :param last_delim: delimiter for last object in list
<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # we need to slice the iterator, so we need a copy</span>
<span class="gi">+    values = list(values)</span>
<span class="gi">+    return delim.join(chain((str(i) for i in values[:-2]),</span>
<span class="gi">+                            [last_delim.join(str(i) for i in values[-2:])]))</span>
<span class="gh">diff --git a/tlslite/utils/openssl_aes.py b/tlslite/utils/openssl_aes.py</span>
<span class="gh">index 1d3b56d..21b16c3 100644</span>
<span class="gd">--- a/tlslite/utils/openssl_aes.py</span>
<span class="gi">+++ b/tlslite/utils/openssl_aes.py</span>
<span class="gu">@@ -1,26 +1,85 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;OpenSSL/M2Crypto AES implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import *
<span class="w"> </span>from .aes import *
<span class="w"> </span>from .python_aes import Python_AES_CTR
<span class="gi">+</span>
<span class="w"> </span>if m2cryptoLoaded:

<span class="w"> </span>    def new(key, mode, IV):
<span class="gi">+        # IV argument name is a part of the interface</span>
<span class="gi">+        # pylint: disable=invalid-name</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Try using AES CTR from m2crpyto,
<span class="w"> </span>        if it is not available fall back to the
<span class="w"> </span>        python implementation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mode == 2:</span>
<span class="gi">+            return OpenSSL_AES(key, mode, IV)</span>
<span class="gi">+        elif mode == 6:</span>
<span class="gi">+            if M2CRYPTO_AES_CTR:</span>
<span class="gi">+                return OpenSSL_CTR(key, mode, IV)</span>
<span class="gi">+            return Python_AES_CTR(key, mode, IV)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError()</span>


<span class="w"> </span>    class OpenSSL_AES(AES):

<span class="w"> </span>        def __init__(self, key, mode, IV):
<span class="gd">-            AES.__init__(self, key, mode, IV, &#39;openssl&#39;)</span>
<span class="gi">+            # IV argument/field names are a part of the interface</span>
<span class="gi">+            # pylint: disable=invalid-name</span>
<span class="gi">+            AES.__init__(self, key, mode, IV, &quot;openssl&quot;)</span>
<span class="w"> </span>            self._IV, self._key = IV, key
<span class="w"> </span>            self._context = None
<span class="w"> </span>            self._encrypt = None

<span class="gi">+        @property</span>
<span class="gi">+        def IV(self):</span>
<span class="gi">+            return self._IV</span>
<span class="gi">+</span>
<span class="gi">+        @IV.setter</span>
<span class="gi">+        def IV(self, iv):</span>
<span class="gi">+            if self._context is not None:</span>
<span class="gi">+                m2.cipher_ctx_free(self._context)</span>
<span class="gi">+            self._IV = iv</span>
<span class="gi">+            self._init_context()</span>
<span class="gi">+</span>
<span class="gi">+        def _init_context(self, encrypt=True):</span>
<span class="gi">+            if len(self._key) == 16:</span>
<span class="gi">+                cipherType = m2.aes_128_cbc()</span>
<span class="gi">+            if len(self._key) == 24:</span>
<span class="gi">+                cipherType = m2.aes_192_cbc()</span>
<span class="gi">+            if len(self._key) == 32:</span>
<span class="gi">+                cipherType = m2.aes_256_cbc()</span>
<span class="gi">+            self._context = m2.cipher_ctx_new()</span>
<span class="gi">+            m2.cipher_init(self._context, cipherType, self._key, self._IV,</span>
<span class="gi">+                           int(encrypt))</span>
<span class="gi">+            m2.cipher_set_padding(self._context, 0)</span>
<span class="gi">+            self._encrypt = encrypt</span>
<span class="gi">+</span>
<span class="gi">+        def encrypt(self, plaintext):</span>
<span class="gi">+            if self._context is None:</span>
<span class="gi">+                self._init_context(encrypt=True)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert self._encrypt, &#39;.encrypt() not allowed after .decrypt()&#39;</span>
<span class="gi">+            AES.encrypt(self, plaintext)</span>
<span class="gi">+            ciphertext = m2.cipher_update(self._context, plaintext)</span>
<span class="gi">+            return bytearray(ciphertext)</span>
<span class="gi">+</span>
<span class="gi">+        def decrypt(self, ciphertext):</span>
<span class="gi">+            if self._context is None:</span>
<span class="gi">+                self._init_context(encrypt=False)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert not self._encrypt, \</span>
<span class="gi">+                       &#39;.decrypt() not allowed after .encrypt()&#39;</span>
<span class="gi">+            AES.decrypt(self, ciphertext)</span>
<span class="gi">+            plaintext = m2.cipher_update(self._context, ciphertext)</span>
<span class="gi">+            return bytearray(plaintext)</span>
<span class="gi">+</span>
<span class="w"> </span>        def __del__(self):
<span class="w"> </span>            if self._context is not None:
<span class="w"> </span>                m2.cipher_ctx_free(self._context)
<span class="gu">@@ -29,7 +88,9 @@ if m2cryptoLoaded:</span>
<span class="w"> </span>    class OpenSSL_CTR(AES):

<span class="w"> </span>        def __init__(self, key, mode, IV):
<span class="gd">-            AES.__init__(self, key, mode, IV, &#39;openssl&#39;)</span>
<span class="gi">+            # IV argument/field names are a part of the interface</span>
<span class="gi">+            # pylint: disable=invalid-name</span>
<span class="gi">+            AES.__init__(self, key, mode, IV, &quot;openssl&quot;)</span>
<span class="w"> </span>            self._IV = IV
<span class="w"> </span>            self.key = key
<span class="w"> </span>            self._context = None
<span class="gu">@@ -37,6 +98,38 @@ if m2cryptoLoaded:</span>
<span class="w"> </span>            if len(key) not in (16, 24, 32):
<span class="w"> </span>                raise AssertionError()

<span class="gi">+        @property</span>
<span class="gi">+        def counter(self):</span>
<span class="gi">+            return self._IV</span>
<span class="gi">+</span>
<span class="gi">+        @counter.setter</span>
<span class="gi">+        def counter(self, ctr):</span>
<span class="gi">+            if self._context is not None:</span>
<span class="gi">+                m2.cipher_ctx_free(self._context)</span>
<span class="gi">+            self._IV = ctr</span>
<span class="gi">+            self._init_context()</span>
<span class="gi">+</span>
<span class="gi">+        def _init_context(self, encrypt=True):</span>
<span class="gi">+            if len(self.key) == 16:</span>
<span class="gi">+                cipherType = m2.aes_128_ctr()</span>
<span class="gi">+            if len(self.key) == 24:</span>
<span class="gi">+                cipherType = m2.aes_192_ctr()</span>
<span class="gi">+            if len(self.key) == 32:</span>
<span class="gi">+                cipherType = m2.aes_256_ctr()</span>
<span class="gi">+            self._context = m2.cipher_ctx_new()</span>
<span class="gi">+            m2.cipher_init(self._context, cipherType, self.key, self._IV,</span>
<span class="gi">+                           int(encrypt))</span>
<span class="gi">+            m2.cipher_set_padding(self._context, 0)</span>
<span class="gi">+            self._encrypt = encrypt</span>
<span class="gi">+</span>
<span class="gi">+        def encrypt(self, plaintext):</span>
<span class="gi">+            ciphertext = m2.cipher_update(self._context, plaintext)</span>
<span class="gi">+            return bytearray(ciphertext)</span>
<span class="gi">+</span>
<span class="gi">+        def decrypt(self, ciphertext):</span>
<span class="gi">+            plaintext = m2.cipher_update(self._context, ciphertext)</span>
<span class="gi">+            return bytearray(plaintext)</span>
<span class="gi">+</span>
<span class="w"> </span>        def __del__(self):
<span class="w"> </span>            if self._context is not None:
<span class="w"> </span>                m2.cipher_ctx_free(self._context)
<span class="gh">diff --git a/tlslite/utils/openssl_aesccm.py b/tlslite/utils/openssl_aesccm.py</span>
<span class="gh">index 0c807d4..9ee8d7a 100644</span>
<span class="gd">--- a/tlslite/utils/openssl_aesccm.py</span>
<span class="gi">+++ b/tlslite/utils/openssl_aesccm.py</span>
<span class="gu">@@ -1,14 +1,21 @@</span>
<span class="gi">+# Author: Ivan Nikolchev</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;AESCCM with CTR and CBC from m2crypto&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from tlslite.utils.cryptomath import m2cryptoLoaded
<span class="w"> </span>from tlslite.utils.aesccm import AESCCM
<span class="w"> </span>from tlslite.utils import openssl_aes
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if m2cryptoLoaded:
<span class="gi">+    def new(key, tagLength=16):</span>
<span class="gi">+        return OPENSSL_AESCCM(key, &quot;openssl&quot;, bytearray(16), tagLength)</span>


<span class="w"> </span>class OPENSSL_AESCCM(AESCCM):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, key, implementation, rawAesEncrypt, tagLength):
<span class="gd">-        super(OPENSSL_AESCCM, self).__init__(key, implementation,</span>
<span class="gd">-            rawAesEncrypt, tagLength)</span>
<span class="gi">+        super(OPENSSL_AESCCM, self).__init__(key, implementation, rawAesEncrypt, tagLength)</span>
<span class="gi">+</span>
<span class="w"> </span>        self._ctr = openssl_aes.new(key, 6, bytearray(b&#39;\x00&#39; * 16))
<span class="w"> </span>        self._cbc = openssl_aes.new(key, 2, bytearray(b&#39;\x00&#39; * 16))
<span class="gh">diff --git a/tlslite/utils/openssl_aesgcm.py b/tlslite/utils/openssl_aesgcm.py</span>
<span class="gh">index 0b6af7d..e9f342f 100644</span>
<span class="gd">--- a/tlslite/utils/openssl_aesgcm.py</span>
<span class="gi">+++ b/tlslite/utils/openssl_aesgcm.py</span>
<span class="gu">@@ -1,14 +1,20 @@</span>
<span class="gi">+# Author: Ivan Nikolchev</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;AESGCM with CTR from m2crypto&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from tlslite.utils.cryptomath import m2cryptoLoaded
<span class="w"> </span>from tlslite.utils.aesgcm import AESGCM
<span class="w"> </span>from tlslite.utils import openssl_aes
<span class="w"> </span>from tlslite.utils.rijndael import Rijndael
<span class="gi">+</span>
<span class="w"> </span>if m2cryptoLoaded:
<span class="gi">+    def new(key):</span>
<span class="gi">+        return OPENSSL_AESGCM(key, &quot;openssl&quot;, Rijndael(key, 16).encrypt)</span>


<span class="w"> </span>class OPENSSL_AESGCM(AESGCM):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, key, implementation, rawAesEncrypt):
<span class="gd">-        super(OPENSSL_AESGCM, self).__init__(key, implementation, rawAesEncrypt</span>
<span class="gd">-            )</span>
<span class="gi">+        super(OPENSSL_AESGCM, self).__init__(key, implementation, rawAesEncrypt)</span>
<span class="gi">+</span>
<span class="w"> </span>        self._ctr = openssl_aes.new(key, 6, bytearray(b&#39;\x00&#39; * 16))
<span class="gh">diff --git a/tlslite/utils/openssl_rc4.py b/tlslite/utils/openssl_rc4.py</span>
<span class="gh">index fcd3fd7..2fbfa07 100644</span>
<span class="gd">--- a/tlslite/utils/openssl_rc4.py</span>
<span class="gi">+++ b/tlslite/utils/openssl_rc4.py</span>
<span class="gu">@@ -1,15 +1,28 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;OpenSSL/M2Crypto RC4 implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import *
<span class="w"> </span>from .rc4 import RC4
<span class="gi">+</span>
<span class="w"> </span>if m2cryptoLoaded:

<span class="gi">+    def new(key):</span>
<span class="gi">+        return OpenSSL_RC4(key)</span>

<span class="w"> </span>    class OpenSSL_RC4(RC4):

<span class="w"> </span>        def __init__(self, key):
<span class="gd">-            RC4.__init__(self, key, &#39;openssl&#39;)</span>
<span class="gi">+            RC4.__init__(self, key, &quot;openssl&quot;)</span>
<span class="w"> </span>            self.rc4 = m2.rc4_new()
<span class="w"> </span>            m2.rc4_set_key(self.rc4, key)

<span class="w"> </span>        def __del__(self):
<span class="w"> </span>            m2.rc4_free(self.rc4)
<span class="gi">+</span>
<span class="gi">+        def encrypt(self, plaintext):</span>
<span class="gi">+            return bytearray(m2.rc4_update(self.rc4, plaintext))</span>
<span class="gi">+</span>
<span class="gi">+        def decrypt(self, ciphertext):</span>
<span class="gi">+            return bytearray(self.encrypt(ciphertext))</span>
<span class="gh">diff --git a/tlslite/utils/openssl_rsakey.py b/tlslite/utils/openssl_rsakey.py</span>
<span class="gh">index 587131f..240bf78 100644</span>
<span class="gd">--- a/tlslite/utils/openssl_rsakey.py</span>
<span class="gi">+++ b/tlslite/utils/openssl_rsakey.py</span>
<span class="gu">@@ -1,18 +1,42 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;OpenSSL/M2Crypto RSA implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import *
<span class="gi">+</span>
<span class="w"> </span>from .rsakey import *
<span class="w"> </span>from .python_rsakey import Python_RSAKey
<span class="w"> </span>from .compat import compatAscii2Bytes, compat_b2a
<span class="gi">+</span>
<span class="gi">+#copied from M2Crypto.util.py, so when we load the local copy of m2</span>
<span class="gi">+#we can still use it</span>
<span class="gi">+def password_callback(v, prompt1=&#39;Enter private key passphrase:&#39;,</span>
<span class="gi">+                           prompt2=&#39;Verify passphrase:&#39;):</span>
<span class="gi">+    from getpass import getpass</span>
<span class="gi">+    while 1:</span>
<span class="gi">+        try:</span>
<span class="gi">+            p1=getpass(prompt1)</span>
<span class="gi">+            if v:</span>
<span class="gi">+                p2=getpass(prompt2)</span>
<span class="gi">+                if p1==p2:</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        except KeyboardInterrupt:</span>
<span class="gi">+            return None</span>
<span class="gi">+    return p1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if m2cryptoLoaded:
<span class="gi">+    # pylint: disable=import-error</span>
<span class="w"> </span>    from M2Crypto.RSA import RSAError

<span class="gd">-</span>
<span class="w"> </span>    class OpenSSL_RSAKey(RSAKey):
<span class="gd">-</span>
<span class="gd">-        def __init__(self, n=0, e=0, key_type=&#39;rsa&#39;):</span>
<span class="gi">+        def __init__(self, n=0, e=0, key_type=&quot;rsa&quot;):</span>
<span class="w"> </span>            self.rsa = None
<span class="w"> </span>            self._hasPrivateKey = False
<span class="gd">-            if n and not e or e and not n:</span>
<span class="gi">+            if (n and not e) or (e and not n):</span>
<span class="w"> </span>                raise AssertionError()
<span class="w"> </span>            if n and e:
<span class="w"> </span>                self.rsa = m2.rsa_new()
<span class="gu">@@ -35,3 +59,128 @@ if m2cryptoLoaded:</span>
<span class="w"> </span>                return mpiToNumber(m2.rsa_get_n(self.rsa))
<span class="w"> </span>            else:
<span class="w"> </span>                raise AttributeError
<span class="gi">+</span>
<span class="gi">+        def hasPrivateKey(self):</span>
<span class="gi">+            return self._hasPrivateKey</span>
<span class="gi">+</span>
<span class="gi">+        def _rawPrivateKeyOp(self, message):</span>
<span class="gi">+            data = numberToByteArray(message, numBytes(self.n))</span>
<span class="gi">+            string = m2.rsa_private_encrypt(self.rsa, bytes(data),</span>
<span class="gi">+                                            m2.no_padding)</span>
<span class="gi">+            ciphertext = bytesToNumber(bytearray(string))</span>
<span class="gi">+            return ciphertext</span>
<span class="gi">+</span>
<span class="gi">+        def _raw_private_key_op_bytes(self, message):</span>
<span class="gi">+            return self._call_m2crypto(</span>
<span class="gi">+                m2.rsa_private_encrypt, message,</span>
<span class="gi">+                &quot;Bad parameters to private key operation&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        def _rawPublicKeyOp(self, ciphertext):</span>
<span class="gi">+            data = numberToByteArray(ciphertext, numBytes(self.n))</span>
<span class="gi">+            string = m2.rsa_public_decrypt(self.rsa, bytes(data),</span>
<span class="gi">+                                           m2.no_padding)</span>
<span class="gi">+            message = bytesToNumber(bytearray(string))</span>
<span class="gi">+            return message</span>
<span class="gi">+</span>
<span class="gi">+        def _call_m2crypto(self, method, param, err_msg):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return bytearray(method(self.rsa, bytes(param), m2.no_padding))</span>
<span class="gi">+            except RSAError:</span>
<span class="gi">+                raise ValueError(err_msg)</span>
<span class="gi">+</span>
<span class="gi">+        def _raw_public_key_op_bytes(self, ciphertext):</span>
<span class="gi">+            return self._call_m2crypto(</span>
<span class="gi">+                m2.rsa_public_decrypt, ciphertext,</span>
<span class="gi">+                &quot;Bad parameters to public key operation&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        def acceptsPassword(self): return True</span>
<span class="gi">+</span>
<span class="gi">+        def write(self, password=None):</span>
<span class="gi">+            bio = m2.bio_new(m2.bio_s_mem())</span>
<span class="gi">+            if self._hasPrivateKey:</span>
<span class="gi">+                if password:</span>
<span class="gi">+                    def f(v): return password</span>
<span class="gi">+                    m2.rsa_write_key(self.rsa, bio, m2.des_ede_cbc(), f)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    def f(): pass</span>
<span class="gi">+                    m2.rsa_write_key_no_cipher(self.rsa, bio, f)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if password:</span>
<span class="gi">+                    raise AssertionError()</span>
<span class="gi">+                m2.rsa_write_pub_key(self.rsa, bio)</span>
<span class="gi">+            s = m2.bio_read(bio, m2.bio_ctrl_pending(bio))</span>
<span class="gi">+            m2.bio_free(bio)</span>
<span class="gi">+            return s</span>
<span class="gi">+</span>
<span class="gi">+        @staticmethod</span>
<span class="gi">+        def generate(bits, key_type=&quot;rsa&quot;):</span>
<span class="gi">+            key = OpenSSL_RSAKey()</span>
<span class="gi">+            def f():pass</span>
<span class="gi">+            # pylint: disable=no-member</span>
<span class="gi">+            key.rsa = m2.rsa_generate_key(bits, 65537, f)</span>
<span class="gi">+            # pylint: enable=no-member</span>
<span class="gi">+            key._hasPrivateKey = True</span>
<span class="gi">+            key.key_type = key_type</span>
<span class="gi">+            b64_key = compat_b2a(key.write())</span>
<span class="gi">+            py_key = Python_RSAKey.parsePEM(b64_key)</span>
<span class="gi">+            key.d = py_key.d</span>
<span class="gi">+            return key</span>
<span class="gi">+</span>
<span class="gi">+        @staticmethod</span>
<span class="gi">+        def parse(s, passwordCallback=None):</span>
<span class="gi">+            # Skip forward to the first PEM header</span>
<span class="gi">+            start = s.find(&quot;-----BEGIN &quot;)</span>
<span class="gi">+            if start == -1:</span>
<span class="gi">+                raise SyntaxError()</span>
<span class="gi">+            s = s[start:]            </span>
<span class="gi">+            if s.startswith(&quot;-----BEGIN &quot;):</span>
<span class="gi">+                if passwordCallback==None:</span>
<span class="gi">+                    callback = password_callback</span>
<span class="gi">+                else:</span>
<span class="gi">+                    def f(v, prompt1=None, prompt2=None):</span>
<span class="gi">+                        return passwordCallback()</span>
<span class="gi">+                    callback = f</span>
<span class="gi">+                bio = m2.bio_new(m2.bio_s_mem())</span>
<span class="gi">+                try:</span>
<span class="gi">+                    m2.bio_write(bio, compatAscii2Bytes(s))</span>
<span class="gi">+                    key = OpenSSL_RSAKey()</span>
<span class="gi">+                    # parse SSLay format PEM file</span>
<span class="gi">+                    if s.startswith(&quot;-----BEGIN RSA PRIVATE KEY-----&quot;):</span>
<span class="gi">+                        def f():pass</span>
<span class="gi">+                        key.rsa = m2.rsa_read_key(bio, callback)</span>
<span class="gi">+                        if key.rsa == None:</span>
<span class="gi">+                            raise SyntaxError()</span>
<span class="gi">+                        key._hasPrivateKey = True</span>
<span class="gi">+                    # parse a standard PKCS#8 PEM file</span>
<span class="gi">+                    elif s.startswith(&quot;-----BEGIN PRIVATE KEY-----&quot;):</span>
<span class="gi">+                        def f():pass</span>
<span class="gi">+                        key.rsa = m2.pkey_read_pem(bio, callback)</span>
<span class="gi">+                        # the below code assumes RSA key while PKCS#8 files</span>
<span class="gi">+                        # (and by extension the EVP_PKEY structure) can be</span>
<span class="gi">+                        # also DSA or EC, thus the double check against None</span>
<span class="gi">+                        # (first if the file was properly loaded and second</span>
<span class="gi">+                        # if the file actually has a RSA key in it)</span>
<span class="gi">+                        # tlslite doesn&#39;t support DSA or EC so it&#39;s useless</span>
<span class="gi">+                        # to handle them in a different way</span>
<span class="gi">+                        if key.rsa == None:</span>
<span class="gi">+                            raise SyntaxError()</span>
<span class="gi">+                        key.rsa = m2.pkey_get1_rsa(key.rsa)</span>
<span class="gi">+                        if key.rsa == None:</span>
<span class="gi">+                            raise SyntaxError()</span>
<span class="gi">+                        key._hasPrivateKey = True</span>
<span class="gi">+                    elif s.startswith(&quot;-----BEGIN PUBLIC KEY-----&quot;):</span>
<span class="gi">+                        key.rsa = m2.rsa_read_pub_key(bio)</span>
<span class="gi">+                        if key.rsa == None:</span>
<span class="gi">+                            raise SyntaxError()</span>
<span class="gi">+                        key._hasPrivateKey = False</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise SyntaxError()</span>
<span class="gi">+                    if key._hasPrivateKey:</span>
<span class="gi">+                        b64_key = compat_b2a(key.write())</span>
<span class="gi">+                        py_key = Python_RSAKey.parsePEM(b64_key)</span>
<span class="gi">+                        key.d = py_key.d</span>
<span class="gi">+                    return key</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    m2.bio_free(bio)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise SyntaxError()</span>
<span class="gh">diff --git a/tlslite/utils/openssl_tripledes.py b/tlslite/utils/openssl_tripledes.py</span>
<span class="gh">index 19810f4..89daf8c 100644</span>
<span class="gd">--- a/tlslite/utils/openssl_tripledes.py</span>
<span class="gi">+++ b/tlslite/utils/openssl_tripledes.py</span>
<span class="gu">@@ -1,17 +1,51 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;OpenSSL/M2Crypto 3DES implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import *
<span class="w"> </span>from .tripledes import *
<span class="gi">+</span>
<span class="w"> </span>if m2cryptoLoaded:

<span class="gi">+    def new(key, mode, IV):</span>
<span class="gi">+        return OpenSSL_TripleDES(key, mode, IV)</span>

<span class="w"> </span>    class OpenSSL_TripleDES(TripleDES):

<span class="w"> </span>        def __init__(self, key, mode, IV):
<span class="gd">-            TripleDES.__init__(self, key, mode, IV, &#39;openssl&#39;)</span>
<span class="gi">+            TripleDES.__init__(self, key, mode, IV, &quot;openssl&quot;)</span>
<span class="w"> </span>            self._IV, self._key = IV, key
<span class="w"> </span>            self._context = None
<span class="w"> </span>            self._encrypt = None

<span class="gi">+        def _init_context(self, encrypt=True):</span>
<span class="gi">+            cipherType = m2.des_ede3_cbc()</span>
<span class="gi">+            self._context = m2.cipher_ctx_new()</span>
<span class="gi">+            m2.cipher_init(self._context, cipherType, self._key, self._IV,</span>
<span class="gi">+                           int(encrypt))</span>
<span class="gi">+            m2.cipher_set_padding(self._context, 0)</span>
<span class="gi">+            self._encrypt = encrypt</span>
<span class="gi">+</span>
<span class="gi">+        def encrypt(self, plaintext):</span>
<span class="gi">+            if self._context is None:</span>
<span class="gi">+                self._init_context(encrypt=True)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert self._encrypt, &#39;.encrypt() not allowed after .decrypt()&#39;</span>
<span class="gi">+            TripleDES.encrypt(self, plaintext)</span>
<span class="gi">+            ciphertext = m2.cipher_update(self._context, plaintext)</span>
<span class="gi">+            return bytearray(ciphertext)</span>
<span class="gi">+</span>
<span class="gi">+        def decrypt(self, ciphertext):</span>
<span class="gi">+            if self._context is None:</span>
<span class="gi">+                self._init_context(encrypt=False)</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert not self._encrypt, \</span>
<span class="gi">+                       &#39;.decrypt() not allowed after .encrypt()&#39;</span>
<span class="gi">+            TripleDES.decrypt(self, ciphertext)</span>
<span class="gi">+            plaintext = m2.cipher_update(self._context, ciphertext)</span>
<span class="gi">+            return bytearray(plaintext)</span>
<span class="gi">+</span>
<span class="w"> </span>        def __del__(self):
<span class="w"> </span>            if self._context is not None:
<span class="w"> </span>                m2.cipher_ctx_free(self._context)
<span class="gh">diff --git a/tlslite/utils/pem.py b/tlslite/utils/pem.py</span>
<span class="gh">index b7cfe98..548bc34 100644</span>
<span class="gd">--- a/tlslite/utils/pem.py</span>
<span class="gi">+++ b/tlslite/utils/pem.py</span>
<span class="gu">@@ -1,6 +1,11 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>from .compat import *
<span class="w"> </span>import binascii

<span class="gi">+#This code is shared with tackpy (somewhat), so I&#39;d rather make minimal</span>
<span class="gi">+#changes, and preserve the use of a2b_base64 throughout.</span>

<span class="w"> </span>def dePem(s, name):
<span class="w"> </span>    &quot;&quot;&quot;Decode a PEM string into a bytearray of its payload.
<span class="gu">@@ -17,9 +22,18 @@ def dePem(s, name):</span>
<span class="w"> </span>    The first such PEM block in the input will be found, and its
<span class="w"> </span>    payload will be base64 decoded and returned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    prefix  = &quot;-----BEGIN %s-----&quot; % name</span>
<span class="gi">+    postfix = &quot;-----END %s-----&quot; % name    </span>
<span class="gi">+    start = s.find(prefix)</span>
<span class="gi">+    if start == -1:</span>
<span class="gi">+        raise SyntaxError(&quot;Missing PEM prefix&quot;)</span>
<span class="gi">+    end = s.find(postfix, start+len(prefix))</span>
<span class="gi">+    if end == -1:</span>
<span class="gi">+        raise SyntaxError(&quot;Missing PEM postfix&quot;)</span>
<span class="gi">+    s = s[start+len(&quot;-----BEGIN %s-----&quot; % name) : end]</span>
<span class="gi">+    retBytes = a2b_base64(s) # May raise SyntaxError</span>
<span class="gi">+    return retBytes</span>
<span class="gi">+    </span>
<span class="w"> </span>def dePemList(s, name):
<span class="w"> </span>    &quot;&quot;&quot;Decode a sequence of PEM blocks into a list of bytearrays.

<span class="gu">@@ -44,8 +58,20 @@ def dePemList(s, name):</span>
<span class="w"> </span>    All such PEM blocks will be found, decoded, and return in an ordered list
<span class="w"> </span>    of bytearrays, which may have zero elements if not PEM blocks are found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    bList = []</span>
<span class="gi">+    prefix  = &quot;-----BEGIN %s-----&quot; % name</span>
<span class="gi">+    postfix = &quot;-----END %s-----&quot; % name</span>
<span class="gi">+    while 1:</span>
<span class="gi">+        start = s.find(prefix)</span>
<span class="gi">+        if start == -1:</span>
<span class="gi">+            return bList</span>
<span class="gi">+        end = s.find(postfix, start+len(prefix))</span>
<span class="gi">+        if end == -1:</span>
<span class="gi">+            raise SyntaxError(&quot;Missing PEM postfix&quot;)</span>
<span class="gi">+        s2 = s[start+len(prefix) : end]</span>
<span class="gi">+        retBytes = a2b_base64(s2) # May raise SyntaxError</span>
<span class="gi">+        bList.append(retBytes)</span>
<span class="gi">+        s = s[end+len(postfix) : ]</span>

<span class="w"> </span>def pem(b, name):
<span class="w"> </span>    &quot;&quot;&quot;Encode a payload bytearray into a PEM string.
<span class="gu">@@ -59,4 +85,15 @@ def pem(b, name):</span>
<span class="w"> </span>        KoZIhvcNAQEFBQADAwA5kw==
<span class="w"> </span>        -----END CERTIFICATE-----
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    s1 = b2a_base64(b)[:-1] # remove terminating \n</span>
<span class="gi">+    s2 = &quot;&quot;</span>
<span class="gi">+    while s1:</span>
<span class="gi">+        s2 += s1[:64] + &quot;\n&quot;</span>
<span class="gi">+        s1 = s1[64:]</span>
<span class="gi">+    s = (&quot;-----BEGIN %s-----\n&quot; % name) + s2 + \</span>
<span class="gi">+        (&quot;-----END %s-----\n&quot; % name)     </span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+def pemSniff(inStr, name):</span>
<span class="gi">+    searchStr = &quot;-----BEGIN %s-----&quot; % name</span>
<span class="gi">+    return searchStr in inStr</span>
<span class="gh">diff --git a/tlslite/utils/poly1305.py b/tlslite/utils/poly1305.py</span>
<span class="gh">index 23b34cb..935178c 100644</span>
<span class="gd">--- a/tlslite/utils/poly1305.py</span>
<span class="gi">+++ b/tlslite/utils/poly1305.py</span>
<span class="gu">@@ -1,30 +1,49 @@</span>
<span class="gi">+# Copyright (c) 2015, Hubert Kario</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="w"> </span>&quot;&quot;&quot;Implementation of Poly1305 authenticator for RFC 7539&quot;&quot;&quot;
<span class="gd">-from .cryptomath import divceil</span>

<span class="gi">+from .cryptomath import divceil</span>

<span class="w"> </span>class Poly1305(object):
<span class="gi">+</span>
<span class="w"> </span>    &quot;&quot;&quot;Poly1305 authenticator&quot;&quot;&quot;
<span class="gd">-    P = 1361129467683753853853498429727072845819</span>
<span class="gi">+</span>
<span class="gi">+    P = 0x3fffffffffffffffffffffffffffffffb # 2^130-5</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def le_bytes_to_num(data):
<span class="w"> </span>        &quot;&quot;&quot;Convert a number from little endian byte format&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = 0</span>
<span class="gi">+        for i in range(len(data) - 1, -1, -1):</span>
<span class="gi">+            ret &lt;&lt;= 8</span>
<span class="gi">+            ret += data[i]</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def num_to_16_le_bytes(num):
<span class="w"> </span>        &quot;&quot;&quot;Convert number to 16 bytes in little endian format&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ret = [0]*16</span>
<span class="gi">+        for i, _ in enumerate(ret):</span>
<span class="gi">+            ret[i] = num &amp; 0xff</span>
<span class="gi">+            num &gt;&gt;= 8</span>
<span class="gi">+        return bytearray(ret)</span>

<span class="w"> </span>    def __init__(self, key):
<span class="w"> </span>        &quot;&quot;&quot;Set the authenticator key&quot;&quot;&quot;
<span class="w"> </span>        if len(key) != 32:
<span class="gd">-            raise ValueError(&#39;Key must be 256 bit long&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Key must be 256 bit long&quot;)</span>
<span class="w"> </span>        self.acc = 0
<span class="w"> </span>        self.r = self.le_bytes_to_num(key[0:16])
<span class="gd">-        self.r &amp;= 21267647620597763993911028882763415551</span>
<span class="gi">+        self.r &amp;= 0x0ffffffc0ffffffc0ffffffc0fffffff</span>
<span class="w"> </span>        self.s = self.le_bytes_to_num(key[16:32])

<span class="w"> </span>    def create_tag(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Calculate authentication tag for data&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for i in range(0, divceil(len(data), 16)):</span>
<span class="gi">+            n = self.le_bytes_to_num(data[i*16:(i+1)*16] + b&#39;\x01&#39;)</span>
<span class="gi">+            self.acc += n</span>
<span class="gi">+            self.acc = (self.r * self.acc) % self.P</span>
<span class="gi">+        self.acc += self.s</span>
<span class="gi">+        return self.num_to_16_le_bytes(self.acc)</span>
<span class="gi">+</span>
<span class="gh">diff --git a/tlslite/utils/pycrypto_aes.py b/tlslite/utils/pycrypto_aes.py</span>
<span class="gh">index 87b2e5e..b3425c0 100644</span>
<span class="gd">--- a/tlslite/utils/pycrypto_aes.py</span>
<span class="gi">+++ b/tlslite/utils/pycrypto_aes.py</span>
<span class="gu">@@ -1,14 +1,29 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;PyCrypto AES implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import *
<span class="w"> </span>from .aes import *
<span class="gi">+</span>
<span class="w"> </span>if pycryptoLoaded:
<span class="w"> </span>    import Crypto.Cipher.AES

<span class="gi">+    def new(key, mode, IV):</span>
<span class="gi">+        return PyCrypto_AES(key, mode, IV)</span>

<span class="w"> </span>    class PyCrypto_AES(AES):

<span class="w"> </span>        def __init__(self, key, mode, IV):
<span class="gd">-            AES.__init__(self, key, mode, IV, &#39;pycrypto&#39;)</span>
<span class="gi">+            AES.__init__(self, key, mode, IV, &quot;pycrypto&quot;)</span>
<span class="w"> </span>            key = bytes(key)
<span class="w"> </span>            IV = bytes(IV)
<span class="w"> </span>            self.context = Crypto.Cipher.AES.new(key, mode, IV)
<span class="gi">+</span>
<span class="gi">+        def encrypt(self, plaintext):</span>
<span class="gi">+            plaintext = bytes(plaintext)</span>
<span class="gi">+            return bytearray(self.context.encrypt(plaintext))</span>
<span class="gi">+</span>
<span class="gi">+        def decrypt(self, ciphertext):</span>
<span class="gi">+            ciphertext = bytes(ciphertext)</span>
<span class="gi">+            return bytearray(self.context.decrypt(ciphertext))</span>
<span class="gh">diff --git a/tlslite/utils/pycrypto_aesgcm.py b/tlslite/utils/pycrypto_aesgcm.py</span>
<span class="gh">index e22fd29..ee187ee 100644</span>
<span class="gd">--- a/tlslite/utils/pycrypto_aesgcm.py</span>
<span class="gi">+++ b/tlslite/utils/pycrypto_aesgcm.py</span>
<span class="gu">@@ -1,5 +1,16 @@</span>
<span class="gi">+# Author: Google</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;PyCrypto AES-GCM implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import *
<span class="w"> </span>from .aesgcm import AESGCM
<span class="gi">+</span>
<span class="w"> </span>if pycryptoLoaded:
<span class="w"> </span>    import Crypto.Cipher.AES
<span class="gi">+</span>
<span class="gi">+    def new(key):</span>
<span class="gi">+        cipher = Crypto.Cipher.AES.new(bytes(key))</span>
<span class="gi">+        def encrypt(plaintext):</span>
<span class="gi">+            return bytearray(cipher.encrypt(bytes(plaintext)))</span>
<span class="gi">+        return AESGCM(key, &quot;pycrypto&quot;, encrypt)</span>
<span class="gh">diff --git a/tlslite/utils/pycrypto_rc4.py b/tlslite/utils/pycrypto_rc4.py</span>
<span class="gh">index d3fad7d..fc98d7c 100644</span>
<span class="gd">--- a/tlslite/utils/pycrypto_rc4.py</span>
<span class="gi">+++ b/tlslite/utils/pycrypto_rc4.py</span>
<span class="gu">@@ -1,13 +1,28 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;PyCrypto RC4 implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import *
<span class="w"> </span>from .rc4 import *
<span class="gi">+</span>
<span class="w"> </span>if pycryptoLoaded:
<span class="w"> </span>    import Crypto.Cipher.ARC4

<span class="gi">+    def new(key):</span>
<span class="gi">+        return PyCrypto_RC4(key)</span>

<span class="w"> </span>    class PyCrypto_RC4(RC4):

<span class="w"> </span>        def __init__(self, key):
<span class="gd">-            RC4.__init__(self, key, &#39;pycrypto&#39;)</span>
<span class="gi">+            RC4.__init__(self, key, &quot;pycrypto&quot;)</span>
<span class="w"> </span>            key = bytes(key)
<span class="w"> </span>            self.context = Crypto.Cipher.ARC4.new(key)
<span class="gi">+</span>
<span class="gi">+        def encrypt(self, plaintext):</span>
<span class="gi">+            plaintext = bytes(plaintext)</span>
<span class="gi">+            return bytearray(self.context.encrypt(plaintext))</span>
<span class="gi">+</span>
<span class="gi">+        def decrypt(self, ciphertext):</span>
<span class="gi">+            ciphertext = bytes(ciphertext)</span>
<span class="gi">+            return bytearray(self.context.decrypt(ciphertext))</span>
\ No newline at end of file
<span class="gh">diff --git a/tlslite/utils/pycrypto_rsakey.py b/tlslite/utils/pycrypto_rsakey.py</span>
<span class="gh">index bca321b..5a4e730 100644</span>
<span class="gd">--- a/tlslite/utils/pycrypto_rsakey.py</span>
<span class="gi">+++ b/tlslite/utils/pycrypto_rsakey.py</span>
<span class="gu">@@ -1,25 +1,71 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;PyCrypto RSA implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import print_function
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import *
<span class="gi">+</span>
<span class="w"> </span>from .rsakey import *
<span class="w"> </span>from .python_rsakey import Python_RSAKey
<span class="w"> </span>from .compat import compatLong
<span class="gi">+</span>
<span class="w"> </span>if pycryptoLoaded:
<span class="gd">-    from Crypto.PublicKey import RSA</span>

<span class="gi">+    from Crypto.PublicKey import RSA</span>

<span class="w"> </span>    class PyCrypto_RSAKey(RSAKey):
<span class="gd">-</span>
<span class="w"> </span>        def __init__(self, n=0, e=0, d=0, p=0, q=0, dP=0, dQ=0, qInv=0,
<span class="gd">-            key_type=&#39;rsa&#39;):</span>
<span class="gd">-            del dP, dQ, qInv</span>
<span class="gi">+                     key_type=&quot;rsa&quot;):</span>
<span class="gi">+            del dP, dQ, qInv  # pycrypto calculates them by its own</span>
<span class="w"> </span>            if not d:
<span class="w"> </span>                self.rsa = RSA.construct((compatLong(n), compatLong(e)))
<span class="w"> </span>            else:
<span class="w"> </span>                self.rsa = RSA.construct((compatLong(n), compatLong(e),
<span class="gd">-                    compatLong(d), compatLong(p), compatLong(q)))</span>
<span class="gi">+                                          compatLong(d), compatLong(p),</span>
<span class="gi">+                                          compatLong(q)))</span>
<span class="w"> </span>            self.key_type = key_type

<span class="w"> </span>        def __getattr__(self, name):
<span class="w"> </span>            return getattr(self.rsa, name)
<span class="gi">+</span>
<span class="gi">+        def hasPrivateKey(self):</span>
<span class="gi">+            return self.rsa.has_private()</span>
<span class="gi">+</span>
<span class="gi">+        def _rawPrivateKeyOp(self, message):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self.rsa.decrypt((compatLong(message),))</span>
<span class="gi">+            except ValueError as e:</span>
<span class="gi">+                print(&quot;rsa: {0!r}&quot;.format(self.rsa), file=sys.stderr)</span>
<span class="gi">+                values = []</span>
<span class="gi">+                for name in [&quot;n&quot;, &quot;e&quot;, &quot;d&quot;, &quot;p&quot;, &quot;q&quot;, &quot;dP&quot;, &quot;dQ&quot;, &quot;qInv&quot;]:</span>
<span class="gi">+                    values.append(&quot;{0}: {1}&quot;.format(name,</span>
<span class="gi">+                                                    getattr(self, name, None)))</span>
<span class="gi">+                print(&quot;, &quot;.join(values), file=sys.stderr)</span>
<span class="gi">+                print(&quot;message: {0}&quot;.format(message), file=sys.stderr)</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+        def _rawPublicKeyOp(self, ciphertext):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self.rsa.encrypt(compatLong(ciphertext), None)[0]</span>
<span class="gi">+            except ValueError as e:</span>
<span class="gi">+                print(&quot;rsa: {0!r}&quot;.format(self.rsa), file=sys.stderr)</span>
<span class="gi">+                values = []</span>
<span class="gi">+                for name in [&quot;n&quot;, &quot;e&quot;, &quot;d&quot;, &quot;p&quot;, &quot;q&quot;, &quot;dP&quot;, &quot;dQ&quot;, &quot;qInv&quot;]:</span>
<span class="gi">+                    values.append(&quot;{0}: {1}&quot;.format(name,</span>
<span class="gi">+                                                    getattr(self, name, None)))</span>
<span class="gi">+                print(&quot;, &quot;.join(values), file=sys.stderr)</span>
<span class="gi">+                print(&quot;ciphertext: {0}&quot;.format(ciphertext), file=sys.stderr)</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+        @staticmethod</span>
<span class="gi">+        def generate(bits, key_type=&quot;rsa&quot;):</span>
<span class="gi">+            key = PyCrypto_RSAKey()</span>
<span class="gi">+            def f(numBytes):</span>
<span class="gi">+                return bytes(getRandomBytes(numBytes))</span>
<span class="gi">+            key.rsa = RSA.generate(bits, f)</span>
<span class="gi">+            key.key_type = key_type</span>
<span class="gi">+            return key</span>
<span class="gh">diff --git a/tlslite/utils/pycrypto_tripledes.py b/tlslite/utils/pycrypto_tripledes.py</span>
<span class="gh">index 7f9b72f..8117f34 100644</span>
<span class="gd">--- a/tlslite/utils/pycrypto_tripledes.py</span>
<span class="gi">+++ b/tlslite/utils/pycrypto_tripledes.py</span>
<span class="gu">@@ -1,14 +1,29 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;PyCrypto 3DES implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import *
<span class="w"> </span>from .tripledes import *
<span class="gi">+</span>
<span class="w"> </span>if pycryptoLoaded:
<span class="w"> </span>    import Crypto.Cipher.DES3

<span class="gi">+    def new(key, mode, IV):</span>
<span class="gi">+        return PyCrypto_TripleDES(key, mode, IV)</span>

<span class="w"> </span>    class PyCrypto_TripleDES(TripleDES):

<span class="w"> </span>        def __init__(self, key, mode, IV):
<span class="gd">-            TripleDES.__init__(self, key, mode, IV, &#39;pycrypto&#39;)</span>
<span class="gi">+            TripleDES.__init__(self, key, mode, IV, &quot;pycrypto&quot;)</span>
<span class="w"> </span>            key = bytes(key)
<span class="w"> </span>            IV = bytes(IV)
<span class="w"> </span>            self.context = Crypto.Cipher.DES3.new(key, mode, IV)
<span class="gi">+</span>
<span class="gi">+        def encrypt(self, plaintext):</span>
<span class="gi">+            plaintext = bytes(plaintext)</span>
<span class="gi">+            return bytearray(self.context.encrypt(plaintext))</span>
<span class="gi">+</span>
<span class="gi">+        def decrypt(self, ciphertext):</span>
<span class="gi">+            ciphertext = bytes(ciphertext)</span>
<span class="gi">+            return bytearray(self.context.decrypt(ciphertext))</span>
\ No newline at end of file
<span class="gh">diff --git a/tlslite/utils/python_aes.py b/tlslite/utils/python_aes.py</span>
<span class="gh">index 70897d2..df24922 100644</span>
<span class="gd">--- a/tlslite/utils/python_aes.py</span>
<span class="gi">+++ b/tlslite/utils/python_aes.py</span>
<span class="gu">@@ -1,24 +1,119 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Pure-Python AES implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .aes import AES
<span class="w"> </span>from .rijndael import Rijndael
<span class="w"> </span>from .cryptomath import bytesToNumber, numberToByteArray
<span class="gi">+</span>
<span class="w"> </span>__all__ = [&#39;new&#39;, &#39;Python_AES&#39;]


<span class="gd">-class Python_AES(AES):</span>
<span class="gi">+def new(key, mode, IV):</span>
<span class="gi">+    # IV argument name is a part of the interface</span>
<span class="gi">+    # pylint: disable=invalid-name</span>
<span class="gi">+    if mode == 2:</span>
<span class="gi">+        return Python_AES(key, mode, IV)</span>
<span class="gi">+    elif mode == 6:</span>
<span class="gi">+        return Python_AES_CTR(key, mode, IV)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gi">+</span>
<span class="gi">+class Python_AES(AES):</span>
<span class="w"> </span>    def __init__(self, key, mode, IV):
<span class="gi">+        # IV argument/field names are a part of the interface</span>
<span class="gi">+        # pylint: disable=invalid-name</span>
<span class="w"> </span>        key, IV = bytearray(key), bytearray(IV)
<span class="gd">-        super(Python_AES, self).__init__(key, mode, IV, &#39;python&#39;)</span>
<span class="gi">+        super(Python_AES, self).__init__(key, mode, IV, &quot;python&quot;)</span>
<span class="w"> </span>        self.rijndael = Rijndael(key, 16)
<span class="w"> </span>        self.IV = IV

<span class="gi">+    def encrypt(self, plaintext):</span>
<span class="gi">+        super(Python_AES, self).encrypt(plaintext)</span>

<span class="gd">-class Python_AES_CTR(AES):</span>
<span class="gi">+        plaintextBytes = bytearray(plaintext)</span>
<span class="gi">+        chainBytes = self.IV[:]</span>
<span class="gi">+</span>
<span class="gi">+        #CBC Mode: For each block...</span>
<span class="gi">+        for x in range(len(plaintextBytes)//16):</span>
<span class="gi">+</span>
<span class="gi">+            #XOR with the chaining block</span>
<span class="gi">+            blockBytes = plaintextBytes[x*16 : (x*16)+16]</span>
<span class="gi">+            for y in range(16):</span>
<span class="gi">+                blockBytes[y] ^= chainBytes[y]</span>
<span class="gi">+</span>
<span class="gi">+            #Encrypt it</span>
<span class="gi">+            encryptedBytes = self.rijndael.encrypt(blockBytes)</span>
<span class="gi">+</span>
<span class="gi">+            #Overwrite the input with the output</span>
<span class="gi">+            for y in range(16):</span>
<span class="gi">+                plaintextBytes[(x*16)+y] = encryptedBytes[y]</span>
<span class="gi">+</span>
<span class="gi">+            #Set the next chaining block</span>
<span class="gi">+            chainBytes = encryptedBytes</span>
<span class="gi">+</span>
<span class="gi">+        self.IV = chainBytes[:]</span>
<span class="gi">+        return plaintextBytes</span>
<span class="gi">+</span>
<span class="gi">+    def decrypt(self, ciphertext):</span>
<span class="gi">+        super(Python_AES, self).decrypt(ciphertext)</span>

<span class="gi">+        ciphertextBytes = ciphertext[:]</span>
<span class="gi">+        chainBytes = self.IV[:]</span>
<span class="gi">+</span>
<span class="gi">+        #CBC Mode: For each block...</span>
<span class="gi">+        for x in range(len(ciphertextBytes)//16):</span>
<span class="gi">+</span>
<span class="gi">+            #Decrypt it</span>
<span class="gi">+            blockBytes = ciphertextBytes[x*16 : (x*16)+16]</span>
<span class="gi">+            decryptedBytes = self.rijndael.decrypt(blockBytes)</span>
<span class="gi">+</span>
<span class="gi">+            #XOR with the chaining block and overwrite the input with output</span>
<span class="gi">+            for y in range(16):</span>
<span class="gi">+                decryptedBytes[y] ^= chainBytes[y]</span>
<span class="gi">+                ciphertextBytes[(x*16)+y] = decryptedBytes[y]</span>
<span class="gi">+</span>
<span class="gi">+            #Set the next chaining block</span>
<span class="gi">+            chainBytes = blockBytes</span>
<span class="gi">+</span>
<span class="gi">+        self.IV = chainBytes[:]</span>
<span class="gi">+        return ciphertextBytes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class Python_AES_CTR(AES):</span>
<span class="w"> </span>    def __init__(self, key, mode, IV):
<span class="gd">-        super(Python_AES_CTR, self).__init__(key, mode, IV, &#39;python&#39;)</span>
<span class="gi">+        super(Python_AES_CTR, self).__init__(key, mode, IV, &quot;python&quot;)</span>
<span class="w"> </span>        self.rijndael = Rijndael(key, 16)
<span class="w"> </span>        self.IV = IV
<span class="w"> </span>        self._counter_bytes = 16 - len(self.IV)
<span class="w"> </span>        self._counter = self.IV + bytearray(b&#39;\x00&#39; * self._counter_bytes)
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def counter(self):</span>
<span class="gi">+        return self._counter</span>
<span class="gi">+</span>
<span class="gi">+    @counter.setter</span>
<span class="gi">+    def counter(self, ctr):</span>
<span class="gi">+        self._counter = ctr</span>
<span class="gi">+</span>
<span class="gi">+    def _counter_update(self):</span>
<span class="gi">+        counter_int = bytesToNumber(self._counter) + 1</span>
<span class="gi">+        self._counter = numberToByteArray(counter_int, 16)</span>
<span class="gi">+        if self._counter_bytes &gt; 0 and \</span>
<span class="gi">+                self._counter[-self._counter_bytes:] == \</span>
<span class="gi">+                bytearray(b&#39;\xff&#39; * self._counter_bytes):</span>
<span class="gi">+            raise OverflowError(&quot;CTR counter overflowed&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def encrypt(self, plaintext):</span>
<span class="gi">+</span>
<span class="gi">+        mask = bytearray()</span>
<span class="gi">+        while len(mask) &lt; len(plaintext):</span>
<span class="gi">+            mask += self.rijndael.encrypt(self._counter)</span>
<span class="gi">+            self._counter_update()</span>
<span class="gi">+        inp_bytes = bytearray(i ^ j for i, j in zip(plaintext, mask))</span>
<span class="gi">+        return inp_bytes</span>
<span class="gi">+</span>
<span class="gi">+    def decrypt(self, ciphertext):</span>
<span class="gi">+        return self.encrypt(ciphertext)</span>
<span class="gh">diff --git a/tlslite/utils/python_aesccm.py b/tlslite/utils/python_aesccm.py</span>
<span class="gh">index c2335a1..ad3db99 100644</span>
<span class="gd">--- a/tlslite/utils/python_aesccm.py</span>
<span class="gi">+++ b/tlslite/utils/python_aesccm.py</span>
<span class="gu">@@ -1,2 +1,9 @@</span>
<span class="gi">+# Author: Ivan Nikolchev</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot; Pure Python AES-CCM implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from tlslite.utils.aesccm import AESCCM
<span class="gi">+</span>
<span class="gi">+def new(key, tagLength=16):</span>
<span class="gi">+    return AESCCM(key, &quot;python&quot;, bytearray(16), tagLength)</span>
<span class="gh">diff --git a/tlslite/utils/python_aesgcm.py b/tlslite/utils/python_aesgcm.py</span>
<span class="gh">index f90729a..8e7e343 100644</span>
<span class="gd">--- a/tlslite/utils/python_aesgcm.py</span>
<span class="gi">+++ b/tlslite/utils/python_aesgcm.py</span>
<span class="gu">@@ -1,3 +1,11 @@</span>
<span class="gi">+# Author: Google</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Pure-Python AES-GCM implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .aesgcm import AESGCM
<span class="w"> </span>from .rijndael import Rijndael
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def new(key):</span>
<span class="gi">+    return AESGCM(key, &quot;python&quot;, Rijndael(key, 16).encrypt)</span>
<span class="gh">diff --git a/tlslite/utils/python_chacha20_poly1305.py b/tlslite/utils/python_chacha20_poly1305.py</span>
<span class="gh">index d18ffd6..30a74e6 100644</span>
<span class="gd">--- a/tlslite/utils/python_chacha20_poly1305.py</span>
<span class="gi">+++ b/tlslite/utils/python_chacha20_poly1305.py</span>
<span class="gu">@@ -1,7 +1,11 @@</span>
<span class="gi">+# Author: Hubert Kario (c) 2015</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Pure-Python ChaCha20/Poly1305 implementation.&quot;&quot;&quot;
<span class="gd">-from .chacha20_poly1305 import CHACHA20_POLY1305</span>

<span class="gi">+from .chacha20_poly1305 import CHACHA20_POLY1305</span>

<span class="w"> </span>def new(key):
<span class="w"> </span>    &quot;&quot;&quot;Return an AEAD cipher implementation&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return CHACHA20_POLY1305(key, &quot;python&quot;)</span>
<span class="gh">diff --git a/tlslite/utils/python_dsakey.py b/tlslite/utils/python_dsakey.py</span>
<span class="gh">index e515031..b590881 100644</span>
<span class="gd">--- a/tlslite/utils/python_dsakey.py</span>
<span class="gi">+++ b/tlslite/utils/python_dsakey.py</span>
<span class="gu">@@ -1,20 +1,26 @@</span>
<span class="gi">+# Author: Frantisek Krenzelok</span>
<span class="w"> </span>&quot;&quot;&quot;Pure-Python RSA implementation.&quot;&quot;&quot;
<span class="gd">-from ecdsa.der import encode_sequence, encode_integer, remove_sequence, remove_integer</span>
<span class="gd">-from .cryptomath import getRandomNumber, getRandomPrime, powMod, numBits, bytesToNumber, invMod, secureHash, GMPY2_LOADED, gmpyLoaded</span>
<span class="gi">+from ecdsa.der import encode_sequence, encode_integer,  \</span>
<span class="gi">+    remove_sequence, remove_integer</span>
<span class="gi">+</span>
<span class="gi">+from .cryptomath import getRandomNumber, getRandomPrime,    \</span>
<span class="gi">+    powMod, numBits, bytesToNumber, invMod,   \</span>
<span class="gi">+    secureHash, GMPY2_LOADED, gmpyLoaded</span>
<span class="gi">+</span>
<span class="w"> </span>from .compat import compatHMAC
<span class="gi">+</span>
<span class="w"> </span>if GMPY2_LOADED:
<span class="w"> </span>    from gmpy2 import mpz
<span class="w"> </span>elif gmpyLoaded:
<span class="w"> </span>    from gmpy import mpz
<span class="gd">-from .dsakey import DSAKey</span>

<span class="gi">+from .dsakey import DSAKey</span>

<span class="w"> </span>class Python_DSAKey(DSAKey):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Concrete implementaion of DSA object.
<span class="w"> </span>    for func docstring see tlslite/dsakey.py
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, p=0, q=0, g=0, x=0, y=0):
<span class="w"> </span>        if gmpyLoaded or GMPY2_LOADED:
<span class="w"> </span>            p = mpz(p)
<span class="gu">@@ -29,11 +35,52 @@ class Python_DSAKey(DSAKey):</span>
<span class="w"> </span>        self.public_key = y
<span class="w"> </span>        if self.private_key and not self.public_key:
<span class="w"> </span>            self.public_key = powMod(g, self.private_key, p)
<span class="gd">-        self.key_type = &#39;dsa&#39;</span>
<span class="gi">+        self.key_type = &quot;dsa&quot;</span>

<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return numBits(self.p)

<span class="gi">+    def hasPrivateKey(self):</span>
<span class="gi">+        return bool(self.private_key)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def generate(L, N):</span>
<span class="gi">+        assert (L, N) in [(1024, 160), (2048, 224), (2048, 256), (3072, 256)]</span>
<span class="gi">+        key = Python_DSAKey()</span>
<span class="gi">+        (q, p) = Python_DSAKey.generate_qp(L, N)</span>
<span class="gi">+</span>
<span class="gi">+        index = getRandomNumber(1, (p-1))</span>
<span class="gi">+        g = powMod(index, int((p-1)/q), p)</span>
<span class="gi">+        x = getRandomNumber(1, q-1)</span>
<span class="gi">+        y = powMod(g, x, p)</span>
<span class="gi">+        if gmpyLoaded or GMPY2_LOADED:</span>
<span class="gi">+            p = mpz(p)</span>
<span class="gi">+            q = mpz(q)</span>
<span class="gi">+            g = mpz(g)</span>
<span class="gi">+            x = mpz(x)</span>
<span class="gi">+            y = mpz(y)</span>
<span class="gi">+        key.q = q</span>
<span class="gi">+        key.p = p</span>
<span class="gi">+        key.g = g</span>
<span class="gi">+        key.private_key = x</span>
<span class="gi">+        key.public_key = y</span>
<span class="gi">+        return key</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def generate_qp(L, N):</span>
<span class="gi">+        assert (L, N) in [(1024, 160), (2048, 224), (2048, 256), (3072, 256)]</span>
<span class="gi">+</span>
<span class="gi">+        q = int(getRandomPrime(N))</span>
<span class="gi">+        while True:</span>
<span class="gi">+            p = int(getRandomPrime(L))</span>
<span class="gi">+            if (p-1) % q:</span>
<span class="gi">+                break</span>
<span class="gi">+        return (q, p)</span>
<span class="gi">+</span>
<span class="gi">+    def hashAndSign(self, data, hAlg=&quot;sha1&quot;):</span>
<span class="gi">+        hashData = (secureHash(bytearray(data), hAlg))</span>
<span class="gi">+        return self.sign(hashData)</span>
<span class="gi">+</span>
<span class="w"> </span>    def sign(self, data, padding=None, hashAlg=None, saltLen=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :type data: bytearray
<span class="gu">@@ -49,10 +96,23 @@ class Python_DSAKey(DSAKey):</span>
<span class="w"> </span>        :type saltLen: int
<span class="w"> </span>        :param saltLen: Ignored, present for API compatibility with RSA
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        N = numBits(self.q)</span>
<span class="gi">+        digest_len = len(data) * 8</span>
<span class="gi">+        digest = bytesToNumber(data)</span>
<span class="gi">+        if N &lt; digest_len:</span>
<span class="gi">+            digest &gt;&gt;= digest_len - N</span>
<span class="gi">+</span>
<span class="gi">+        k = getRandomNumber(1, (self.q-1))</span>
<span class="gi">+        if gmpyLoaded or GMPY2_LOADED:</span>
<span class="gi">+            k = mpz(k)</span>
<span class="gi">+            digest = mpz(digest)</span>
<span class="gi">+        r = powMod(self.g, k, self.p) % self.q</span>
<span class="gi">+        s = invMod(k, self.q) * (digest + self.private_key * r) % self.q</span>
<span class="gi">+</span>
<span class="gi">+        return encode_sequence(encode_integer(r), encode_integer(s))</span>

<span class="w"> </span>    def verify(self, signature, hashData, padding=None, hashAlg=None,
<span class="gd">-        saltLen=None):</span>
<span class="gi">+               saltLen=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify the passed-in bytes with the signature.

<span class="w"> </span>        This verifies a DSA signature on the passed-in data.
<span class="gu">@@ -75,4 +135,40 @@ class Python_DSAKey(DSAKey):</span>
<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        :returns: Whether the signature matches the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        N = numBits(self.q)</span>
<span class="gi">+        digest_len = len(hashData) * 8</span>
<span class="gi">+        digest = bytesToNumber(hashData)</span>
<span class="gi">+</span>
<span class="gi">+        if N &lt; digest_len:</span>
<span class="gi">+            digest &gt;&gt;= digest_len - N</span>
<span class="gi">+</span>
<span class="gi">+        signature = compatHMAC(signature)</span>
<span class="gi">+</span>
<span class="gi">+        # get r, s keys</span>
<span class="gi">+        if not signature:</span>
<span class="gi">+            return False</span>
<span class="gi">+        body, rest = remove_sequence(signature)</span>
<span class="gi">+        if rest:</span>
<span class="gi">+            return False</span>
<span class="gi">+        r, rest = remove_integer(body)</span>
<span class="gi">+        s, rest = remove_integer(rest)</span>
<span class="gi">+        if rest:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if gmpyLoaded or GMPY2_LOADED:</span>
<span class="gi">+            r = mpz(r)</span>
<span class="gi">+            s = mpz(s)</span>
<span class="gi">+</span>
<span class="gi">+        # check the signature</span>
<span class="gi">+        if 0 &lt; r &lt; self.q and 0 &lt; s &lt; self.q:</span>
<span class="gi">+            w = invMod(s, self.q)</span>
<span class="gi">+            u1 = (digest * w) % self.q</span>
<span class="gi">+            u2 = (r * w) % self.q</span>
<span class="gi">+            v = ((powMod(self.g, u1, self.p) * \</span>
<span class="gi">+                  powMod(self.public_key, u2, self.p)) % self.p) % self.q</span>
<span class="gi">+            return r == v</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def hashAndVerify(self, signature, data, hAlg=&quot;sha1&quot;):</span>
<span class="gi">+        digest = secureHash(bytearray(data), hAlg)</span>
<span class="gi">+        return self.verify(signature, digest)</span>
<span class="gh">diff --git a/tlslite/utils/python_ecdsakey.py b/tlslite/utils/python_ecdsakey.py</span>
<span class="gh">index 8523fc6..b354793 100644</span>
<span class="gd">--- a/tlslite/utils/python_ecdsakey.py</span>
<span class="gi">+++ b/tlslite/utils/python_ecdsakey.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="gi">+# Author Hubert Kario, copyright 2019</span>
<span class="gi">+</span>
<span class="w"> </span>from .ecdsakey import ECDSAKey
<span class="w"> </span>from ecdsa.curves import curves
<span class="w"> </span>from ecdsa.util import sigencode_der, sigdecode_der
<span class="gu">@@ -8,7 +10,6 @@ from . import tlshashlib</span>
<span class="w"> </span>from .cryptomath import numBits
<span class="w"> </span>from .compat import compatHMAC

<span class="gd">-</span>
<span class="w"> </span>class Python_ECDSAKey(ECDSAKey):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Concrete implementation of ECDSA object backed by python-ecdsa.
<span class="gu">@@ -31,26 +32,64 @@ class Python_ECDSAKey(ECDSAKey):</span>

<span class="w"> </span>    def __init__(self, x, y, curve_name, secret_multiplier=None):
<span class="w"> </span>        if not curve_name:
<span class="gd">-            raise ValueError(&#39;curve_name must be specified&#39;)</span>
<span class="gi">+            raise ValueError(&quot;curve_name must be specified&quot;)</span>
<span class="w"> </span>        self.curve_name = curve_name
<span class="gi">+</span>
<span class="w"> </span>        for c in curves:
<span class="w"> </span>            if c.name == curve_name or c.openssl_name == curve_name:
<span class="w"> </span>                curve = c
<span class="w"> </span>                break
<span class="w"> </span>        else:
<span class="gd">-            raise ValueError(&quot;Curve &#39;{0}&#39; not supported by python-ecdsa&quot;.</span>
<span class="gd">-                format(curve_name))</span>
<span class="gi">+            raise ValueError(&quot;Curve &#39;{0}&#39; not supported by python-ecdsa&quot;</span>
<span class="gi">+                             .format(curve_name))</span>
<span class="gi">+</span>
<span class="w"> </span>        self.private_key = None
<span class="w"> </span>        self.public_key = None
<span class="gd">-        self.key_type = &#39;ecdsa&#39;</span>
<span class="gi">+        self.key_type = &quot;ecdsa&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        if secret_multiplier:
<span class="w"> </span>            self.private_key = SigningKey.from_secret_exponent(
<span class="w"> </span>                secret_multiplier, curve)
<span class="gi">+</span>
<span class="w"> </span>        if x and y:
<span class="w"> </span>            point = Point(curve.curve, x, y)
<span class="w"> </span>            self.public_key = VerifyingKey.from_public_point(point, curve)
<span class="gi">+</span>
<span class="w"> </span>        if not self.public_key:
<span class="w"> </span>            self.public_key = self.private_key.get_verifying_key()

<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return numBits(self.public_key.curve.order)
<span class="gi">+</span>
<span class="gi">+    def hasPrivateKey(self):</span>
<span class="gi">+        return bool(self.private_key)</span>
<span class="gi">+</span>
<span class="gi">+    def acceptsPassword(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def generate(bits):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _sign(self, data, hAlg):</span>
<span class="gi">+        func = getattr(tlshashlib, hAlg)</span>
<span class="gi">+</span>
<span class="gi">+        return self.private_key.\</span>
<span class="gi">+            sign_digest_deterministic(compatHMAC(data),</span>
<span class="gi">+                                      hashfunc=func,</span>
<span class="gi">+                                      sigencode=sigencode_der)</span>
<span class="gi">+</span>
<span class="gi">+    def _hashAndSign(self, data, hAlg):</span>
<span class="gi">+        return self.private_key.sign_deterministic(compatHMAC(data),</span>
<span class="gi">+                                                   hash=getattr(tlshashlib,</span>
<span class="gi">+                                                                hAlg),</span>
<span class="gi">+                                                   sigencode=sigencode_der)</span>
<span class="gi">+</span>
<span class="gi">+    def _verify(self, signature, hash_bytes):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.public_key.verify_digest(compatHMAC(signature),</span>
<span class="gi">+                                                 compatHMAC(hash_bytes),</span>
<span class="gi">+                                                 sigdecode_der)</span>
<span class="gi">+        # https://github.com/warner/python-ecdsa/issues/114</span>
<span class="gi">+        except (BadSignatureError, UnexpectedDER, IndexError, AssertionError):</span>
<span class="gi">+            return False</span>
<span class="gh">diff --git a/tlslite/utils/python_eddsakey.py b/tlslite/utils/python_eddsakey.py</span>
<span class="gh">index 6129165..0829944 100644</span>
<span class="gd">--- a/tlslite/utils/python_eddsakey.py</span>
<span class="gi">+++ b/tlslite/utils/python_eddsakey.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="gi">+# Author Hubert Kario, copyright 2021</span>
<span class="gi">+</span>
<span class="w"> </span>from .eddsakey import EdDSAKey
<span class="w"> </span>from ecdsa.keys import BadSignatureError
<span class="w"> </span>from ecdsa.der import UnexpectedDER
<span class="gu">@@ -27,13 +29,36 @@ class Python_EdDSAKey(EdDSAKey):</span>

<span class="w"> </span>    def __init__(self, public_key, private_key=None):
<span class="w"> </span>        if not public_key and not private_key:
<span class="gd">-            raise ValueError(&#39;at least one key must be provided&#39;)</span>
<span class="gi">+            raise ValueError(&quot;at least one key must be provided&quot;)</span>
<span class="w"> </span>        if not public_key:
<span class="w"> </span>            public_key = private_key.verifying_key
<span class="gi">+</span>
<span class="w"> </span>        self.curve_name = public_key.curve.name
<span class="gi">+</span>
<span class="w"> </span>        self.private_key = private_key
<span class="w"> </span>        self.public_key = public_key
<span class="w"> </span>        self.key_type = self.curve_name

<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return numBits(self.public_key.curve.order)
<span class="gi">+</span>
<span class="gi">+    def hasPrivateKey(self):</span>
<span class="gi">+        return bool(self.private_key)</span>
<span class="gi">+</span>
<span class="gi">+    def acceptsPassword(self):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def generate(bits):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _hashAndSign(self, data):</span>
<span class="gi">+        return self.private_key.sign_deterministic(compatHMAC(data))</span>
<span class="gi">+</span>
<span class="gi">+    def _hashAndVerify(self, signature, data):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.public_key.verify(compatHMAC(signature),</span>
<span class="gi">+                                          compatHMAC(data))</span>
<span class="gi">+        # https://github.com/warner/python-ecdsa/issues/114</span>
<span class="gi">+        except (BadSignatureError, UnexpectedDER, IndexError, AssertionError):</span>
<span class="gi">+            return False</span>
<span class="gh">diff --git a/tlslite/utils/python_key.py b/tlslite/utils/python_key.py</span>
<span class="gh">index 5c423c7..29e4701 100644</span>
<span class="gd">--- a/tlslite/utils/python_key.py</span>
<span class="gi">+++ b/tlslite/utils/python_key.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from .python_rsakey import Python_RSAKey
<span class="w"> </span>from .python_ecdsakey import Python_ECDSAKey
<span class="w"> </span>from .python_dsakey import Python_DSAKey
<span class="gu">@@ -9,7 +11,6 @@ from .compat import compatHMAC</span>
<span class="w"> </span>from ecdsa.curves import NIST256p, NIST384p, NIST521p
<span class="w"> </span>from ecdsa.keys import SigningKey, VerifyingKey

<span class="gd">-</span>
<span class="w"> </span>class Python_Key(object):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Generic methods for parsing private keys from files.
<span class="gu">@@ -20,16 +21,162 @@ class Python_Key(object):</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def parsePEM(s, passwordCallback=None):
<span class="w"> </span>        &quot;&quot;&quot;Parse a string containing a PEM-encoded &lt;privateKey&gt;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if pemSniff(s, &quot;PRIVATE KEY&quot;):</span>
<span class="gi">+            bytes = dePem(s, &quot;PRIVATE KEY&quot;)</span>
<span class="gi">+            return Python_Key._parse_pkcs8(bytes)</span>
<span class="gi">+        elif pemSniff(s, &quot;RSA PRIVATE KEY&quot;):</span>
<span class="gi">+            bytes = dePem(s, &quot;RSA PRIVATE KEY&quot;)</span>
<span class="gi">+            return Python_Key._parse_ssleay(bytes, &quot;rsa&quot;)</span>
<span class="gi">+        elif pemSniff(s, &quot;DSA PRIVATE KEY&quot;):</span>
<span class="gi">+            bytes = dePem(s, &quot;DSA PRIVATE KEY&quot;)</span>
<span class="gi">+            return Python_Key._parse_dsa_ssleay(bytes)</span>
<span class="gi">+        elif pemSniff(s, &quot;EC PRIVATE KEY&quot;):</span>
<span class="gi">+            bytes = dePem(s, &quot;EC PRIVATE KEY&quot;)</span>
<span class="gi">+            return Python_Key._parse_ecc_ssleay(bytes)</span>
<span class="gi">+        elif pemSniff(s, &quot;PUBLIC KEY&quot;):</span>
<span class="gi">+            bytes = dePem(s, &quot;PUBLIC KEY&quot;)</span>
<span class="gi">+            return Python_Key._parse_public_key(bytes)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SyntaxError(&quot;Not a PEM private key file&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _parse_public_key(bytes):</span>
<span class="gi">+        # public keys are encoded as the subject_public_key_info objects</span>
<span class="gi">+        spk_info = ASN1Parser(bytes)</span>
<span class="gi">+</span>
<span class="gi">+        # first element of the SEQUENCE is the AlgorithmIdentifier</span>
<span class="gi">+        alg_id = spk_info.getChild(0)</span>
<span class="gi">+</span>
<span class="gi">+        # AlgId has two elements, the OID of the algorithm and parameters</span>
<span class="gi">+        # parameters generally have to be NULL, with exception of RSA-PSS</span>
<span class="gi">+</span>
<span class="gi">+        alg_oid = alg_id.getChild(0)</span>
<span class="gi">+</span>
<span class="gi">+        if list(alg_oid.value) == [42, 134, 72, 134, 247, 13, 1, 1, 1]:</span>
<span class="gi">+            key_type = &quot;rsa&quot;</span>
<span class="gi">+        elif list(alg_oid.value) == [42, 134, 72, 206, 56, 4, 1]:</span>
<span class="gi">+            key_type = &quot;dsa&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SyntaxError(&quot;Only RSA or DSA Public keys supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if key_type == &quot;rsa&quot;:</span>
<span class="gi">+            subject_public_key = ASN1Parser(</span>
<span class="gi">+                ASN1Parser(spk_info.getChildBytes(1)).value[1:])</span>
<span class="gi">+</span>
<span class="gi">+            modulus = subject_public_key.getChild(0)</span>
<span class="gi">+            exponent = subject_public_key.getChild(1)</span>
<span class="gi">+</span>
<span class="gi">+            n = bytesToNumber(modulus.value)</span>
<span class="gi">+            e = bytesToNumber(exponent.value)</span>
<span class="gi">+</span>
<span class="gi">+            return Python_RSAKey(n, e, key_type=&quot;rsa&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        elif key_type == &quot;dsa&quot;:</span>
<span class="gi">+            # public key</span>
<span class="gi">+            subject_public_key = ASN1Parser(</span>
<span class="gi">+                ASN1Parser(spk_info.getChildBytes(1)).value[1:])</span>
<span class="gi">+</span>
<span class="gi">+            public_key = bytesToNumber(subject_public_key.value)</span>
<span class="gi">+</span>
<span class="gi">+            # domain parameters</span>
<span class="gi">+            domain = alg_id.getChild(1)</span>
<span class="gi">+</span>
<span class="gi">+            p = bytesToNumber(domain.getChild(0).value)</span>
<span class="gi">+            q = bytesToNumber(domain.getChild(1).value)</span>
<span class="gi">+            g = bytesToNumber(domain.getChild(2).value)</span>
<span class="gi">+</span>
<span class="gi">+            return Python_DSAKey(p, q, g, y=public_key)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _parse_pkcs8(bytes):</span>
<span class="gi">+        parser = ASN1Parser(bytes)</span>
<span class="gi">+</span>
<span class="gi">+        # first element in PrivateKeyInfo is an INTEGER</span>
<span class="gi">+        version = parser.getChild(0).value</span>
<span class="gi">+        if bytesToNumber(version) != 0:</span>
<span class="gi">+            raise SyntaxError(&quot;Unrecognized PKCS8 version&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # second element in PrivateKeyInfo is a SEQUENCE of type</span>
<span class="gi">+        # AlgorithmIdentifier</span>
<span class="gi">+        alg_ident = parser.getChild(1)</span>
<span class="gi">+        seq_len = alg_ident.getChildCount()</span>
<span class="gi">+        # first item of AlgorithmIdentifier is an OBJECT (OID)</span>
<span class="gi">+        oid = alg_ident.getChild(0)</span>
<span class="gi">+        if list(oid.value) == [42, 134, 72, 134, 247, 13, 1, 1, 1]:</span>
<span class="gi">+            key_type = &quot;rsa&quot;</span>
<span class="gi">+        elif list(oid.value) == [42, 134, 72, 134, 247, 13, 1, 1, 10]:</span>
<span class="gi">+            key_type = &quot;rsa-pss&quot;</span>
<span class="gi">+        elif list(oid.value) == [42, 134, 72, 206, 56, 4, 1]:</span>
<span class="gi">+            key_type = &quot;dsa&quot;</span>
<span class="gi">+        elif list(oid.value) == [42, 134, 72, 206, 61, 2, 1]:</span>
<span class="gi">+            key_type = &quot;ecdsa&quot;</span>
<span class="gi">+        elif list(oid.value) == [43, 101, 112]:</span>
<span class="gi">+            key_type = &quot;Ed25519&quot;</span>
<span class="gi">+        elif list(oid.value) == [43, 101, 113]:</span>
<span class="gi">+            key_type = &quot;Ed448&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SyntaxError(&quot;Unrecognized AlgorithmIdentifier: {0}&quot;</span>
<span class="gi">+                              .format(list(oid.value)))</span>
<span class="gi">+        # second item of AlgorithmIdentifier are parameters (defined by</span>
<span class="gi">+        # above algorithm)</span>
<span class="gi">+        if key_type == &quot;rsa&quot;:</span>
<span class="gi">+            if seq_len != 2:</span>
<span class="gi">+                raise SyntaxError(&quot;Missing parameters for RSA algorithm ID&quot;)</span>
<span class="gi">+            parameters = alg_ident.getChild(1)</span>
<span class="gi">+            if parameters.value != bytearray(0):</span>
<span class="gi">+                raise SyntaxError(&quot;RSA parameters are not NULL&quot;)</span>
<span class="gi">+        if key_type == &quot;dsa&quot;:</span>
<span class="gi">+            if seq_len != 2:</span>
<span class="gi">+                raise SyntaxError(&quot;Invalid encoding of algorithm identifier&quot;)</span>
<span class="gi">+            parameters = alg_ident.getChild(1)</span>
<span class="gi">+            if parameters.value == bytearray(0):</span>
<span class="gi">+                parameters = None</span>
<span class="gi">+        elif key_type == &quot;ecdsa&quot;:</span>
<span class="gi">+            if seq_len != 2:</span>
<span class="gi">+                raise SyntaxError(&quot;Invalid encoding of algorithm identifier&quot;)</span>
<span class="gi">+            curveID = alg_ident.getChild(1)</span>
<span class="gi">+            if list(curveID.value) == [42, 134, 72, 206, 61, 3, 1, 7]:</span>
<span class="gi">+                curve = NIST256p</span>
<span class="gi">+            elif list(curveID.value) == [43, 129, 4, 0, 34]:</span>
<span class="gi">+                curve = NIST384p</span>
<span class="gi">+            elif list(curveID.value) == [43, 129, 4, 0, 35]:</span>
<span class="gi">+                curve = NIST521p</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise SyntaxError(&quot;Unknown curve&quot;)</span>
<span class="gi">+        else:  # rsa-pss</span>
<span class="gi">+            pass  # ignore parameters - don&#39;t apply restrictions</span>
<span class="gi">+</span>
<span class="gi">+        if seq_len &gt; 2:</span>
<span class="gi">+            raise SyntaxError(&quot;Invalid encoding of AlgorithmIdentifier&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        #Get the privateKey</span>
<span class="gi">+        private_key_parser = parser.getChild(2)</span>
<span class="gi">+</span>
<span class="gi">+        #Adjust for OCTET STRING encapsulation</span>
<span class="gi">+        private_key_parser = ASN1Parser(private_key_parser.value)</span>
<span class="gi">+</span>
<span class="gi">+        if key_type in (&quot;Ed25519&quot;, &quot;Ed448&quot;):</span>
<span class="gi">+            return Python_Key._parse_eddsa_private_key(bytes)</span>
<span class="gi">+        if key_type == &quot;ecdsa&quot;:</span>
<span class="gi">+            return Python_Key._parse_ecdsa_private_key(private_key_parser,</span>
<span class="gi">+                                                       curve)</span>
<span class="gi">+        elif key_type == &quot;dsa&quot;:</span>
<span class="gi">+            return Python_Key._parse_dsa_private_key(private_key_parser, parameters)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Python_Key._parse_asn1_private_key(private_key_parser,</span>
<span class="gi">+                                                      key_type)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _parse_ssleay(data, key_type=&#39;rsa&#39;):</span>
<span class="gi">+    def _parse_ssleay(data, key_type=&quot;rsa&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Parse binary structure of the old SSLeay file format used by OpenSSL.

<span class="w"> </span>        For RSA keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        private_key_parser = ASN1Parser(data)</span>
<span class="gi">+        # &quot;rsa&quot; type as old format doesn&#39;t support rsa-pss parameters</span>
<span class="gi">+        return Python_Key._parse_asn1_private_key(private_key_parser, key_type)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _parse_dsa_ssleay(data):
<span class="gu">@@ -38,7 +185,8 @@ class Python_Key(object):</span>

<span class="w"> </span>        For DSA keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        private_key_parser = ASN1Parser(data)</span>
<span class="gi">+        return Python_Key._parse_dsa_private_key(private_key_parser)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _parse_ecc_ssleay(data):
<span class="gu">@@ -47,9 +195,78 @@ class Python_Key(object):</span>

<span class="w"> </span>        For ECDSA keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        private_key = SigningKey.from_der(compatHMAC(data))</span>
<span class="gi">+        secret_mult = private_key.privkey.secret_multiplier</span>
<span class="gi">+        return Python_ECDSAKey(None, None, private_key.curve.name,</span>
<span class="gi">+                               secret_mult)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _parse_ecdsa_private_key(private, curve):</span>
<span class="gi">+        ver = private.getChild(0)</span>
<span class="gi">+        if ver.value != b&#39;\x01&#39;:</span>
<span class="gi">+            raise SyntaxError(&quot;Unexpected EC key version&quot;)</span>
<span class="gi">+        private_key = private.getChild(1)</span>
<span class="gi">+        public_key = private.getChild(2)</span>
<span class="gi">+        # first two bytes are the ASN.1 custom type and the length of payload</span>
<span class="gi">+        # while the latter two bytes are just specification of the public</span>
<span class="gi">+        # key encoding (uncompressed)</span>
<span class="gi">+        # TODO: update ecdsa lib to be able to parse PKCS#8 files</span>
<span class="gi">+        if curve is not NIST521p:</span>
<span class="gi">+            if list(public_key.value[:1]) != [3] or \</span>
<span class="gi">+                    list(public_key.value[2:4]) != [0, 4]:</span>
<span class="gi">+                raise SyntaxError(&quot;Invalid or unsupported encoding of public key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            pub_key = VerifyingKey.from_string(</span>
<span class="gi">+                    compatHMAC(public_key.value[4:]),</span>
<span class="gi">+                    curve)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if list(public_key.value[:3]) != [3, 129, 134] or \</span>
<span class="gi">+                    list(public_key.value[3:5]) != [0, 4]:</span>
<span class="gi">+                raise SyntaxError(&quot;Invalid or unsupported encoding of public key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            pub_key = VerifyingKey.from_string(</span>
<span class="gi">+                    compatHMAC(public_key.value[5:]),</span>
<span class="gi">+                    curve)</span>
<span class="gi">+        pub_x = pub_key.pubkey.point.x()</span>
<span class="gi">+        pub_y = pub_key.pubkey.point.y()</span>
<span class="gi">+        priv_key = SigningKey.from_string(compatHMAC(private_key.value),</span>
<span class="gi">+                                          curve)</span>
<span class="gi">+        mult = priv_key.privkey.secret_multiplier</span>
<span class="gi">+        return Python_ECDSAKey(pub_x, pub_y, curve.name, mult)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _parse_eddsa_private_key(data):
<span class="w"> </span>        &quot;&quot;&quot;Parse a DER encoded EdDSA key.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        priv_key = SigningKey.from_der(data)</span>
<span class="gi">+        return Python_EdDSAKey(priv_key.verifying_key, private_key=priv_key)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _parse_asn1_private_key(private_key_parser, key_type):</span>
<span class="gi">+        version = private_key_parser.getChild(0).value[0]</span>
<span class="gi">+        if version != 0:</span>
<span class="gi">+            raise SyntaxError(&quot;Unrecognized RSAPrivateKey version&quot;)</span>
<span class="gi">+        n = bytesToNumber(private_key_parser.getChild(1).value)</span>
<span class="gi">+        e = bytesToNumber(private_key_parser.getChild(2).value)</span>
<span class="gi">+        d = bytesToNumber(private_key_parser.getChild(3).value)</span>
<span class="gi">+        p = bytesToNumber(private_key_parser.getChild(4).value)</span>
<span class="gi">+        q = bytesToNumber(private_key_parser.getChild(5).value)</span>
<span class="gi">+        dP = bytesToNumber(private_key_parser.getChild(6).value)</span>
<span class="gi">+        dQ = bytesToNumber(private_key_parser.getChild(7).value)</span>
<span class="gi">+        qInv = bytesToNumber(private_key_parser.getChild(8).value)</span>
<span class="gi">+        return Python_RSAKey(n, e, d, p, q, dP, dQ, qInv, key_type)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _parse_dsa_private_key(private_key_parser, domain_parameters=None):</span>
<span class="gi">+        if domain_parameters:</span>
<span class="gi">+            p = bytesToNumber(domain_parameters.getChild(0).value)</span>
<span class="gi">+            q = bytesToNumber(domain_parameters.getChild(1).value)</span>
<span class="gi">+            g = bytesToNumber(domain_parameters.getChild(2).value)</span>
<span class="gi">+            x = bytesToNumber(private_key_parser.value)</span>
<span class="gi">+            return Python_DSAKey(p, q, g, x)</span>
<span class="gi">+        p = bytesToNumber(private_key_parser.getChild(1).value)</span>
<span class="gi">+        q = bytesToNumber(private_key_parser.getChild(2).value)</span>
<span class="gi">+        g = bytesToNumber(private_key_parser.getChild(3).value)</span>
<span class="gi">+        y = bytesToNumber(private_key_parser.getChild(4).value)</span>
<span class="gi">+        x = bytesToNumber(private_key_parser.getChild(5).value)</span>
<span class="gi">+        return Python_DSAKey(p, q, g, x, y)</span>
<span class="gh">diff --git a/tlslite/utils/python_rc4.py b/tlslite/utils/python_rc4.py</span>
<span class="gh">index 84242a5..15d9fd4 100644</span>
<span class="gd">--- a/tlslite/utils/python_rc4.py</span>
<span class="gi">+++ b/tlslite/utils/python_rc4.py</span>
<span class="gu">@@ -1,17 +1,41 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Pure-Python RC4 implementation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .rc4 import RC4
<span class="w"> </span>from .cryptomath import *

<span class="gi">+def new(key):</span>
<span class="gi">+    return Python_RC4(key)</span>

<span class="w"> </span>class Python_RC4(RC4):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, keyBytes):
<span class="gd">-        RC4.__init__(self, keyBytes, &#39;python&#39;)</span>
<span class="gi">+        RC4.__init__(self, keyBytes, &quot;python&quot;)</span>
<span class="w"> </span>        S = [i for i in range(256)]
<span class="w"> </span>        j = 0
<span class="w"> </span>        for i in range(256):
<span class="w"> </span>            j = (j + S[i] + keyBytes[i % len(keyBytes)]) % 256
<span class="w"> </span>            S[i], S[j] = S[j], S[i]
<span class="gi">+</span>
<span class="w"> </span>        self.S = S
<span class="w"> </span>        self.i = 0
<span class="w"> </span>        self.j = 0
<span class="gi">+</span>
<span class="gi">+    def encrypt(self, plaintextBytes):</span>
<span class="gi">+        ciphertextBytes = plaintextBytes[:]</span>
<span class="gi">+        S = self.S</span>
<span class="gi">+        i = self.i</span>
<span class="gi">+        j = self.j</span>
<span class="gi">+        for x in range(len(ciphertextBytes)):</span>
<span class="gi">+            i = (i + 1) % 256</span>
<span class="gi">+            j = (j + S[i]) % 256</span>
<span class="gi">+            S[i], S[j] = S[j], S[i]</span>
<span class="gi">+            t = (S[i] + S[j]) % 256</span>
<span class="gi">+            ciphertextBytes[x] ^= S[t]</span>
<span class="gi">+        self.i = i</span>
<span class="gi">+        self.j = j</span>
<span class="gi">+        return ciphertextBytes</span>
<span class="gi">+</span>
<span class="gi">+    def decrypt(self, ciphertext):</span>
<span class="gi">+        return self.encrypt(ciphertext)</span>
<span class="gh">diff --git a/tlslite/utils/python_rsakey.py b/tlslite/utils/python_rsakey.py</span>
<span class="gh">index 8e9c317..ab4bf41 100644</span>
<span class="gd">--- a/tlslite/utils/python_rsakey.py</span>
<span class="gi">+++ b/tlslite/utils/python_rsakey.py</span>
<span class="gu">@@ -1,3 +1,6 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Pure-Python RSA implementation.&quot;&quot;&quot;
<span class="w"> </span>import threading
<span class="w"> </span>from .cryptomath import *
<span class="gu">@@ -9,15 +12,13 @@ if GMPY2_LOADED:</span>
<span class="w"> </span>elif gmpyLoaded:
<span class="w"> </span>    from gmpy import mpz

<span class="gd">-</span>
<span class="w"> </span>class Python_RSAKey(RSAKey):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, n=0, e=0, d=0, p=0, q=0, dP=0, dQ=0, qInv=0,
<span class="gd">-        key_type=&#39;rsa&#39;):</span>
<span class="gi">+                 key_type=&quot;rsa&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialise key directly from integers.

<span class="w"> </span>        see also generate() and parsePEM().&quot;&quot;&quot;
<span class="gd">-        if n and not e or e and not n:</span>
<span class="gi">+        if (n and not e) or (e and not n):</span>
<span class="w"> </span>            raise AssertionError()
<span class="w"> </span>        if gmpyLoaded or GMPY2_LOADED:
<span class="w"> </span>            n = mpz(n)
<span class="gu">@@ -31,7 +32,7 @@ class Python_RSAKey(RSAKey):</span>
<span class="w"> </span>        self.n = n
<span class="w"> </span>        self.e = e
<span class="w"> </span>        if p and not q or not p and q:
<span class="gd">-            raise ValueError(&#39;p and q must be set or left unset together&#39;)</span>
<span class="gi">+            raise ValueError(&quot;p and q must be set or left unset together&quot;)</span>
<span class="w"> </span>        if not d and p and q:
<span class="w"> </span>            t = lcm(p - 1, q - 1)
<span class="w"> </span>            d = invMod(e, t)
<span class="gu">@@ -57,22 +58,94 @@ class Python_RSAKey(RSAKey):</span>
<span class="w"> </span>        Does the key has the associated private key (True) or is it only
<span class="w"> </span>        the public part (False).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.d != 0</span>
<span class="gi">+</span>
<span class="gi">+    def _rawPrivateKeyOp(self, message):</span>
<span class="gi">+        n = self.n</span>
<span class="gi">+        with self._lock:</span>
<span class="gi">+            # Create blinding values, on the first pass:</span>
<span class="gi">+            if not self.blinder:</span>
<span class="gi">+                self.unblinder = getRandomNumber(2, n)</span>
<span class="gi">+                self.blinder = powMod(invMod(self.unblinder, n), self.e,</span>
<span class="gi">+                                      n)</span>
<span class="gi">+            unblinder = self.unblinder</span>
<span class="gi">+            blinder = self.blinder</span>
<span class="gi">+</span>
<span class="gi">+            # Update blinding values</span>
<span class="gi">+            self.blinder = (blinder * blinder) % n</span>
<span class="gi">+            self.unblinder = (unblinder * unblinder) % n</span>
<span class="gi">+</span>
<span class="gi">+        # Blind the input</span>
<span class="gi">+        message = (message * blinder) % n</span>
<span class="gi">+</span>
<span class="gi">+        # Perform the RSA operation</span>
<span class="gi">+        cipher = self._rawPrivateKeyOpHelper(message)</span>
<span class="gi">+</span>
<span class="gi">+        # Unblind the output</span>
<span class="gi">+        cipher = (cipher * unblinder) % n</span>
<span class="gi">+</span>
<span class="gi">+        # Return the output</span>
<span class="gi">+        return cipher</span>
<span class="gi">+</span>
<span class="gi">+    def _rawPrivateKeyOpHelper(self, m):</span>
<span class="gi">+        #Non-CRT version</span>
<span class="gi">+        #c = pow(m, self.d, self.n)</span>
<span class="gi">+</span>
<span class="gi">+        #CRT version  (~3x faster).</span>
<span class="gi">+        p, q = self.p, self.q</span>
<span class="gi">+        s1 = pow(m, self.dP, p)</span>
<span class="gi">+        s2 = pow(m, self.dQ, q)</span>
<span class="gi">+        h = ((s1 - s2) * self.qInv) % p</span>
<span class="gi">+        c = s2 + q * h</span>
<span class="gi">+        return c</span>
<span class="gi">+</span>
<span class="gi">+    def _rawPublicKeyOp(self, ciphertext):</span>
<span class="gi">+        msg = pow(ciphertext, self.e, self.n)</span>
<span class="gi">+        return msg</span>

<span class="w"> </span>    def acceptsPassword(self):
<span class="w"> </span>        &quot;&quot;&quot;Does it support encrypted key files.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def generate(bits, key_type=&#39;rsa&#39;):</span>
<span class="gi">+    def generate(bits, key_type=&quot;rsa&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a private key with modulus &#39;bits&#39; bit big.

<span class="w"> </span>        key_type can be &quot;rsa&quot; for a universal rsaEncryption key or
<span class="w"> </span>        &quot;rsa-pss&quot; for a key that can be used only for RSASSA-PSS.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # p, q, and t are standard names for the variables in RSA, so</span>
<span class="gi">+        # ignore the fact those are one character long variable names</span>
<span class="gi">+        # pylint: disable=invalid-name</span>
<span class="gi">+        key = Python_RSAKey()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            p = getRandomPrime(bits//2, False)</span>
<span class="gi">+            q = getRandomPrime(bits//2, False)</span>
<span class="gi">+            if gmpyLoaded or GMPY2_LOADED:</span>
<span class="gi">+                p = mpz(p)</span>
<span class="gi">+                q = mpz(q)</span>
<span class="gi">+            t = lcm(p-1, q-1)</span>
<span class="gi">+            # since we need to calculate inverse of 65537 mod t, they</span>
<span class="gi">+            # must be relatively prime (coprime)</span>
<span class="gi">+            if gcd(t, 65537) == 1:</span>
<span class="gi">+                break</span>
<span class="gi">+        key.n = p * q</span>
<span class="gi">+        if gmpyLoaded or GMPY2_LOADED:</span>
<span class="gi">+            key.e = mpz(65537)</span>
<span class="gi">+        else:</span>
<span class="gi">+            key.e = 65537</span>
<span class="gi">+        key.d = invMod(key.e, t)</span>
<span class="gi">+        key.p = p</span>
<span class="gi">+        key.q = q</span>
<span class="gi">+        key.dP = key.d % (p-1)</span>
<span class="gi">+        key.dQ = key.d % (q-1)</span>
<span class="gi">+        key.qInv = invMod(q, p)</span>
<span class="gi">+        key.key_type = key_type</span>
<span class="gi">+        # pylint: enable=invalid-name</span>
<span class="gi">+        return key</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    @deprecated_params({&#39;data&#39;: &#39;s&#39;, &#39;password_callback&#39;: &#39;passwordCallback&#39;})</span>
<span class="gi">+    @deprecated_params({&quot;data&quot;: &quot;s&quot;, &quot;password_callback&quot;: &quot;passwordCallback&quot;})</span>
<span class="w"> </span>    def parsePEM(data, password_callback=None):
<span class="w"> </span>        &quot;&quot;&quot;Parse a string containing a PEM-encoded &lt;privateKey&gt;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .python_key import Python_Key</span>
<span class="gi">+        return Python_Key.parsePEM(data, password_callback)</span>
<span class="gh">diff --git a/tlslite/utils/python_tripledes.py b/tlslite/utils/python_tripledes.py</span>
<span class="gh">index c926c9c..431be5d 100644</span>
<span class="gd">--- a/tlslite/utils/python_tripledes.py</span>
<span class="gi">+++ b/tlslite/utils/python_tripledes.py</span>
<span class="gu">@@ -1,3 +1,20 @@</span>
<span class="gi">+#################################################</span>
<span class="gi">+#               Documentation                   #</span>
<span class="gi">+#################################################</span>
<span class="gi">+</span>
<span class="gi">+# Author:   Todd Whiteman</span>
<span class="gi">+# Date:     16th March, 2009</span>
<span class="gi">+# Verion:   2.0.0</span>
<span class="gi">+# License:  Public Domain - free to do as you wish</span>
<span class="gi">+# Homepage: http://twhiteman.netfirms.com/Des.html</span>
<span class="gi">+#</span>
<span class="gi">+# Modified by: Adam Varga, 2018</span>
<span class="gi">+#</span>
<span class="gi">+# A pure python implementation of the DES and Triple DES</span>
<span class="gi">+# encryption algorithms using CBC mode. Triple DES class is</span>
<span class="gi">+# implemented by utilising the DES base. Triple DES is</span>
<span class="gi">+# DES-EDE3 with a 24 byte key, or DES-EDE2 with a 16 byte key.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Class initialization
<span class="w"> </span>--------------------
<span class="gu">@@ -8,14 +25,18 @@ key -&gt; Bytes containing the encryption key. 8 bytes for DES, 16 or 24 bytes</span>
<span class="w"> </span>       for Triple DES
<span class="w"> </span>iv  -&gt; Initialization Vector in bytes. Length must be 8 bytes.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="gi">+# PY_VER is used to handle Python2 and Python3 differences.</span>
<span class="w"> </span>PY_VER = sys.version_info


<span class="w"> </span>def new(key, iv):
<span class="w"> </span>    &quot;&quot;&quot;Operate this 3DES cipher.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return Python_TripleDES(key, iv)</span>


<span class="w"> </span>class _baseDes(object):
<span class="gu">@@ -30,7 +51,28 @@ class _baseDes(object):</span>
<span class="w"> </span>        Only accept byte strings or ascii unicode values.
<span class="w"> </span>        Otherwise there is no way to correctly decode the data into bytes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if PY_VER &lt; (3, ):</span>
<span class="gi">+            if isinstance(data, unicode):</span>
<span class="gi">+                raise ValueError(&quot;Only bytes, bytearray or memoryview &quot;</span>
<span class="gi">+                                 &quot;objects of them should be passed, &quot;</span>
<span class="gi">+                                 &quot;not Unicode strings&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(data, str):</span>
<span class="gi">+                warnings.warn(&quot;Only bytes, bytearray or memoryview &quot;</span>
<span class="gi">+                              &quot;objects of them should be passed&quot;,</span>
<span class="gi">+                              DeprecationWarning,</span>
<span class="gi">+                              stacklevel=3)</span>
<span class="gi">+                # Only accept ascii unicode values.</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return data.encode(&#39;ascii&#39;)</span>
<span class="gi">+                except UnicodeEncodeError:</span>
<span class="gi">+                    raise ValueError(&quot;The Unicode string shouldn&#39;t be passed&quot;)</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+#############################################</span>
<span class="gi">+#                   DES                     #</span>
<span class="gi">+#############################################</span>


<span class="w"> </span>class Des(_baseDes):
<span class="gu">@@ -38,98 +80,303 @@ class Des(_baseDes):</span>

<span class="w"> </span>    Supports CBC (Cypher Block Chaining) mode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __pc1 = [56, 48, 40, 32, 24, 16, 8, 0, 57, 49, 41, 33, 25, 17, 9, 1, 58,</span>
<span class="gd">-        50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 62, 54, 46, 38, 30, 22, </span>
<span class="gd">-        14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 60, 52, 44, 36, 28, 20, 12, 4,</span>
<span class="gd">-        27, 19, 11, 3]</span>
<span class="gd">-    __left_rotations = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]</span>
<span class="gd">-    __pc2 = [13, 16, 10, 23, 0, 4, 2, 27, 14, 5, 20, 9, 22, 18, 11, 3, 25, </span>
<span class="gd">-        7, 15, 6, 26, 19, 12, 1, 40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32,</span>
<span class="gd">-        47, 43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31]</span>
<span class="gd">-    __ip = [57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61,</span>
<span class="gd">-        53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7, 56, 48, </span>
<span class="gd">-        40, 32, 24, 16, 8, 0, 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36,</span>
<span class="gd">-        28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6]</span>
<span class="gd">-    __expansion_table = [31, 0, 1, 2, 3, 4, 3, 4, 5, 6, 7, 8, 7, 8, 9, 10, </span>
<span class="gd">-        11, 12, 11, 12, 13, 14, 15, 16, 15, 16, 17, 18, 19, 20, 19, 20, 21,</span>
<span class="gd">-        22, 23, 24, 23, 24, 25, 26, 27, 28, 27, 28, 29, 30, 31, 0]</span>
<span class="gd">-    __sbox = [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15,</span>
<span class="gd">-        7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, </span>
<span class="gd">-        2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, </span>
<span class="gd">-        3, 14, 10, 0, 6, 13], [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, </span>
<span class="gd">-        0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, </span>
<span class="gd">-        14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3,</span>
<span class="gd">-        15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9], [10, 0, 9, 14, 6, 3, 15, 5, 1,</span>
<span class="gd">-        13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, </span>
<span class="gd">-        11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1,</span>
<span class="gd">-        10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12], [7, 13, 14, 3, </span>
<span class="gd">-        0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, </span>
<span class="gd">-        4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14,</span>
<span class="gd">-        5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],</span>
<span class="gd">-        [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, </span>
<span class="gd">-        12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, </span>
<span class="gd">-        8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0,</span>
<span class="gd">-        9, 10, 4, 5, 3], [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5,</span>
<span class="gd">-        11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15,</span>
<span class="gd">-        5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, </span>
<span class="gd">-        10, 11, 14, 1, 7, 6, 0, 8, 13], [4, 11, 2, 14, 15, 0, 8, 13, 3, 12,</span>
<span class="gd">-        9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, </span>
<span class="gd">-        8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, </span>
<span class="gd">-        13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12], [13, 2, 8, 4, 6, 15,</span>
<span class="gd">-        11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5,</span>
<span class="gd">-        6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3,</span>
<span class="gd">-        5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]</span>
<span class="gd">-    __p = [15, 6, 19, 20, 28, 11, 27, 16, 0, 14, 22, 25, 4, 17, 30, 9, 1, 7,</span>
<span class="gd">-        23, 13, 31, 26, 2, 8, 18, 12, 29, 5, 21, 10, 3, 24]</span>
<span class="gd">-    __fp = [39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, </span>
<span class="gd">-        37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3,</span>
<span class="gd">-        43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9,</span>
<span class="gd">-        49, 17, 57, 25, 32, 0, 40, 8, 48, 16, 56, 24]</span>
<span class="gd">-    ENCRYPT = 0</span>
<span class="gd">-    DECRYPT = 1</span>

<span class="gi">+    # Permutation and translation tables for DES</span>
<span class="gi">+    __pc1 = [56, 48, 40, 32, 24, 16, 8,</span>
<span class="gi">+             0, 57, 49, 41, 33, 25, 17,</span>
<span class="gi">+             9, 1, 58, 50, 42, 34, 26,</span>
<span class="gi">+             18, 10, 2, 59, 51, 43, 35,</span>
<span class="gi">+             62, 54, 46, 38, 30, 22, 14,</span>
<span class="gi">+             6, 61, 53, 45, 37, 29, 21,</span>
<span class="gi">+             13, 5, 60, 52, 44, 36, 28,</span>
<span class="gi">+             20, 12, 4, 27, 19, 11, 3]</span>
<span class="gi">+</span>
<span class="gi">+    # Number left rotations of pc1</span>
<span class="gi">+    __left_rotations = [1, 1, 2, 2, 2, 2, 2, 2,</span>
<span class="gi">+                        1, 2, 2, 2, 2, 2, 2, 1]</span>
<span class="gi">+</span>
<span class="gi">+    # Permuted choice key (table 2)</span>
<span class="gi">+    __pc2 = [13, 16, 10, 23, 0, 4,</span>
<span class="gi">+             2, 27, 14, 5, 20, 9,</span>
<span class="gi">+             22, 18, 11, 3, 25, 7,</span>
<span class="gi">+             15, 6, 26, 19, 12, 1,</span>
<span class="gi">+             40, 51, 30, 36, 46, 54,</span>
<span class="gi">+             29, 39, 50, 44, 32, 47,</span>
<span class="gi">+             43, 48, 38, 55, 33, 52,</span>
<span class="gi">+             45, 41, 49, 35, 28, 31]</span>
<span class="gi">+</span>
<span class="gi">+    # Initial permutation IP</span>
<span class="gi">+    __ip = [57, 49, 41, 33, 25, 17, 9, 1,</span>
<span class="gi">+            59, 51, 43, 35, 27, 19, 11, 3,</span>
<span class="gi">+            61, 53, 45, 37, 29, 21, 13, 5,</span>
<span class="gi">+            63, 55, 47, 39, 31, 23, 15, 7,</span>
<span class="gi">+            56, 48, 40, 32, 24, 16, 8, 0,</span>
<span class="gi">+            58, 50, 42, 34, 26, 18, 10, 2,</span>
<span class="gi">+            60, 52, 44, 36, 28, 20, 12, 4,</span>
<span class="gi">+            62, 54, 46, 38, 30, 22, 14, 6]</span>
<span class="gi">+</span>
<span class="gi">+    # Expansion table for turning 32 bit blocks into 48 bits</span>
<span class="gi">+    __expansion_table = [31, 0, 1, 2, 3, 4,</span>
<span class="gi">+                         3, 4, 5, 6, 7, 8,</span>
<span class="gi">+                         7, 8, 9, 10, 11, 12,</span>
<span class="gi">+                         11, 12, 13, 14, 15, 16,</span>
<span class="gi">+                         15, 16, 17, 18, 19, 20,</span>
<span class="gi">+                         19, 20, 21, 22, 23, 24,</span>
<span class="gi">+                         23, 24, 25, 26, 27, 28,</span>
<span class="gi">+                         27, 28, 29, 30, 31, 0]</span>
<span class="gi">+</span>
<span class="gi">+    # The (in)famous S-boxes</span>
<span class="gi">+    __sbox = [  # S1</span>
<span class="gi">+              [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,</span>
<span class="gi">+               0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,</span>
<span class="gi">+               4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,</span>
<span class="gi">+               15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],</span>
<span class="gi">+</span>
<span class="gi">+              # S2</span>
<span class="gi">+              [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,</span>
<span class="gi">+               3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,</span>
<span class="gi">+               0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,</span>
<span class="gi">+               13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],</span>
<span class="gi">+</span>
<span class="gi">+              # S3</span>
<span class="gi">+              [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,</span>
<span class="gi">+               13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,</span>
<span class="gi">+               13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,</span>
<span class="gi">+               1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],</span>
<span class="gi">+</span>
<span class="gi">+              # S4</span>
<span class="gi">+              [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,</span>
<span class="gi">+               13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,</span>
<span class="gi">+               10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,</span>
<span class="gi">+               3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],</span>
<span class="gi">+</span>
<span class="gi">+              # S5</span>
<span class="gi">+              [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,</span>
<span class="gi">+               14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,</span>
<span class="gi">+               4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,</span>
<span class="gi">+               11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],</span>
<span class="gi">+</span>
<span class="gi">+              # S6</span>
<span class="gi">+              [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,</span>
<span class="gi">+               10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,</span>
<span class="gi">+               9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,</span>
<span class="gi">+               4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],</span>
<span class="gi">+</span>
<span class="gi">+              # S7</span>
<span class="gi">+              [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,</span>
<span class="gi">+               13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,</span>
<span class="gi">+               1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,</span>
<span class="gi">+               6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],</span>
<span class="gi">+</span>
<span class="gi">+              # S8</span>
<span class="gi">+              [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,</span>
<span class="gi">+               1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,</span>
<span class="gi">+               7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,</span>
<span class="gi">+               2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11], ]</span>
<span class="gi">+</span>
<span class="gi">+    # 32-bit permutation function P used on the output of the S-boxes</span>
<span class="gi">+    __p = [15, 6, 19, 20, 28, 11,</span>
<span class="gi">+           27, 16, 0, 14, 22, 25,</span>
<span class="gi">+           4, 17, 30, 9, 1, 7,</span>
<span class="gi">+           23, 13, 31, 26, 2, 8,</span>
<span class="gi">+           18, 12, 29, 5, 21, 10,</span>
<span class="gi">+           3, 24]</span>
<span class="gi">+</span>
<span class="gi">+    # Final permutation IP^-1</span>
<span class="gi">+    __fp = [39, 7, 47, 15, 55, 23, 63, 31,</span>
<span class="gi">+            38, 6, 46, 14, 54, 22, 62, 30,</span>
<span class="gi">+            37, 5, 45, 13, 53, 21, 61, 29,</span>
<span class="gi">+            36, 4, 44, 12, 52, 20, 60, 28,</span>
<span class="gi">+            35, 3, 43, 11, 51, 19, 59, 27,</span>
<span class="gi">+            34, 2, 42, 10, 50, 18, 58, 26,</span>
<span class="gi">+            33, 1, 41, 9, 49, 17, 57, 25,</span>
<span class="gi">+            32, 0, 40, 8, 48, 16, 56, 24]</span>
<span class="gi">+</span>
<span class="gi">+    # Type of crypting being done</span>
<span class="gi">+    ENCRYPT = 0x00</span>
<span class="gi">+    DECRYPT = 0x01</span>
<span class="gi">+</span>
<span class="gi">+    # Initialisation</span>
<span class="w"> </span>    def __init__(self, key, iv=None):
<span class="gi">+        # Sanity checking of arguments</span>
<span class="w"> </span>        if len(key) != 8:
<span class="gd">-            raise ValueError(</span>
<span class="gd">-                &#39;Invalid DES key size. Key must be exactly 8 bytes long&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Invalid DES key size. Key must be exactly &quot;</span>
<span class="gi">+                             &quot;8 bytes long&quot;)</span>
<span class="w"> </span>        super(Des, self).__init__(iv)
<span class="gi">+</span>
<span class="w"> </span>        self.key_size = 8
<span class="w"> </span>        self._l = []
<span class="w"> </span>        self._r = []
<span class="gd">-        self._kn = [[0] * 48] * 16</span>
<span class="gi">+        self._kn = [[0] * 48] * 16  # 16 48-bit keys (K1 - K16)</span>
<span class="w"> </span>        self._final = []
<span class="gi">+</span>
<span class="w"> </span>        self.set_key(key)

<span class="w"> </span>    def set_key(self, key):
<span class="w"> </span>        &quot;&quot;&quot;Set the crypting key for this object. Must be 8 bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.key = key</span>
<span class="gi">+        self.__create_sub_keys()</span>

<span class="w"> </span>    def __string_to_bitlist(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Turn the string data into a list of bits (1, 0)&#39;s.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if PY_VER &lt; (3, ):</span>
<span class="gi">+            # Turn the strings into integers. Python 3 uses a bytes</span>
<span class="gi">+            # class, which already has this behaviour</span>
<span class="gi">+            if not isinstance(data, bytearray):</span>
<span class="gi">+                data = [ord(c) for c in data]</span>
<span class="gi">+        len_data = len(data) * 8</span>
<span class="gi">+        result = [0] * len_data</span>
<span class="gi">+        pos = 0</span>
<span class="gi">+        for ch in data:</span>
<span class="gi">+            i = 7</span>
<span class="gi">+            while i &gt;= 0:</span>
<span class="gi">+                if ch &amp; (1 &lt;&lt; i) != 0:</span>
<span class="gi">+                    result[pos] = 1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result[pos] = 0</span>
<span class="gi">+                pos += 1</span>
<span class="gi">+                i -= 1</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def __bitlist_to_string(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Turn the data as list of bits into a string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        result = []</span>
<span class="gi">+        pos = 0</span>
<span class="gi">+        c = 0</span>
<span class="gi">+        while pos &lt; len(data):</span>
<span class="gi">+            c += data[pos] &lt;&lt; (7 - (pos % 8))</span>
<span class="gi">+            if (pos % 8) == 7:</span>
<span class="gi">+                result.append(c)</span>
<span class="gi">+                c = 0</span>
<span class="gi">+            pos += 1</span>
<span class="gi">+</span>
<span class="gi">+        if PY_VER &lt; (3, ):</span>
<span class="gi">+            return &#39;&#39;.join([chr(c) for c in result])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return bytes(result)</span>

<span class="w"> </span>    def __permutate(self, table, block):
<span class="w"> </span>        &quot;&quot;&quot;Permutate this block with the specified table.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [block[x] for x in table]</span>

<span class="w"> </span>    def __create_sub_keys(self):
<span class="w"> </span>        &quot;&quot;&quot;Transform the secret key for data processing.

<span class="w"> </span>        Create the 16 subkeys k[1] to k[16] from the given key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key = self.__permutate(Des.__pc1,</span>
<span class="gi">+                               self.__string_to_bitlist(self.key))</span>
<span class="gi">+        # Split into Left and Right sections</span>
<span class="gi">+        self._l = key[:28]</span>
<span class="gi">+        self._r = key[28:]</span>
<span class="gi">+        for i in range(16):</span>
<span class="gi">+            # Perform circular left shifts</span>
<span class="gi">+            for _ in range(Des.__left_rotations[i]):</span>
<span class="gi">+                self._l.append(self._l[0])</span>
<span class="gi">+                del self._l[0]</span>
<span class="gi">+                self._r.append(self._r[0])</span>
<span class="gi">+                del self._r[0]</span>
<span class="gi">+</span>
<span class="gi">+            # Create one of the 16 subkeys through pc2 permutation</span>
<span class="gi">+            self._kn[i] = self.__permutate(Des.__pc2, self._l + self._r)</span>

<span class="w"> </span>    def __des_crypt(self, block, crypt_type):
<span class="w"> </span>        &quot;&quot;&quot;Crypt the block of data through DES bit-manipulation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        block = self.__permutate(Des.__ip, block)</span>
<span class="gi">+        self._l = block[:32]</span>
<span class="gi">+        self._r = block[32:]</span>
<span class="gi">+</span>
<span class="gi">+        # Encryption starts from _kn[1] through to _kn[16]</span>
<span class="gi">+        if crypt_type == Des.ENCRYPT:</span>
<span class="gi">+            iteration = 0</span>
<span class="gi">+            iteration_adjustment = 1</span>
<span class="gi">+        # Decryption starts from _kn[16] down to _kn[1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            iteration = 15</span>
<span class="gi">+            iteration_adjustment = -1</span>
<span class="gi">+</span>
<span class="gi">+        for _ in range(16):</span>
<span class="gi">+            # Make a copy of _r[i-1], this will later become _l[i]</span>
<span class="gi">+            temp_r = self._r[:]</span>
<span class="gi">+</span>
<span class="gi">+            # Permutate _r[i - 1] to start creating _r[i]</span>
<span class="gi">+            self._r = self.__permutate(Des.__expansion_table, self._r)</span>
<span class="gi">+</span>
<span class="gi">+            # Exclusive or _r[i - 1] with k[i], create b[1] to b[8] whilst here</span>
<span class="gi">+            self._r = [x ^ y for x, y in zip(self._r, self._kn[iteration])]</span>
<span class="gi">+            b = [self._r[:6], self._r[6:12], self._r[12:18], self._r[18:24],</span>
<span class="gi">+                 self._r[24:30], self._r[30:36], self._r[36:42], self._r[42:]]</span>
<span class="gi">+</span>
<span class="gi">+            # Permutate b[1] to b[8] using the S-Boxes</span>
<span class="gi">+            bn = [0] * 32</span>
<span class="gi">+            pos = 0</span>
<span class="gi">+            for j in range(8):</span>
<span class="gi">+                # Work out the offsets</span>
<span class="gi">+                m = (b[j][0] &lt;&lt; 1) + b[j][5]</span>
<span class="gi">+                n = (b[j][1] &lt;&lt; 3) + (b[j][2] &lt;&lt; 2) + (b[j][3] &lt;&lt; 1) + b[j][4]</span>
<span class="gi">+</span>
<span class="gi">+                # Find the permutation value</span>
<span class="gi">+                v = Des.__sbox[j][(m &lt;&lt; 4) + n]</span>
<span class="gi">+</span>
<span class="gi">+                # Turn value into bits, add it to result: bn</span>
<span class="gi">+                bn[pos] = (v &amp; 8) &gt;&gt; 3</span>
<span class="gi">+                bn[pos + 1] = (v &amp; 4) &gt;&gt; 2</span>
<span class="gi">+                bn[pos + 2] = (v &amp; 2) &gt;&gt; 1</span>
<span class="gi">+                bn[pos + 3] = v &amp; 1</span>
<span class="gi">+</span>
<span class="gi">+                pos += 4</span>
<span class="gi">+</span>
<span class="gi">+            # Permutate the concatination of b[1] to b[8] (bn)</span>
<span class="gi">+            self._r = self.__permutate(Des.__p, bn)</span>
<span class="gi">+</span>
<span class="gi">+            # Xor with _l[i - 1]</span>
<span class="gi">+            self._r = [x ^ y for x, y in zip(self._r, self._l)]</span>
<span class="gi">+            self._l = temp_r</span>
<span class="gi">+</span>
<span class="gi">+            iteration += iteration_adjustment</span>
<span class="gi">+</span>
<span class="gi">+        # Final permutation of _r[16]_l[16]</span>
<span class="gi">+        self._final = self.__permutate(Des.__fp, self._r + self._l)</span>
<span class="gi">+        return self._final</span>

<span class="w"> </span>    def crypt(self, data, crypt_type):
<span class="w"> </span>        &quot;&quot;&quot;Crypt the data in blocks, running it through des_crypt().&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        iv = self.__string_to_bitlist(self.iv)</span>
<span class="gi">+</span>
<span class="gi">+        # Split the data into blocks, crypting each one seperately</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        result = []</span>
<span class="gi">+        while i &lt; len(data):</span>
<span class="gi">+            # Test code for caching encryption results</span>
<span class="gi">+            block = self.__string_to_bitlist(data[i:i+8])</span>
<span class="gi">+</span>
<span class="gi">+            # Xor with iv if using CBC mode</span>
<span class="gi">+            if crypt_type == Des.ENCRYPT:</span>
<span class="gi">+                block = [x ^ y for x, y in zip(block, iv)]</span>
<span class="gi">+</span>
<span class="gi">+            processed_block = self.__des_crypt(block, crypt_type)</span>
<span class="gi">+</span>
<span class="gi">+            if crypt_type == Des.DECRYPT:</span>
<span class="gi">+                processed_block = [x ^ y for x, y in zip(processed_block, iv)]</span>
<span class="gi">+                iv = block</span>
<span class="gi">+            else:</span>
<span class="gi">+                iv = processed_block</span>
<span class="gi">+</span>
<span class="gi">+            # Add the resulting crypted block to our list</span>
<span class="gi">+            result.append(self.__bitlist_to_string(processed_block))</span>
<span class="gi">+            i += 8</span>
<span class="gi">+</span>
<span class="gi">+        # Return the full crypted string</span>
<span class="gi">+        return b&#39;&#39;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+#############################################</span>
<span class="gi">+#               Triple DES                  #</span>
<span class="gi">+#############################################</span>


<span class="w"> </span>class Python_TripleDES(_baseDes):
<span class="gu">@@ -139,34 +386,37 @@ class Python_TripleDES(_baseDes):</span>
<span class="w"> </span>    the DES-EDE2 (when a 16 byte key is supplied) encryption methods.
<span class="w"> </span>    Supports CBC (Cypher Block Chaining) mode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, key, iv=None):
<span class="w"> </span>        self.block_size = 8
<span class="w"> </span>        if iv:
<span class="w"> </span>            if len(iv) != self.block_size:
<span class="gd">-                raise ValueError(</span>
<span class="gd">-                    &#39;Invalid Initialization Vector (iv) must be {0} bytes long&#39;</span>
<span class="gd">-                    .format(self.block_size))</span>
<span class="gi">+                raise ValueError(&quot;Invalid Initialization Vector (iv) must be&quot;</span>
<span class="gi">+                                 &quot; {0} bytes long&quot;.format(self.block_size))</span>
<span class="w"> </span>            iv = self._guard_against_unicode(iv)
<span class="w"> </span>        else:
<span class="gd">-            raise ValueError(&#39;Initialization Vector (iv) must be supplied&#39;)</span>
<span class="gi">+            raise ValueError(&quot;Initialization Vector (iv) must be supplied&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        super(Python_TripleDES, self).__init__(iv)
<span class="gi">+</span>
<span class="gi">+        # Will set crypting key for this object. Either 16/24 bytes long.</span>
<span class="w"> </span>        self.key_size = len(key)
<span class="w"> </span>        if self.key_size not in (16, 24):
<span class="gd">-            raise ValueError(</span>
<span class="gd">-                &#39;Invalid triple DES key size. Key must be either 16 or 24 bytes long&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            raise ValueError(&quot;Invalid triple DES key size. &quot;</span>
<span class="gi">+                             &quot;Key must be either 16 or 24 bytes long&quot;)</span>
<span class="w"> </span>        key = self._guard_against_unicode(key)
<span class="gi">+</span>
<span class="w"> </span>        self.__key1 = Des(key[:8], self.iv)
<span class="w"> </span>        self.__key2 = Des(key[8:16], self.iv)
<span class="w"> </span>        if self.key_size == 16:
<span class="w"> </span>            self.__key3 = Des(key[:8], self.iv)
<span class="w"> </span>        else:
<span class="w"> </span>            self.__key3 = Des(key[16:], self.iv)
<span class="gi">+</span>
<span class="w"> </span>        self.isAEAD = False
<span class="w"> </span>        self.isBlockCipher = True
<span class="gd">-        self.name = &#39;3des&#39;</span>
<span class="gd">-        self.implementation = &#39;python&#39;</span>
<span class="gi">+        self.name = &quot;3des&quot;</span>
<span class="gi">+        self.implementation = &quot;python&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        self.__key1.iv = self.iv
<span class="w"> </span>        self.__key2.iv = self.iv
<span class="w"> </span>        self.__key3.iv = self.iv
<span class="gu">@@ -179,7 +429,31 @@ class Python_TripleDES(_baseDes):</span>
<span class="w"> </span>        The data must be a multiple of 8 bytes and will be encrypted
<span class="w"> </span>        with the already specified key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        ENCRYPT = Des.ENCRYPT</span>
<span class="gi">+        DECRYPT = Des.DECRYPT</span>
<span class="gi">+</span>
<span class="gi">+        if not data:</span>
<span class="gi">+            return bytearray(b&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        data = self._guard_against_unicode(data)</span>
<span class="gi">+        if len(data) % self.block_size:</span>
<span class="gi">+            raise ValueError(&quot;Invalid data length, must be a multiple &quot;</span>
<span class="gi">+                             &quot;of {0} bytes&quot;.format(self.block_size))</span>
<span class="gi">+</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        result = []</span>
<span class="gi">+        while i &lt; len(data):</span>
<span class="gi">+            block = self.__key1.crypt(data[i:i+8], ENCRYPT)</span>
<span class="gi">+            block = self.__key2.crypt(block, DECRYPT)</span>
<span class="gi">+            block = self.__key3.crypt(block, ENCRYPT)</span>
<span class="gi">+            self.__key1.iv = block</span>
<span class="gi">+            self.__key2.iv = block</span>
<span class="gi">+            self.__key3.iv = block</span>
<span class="gi">+            result.append(block)</span>
<span class="gi">+            i += 8</span>
<span class="gi">+</span>
<span class="gi">+        return bytearray(b&#39;&#39;.join(result))</span>

<span class="w"> </span>    def decrypt(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Decrypt data and return bytes.
<span class="gu">@@ -189,4 +463,29 @@ class Python_TripleDES(_baseDes):</span>
<span class="w"> </span>        The data must be a multiple of 8 bytes and will be decrypted
<span class="w"> </span>        with the already specified key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ENCRYPT = Des.ENCRYPT</span>
<span class="gi">+        DECRYPT = Des.DECRYPT</span>
<span class="gi">+</span>
<span class="gi">+        if not data:</span>
<span class="gi">+            return bytearray(b&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        data = self._guard_against_unicode(data)</span>
<span class="gi">+        if len(data) % self.block_size:</span>
<span class="gi">+            raise ValueError(&quot;Invalid data length, must be a multiple &quot;</span>
<span class="gi">+                             &quot;of {0} bytes&quot;.format(self.block_size))</span>
<span class="gi">+</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        result = []</span>
<span class="gi">+        while i &lt; len(data):</span>
<span class="gi">+            iv = data[i:i+8]</span>
<span class="gi">+            block = self.__key3.crypt(iv, DECRYPT)</span>
<span class="gi">+            block = self.__key2.crypt(block, ENCRYPT)</span>
<span class="gi">+            block = self.__key1.crypt(block, DECRYPT)</span>
<span class="gi">+            self.__key1.iv = iv</span>
<span class="gi">+            self.__key2.iv = iv</span>
<span class="gi">+            self.__key3.iv = iv</span>
<span class="gi">+            result.append(block)</span>
<span class="gi">+            i += 8</span>
<span class="gi">+        data = b&#39;&#39;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+        return bytearray(data)</span>
<span class="gh">diff --git a/tlslite/utils/rc4.py b/tlslite/utils/rc4.py</span>
<span class="gh">index 2692715..3853f5b 100644</span>
<span class="gd">--- a/tlslite/utils/rc4.py</span>
<span class="gi">+++ b/tlslite/utils/rc4.py</span>
<span class="gu">@@ -1,12 +1,20 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Abstract class for RC4.&quot;&quot;&quot;


<span class="w"> </span>class RC4(object):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, keyBytes, implementation):
<span class="w"> </span>        if len(keyBytes) &lt; 16 or len(keyBytes) &gt; 256:
<span class="w"> </span>            raise ValueError()
<span class="w"> </span>        self.isBlockCipher = False
<span class="w"> </span>        self.isAEAD = False
<span class="gd">-        self.name = &#39;rc4&#39;</span>
<span class="gi">+        self.name = &quot;rc4&quot;</span>
<span class="w"> </span>        self.implementation = implementation
<span class="gi">+</span>
<span class="gi">+    def encrypt(self, plaintext):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def decrypt(self, ciphertext):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gh">diff --git a/tlslite/utils/rijndael.py b/tlslite/utils/rijndael.py</span>
<span class="gh">index 7a1e878..a1bf6a9 100644</span>
<span class="gd">--- a/tlslite/utils/rijndael.py</span>
<span class="gi">+++ b/tlslite/utils/rijndael.py</span>
<span class="gu">@@ -1,3 +1,10 @@</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Bram Cohen</span>
<span class="gi">+#   Trevor Perrin - various changes</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+# Also see Bram Cohen&#39;s statement below</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>A pure python (slow) implementation of rijndael with a decent interface

<span class="gu">@@ -19,564 +26,879 @@ plaintext = r.decrypt(ciphertext)</span>

<span class="w"> </span>If any strings are of the wrong length a ValueError is thrown
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .deprecations import deprecated_class_name
<span class="gd">-shifts = [[[0, 0], [1, 3], [2, 2], [3, 1]], [[0, 0], [1, 5], [2, 4], [3, 3]</span>
<span class="gd">-    ], [[0, 0], [1, 7], [3, 5], [4, 4]]]</span>
<span class="gd">-num_rounds = {(16): {(16): 10, (24): 12, (32): 14}, (24): {(16): 12, (24): </span>
<span class="gd">-    12, (32): 14}, (32): {(16): 14, (24): 14, (32): 14}}</span>
<span class="gd">-S = (99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, </span>
<span class="gd">-    118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164,</span>
<span class="gd">-    114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, </span>
<span class="gd">-    216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39,</span>
<span class="gd">-    178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, </span>
<span class="gd">-    47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, </span>
<span class="gd">-    88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, </span>
<span class="gd">-    159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, </span>
<span class="gd">-    255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, </span>
<span class="gd">-    100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20,</span>
<span class="gd">-    222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, </span>
<span class="gd">-    145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244,</span>
<span class="gd">-    234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, </span>
<span class="gd">-    116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, </span>
<span class="gd">-    87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155,</span>
<span class="gd">-    30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, </span>
<span class="gd">-    65, 153, 45, 15, 176, 84, 187, 22)</span>
<span class="gd">-Si = (82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, </span>
<span class="gd">-    251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, </span>
<span class="gd">-    233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250,</span>
<span class="gd">-    195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139,</span>
<span class="gd">-    209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, </span>
<span class="gd">-    101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, </span>
<span class="gd">-    167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, </span>
<span class="gd">-    5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3,</span>
<span class="gd">-    1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206,</span>
<span class="gd">-    240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55,</span>
<span class="gd">-    232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, </span>
<span class="gd">-    98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219,</span>
<span class="gd">-    192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18,</span>
<span class="gd">-    16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, </span>
<span class="gd">-    122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200,</span>
<span class="gd">-    235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225,</span>
<span class="gd">-    105, 20, 99, 85, 33, 12, 125)</span>
<span class="gd">-T1 = (3328402341, 4168907908, 4000806809, 4135287693, 4294111757, </span>
<span class="gd">-    3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, </span>
<span class="gd">-    1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941,</span>
<span class="gd">-    528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, </span>
<span class="gd">-    4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, </span>
<span class="gd">-    1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774,</span>
<span class="gd">-    1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740,</span>
<span class="gd">-    1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059,</span>
<span class="gd">-    706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, </span>
<span class="gd">-    932615841, 168101135, 798661301, 235341577, 605164086, 461406363, </span>
<span class="gd">-    3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, </span>
<span class="gd">-    495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, </span>
<span class="gd">-    1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307,</span>
<span class="gd">-    3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, </span>
<span class="gd">-    3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934,</span>
<span class="gd">-    2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944,</span>
<span class="gd">-    2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205,</span>
<span class="gd">-    2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, </span>
<span class="gd">-    4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, </span>
<span class="gd">-    1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, </span>
<span class="gd">-    4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, </span>
<span class="gd">-    3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, </span>
<span class="gd">-    3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, </span>
<span class="gd">-    1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, </span>
<span class="gd">-    3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, </span>
<span class="gd">-    1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, </span>
<span class="gd">-    672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, </span>
<span class="gd">-    1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, </span>
<span class="gd">-    3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, </span>
<span class="gd">-    831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, </span>
<span class="gd">-    3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, </span>
<span class="gd">-    2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377,</span>
<span class="gd">-    268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, </span>
<span class="gd">-    1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140,</span>
<span class="gd">-    1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, </span>
<span class="gd">-    2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, </span>
<span class="gd">-    470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, </span>
<span class="gd">-    2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, </span>
<span class="gd">-    571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, </span>
<span class="gd">-    1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, </span>
<span class="gd">-    2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, </span>
<span class="gd">-    3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, </span>
<span class="gd">-    504303377, 2075177163, 2824099068, 1841019862, 739644986)</span>
<span class="gd">-T2 = (2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027,</span>
<span class="gd">-    2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, </span>
<span class="gd">-    434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, </span>
<span class="gd">-    1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, </span>
<span class="gd">-    3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988,</span>
<span class="gd">-    2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, </span>
<span class="gd">-    1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, </span>
<span class="gd">-    886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, </span>
<span class="gd">-    201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, </span>
<span class="gd">-    252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, </span>
<span class="gd">-    651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, </span>
<span class="gd">-    1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, </span>
<span class="gd">-    4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187,</span>
<span class="gd">-    1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, </span>
<span class="gd">-    1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, </span>
<span class="gd">-    3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471,</span>
<span class="gd">-    1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, </span>
<span class="gd">-    1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, </span>
<span class="gd">-    4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603,</span>
<span class="gd">-    3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, </span>
<span class="gd">-    3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, </span>
<span class="gd">-    251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, </span>
<span class="gd">-    3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, </span>
<span class="gd">-    2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, </span>
<span class="gd">-    2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034,</span>
<span class="gd">-    2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, </span>
<span class="gd">-    2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, </span>
<span class="gd">-    1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, </span>
<span class="gd">-    1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981,</span>
<span class="gd">-    936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, </span>
<span class="gd">-    2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294,</span>
<span class="gd">-    133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, </span>
<span class="gd">-    3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, </span>
<span class="gd">-    3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, </span>
<span class="gd">-    3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654,</span>
<span class="gd">-    3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, </span>
<span class="gd">-    2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617,</span>
<span class="gd">-    658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, </span>
<span class="gd">-    3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, </span>
<span class="gd">-    2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, </span>
<span class="gd">-    2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, </span>
<span class="gd">-    3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, </span>
<span class="gd">-    3413881008, 4238890068, 3597515707, 975967766)</span>
<span class="gd">-T3 = (1671808611, 2089089148, 2006576759, 2072901243, 4061003762, </span>
<span class="gd">-    1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, </span>
<span class="gd">-    729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, </span>
<span class="gd">-    2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495,</span>
<span class="gd">-    4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188,</span>
<span class="gd">-    2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779,</span>
<span class="gd">-    644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, </span>
<span class="gd">-    2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, </span>
<span class="gd">-    356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, </span>
<span class="gd">-    2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, </span>
<span class="gd">-    3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, </span>
<span class="gd">-    2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, </span>
<span class="gd">-    2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, </span>
<span class="gd">-    3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, </span>
<span class="gd">-    3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, </span>
<span class="gd">-    3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, </span>
<span class="gd">-    3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435,</span>
<span class="gd">-    1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, </span>
<span class="gd">-    2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297,</span>
<span class="gd">-    2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, </span>
<span class="gd">-    4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, </span>
<span class="gd">-    4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, </span>
<span class="gd">-    3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, </span>
<span class="gd">-    2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, </span>
<span class="gd">-    1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, </span>
<span class="gd">-    712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, </span>
<span class="gd">-    339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, </span>
<span class="gd">-    844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, </span>
<span class="gd">-    1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105,</span>
<span class="gd">-    2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, </span>
<span class="gd">-    1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212,</span>
<span class="gd">-    1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822,</span>
<span class="gd">-    135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, </span>
<span class="gd">-    2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180,</span>
<span class="gd">-    522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, </span>
<span class="gd">-    1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, </span>
<span class="gd">-    236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, </span>
<span class="gd">-    3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, </span>
<span class="gd">-    288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, </span>
<span class="gd">-    505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, </span>
<span class="gd">-    3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, </span>
<span class="gd">-    3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, </span>
<span class="gd">-    252780047, 2966125488, 1425844308, 3151392187, 372911126)</span>
<span class="gd">-T4 = (1667474886, 2088535288, 2004326894, 2071694838, 4075949567, </span>
<span class="gd">-    1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, </span>
<span class="gd">-    724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, </span>
<span class="gd">-    2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990,</span>
<span class="gd">-    4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243,</span>
<span class="gd">-    2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149,</span>
<span class="gd">-    640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, </span>
<span class="gd">-    2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, </span>
<span class="gd">-    353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, </span>
<span class="gd">-    2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, </span>
<span class="gd">-    3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, </span>
<span class="gd">-    2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, </span>
<span class="gd">-    2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, </span>
<span class="gd">-    3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, </span>
<span class="gd">-    3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, </span>
<span class="gd">-    3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, </span>
<span class="gd">-    3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950,</span>
<span class="gd">-    1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, </span>
<span class="gd">-    2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282,</span>
<span class="gd">-    2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, </span>
<span class="gd">-    4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, </span>
<span class="gd">-    4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, </span>
<span class="gd">-    3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, </span>
<span class="gd">-    2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, </span>
<span class="gd">-    1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, </span>
<span class="gd">-    707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, </span>
<span class="gd">-    336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, </span>
<span class="gd">-    842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, </span>
<span class="gd">-    1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105,</span>
<span class="gd">-    2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, </span>
<span class="gd">-    1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512,</span>
<span class="gd">-    1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567,</span>
<span class="gd">-    134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, </span>
<span class="gd">-    2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400,</span>
<span class="gd">-    522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, </span>
<span class="gd">-    1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, </span>
<span class="gd">-    235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, </span>
<span class="gd">-    3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, </span>
<span class="gd">-    286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, </span>
<span class="gd">-    505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, </span>
<span class="gd">-    3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, </span>
<span class="gd">-    3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, </span>
<span class="gd">-    252645662, 2964376443, 1414855848, 3149649517, 370555436)</span>
<span class="gd">-T5 = (1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, </span>
<span class="gd">-    2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, </span>
<span class="gd">-    1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, </span>
<span class="gd">-    1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150,</span>
<span class="gd">-    59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, </span>
<span class="gd">-    1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, </span>
<span class="gd">-    3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074,</span>
<span class="gd">-    2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228,</span>
<span class="gd">-    1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562,</span>
<span class="gd">-    3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, </span>
<span class="gd">-    807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, </span>
<span class="gd">-    4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, </span>
<span class="gd">-    875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, </span>
<span class="gd">-    1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366,</span>
<span class="gd">-    2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, </span>
<span class="gd">-    2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, </span>
<span class="gd">-    2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436,</span>
<span class="gd">-    1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, </span>
<span class="gd">-    1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, </span>
<span class="gd">-    463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, </span>
<span class="gd">-    3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, </span>
<span class="gd">-    337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, </span>
<span class="gd">-    1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960,</span>
<span class="gd">-    3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, </span>
<span class="gd">-    3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, </span>
<span class="gd">-    2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, </span>
<span class="gd">-    2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, </span>
<span class="gd">-    2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, </span>
<span class="gd">-    1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, </span>
<span class="gd">-    2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619,</span>
<span class="gd">-    270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, </span>
<span class="gd">-    2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, </span>
<span class="gd">-    1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, </span>
<span class="gd">-    899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, </span>
<span class="gd">-    1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, </span>
<span class="gd">-    3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204,</span>
<span class="gd">-    25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, </span>
<span class="gd">-    1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, </span>
<span class="gd">-    3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, </span>
<span class="gd">-    1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769,</span>
<span class="gd">-    3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, </span>
<span class="gd">-    4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, </span>
<span class="gd">-    3576870512, 1215061108, 3501741890)</span>
<span class="gd">-T6 = (1347548327, 1400783205, 3273267108, 2520393566, 3409685355, </span>
<span class="gd">-    4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558,</span>
<span class="gd">-    636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, </span>
<span class="gd">-    1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, </span>
<span class="gd">-    3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, </span>
<span class="gd">-    3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, </span>
<span class="gd">-    3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, </span>
<span class="gd">-    2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, </span>
<span class="gd">-    2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, </span>
<span class="gd">-    3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, </span>
<span class="gd">-    2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, </span>
<span class="gd">-    2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, </span>
<span class="gd">-    2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, </span>
<span class="gd">-    2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, </span>
<span class="gd">-    1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, </span>
<span class="gd">-    2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, </span>
<span class="gd">-    3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, </span>
<span class="gd">-    1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, </span>
<span class="gd">-    657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, </span>
<span class="gd">-    261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, </span>
<span class="gd">-    370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, </span>
<span class="gd">-    2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349,</span>
<span class="gd">-    4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, </span>
<span class="gd">-    3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, </span>
<span class="gd">-    545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, </span>
<span class="gd">-    4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072,</span>
<span class="gd">-    575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, </span>
<span class="gd">-    3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, </span>
<span class="gd">-    2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, </span>
<span class="gd">-    3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573,</span>
<span class="gd">-    3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, </span>
<span class="gd">-    4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, </span>
<span class="gd">-    3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226,</span>
<span class="gd">-    824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, </span>
<span class="gd">-    355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, </span>
<span class="gd">-    1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, </span>
<span class="gd">-    2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, </span>
<span class="gd">-    1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, </span>
<span class="gd">-    2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, </span>
<span class="gd">-    1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, </span>
<span class="gd">-    2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, </span>
<span class="gd">-    213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, </span>
<span class="gd">-    2422494913, 1635502980, 1893020342, 1950903388, 1120974935)</span>
<span class="gd">-T7 = (2807058932, 1699970625, 2764249623, 1586903591, 1808481195, </span>
<span class="gd">-    1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, </span>
<span class="gd">-    1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577,</span>
<span class="gd">-    459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, </span>
<span class="gd">-    4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878,</span>
<span class="gd">-    567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239000, </span>
<span class="gd">-    1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, </span>
<span class="gd">-    830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, </span>
<span class="gd">-    731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, </span>
<span class="gd">-    48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, </span>
<span class="gd">-    145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, </span>
<span class="gd">-    3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340,</span>
<span class="gd">-    4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475,</span>
<span class="gd">-    4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, </span>
<span class="gd">-    3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, </span>
<span class="gd">-    3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833,</span>
<span class="gd">-    4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627,</span>
<span class="gd">-    1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, </span>
<span class="gd">-    3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, </span>
<span class="gd">-    2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, </span>
<span class="gd">-    3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, </span>
<span class="gd">-    2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, </span>
<span class="gd">-    648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, </span>
<span class="gd">-    4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, </span>
<span class="gd">-    612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, </span>
<span class="gd">-    1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, </span>
<span class="gd">-    2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, </span>
<span class="gd">-    2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, </span>
<span class="gd">-    2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, </span>
<span class="gd">-    4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, </span>
<span class="gd">-    2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, </span>
<span class="gd">-    3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597,</span>
<span class="gd">-    2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, </span>
<span class="gd">-    2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135,</span>
<span class="gd">-    2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679,</span>
<span class="gd">-    1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, </span>
<span class="gd">-    3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, </span>
<span class="gd">-    1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, </span>
<span class="gd">-    669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, </span>
<span class="gd">-    3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, </span>
<span class="gd">-    4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, </span>
<span class="gd">-    1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, </span>
<span class="gd">-    2220981195, 3060847922, 1551124588, 1463996600)</span>
<span class="gd">-T8 = (4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623,</span>
<span class="gd">-    4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, </span>
<span class="gd">-    3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, </span>
<span class="gd">-    3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, </span>
<span class="gd">-    2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848,</span>
<span class="gd">-    3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143,</span>
<span class="gd">-    3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, </span>
<span class="gd">-    1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, </span>
<span class="gd">-    1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242,</span>
<span class="gd">-    529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, </span>
<span class="gd">-    679998000, 3215307299, 57326082, 377642221, 3474729866, 2041877159, </span>
<span class="gd">-    133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, </span>
<span class="gd">-    777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, </span>
<span class="gd">-    1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, </span>
<span class="gd">-    1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, </span>
<span class="gd">-    1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, </span>
<span class="gd">-    2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766,</span>
<span class="gd">-    1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, </span>
<span class="gd">-    1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, </span>
<span class="gd">-    2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, </span>
<span class="gd">-    2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, </span>
<span class="gd">-    514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, </span>
<span class="gd">-    1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, </span>
<span class="gd">-    3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, </span>
<span class="gd">-    3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, </span>
<span class="gd">-    3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816,</span>
<span class="gd">-    4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, </span>
<span class="gd">-    3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, </span>
<span class="gd">-    2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, </span>
<span class="gd">-    3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, </span>
<span class="gd">-    410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, </span>
<span class="gd">-    1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, </span>
<span class="gd">-    1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454,</span>
<span class="gd">-    2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, </span>
<span class="gd">-    3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700,</span>
<span class="gd">-    2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, </span>
<span class="gd">-    2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, </span>
<span class="gd">-    3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, </span>
<span class="gd">-    1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, </span>
<span class="gd">-    3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274,</span>
<span class="gd">-    1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, </span>
<span class="gd">-    227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, </span>
<span class="gd">-    850817237, 1817998408, 3092726480)</span>
<span class="gd">-U1 = (0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, </span>
<span class="gd">-    708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, </span>
<span class="gd">-    1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990,</span>
<span class="gd">-    4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216,</span>
<span class="gd">-    2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058,</span>
<span class="gd">-    3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343,</span>
<span class="gd">-    3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029,</span>
<span class="gd">-    3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995,</span>
<span class="gd">-    899835584, 666464733, 699432150, 59727847, 226906860, 530400753, </span>
<span class="gd">-    294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, </span>
<span class="gd">-    2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520,</span>
<span class="gd">-    3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422,</span>
<span class="gd">-    3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228,</span>
<span class="gd">-    4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434,</span>
<span class="gd">-    2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, </span>
<span class="gd">-    800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, </span>
<span class="gd">-    2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311,</span>
<span class="gd">-    1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, </span>
<span class="gd">-    807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, </span>
<span class="gd">-    2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805,</span>
<span class="gd">-    3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751,</span>
<span class="gd">-    3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483,</span>
<span class="gd">-    2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, </span>
<span class="gd">-    599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, </span>
<span class="gd">-    2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733,</span>
<span class="gd">-    2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971,</span>
<span class="gd">-    3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178,</span>
<span class="gd">-    2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284,</span>
<span class="gd">-    3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302,</span>
<span class="gd">-    3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384,</span>
<span class="gd">-    1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, </span>
<span class="gd">-    404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, </span>
<span class="gd">-    3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619,</span>
<span class="gd">-    3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557,</span>
<span class="gd">-    2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, </span>
<span class="gd">-    504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, </span>
<span class="gd">-    1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843,</span>
<span class="gd">-    1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, </span>
<span class="gd">-    25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, </span>
<span class="gd">-    1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226,</span>
<span class="gd">-    3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432,</span>
<span class="gd">-    4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150,</span>
<span class="gd">-    2438237621, 2203032232, 2370213795)</span>
<span class="gd">-U2 = (0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, </span>
<span class="gd">-    824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, </span>
<span class="gd">-    2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410,</span>
<span class="gd">-    2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776,</span>
<span class="gd">-    3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918,</span>
<span class="gd">-    3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543,</span>
<span class="gd">-    1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, </span>
<span class="gd">-    1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, </span>
<span class="gd">-    3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933,</span>
<span class="gd">-    4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895,</span>
<span class="gd">-    3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975,</span>
<span class="gd">-    3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917,</span>
<span class="gd">-    2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523,</span>
<span class="gd">-    2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409,</span>
<span class="gd">-    1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, </span>
<span class="gd">-    53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, </span>
<span class="gd">-    2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216,</span>
<span class="gd">-    3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602,</span>
<span class="gd">-    4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, </span>
<span class="gd">-    545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, </span>
<span class="gd">-    1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296,</span>
<span class="gd">-    1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598,</span>
<span class="gd">-    3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840,</span>
<span class="gd">-    2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386,</span>
<span class="gd">-    1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268,</span>
<span class="gd">-    1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, </span>
<span class="gd">-    954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, </span>
<span class="gd">-    2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929,</span>
<span class="gd">-    3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127,</span>
<span class="gd">-    3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, </span>
<span class="gd">-    457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, </span>
<span class="gd">-    2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, </span>
<span class="gd">-    182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, </span>
<span class="gd">-    818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, </span>
<span class="gd">-    2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917,</span>
<span class="gd">-    2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703,</span>
<span class="gd">-    3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473,</span>
<span class="gd">-    3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720,</span>
<span class="gd">-    1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, </span>
<span class="gd">-    1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, </span>
<span class="gd">-    3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122,</span>
<span class="gd">-    4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200,</span>
<span class="gd">-    3046200461, 2827177882, 2743944855)</span>
<span class="gd">-U3 = (0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, </span>
<span class="gd">-    590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, </span>
<span class="gd">-    1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250,</span>
<span class="gd">-    3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176,</span>
<span class="gd">-    3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278,</span>
<span class="gd">-    2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663,</span>
<span class="gd">-    2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769,</span>
<span class="gd">-    3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195,</span>
<span class="gd">-    1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173,</span>
<span class="gd">-    1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, </span>
<span class="gd">-    984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, </span>
<span class="gd">-    2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, </span>
<span class="gd">-    145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, </span>
<span class="gd">-    648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, </span>
<span class="gd">-    2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636,</span>
<span class="gd">-    3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085,</span>
<span class="gd">-    3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771,</span>
<span class="gd">-    4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177,</span>
<span class="gd">-    2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, </span>
<span class="gd">-    287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, </span>
<span class="gd">-    1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571,</span>
<span class="gd">-    1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968,</span>
<span class="gd">-    3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150,</span>
<span class="gd">-    2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, </span>
<span class="gd">-    122466165, 273792366, 492483431, 1047239000, 861968209, 612205898, </span>
<span class="gd">-    695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, </span>
<span class="gd">-    1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613,</span>
<span class="gd">-    1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, </span>
<span class="gd">-    81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, </span>
<span class="gd">-    719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, </span>
<span class="gd">-    2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885,</span>
<span class="gd">-    3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634,</span>
<span class="gd">-    3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044,</span>
<span class="gd">-    2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702,</span>
<span class="gd">-    3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632,</span>
<span class="gd">-    1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, </span>
<span class="gd">-    48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, </span>
<span class="gd">-    752375421, 209336225, 24197544, 376187827, 459744698, 945164165, </span>
<span class="gd">-    895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, </span>
<span class="gd">-    1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881,</span>
<span class="gd">-    3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127,</span>
<span class="gd">-    4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285,</span>
<span class="gd">-    2377486676, 2594734927, 2544078150)</span>
<span class="gd">-U4 = (0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, </span>
<span class="gd">-    1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408,</span>
<span class="gd">-    1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100,</span>
<span class="gd">-    2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816,</span>
<span class="gd">-    3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748,</span>
<span class="gd">-    3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, </span>
<span class="gd">-    377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, </span>
<span class="gd">-    1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315,</span>
<span class="gd">-    2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623,</span>
<span class="gd">-    2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475,</span>
<span class="gd">-    3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905,</span>
<span class="gd">-    1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837,</span>
<span class="gd">-    923313619, 740276417, 621982671, 439452389, 322734571, 137073913, </span>
<span class="gd">-    19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, </span>
<span class="gd">-    3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641,</span>
<span class="gd">-    3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550,</span>
<span class="gd">-    1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426,</span>
<span class="gd">-    1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, </span>
<span class="gd">-    679998000, 865136418, 983426092, 3708173718, 3557504664, 3474729866, </span>
<span class="gd">-    3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230,</span>
<span class="gd">-    2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026,</span>
<span class="gd">-    2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953,</span>
<span class="gd">-    3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765,</span>
<span class="gd">-    3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481,</span>
<span class="gd">-    1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413,</span>
<span class="gd">-    1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, </span>
<span class="gd">-    425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, </span>
<span class="gd">-    3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674,</span>
<span class="gd">-    2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542,</span>
<span class="gd">-    2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834,</span>
<span class="gd">-    1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, </span>
<span class="gd">-    349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, </span>
<span class="gd">-    2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464,</span>
<span class="gd">-    2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212,</span>
<span class="gd">-    4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, </span>
<span class="gd">-    292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, </span>
<span class="gd">-    1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848,</span>
<span class="gd">-    2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775,</span>
<span class="gd">-    2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155,</span>
<span class="gd">-    4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, </span>
<span class="gd">-    953270745, 600235211, 718002117, 367585007, 484830689, 133361907, </span>
<span class="gd">-    251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, </span>
<span class="gd">-    1418573201, 1335535747, 1184342925)</span>
<span class="gd">-rcon = (1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94,</span>
<span class="gd">-    188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145)</span>

<span class="gi">+# ported from the Java reference code by Bram Cohen, bram@gawth.com, April 2001</span>
<span class="gi">+# this code is public domain, unless someone makes</span>
<span class="gi">+# an intellectual property claim against the reference</span>
<span class="gi">+# code, in which case it can be made public domain by</span>
<span class="gi">+# deleting all the comments and renaming all the variables</span>
<span class="gi">+</span>
<span class="gi">+shifts = [[[0, 0], [1, 3], [2, 2], [3, 1]],</span>
<span class="gi">+          [[0, 0], [1, 5], [2, 4], [3, 3]],</span>
<span class="gi">+          [[0, 0], [1, 7], [3, 5], [4, 4]]]</span>
<span class="gi">+</span>
<span class="gi">+# [keysize][block_size]</span>
<span class="gi">+num_rounds = {16: {16: 10, 24: 12, 32: 14},</span>
<span class="gi">+              24: {16: 12, 24: 12, 32: 14},</span>
<span class="gi">+              32: {16: 14, 24: 14, 32: 14}}</span>
<span class="gi">+</span>
<span class="gi">+# see unit_tests/test_tlslite_utils_rijndael.py for algorithm used to</span>
<span class="gi">+# calculate S, Si, T, U and rcon arrays</span>
<span class="gi">+</span>
<span class="gi">+# S box</span>
<span class="gi">+S = (99, 124, 119, 123, 242, 107, 111, 197,</span>
<span class="gi">+     48, 1, 103, 43, 254, 215, 171, 118,</span>
<span class="gi">+     202, 130, 201, 125, 250, 89, 71, 240,</span>
<span class="gi">+     173, 212, 162, 175, 156, 164, 114, 192,</span>
<span class="gi">+     183, 253, 147, 38, 54, 63, 247, 204,</span>
<span class="gi">+     52, 165, 229, 241, 113, 216, 49, 21,</span>
<span class="gi">+     4, 199, 35, 195, 24, 150, 5, 154,</span>
<span class="gi">+     7, 18, 128, 226, 235, 39, 178, 117,</span>
<span class="gi">+     9, 131, 44, 26, 27, 110, 90, 160,</span>
<span class="gi">+     82, 59, 214, 179, 41, 227, 47, 132,</span>
<span class="gi">+     83, 209, 0, 237, 32, 252, 177, 91,</span>
<span class="gi">+     106, 203, 190, 57, 74, 76, 88, 207,</span>
<span class="gi">+     208, 239, 170, 251, 67, 77, 51, 133,</span>
<span class="gi">+     69, 249, 2, 127, 80, 60, 159, 168,</span>
<span class="gi">+     81, 163, 64, 143, 146, 157, 56, 245,</span>
<span class="gi">+     188, 182, 218, 33, 16, 255, 243, 210,</span>
<span class="gi">+     205, 12, 19, 236, 95, 151, 68, 23,</span>
<span class="gi">+     196, 167, 126, 61, 100, 93, 25, 115,</span>
<span class="gi">+     96, 129, 79, 220, 34, 42, 144, 136,</span>
<span class="gi">+     70, 238, 184, 20, 222, 94, 11, 219,</span>
<span class="gi">+     224, 50, 58, 10, 73, 6, 36, 92,</span>
<span class="gi">+     194, 211, 172, 98, 145, 149, 228, 121,</span>
<span class="gi">+     231, 200, 55, 109, 141, 213, 78, 169,</span>
<span class="gi">+     108, 86, 244, 234, 101, 122, 174, 8,</span>
<span class="gi">+     186, 120, 37, 46, 28, 166, 180, 198,</span>
<span class="gi">+     232, 221, 116, 31, 75, 189, 139, 138,</span>
<span class="gi">+     112, 62, 181, 102, 72, 3, 246, 14,</span>
<span class="gi">+     97, 53, 87, 185, 134, 193, 29, 158,</span>
<span class="gi">+     225, 248, 152, 17, 105, 217, 142, 148,</span>
<span class="gi">+     155, 30, 135, 233, 206, 85, 40, 223,</span>
<span class="gi">+     140, 161, 137, 13, 191, 230, 66, 104,</span>
<span class="gi">+     65, 153, 45, 15, 176, 84, 187, 22)</span>
<span class="gi">+</span>
<span class="gi">+# inverse of S box</span>
<span class="gi">+Si = (82, 9, 106, 213, 48, 54, 165, 56,</span>
<span class="gi">+      191, 64, 163, 158, 129, 243, 215, 251,</span>
<span class="gi">+      124, 227, 57, 130, 155, 47, 255, 135,</span>
<span class="gi">+      52, 142, 67, 68, 196, 222, 233, 203,</span>
<span class="gi">+      84, 123, 148, 50, 166, 194, 35, 61,</span>
<span class="gi">+      238, 76, 149, 11, 66, 250, 195, 78,</span>
<span class="gi">+      8, 46, 161, 102, 40, 217, 36, 178,</span>
<span class="gi">+      118, 91, 162, 73, 109, 139, 209, 37,</span>
<span class="gi">+      114, 248, 246, 100, 134, 104, 152, 22,</span>
<span class="gi">+      212, 164, 92, 204, 93, 101, 182, 146,</span>
<span class="gi">+      108, 112, 72, 80, 253, 237, 185, 218,</span>
<span class="gi">+      94, 21, 70, 87, 167, 141, 157, 132,</span>
<span class="gi">+      144, 216, 171, 0, 140, 188, 211, 10,</span>
<span class="gi">+      247, 228, 88, 5, 184, 179, 69, 6,</span>
<span class="gi">+      208, 44, 30, 143, 202, 63, 15, 2,</span>
<span class="gi">+      193, 175, 189, 3, 1, 19, 138, 107,</span>
<span class="gi">+      58, 145, 17, 65, 79, 103, 220, 234,</span>
<span class="gi">+      151, 242, 207, 206, 240, 180, 230, 115,</span>
<span class="gi">+      150, 172, 116, 34, 231, 173, 53, 133,</span>
<span class="gi">+      226, 249, 55, 232, 28, 117, 223, 110,</span>
<span class="gi">+      71, 241, 26, 113, 29, 41, 197, 137,</span>
<span class="gi">+      111, 183, 98, 14, 170, 24, 190, 27,</span>
<span class="gi">+      252, 86, 62, 75, 198, 210, 121, 32,</span>
<span class="gi">+      154, 219, 192, 254, 120, 205, 90, 244,</span>
<span class="gi">+      31, 221, 168, 51, 136, 7, 199, 49,</span>
<span class="gi">+      177, 18, 16, 89, 39, 128, 236, 95,</span>
<span class="gi">+      96, 81, 127, 169, 25, 181, 74, 13,</span>
<span class="gi">+      45, 229, 122, 159, 147, 201, 156, 239,</span>
<span class="gi">+      160, 224, 59, 77, 174, 42, 245, 176,</span>
<span class="gi">+      200, 235, 187, 60, 131, 83, 153, 97,</span>
<span class="gi">+      23, 43, 4, 126, 186, 119, 214, 38,</span>
<span class="gi">+      225, 105, 20, 99, 85, 33, 12, 125)</span>
<span class="gi">+</span>
<span class="gi">+T1 = (0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d,</span>
<span class="gi">+      0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554,</span>
<span class="gi">+      0x60303050, 0x2010103, 0xce6767a9, 0x562b2b7d,</span>
<span class="gi">+      0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a,</span>
<span class="gi">+      0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87,</span>
<span class="gi">+      0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b,</span>
<span class="gi">+      0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea,</span>
<span class="gi">+      0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b,</span>
<span class="gi">+      0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a,</span>
<span class="gi">+      0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f,</span>
<span class="gi">+      0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108,</span>
<span class="gi">+      0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f,</span>
<span class="gi">+      0x804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e,</span>
<span class="gi">+      0x30181828, 0x379696a1, 0xa05050f, 0x2f9a9ab5,</span>
<span class="gi">+      0xe070709, 0x24121236, 0x1b80809b, 0xdfe2e23d,</span>
<span class="gi">+      0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f,</span>
<span class="gi">+      0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e,</span>
<span class="gi">+      0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb,</span>
<span class="gi">+      0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce,</span>
<span class="gi">+      0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497,</span>
<span class="gi">+      0xa65353f5, 0xb9d1d168, 0x0, 0xc1eded2c,</span>
<span class="gi">+      0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed,</span>
<span class="gi">+      0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b,</span>
<span class="gi">+      0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a,</span>
<span class="gi">+      0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16,</span>
<span class="gi">+      0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594,</span>
<span class="gi">+      0x8a4545cf, 0xe9f9f910, 0x4020206, 0xfe7f7f81,</span>
<span class="gi">+      0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3,</span>
<span class="gi">+      0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x58f8f8a,</span>
<span class="gi">+      0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504,</span>
<span class="gi">+      0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163,</span>
<span class="gi">+      0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d,</span>
<span class="gi">+      0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f,</span>
<span class="gi">+      0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739,</span>
<span class="gi">+      0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47,</span>
<span class="gi">+      0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395,</span>
<span class="gi">+      0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f,</span>
<span class="gi">+      0x44222266, 0x542a2a7e, 0x3b9090ab, 0xb888883,</span>
<span class="gi">+      0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c,</span>
<span class="gi">+      0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76,</span>
<span class="gi">+      0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e,</span>
<span class="gi">+      0x924949db, 0xc06060a, 0x4824246c, 0xb85c5ce4,</span>
<span class="gi">+      0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6,</span>
<span class="gi">+      0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b,</span>
<span class="gi">+      0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7,</span>
<span class="gi">+      0x18d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0,</span>
<span class="gi">+      0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25,</span>
<span class="gi">+      0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818,</span>
<span class="gi">+      0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72,</span>
<span class="gi">+      0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651,</span>
<span class="gi">+      0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21,</span>
<span class="gi">+      0x964b4bdd, 0x61bdbddc, 0xd8b8b86, 0xf8a8a85,</span>
<span class="gi">+      0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa,</span>
<span class="gi">+      0x904848d8, 0x6030305, 0xf7f6f601, 0x1c0e0e12,</span>
<span class="gi">+      0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0,</span>
<span class="gi">+      0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9,</span>
<span class="gi">+      0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133,</span>
<span class="gi">+      0xd26969bb, 0xa9d9d970, 0x78e8e89, 0x339494a7,</span>
<span class="gi">+      0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920,</span>
<span class="gi">+      0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a,</span>
<span class="gi">+      0x38c8c8f, 0x59a1a1f8, 0x9898980, 0x1a0d0d17,</span>
<span class="gi">+      0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8,</span>
<span class="gi">+      0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11,</span>
<span class="gi">+      0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a)</span>
<span class="gi">+</span>
<span class="gi">+T2 = (0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b,</span>
<span class="gi">+      0xdfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5,</span>
<span class="gi">+      0x50603030, 0x3020101, 0xa9ce6767, 0x7d562b2b,</span>
<span class="gi">+      0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676,</span>
<span class="gi">+      0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d,</span>
<span class="gi">+      0x15effafa, 0xebb25959, 0xc98e4747, 0xbfbf0f0,</span>
<span class="gi">+      0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf,</span>
<span class="gi">+      0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0,</span>
<span class="gi">+      0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626,</span>
<span class="gi">+      0x5a6c3636, 0x417e3f3f, 0x2f5f7f7, 0x4f83cccc,</span>
<span class="gi">+      0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x8f9f1f1,</span>
<span class="gi">+      0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515,</span>
<span class="gi">+      0xc080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3,</span>
<span class="gi">+      0x28301818, 0xa1379696, 0xf0a0505, 0xb52f9a9a,</span>
<span class="gi">+      0x90e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2,</span>
<span class="gi">+      0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575,</span>
<span class="gi">+      0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a,</span>
<span class="gi">+      0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0,</span>
<span class="gi">+      0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3,</span>
<span class="gi">+      0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484,</span>
<span class="gi">+      0xf5a65353, 0x68b9d1d1, 0x0, 0x2cc1eded,</span>
<span class="gi">+      0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b,</span>
<span class="gi">+      0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939,</span>
<span class="gi">+      0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf,</span>
<span class="gi">+      0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb,</span>
<span class="gi">+      0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585,</span>
<span class="gi">+      0xcf8a4545, 0x10e9f9f9, 0x6040202, 0x81fe7f7f,</span>
<span class="gi">+      0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8,</span>
<span class="gi">+      0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f,</span>
<span class="gi">+      0xad3f9292, 0xbc219d9d, 0x48703838, 0x4f1f5f5,</span>
<span class="gi">+      0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121,</span>
<span class="gi">+      0x30201010, 0x1ae5ffff, 0xefdf3f3, 0x6dbfd2d2,</span>
<span class="gi">+      0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec,</span>
<span class="gi">+      0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717,</span>
<span class="gi">+      0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d,</span>
<span class="gi">+      0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373,</span>
<span class="gi">+      0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc,</span>
<span class="gi">+      0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888,</span>
<span class="gi">+      0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414,</span>
<span class="gi">+      0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb,</span>
<span class="gi">+      0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a,</span>
<span class="gi">+      0xdb924949, 0xa0c0606, 0x6c482424, 0xe4b85c5c,</span>
<span class="gi">+      0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262,</span>
<span class="gi">+      0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979,</span>
<span class="gi">+      0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d,</span>
<span class="gi">+      0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9,</span>
<span class="gi">+      0xb4d86c6c, 0xfaac5656, 0x7f3f4f4, 0x25cfeaea,</span>
<span class="gi">+      0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808,</span>
<span class="gi">+      0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e,</span>
<span class="gi">+      0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6,</span>
<span class="gi">+      0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f,</span>
<span class="gi">+      0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a,</span>
<span class="gi">+      0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666,</span>
<span class="gi">+      0xd8904848, 0x5060303, 0x1f7f6f6, 0x121c0e0e,</span>
<span class="gi">+      0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9,</span>
<span class="gi">+      0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e,</span>
<span class="gi">+      0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111,</span>
<span class="gi">+      0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494,</span>
<span class="gi">+      0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9,</span>
<span class="gi">+      0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf,</span>
<span class="gi">+      0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d,</span>
<span class="gi">+      0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868,</span>
<span class="gi">+      0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f,</span>
<span class="gi">+      0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616)</span>
<span class="gi">+</span>
<span class="gi">+T3 = (0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b,</span>
<span class="gi">+      0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5,</span>
<span class="gi">+      0x30506030, 0x1030201, 0x67a9ce67, 0x2b7d562b,</span>
<span class="gi">+      0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76,</span>
<span class="gi">+      0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d,</span>
<span class="gi">+      0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0,</span>
<span class="gi">+      0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af,</span>
<span class="gi">+      0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0,</span>
<span class="gi">+      0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26,</span>
<span class="gi">+      0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc,</span>
<span class="gi">+      0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1,</span>
<span class="gi">+      0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15,</span>
<span class="gi">+      0x40c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3,</span>
<span class="gi">+      0x18283018, 0x96a13796, 0x50f0a05, 0x9ab52f9a,</span>
<span class="gi">+      0x7090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2,</span>
<span class="gi">+      0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75,</span>
<span class="gi">+      0x91b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a,</span>
<span class="gi">+      0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0,</span>
<span class="gi">+      0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3,</span>
<span class="gi">+      0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384,</span>
<span class="gi">+      0x53f5a653, 0xd168b9d1, 0x0, 0xed2cc1ed,</span>
<span class="gi">+      0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b,</span>
<span class="gi">+      0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239,</span>
<span class="gi">+      0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf,</span>
<span class="gi">+      0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb,</span>
<span class="gi">+      0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185,</span>
<span class="gi">+      0x45cf8a45, 0xf910e9f9, 0x2060402, 0x7f81fe7f,</span>
<span class="gi">+      0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8,</span>
<span class="gi">+      0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f,</span>
<span class="gi">+      0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5,</span>
<span class="gi">+      0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221,</span>
<span class="gi">+      0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2,</span>
<span class="gi">+      0xcd4c81cd, 0xc14180c, 0x13352613, 0xec2fc3ec,</span>
<span class="gi">+      0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17,</span>
<span class="gi">+      0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d,</span>
<span class="gi">+      0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673,</span>
<span class="gi">+      0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc,</span>
<span class="gi">+      0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88,</span>
<span class="gi">+      0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814,</span>
<span class="gi">+      0xde79a7de, 0x5ee2bc5e, 0xb1d160b, 0xdb76addb,</span>
<span class="gi">+      0xe03bdbe0, 0x32566432, 0x3a4e743a, 0xa1e140a,</span>
<span class="gi">+      0x49db9249, 0x60a0c06, 0x246c4824, 0x5ce4b85c,</span>
<span class="gi">+      0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462,</span>
<span class="gi">+      0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279,</span>
<span class="gi">+      0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d,</span>
<span class="gi">+      0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9,</span>
<span class="gi">+      0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea,</span>
<span class="gi">+      0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x8181008,</span>
<span class="gi">+      0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e,</span>
<span class="gi">+      0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6,</span>
<span class="gi">+      0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f,</span>
<span class="gi">+      0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a,</span>
<span class="gi">+      0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66,</span>
<span class="gi">+      0x48d89048, 0x3050603, 0xf601f7f6, 0xe121c0e,</span>
<span class="gi">+      0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9,</span>
<span class="gi">+      0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e,</span>
<span class="gi">+      0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211,</span>
<span class="gi">+      0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394,</span>
<span class="gi">+      0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9,</span>
<span class="gi">+      0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df,</span>
<span class="gi">+      0x8c8f038c, 0xa1f859a1, 0x89800989, 0xd171a0d,</span>
<span class="gi">+      0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068,</span>
<span class="gi">+      0x41c38241, 0x99b02999, 0x2d775a2d, 0xf111e0f,</span>
<span class="gi">+      0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16)</span>
<span class="gi">+</span>
<span class="gi">+T4 = (0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6,</span>
<span class="gi">+      0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491,</span>
<span class="gi">+      0x30305060, 0x1010302, 0x6767a9ce, 0x2b2b7d56,</span>
<span class="gi">+      0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec,</span>
<span class="gi">+      0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa,</span>
<span class="gi">+      0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb,</span>
<span class="gi">+      0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45,</span>
<span class="gi">+      0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b,</span>
<span class="gi">+      0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c,</span>
<span class="gi">+      0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83,</span>
<span class="gi">+      0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9,</span>
<span class="gi">+      0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a,</span>
<span class="gi">+      0x4040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d,</span>
<span class="gi">+      0x18182830, 0x9696a137, 0x5050f0a, 0x9a9ab52f,</span>
<span class="gi">+      0x707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf,</span>
<span class="gi">+      0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea,</span>
<span class="gi">+      0x9091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34,</span>
<span class="gi">+      0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b,</span>
<span class="gi">+      0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d,</span>
<span class="gi">+      0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713,</span>
<span class="gi">+      0x5353f5a6, 0xd1d168b9, 0x0, 0xeded2cc1,</span>
<span class="gi">+      0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6,</span>
<span class="gi">+      0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72,</span>
<span class="gi">+      0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85,</span>
<span class="gi">+      0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed,</span>
<span class="gi">+      0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411,</span>
<span class="gi">+      0x4545cf8a, 0xf9f910e9, 0x2020604, 0x7f7f81fe,</span>
<span class="gi">+      0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b,</span>
<span class="gi">+      0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05,</span>
<span class="gi">+      0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1,</span>
<span class="gi">+      0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342,</span>
<span class="gi">+      0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf,</span>
<span class="gi">+      0xcdcd4c81, 0xc0c1418, 0x13133526, 0xecec2fc3,</span>
<span class="gi">+      0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e,</span>
<span class="gi">+      0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a,</span>
<span class="gi">+      0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6,</span>
<span class="gi">+      0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3,</span>
<span class="gi">+      0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b,</span>
<span class="gi">+      0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28,</span>
<span class="gi">+      0xdede79a7, 0x5e5ee2bc, 0xb0b1d16, 0xdbdb76ad,</span>
<span class="gi">+      0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0xa0a1e14,</span>
<span class="gi">+      0x4949db92, 0x6060a0c, 0x24246c48, 0x5c5ce4b8,</span>
<span class="gi">+      0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4,</span>
<span class="gi">+      0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2,</span>
<span class="gi">+      0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da,</span>
<span class="gi">+      0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049,</span>
<span class="gi">+      0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf,</span>
<span class="gi">+      0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x8081810,</span>
<span class="gi">+      0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c,</span>
<span class="gi">+      0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197,</span>
<span class="gi">+      0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e,</span>
<span class="gi">+      0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f,</span>
<span class="gi">+      0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc,</span>
<span class="gi">+      0x4848d890, 0x3030506, 0xf6f601f7, 0xe0e121c,</span>
<span class="gi">+      0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069,</span>
<span class="gi">+      0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927,</span>
<span class="gi">+      0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322,</span>
<span class="gi">+      0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733,</span>
<span class="gi">+      0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9,</span>
<span class="gi">+      0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5,</span>
<span class="gi">+      0x8c8c8f03, 0xa1a1f859, 0x89898009, 0xd0d171a,</span>
<span class="gi">+      0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0,</span>
<span class="gi">+      0x4141c382, 0x9999b029, 0x2d2d775a, 0xf0f111e,</span>
<span class="gi">+      0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c)</span>
<span class="gi">+</span>
<span class="gi">+T5 = (0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96,</span>
<span class="gi">+      0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393,</span>
<span class="gi">+      0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25,</span>
<span class="gi">+      0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f,</span>
<span class="gi">+      0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1,</span>
<span class="gi">+      0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6,</span>
<span class="gi">+      0x38f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da,</span>
<span class="gi">+      0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844,</span>
<span class="gi">+      0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd,</span>
<span class="gi">+      0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4,</span>
<span class="gi">+      0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45,</span>
<span class="gi">+      0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94,</span>
<span class="gi">+      0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7,</span>
<span class="gi">+      0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a,</span>
<span class="gi">+      0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5,</span>
<span class="gi">+      0x302887f2, 0x23bfa5b2, 0x2036aba, 0xed16825c,</span>
<span class="gi">+      0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1,</span>
<span class="gi">+      0x65daf4cd, 0x605bed5, 0xd134621f, 0xc4a6fe8a,</span>
<span class="gi">+      0x342e539d, 0xa2f355a0, 0x58ae132, 0xa4f6eb75,</span>
<span class="gi">+      0xb83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051,</span>
<span class="gi">+      0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46,</span>
<span class="gi">+      0x91548db5, 0x71c45d05, 0x406d46f, 0x605015ff,</span>
<span class="gi">+      0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77,</span>
<span class="gi">+      0xb0e842bd, 0x7898b88, 0xe7195b38, 0x79c8eedb,</span>
<span class="gi">+      0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x0,</span>
<span class="gi">+      0x9808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e,</span>
<span class="gi">+      0xfd0efffb, 0xf853856, 0x3daed51e, 0x362d3927,</span>
<span class="gi">+      0xa0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a,</span>
<span class="gi">+      0xc0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e,</span>
<span class="gi">+      0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16,</span>
<span class="gi">+      0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d,</span>
<span class="gi">+      0xe090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8,</span>
<span class="gi">+      0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd,</span>
<span class="gi">+      0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34,</span>
<span class="gi">+      0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163,</span>
<span class="gi">+      0xd731dcca, 0x42638510, 0x13972240, 0x84c61120,</span>
<span class="gi">+      0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d,</span>
<span class="gi">+      0x1d9e2f4b, 0xdcb230f3, 0xd8652ec, 0x77c1e3d0,</span>
<span class="gi">+      0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422,</span>
<span class="gi">+      0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef,</span>
<span class="gi">+      0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36,</span>
<span class="gi">+      0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4,</span>
<span class="gi">+      0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662,</span>
<span class="gi">+      0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5,</span>
<span class="gi">+      0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3,</span>
<span class="gi">+      0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b,</span>
<span class="gi">+      0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8,</span>
<span class="gi">+      0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6,</span>
<span class="gi">+      0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6,</span>
<span class="gi">+      0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0,</span>
<span class="gi">+      0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815,</span>
<span class="gi">+      0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f,</span>
<span class="gi">+      0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df,</span>
<span class="gi">+      0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f,</span>
<span class="gi">+      0x9d5eea04, 0x18c355d, 0xfa877473, 0xfb0b412e,</span>
<span class="gi">+      0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713,</span>
<span class="gi">+      0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89,</span>
<span class="gi">+      0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c,</span>
<span class="gi">+      0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf,</span>
<span class="gi">+      0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86,</span>
<span class="gi">+      0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f,</span>
<span class="gi">+      0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541,</span>
<span class="gi">+      0x39a80171, 0x80cb3de, 0xd8b4e49c, 0x6456c190,</span>
<span class="gi">+      0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742)</span>
<span class="gi">+</span>
<span class="gi">+T6 = (0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e,</span>
<span class="gi">+      0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303,</span>
<span class="gi">+      0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c,</span>
<span class="gi">+      0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3,</span>
<span class="gi">+      0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0,</span>
<span class="gi">+      0x2c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9,</span>
<span class="gi">+      0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259,</span>
<span class="gi">+      0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8,</span>
<span class="gi">+      0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971,</span>
<span class="gi">+      0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a,</span>
<span class="gi">+      0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f,</span>
<span class="gi">+      0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b,</span>
<span class="gi">+      0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8,</span>
<span class="gi">+      0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab,</span>
<span class="gi">+      0x7b2eb28, 0x32fb5c2, 0x9a86c57b, 0xa5d33708,</span>
<span class="gi">+      0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682,</span>
<span class="gi">+      0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2,</span>
<span class="gi">+      0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe,</span>
<span class="gi">+      0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb,</span>
<span class="gi">+      0x390b83ec, 0xaa4060ef, 0x65e719f, 0x51bd6e10,</span>
<span class="gi">+      0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd,</span>
<span class="gi">+      0xb591548d, 0x571c45d, 0x6f0406d4, 0xff605015,</span>
<span class="gi">+      0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e,</span>
<span class="gi">+      0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee,</span>
<span class="gi">+      0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x0,</span>
<span class="gi">+      0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72,</span>
<span class="gi">+      0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39,</span>
<span class="gi">+      0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e,</span>
<span class="gi">+      0xb10c0a67, 0xf9357e7, 0xd2b4ee96, 0x9e1b9b91,</span>
<span class="gi">+      0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a,</span>
<span class="gi">+      0xae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17,</span>
<span class="gi">+      0xb0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9,</span>
<span class="gi">+      0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60,</span>
<span class="gi">+      0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e,</span>
<span class="gi">+      0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1,</span>
<span class="gi">+      0xcad731dc, 0x10426385, 0x40139722, 0x2084c611,</span>
<span class="gi">+      0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1,</span>
<span class="gi">+      0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3,</span>
<span class="gi">+      0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964,</span>
<span class="gi">+      0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390,</span>
<span class="gi">+      0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b,</span>
<span class="gi">+      0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf,</span>
<span class="gi">+      0xe42c3a9d, 0xd507892, 0x9b6a5fcc, 0x62547e46,</span>
<span class="gi">+      0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af,</span>
<span class="gi">+      0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512,</span>
<span class="gi">+      0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb,</span>
<span class="gi">+      0x9cd2678, 0xf46e5918, 0x1ec9ab7, 0xa8834f9a,</span>
<span class="gi">+      0x65e6956e, 0x7eaaffe6, 0x821bccf, 0xe6ef15e8,</span>
<span class="gi">+      0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c,</span>
<span class="gi">+      0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266,</span>
<span class="gi">+      0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8,</span>
<span class="gi">+      0x4af10498, 0xf741ecda, 0xe7fcd50, 0x2f1791f6,</span>
<span class="gi">+      0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604,</span>
<span class="gi">+      0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551,</span>
<span class="gi">+      0x49d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41,</span>
<span class="gi">+      0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647,</span>
<span class="gi">+      0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c,</span>
<span class="gi">+      0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1,</span>
<span class="gi">+      0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737,</span>
<span class="gi">+      0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db,</span>
<span class="gi">+      0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340,</span>
<span class="gi">+      0x72161dc3, 0xcbce225, 0x8b283c49, 0x41ff0d95,</span>
<span class="gi">+      0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1,</span>
<span class="gi">+      0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857)</span>
<span class="gi">+</span>
<span class="gi">+T7 = (0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27,</span>
<span class="gi">+      0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x3934be3,</span>
<span class="gi">+      0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502,</span>
<span class="gi">+      0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562,</span>
<span class="gi">+      0x5a49deb1, 0x1b6725ba, 0xe9845ea, 0xc0e15dfe,</span>
<span class="gi">+      0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3,</span>
<span class="gi">+      0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552,</span>
<span class="gi">+      0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9,</span>
<span class="gi">+      0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9,</span>
<span class="gi">+      0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce,</span>
<span class="gi">+      0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253,</span>
<span class="gi">+      0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908,</span>
<span class="gi">+      0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b,</span>
<span class="gi">+      0xd323ab73, 0x2e2724b, 0x8f57e31f, 0xab2a6655,</span>
<span class="gi">+      0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x8a5d337,</span>
<span class="gi">+      0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16,</span>
<span class="gi">+      0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69,</span>
<span class="gi">+      0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6,</span>
<span class="gi">+      0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6,</span>
<span class="gi">+      0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e,</span>
<span class="gi">+      0x8af93e21, 0x63d96dd, 0x5aedd3e, 0xbd464de6,</span>
<span class="gi">+      0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050,</span>
<span class="gi">+      0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9,</span>
<span class="gi">+      0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8,</span>
<span class="gi">+      0xa47a17c, 0xfe97c42, 0x1ec9f884, 0x0,</span>
<span class="gi">+      0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a,</span>
<span class="gi">+      0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d,</span>
<span class="gi">+      0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436,</span>
<span class="gi">+      0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b,</span>
<span class="gi">+      0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12,</span>
<span class="gi">+      0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b,</span>
<span class="gi">+      0xd0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e,</span>
<span class="gi">+      0x198557f1, 0x74caf75, 0xddbbee99, 0x60fda37f,</span>
<span class="gi">+      0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb,</span>
<span class="gi">+      0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4,</span>
<span class="gi">+      0xdccad731, 0x85104263, 0x22401397, 0x112084c6,</span>
<span class="gi">+      0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729,</span>
<span class="gi">+      0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1,</span>
<span class="gi">+      0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9,</span>
<span class="gi">+      0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233,</span>
<span class="gi">+      0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0xb3698d4,</span>
<span class="gi">+      0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad,</span>
<span class="gi">+      0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e,</span>
<span class="gi">+      0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3,</span>
<span class="gi">+      0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25,</span>
<span class="gi">+      0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b,</span>
<span class="gi">+      0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f,</span>
<span class="gi">+      0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15,</span>
<span class="gi">+      0x9bd9bae7, 0x36ce4a6f, 0x9d4ea9f, 0x7cd629b0,</span>
<span class="gi">+      0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2,</span>
<span class="gi">+      0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7,</span>
<span class="gi">+      0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791,</span>
<span class="gi">+      0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x4dfe496,</span>
<span class="gi">+      0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665,</span>
<span class="gi">+      0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b,</span>
<span class="gi">+      0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6,</span>
<span class="gi">+      0x618c9ad7, 0xc7a37a1, 0x148e59f8, 0x3c89eb13,</span>
<span class="gi">+      0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47,</span>
<span class="gi">+      0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7,</span>
<span class="gi">+      0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844,</span>
<span class="gi">+      0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3,</span>
<span class="gi">+      0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d,</span>
<span class="gi">+      0x17139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456,</span>
<span class="gi">+      0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8)</span>
<span class="gi">+</span>
<span class="gi">+T8 = (0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a,</span>
<span class="gi">+      0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b,</span>
<span class="gi">+      0x30fa5520, 0x766df6ad, 0xcc769188, 0x24c25f5,</span>
<span class="gi">+      0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5,</span>
<span class="gi">+      0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d,</span>
<span class="gi">+      0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b,</span>
<span class="gi">+      0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95,</span>
<span class="gi">+      0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e,</span>
<span class="gi">+      0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27,</span>
<span class="gi">+      0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d,</span>
<span class="gi">+      0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562,</span>
<span class="gi">+      0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x82b94f9,</span>
<span class="gi">+      0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752,</span>
<span class="gi">+      0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66,</span>
<span class="gi">+      0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3,</span>
<span class="gi">+      0x2887f230, 0xbfa5b223, 0x36aba02, 0x16825ced,</span>
<span class="gi">+      0xcf1c2b8a, 0x79b492a7, 0x7f2f0f3, 0x69e2a14e,</span>
<span class="gi">+      0xdaf4cd65, 0x5bed506, 0x34621fd1, 0xa6fe8ac4,</span>
<span class="gi">+      0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4,</span>
<span class="gi">+      0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd,</span>
<span class="gi">+      0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d,</span>
<span class="gi">+      0x548db591, 0xc45d0571, 0x6d46f04, 0x5015ff60,</span>
<span class="gi">+      0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767,</span>
<span class="gi">+      0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79,</span>
<span class="gi">+      0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x0,</span>
<span class="gi">+      0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c,</span>
<span class="gi">+      0xefffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736,</span>
<span class="gi">+      0xfd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24,</span>
<span class="gi">+      0xa67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b,</span>
<span class="gi">+      0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c,</span>
<span class="gi">+      0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12,</span>
<span class="gi">+      0x90d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814,</span>
<span class="gi">+      0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3,</span>
<span class="gi">+      0x1269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b,</span>
<span class="gi">+      0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8,</span>
<span class="gi">+      0x31dccad7, 0x63851042, 0x97224013, 0xc6112084,</span>
<span class="gi">+      0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7,</span>
<span class="gi">+      0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077,</span>
<span class="gi">+      0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247,</span>
<span class="gi">+      0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22,</span>
<span class="gi">+      0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698,</span>
<span class="gi">+      0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f,</span>
<span class="gi">+      0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254,</span>
<span class="gi">+      0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582,</span>
<span class="gi">+      0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf,</span>
<span class="gi">+      0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb,</span>
<span class="gi">+      0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883,</span>
<span class="gi">+      0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef,</span>
<span class="gi">+      0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629,</span>
<span class="gi">+      0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035,</span>
<span class="gi">+      0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533,</span>
<span class="gi">+      0x4984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17,</span>
<span class="gi">+      0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4,</span>
<span class="gi">+      0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46,</span>
<span class="gi">+      0x5eea049d, 0x8c355d01, 0x877473fa, 0xb412efb,</span>
<span class="gi">+      0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d,</span>
<span class="gi">+      0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb,</span>
<span class="gi">+      0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a,</span>
<span class="gi">+      0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73,</span>
<span class="gi">+      0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678,</span>
<span class="gi">+      0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2,</span>
<span class="gi">+      0x1dc37216, 0xe2250cbc, 0x3c498b28, 0xd9541ff,</span>
<span class="gi">+      0xa8017139, 0xcb3de08, 0xb4e49cd8, 0x56c19064,</span>
<span class="gi">+      0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0)</span>
<span class="gi">+</span>
<span class="gi">+U1 = (0x0, 0xe090d0b, 0x1c121a16, 0x121b171d,</span>
<span class="gi">+      0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331,</span>
<span class="gi">+      0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45,</span>
<span class="gi">+      0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69,</span>
<span class="gi">+      0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad,</span>
<span class="gi">+      0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381,</span>
<span class="gi">+      0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5,</span>
<span class="gi">+      0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9,</span>
<span class="gi">+      0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66,</span>
<span class="gi">+      0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a,</span>
<span class="gi">+      0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e,</span>
<span class="gi">+      0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012,</span>
<span class="gi">+      0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6,</span>
<span class="gi">+      0x38f5fe7, 0xd8652ec, 0x1f9d45f1, 0x119448fa,</span>
<span class="gi">+      0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e,</span>
<span class="gi">+      0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2,</span>
<span class="gi">+      0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb,</span>
<span class="gi">+      0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7,</span>
<span class="gi">+      0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3,</span>
<span class="gi">+      0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f,</span>
<span class="gi">+      0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b,</span>
<span class="gi">+      0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77,</span>
<span class="gi">+      0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203,</span>
<span class="gi">+      0x58ae132, 0xb83ec39, 0x1998fb24, 0x1791f62f,</span>
<span class="gi">+      0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190,</span>
<span class="gi">+      0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc,</span>
<span class="gi">+      0x605bed5, 0x80cb3de, 0x1a17a4c3, 0x141ea9c8,</span>
<span class="gi">+      0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4,</span>
<span class="gi">+      0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120,</span>
<span class="gi">+      0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c,</span>
<span class="gi">+      0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978,</span>
<span class="gi">+      0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54,</span>
<span class="gi">+      0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea,</span>
<span class="gi">+      0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6,</span>
<span class="gi">+      0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2,</span>
<span class="gi">+      0x9808683, 0x7898b88, 0x15929c95, 0x1b9b919e,</span>
<span class="gi">+      0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a,</span>
<span class="gi">+      0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976,</span>
<span class="gi">+      0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502,</span>
<span class="gi">+      0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e,</span>
<span class="gi">+      0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691,</span>
<span class="gi">+      0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd,</span>
<span class="gi">+      0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9,</span>
<span class="gi">+      0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5,</span>
<span class="gi">+      0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621,</span>
<span class="gi">+      0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d,</span>
<span class="gi">+      0xa0fd964, 0x406d46f, 0x161dc372, 0x1814ce79,</span>
<span class="gi">+      0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55,</span>
<span class="gi">+      0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c,</span>
<span class="gi">+      0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430,</span>
<span class="gi">+      0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844,</span>
<span class="gi">+      0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68,</span>
<span class="gi">+      0xc0a67b1, 0x2036aba, 0x10187da7, 0x1e1170ac,</span>
<span class="gi">+      0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480,</span>
<span class="gi">+      0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4,</span>
<span class="gi">+      0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8,</span>
<span class="gi">+      0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67,</span>
<span class="gi">+      0xf853856, 0x18c355d, 0x13972240, 0x1d9e2f4b,</span>
<span class="gi">+      0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f,</span>
<span class="gi">+      0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713,</span>
<span class="gi">+      0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7,</span>
<span class="gi">+      0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb,</span>
<span class="gi">+      0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f,</span>
<span class="gi">+      0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3)</span>
<span class="gi">+</span>
<span class="gi">+U2 = (0x0, 0xb0e090d, 0x161c121a, 0x1d121b17,</span>
<span class="gi">+      0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23,</span>
<span class="gi">+      0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f,</span>
<span class="gi">+      0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b,</span>
<span class="gi">+      0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7,</span>
<span class="gi">+      0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3,</span>
<span class="gi">+      0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af,</span>
<span class="gi">+      0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b,</span>
<span class="gi">+      0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac,</span>
<span class="gi">+      0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498,</span>
<span class="gi">+      0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4,</span>
<span class="gi">+      0xf9357e7, 0x49d5eea, 0x198f45fd, 0x12814cf0,</span>
<span class="gi">+      0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c,</span>
<span class="gi">+      0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448,</span>
<span class="gi">+      0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814,</span>
<span class="gi">+      0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20,</span>
<span class="gi">+      0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a,</span>
<span class="gi">+      0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e,</span>
<span class="gi">+      0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512,</span>
<span class="gi">+      0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126,</span>
<span class="gi">+      0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa,</span>
<span class="gi">+      0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e,</span>
<span class="gi">+      0x1e3daed5, 0x1533a7d8, 0x821bccf, 0x32fb5c2,</span>
<span class="gi">+      0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6,</span>
<span class="gi">+      0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1,</span>
<span class="gi">+      0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5,</span>
<span class="gi">+      0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9,</span>
<span class="gi">+      0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d,</span>
<span class="gi">+      0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611,</span>
<span class="gi">+      0x11aef932, 0x1aa0f03f, 0x7b2eb28, 0xcbce225,</span>
<span class="gi">+      0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79,</span>
<span class="gi">+      0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d,</span>
<span class="gi">+      0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd,</span>
<span class="gi">+      0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9,</span>
<span class="gi">+      0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5,</span>
<span class="gi">+      0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91,</span>
<span class="gi">+      0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d,</span>
<span class="gi">+      0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329,</span>
<span class="gi">+      0x1fd13462, 0x14df3d6f, 0x9cd2678, 0x2c32f75,</span>
<span class="gi">+      0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41,</span>
<span class="gi">+      0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76,</span>
<span class="gi">+      0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842,</span>
<span class="gi">+      0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e,</span>
<span class="gi">+      0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a,</span>
<span class="gi">+      0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6,</span>
<span class="gi">+      0x10426385, 0x1b4c6a88, 0x65e719f, 0xd507892,</span>
<span class="gi">+      0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce,</span>
<span class="gi">+      0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa,</span>
<span class="gi">+      0x1ec9ab7, 0xae293ba, 0x17f088ad, 0x1cfe81a0,</span>
<span class="gi">+      0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594,</span>
<span class="gi">+      0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8,</span>
<span class="gi">+      0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc,</span>
<span class="gi">+      0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170,</span>
<span class="gi">+      0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544,</span>
<span class="gi">+      0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918,</span>
<span class="gi">+      0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c,</span>
<span class="gi">+      0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b,</span>
<span class="gi">+      0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f,</span>
<span class="gi">+      0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273,</span>
<span class="gi">+      0xe7fcd50, 0x571c45d, 0x1863df4a, 0x136dd647,</span>
<span class="gi">+      0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb,</span>
<span class="gi">+      0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff,</span>
<span class="gi">+      0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3,</span>
<span class="gi">+      0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697)</span>
<span class="gi">+</span>
<span class="gi">+U3 = (0x0, 0xd0b0e09, 0x1a161c12, 0x171d121b,</span>
<span class="gi">+      0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f,</span>
<span class="gi">+      0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253,</span>
<span class="gi">+      0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77,</span>
<span class="gi">+      0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b,</span>
<span class="gi">+      0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf,</span>
<span class="gi">+      0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3,</span>
<span class="gi">+      0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7,</span>
<span class="gi">+      0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920,</span>
<span class="gi">+      0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104,</span>
<span class="gi">+      0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968,</span>
<span class="gi">+      0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c,</span>
<span class="gi">+      0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0,</span>
<span class="gi">+      0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194,</span>
<span class="gi">+      0x3934be3, 0xe9845ea, 0x198557f1, 0x148e59f8,</span>
<span class="gi">+      0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc,</span>
<span class="gi">+      0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d,</span>
<span class="gi">+      0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749,</span>
<span class="gi">+      0x5aedd3e, 0x8a5d337, 0x1fb8c12c, 0x12b3cf25,</span>
<span class="gi">+      0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701,</span>
<span class="gi">+      0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd,</span>
<span class="gi">+      0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9,</span>
<span class="gi">+      0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5,</span>
<span class="gi">+      0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791,</span>
<span class="gi">+      0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456,</span>
<span class="gi">+      0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72,</span>
<span class="gi">+      0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e,</span>
<span class="gi">+      0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a,</span>
<span class="gi">+      0x63d96dd, 0xb3698d4, 0x1c2b8acf, 0x112084c6,</span>
<span class="gi">+      0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2,</span>
<span class="gi">+      0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e,</span>
<span class="gi">+      0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa,</span>
<span class="gi">+      0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7,</span>
<span class="gi">+      0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3,</span>
<span class="gi">+      0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf,</span>
<span class="gi">+      0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b,</span>
<span class="gi">+      0xa47a17c, 0x74caf75, 0x1051bd6e, 0x1d5ab367,</span>
<span class="gi">+      0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43,</span>
<span class="gi">+      0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f,</span>
<span class="gi">+      0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b,</span>
<span class="gi">+      0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc,</span>
<span class="gi">+      0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8,</span>
<span class="gi">+      0x9d4ea9f, 0x4dfe496, 0x13c2f68d, 0x1ec9f884,</span>
<span class="gi">+      0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0,</span>
<span class="gi">+      0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c,</span>
<span class="gi">+      0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078,</span>
<span class="gi">+      0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814,</span>
<span class="gi">+      0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030,</span>
<span class="gi">+      0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81,</span>
<span class="gi">+      0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5,</span>
<span class="gi">+      0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9,</span>
<span class="gi">+      0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed,</span>
<span class="gi">+      0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11,</span>
<span class="gi">+      0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635,</span>
<span class="gi">+      0xfe97c42, 0x2e2724b, 0x15ff6050, 0x18f46e59,</span>
<span class="gi">+      0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d,</span>
<span class="gi">+      0xc7a37a1, 0x17139a8, 0x166c2bb3, 0x1b6725ba,</span>
<span class="gi">+      0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e,</span>
<span class="gi">+      0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2,</span>
<span class="gi">+      0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6,</span>
<span class="gi">+      0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a,</span>
<span class="gi">+      0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e,</span>
<span class="gi">+      0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562,</span>
<span class="gi">+      0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46)</span>
<span class="gi">+</span>
<span class="gi">+U4 = (0x0, 0x90d0b0e, 0x121a161c, 0x1b171d12,</span>
<span class="gi">+      0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a,</span>
<span class="gi">+      0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562,</span>
<span class="gi">+      0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a,</span>
<span class="gi">+      0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2,</span>
<span class="gi">+      0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca,</span>
<span class="gi">+      0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582,</span>
<span class="gi">+      0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba,</span>
<span class="gi">+      0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9,</span>
<span class="gi">+      0x1f8f57e3, 0x16825ced, 0xd9541ff, 0x4984af1,</span>
<span class="gi">+      0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9,</span>
<span class="gi">+      0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281,</span>
<span class="gi">+      0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629,</span>
<span class="gi">+      0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11,</span>
<span class="gi">+      0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59,</span>
<span class="gi">+      0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261,</span>
<span class="gi">+      0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf,</span>
<span class="gi">+      0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787,</span>
<span class="gi">+      0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf,</span>
<span class="gi">+      0x1a3182e5, 0x133c89eb, 0x82b94f9, 0x1269ff7,</span>
<span class="gi">+      0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f,</span>
<span class="gi">+      0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767,</span>
<span class="gi">+      0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f,</span>
<span class="gi">+      0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17,</span>
<span class="gi">+      0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064,</span>
<span class="gi">+      0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c,</span>
<span class="gi">+      0x5bed506, 0xcb3de08, 0x17a4c31a, 0x1ea9c814,</span>
<span class="gi">+      0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c,</span>
<span class="gi">+      0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084,</span>
<span class="gi">+      0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc,</span>
<span class="gi">+      0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4,</span>
<span class="gi">+      0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc,</span>
<span class="gi">+      0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53,</span>
<span class="gi">+      0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b,</span>
<span class="gi">+      0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223,</span>
<span class="gi">+      0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b,</span>
<span class="gi">+      0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3,</span>
<span class="gi">+      0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b,</span>
<span class="gi">+      0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3,</span>
<span class="gi">+      0x105633e9, 0x195b38e7, 0x24c25f5, 0xb412efb,</span>
<span class="gi">+      0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188,</span>
<span class="gi">+      0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0,</span>
<span class="gi">+      0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8,</span>
<span class="gi">+      0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0,</span>
<span class="gi">+      0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168,</span>
<span class="gi">+      0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50,</span>
<span class="gi">+      0xfd9640a, 0x6d46f04, 0x1dc37216, 0x14ce7918,</span>
<span class="gi">+      0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520,</span>
<span class="gi">+      0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe,</span>
<span class="gi">+      0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6,</span>
<span class="gi">+      0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e,</span>
<span class="gi">+      0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6,</span>
<span class="gi">+      0xa67b10c, 0x36aba02, 0x187da710, 0x1170ac1e,</span>
<span class="gi">+      0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026,</span>
<span class="gi">+      0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e,</span>
<span class="gi">+      0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856,</span>
<span class="gi">+      0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725,</span>
<span class="gi">+      0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d,</span>
<span class="gi">+      0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55,</span>
<span class="gi">+      0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d,</span>
<span class="gi">+      0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5,</span>
<span class="gi">+      0x15e8e6ef, 0x1ce5ede1, 0x7f2f0f3, 0xefffbfd,</span>
<span class="gi">+      0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5,</span>
<span class="gi">+      0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d)</span>
<span class="gi">+</span>
<span class="gi">+rcon = (0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,</span>
<span class="gi">+        0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f,</span>
<span class="gi">+        0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4,</span>
<span class="gi">+        0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91)</span>

<span class="w"> </span>@deprecated_class_name(&#39;rijndael&#39;)
<span class="w"> </span>class Rijndael(object):
<span class="gu">@@ -597,69 +919,187 @@ class Rijndael(object):</span>
<span class="w"> </span>    :ival list Ke: key schedule for encryption
<span class="w"> </span>    :ival list Kd: key schedule for decryption
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="gd">-    def __init__(self, key, block_size=16):</span>
<span class="gi">+    def __init__(self, key, block_size = 16):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialise the object, derive keys for encryption and decryption.&quot;&quot;&quot;
<span class="w"> </span>        if block_size != 16 and block_size != 24 and block_size != 32:
<span class="w"> </span>            raise ValueError(&#39;Invalid block size: &#39; + str(block_size))
<span class="w"> </span>        if len(key) != 16 and len(key) != 24 and len(key) != 32:
<span class="w"> </span>            raise ValueError(&#39;Invalid key size: &#39; + str(len(key)))
<span class="w"> </span>        self.block_size = block_size
<span class="gi">+</span>
<span class="w"> </span>        ROUNDS = num_rounds[len(key)][block_size]
<span class="w"> </span>        BC = block_size // 4
<span class="gd">-        Ke = [([0] * BC) for i in range(ROUNDS + 1)]</span>
<span class="gd">-        Kd = [([0] * BC) for i in range(ROUNDS + 1)]</span>
<span class="gi">+        # encryption round keys</span>
<span class="gi">+        Ke = [[0] * BC for i in range(ROUNDS + 1)]</span>
<span class="gi">+        # decryption round keys</span>
<span class="gi">+        Kd = [[0] * BC for i in range(ROUNDS + 1)]</span>
<span class="w"> </span>        ROUND_KEY_COUNT = (ROUNDS + 1) * BC
<span class="w"> </span>        KC = len(key) // 4
<span class="gi">+</span>
<span class="gi">+        # copy user material bytes into temporary ints</span>
<span class="w"> </span>        tk = []
<span class="w"> </span>        for i in range(0, KC):
<span class="gd">-            tk.append(key[i * 4] &lt;&lt; 24 | key[i * 4 + 1] &lt;&lt; 16 | key[i * 4 +</span>
<span class="gd">-                2] &lt;&lt; 8 | key[i * 4 + 3])</span>
<span class="gi">+            tk.append((key[i * 4] &lt;&lt; 24) | (key[i * 4 + 1] &lt;&lt; 16) |</span>
<span class="gi">+                (key[i * 4 + 2] &lt;&lt; 8) | key[i * 4 + 3])</span>
<span class="gi">+</span>
<span class="gi">+        # copy values into round key arrays</span>
<span class="w"> </span>        t = 0
<span class="w"> </span>        j = 0
<span class="w"> </span>        while j &lt; KC and t &lt; ROUND_KEY_COUNT:
<span class="w"> </span>            Ke[t // BC][t % BC] = tk[j]
<span class="gd">-            Kd[ROUNDS - t // BC][t % BC] = tk[j]</span>
<span class="gi">+            Kd[ROUNDS - (t // BC)][t % BC] = tk[j]</span>
<span class="w"> </span>            j += 1
<span class="w"> </span>            t += 1
<span class="w"> </span>        tt = 0
<span class="w"> </span>        rconpointer = 0
<span class="w"> </span>        while t &lt; ROUND_KEY_COUNT:
<span class="gi">+            # extrapolate using phi (the round key evolution function)</span>
<span class="w"> </span>            tt = tk[KC - 1]
<span class="gd">-            tk[0] ^= (S[tt &gt;&gt; 16 &amp; 255] &amp; 255) &lt;&lt; 24 ^ (S[tt &gt;&gt; 8 &amp; 255] &amp; 255</span>
<span class="gd">-                ) &lt;&lt; 16 ^ (S[tt &amp; 255] &amp; 255) &lt;&lt; 8 ^ S[tt &gt;&gt; 24 &amp; 255</span>
<span class="gd">-                ] &amp; 255 ^ (rcon[rconpointer] &amp; 255) &lt;&lt; 24</span>
<span class="gi">+            tk[0] ^= (S[(tt &gt;&gt; 16) &amp; 0xFF] &amp; 0xFF) &lt;&lt; 24 ^  \</span>
<span class="gi">+                     (S[(tt &gt;&gt;  8) &amp; 0xFF] &amp; 0xFF) &lt;&lt; 16 ^  \</span>
<span class="gi">+                     (S[ tt        &amp; 0xFF] &amp; 0xFF) &lt;&lt;  8 ^  \</span>
<span class="gi">+                     (S[(tt &gt;&gt; 24) &amp; 0xFF] &amp; 0xFF)       ^  \</span>
<span class="gi">+                     (rcon[rconpointer]    &amp; 0xFF) &lt;&lt; 24</span>
<span class="w"> </span>            rconpointer += 1
<span class="w"> </span>            if KC != 8:
<span class="w"> </span>                for i in range(1, KC):
<span class="gd">-                    tk[i] ^= tk[i - 1]</span>
<span class="gi">+                    tk[i] ^= tk[i-1]</span>
<span class="w"> </span>            else:
<span class="w"> </span>                for i in range(1, KC // 2):
<span class="gd">-                    tk[i] ^= tk[i - 1]</span>
<span class="gi">+                    tk[i] ^= tk[i-1]</span>
<span class="w"> </span>                tt = tk[KC // 2 - 1]
<span class="gd">-                tk[KC // 2] ^= S[tt &amp; 255] &amp; 255 ^ (S[tt &gt;&gt; 8 &amp; 255] &amp; 255</span>
<span class="gd">-                    ) &lt;&lt; 8 ^ (S[tt &gt;&gt; 16 &amp; 255] &amp; 255) &lt;&lt; 16 ^ (S[tt &gt;&gt; 24 &amp;</span>
<span class="gd">-                    255] &amp; 255) &lt;&lt; 24</span>
<span class="gi">+                tk[KC // 2] ^= (S[ tt        &amp; 0xFF] &amp; 0xFF)       ^ \</span>
<span class="gi">+                              (S[(tt &gt;&gt;  8) &amp; 0xFF] &amp; 0xFF) &lt;&lt;  8 ^ \</span>
<span class="gi">+                              (S[(tt &gt;&gt; 16) &amp; 0xFF] &amp; 0xFF) &lt;&lt; 16 ^ \</span>
<span class="gi">+                              (S[(tt &gt;&gt; 24) &amp; 0xFF] &amp; 0xFF) &lt;&lt; 24</span>
<span class="w"> </span>                for i in range(KC // 2 + 1, KC):
<span class="gd">-                    tk[i] ^= tk[i - 1]</span>
<span class="gi">+                    tk[i] ^= tk[i-1]</span>
<span class="gi">+            # copy values into round key arrays</span>
<span class="w"> </span>            j = 0
<span class="w"> </span>            while j &lt; KC and t &lt; ROUND_KEY_COUNT:
<span class="w"> </span>                Ke[t // BC][t % BC] = tk[j]
<span class="gd">-                Kd[ROUNDS - t // BC][t % BC] = tk[j]</span>
<span class="gi">+                Kd[ROUNDS - (t // BC)][t % BC] = tk[j]</span>
<span class="w"> </span>                j += 1
<span class="w"> </span>                t += 1
<span class="gi">+        # inverse MixColumn where needed</span>
<span class="w"> </span>        for r in range(1, ROUNDS):
<span class="w"> </span>            for j in range(BC):
<span class="w"> </span>                tt = Kd[r][j]
<span class="gd">-                Kd[r][j] = U1[tt &gt;&gt; 24 &amp; 255] ^ U2[tt &gt;&gt; 16 &amp; 255] ^ U3[tt &gt;&gt;</span>
<span class="gd">-                    8 &amp; 255] ^ U4[tt &amp; 255]</span>
<span class="gi">+                Kd[r][j] = U1[(tt &gt;&gt; 24) &amp; 0xFF] ^ \</span>
<span class="gi">+                           U2[(tt &gt;&gt; 16) &amp; 0xFF] ^ \</span>
<span class="gi">+                           U3[(tt &gt;&gt;  8) &amp; 0xFF] ^ \</span>
<span class="gi">+                           U4[ tt        &amp; 0xFF]</span>
<span class="w"> </span>        self.Ke = Ke
<span class="w"> </span>        self.Kd = Kd

<span class="w"> </span>    def encrypt(self, plaintext):
<span class="w"> </span>        &quot;&quot;&quot;Encrypt a single block of plaintext.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(plaintext) != self.block_size:</span>
<span class="gi">+            raise ValueError(&#39;wrong block length, expected {0} got {1}&#39;</span>
<span class="gi">+                             .format(self.block_size, len(plaintext)))</span>
<span class="gi">+        Ke = self.Ke</span>
<span class="gi">+</span>
<span class="gi">+        BC = self.block_size // 4</span>
<span class="gi">+        ROUNDS = len(Ke) - 1</span>
<span class="gi">+        if BC == 4:</span>
<span class="gi">+            SC = 0</span>
<span class="gi">+        elif BC == 6:</span>
<span class="gi">+            SC = 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            SC = 2</span>
<span class="gi">+        s1 = shifts[SC][1][0]</span>
<span class="gi">+        s2 = shifts[SC][2][0]</span>
<span class="gi">+        s3 = shifts[SC][3][0]</span>
<span class="gi">+        a = [0] * BC</span>
<span class="gi">+        # temporary work array</span>
<span class="gi">+        t = []</span>
<span class="gi">+        # plaintext to ints + key</span>
<span class="gi">+        for i in range(BC):</span>
<span class="gi">+            t.append((plaintext[i * 4    ] &lt;&lt; 24 |</span>
<span class="gi">+                      plaintext[i * 4 + 1] &lt;&lt; 16 |</span>
<span class="gi">+                      plaintext[i * 4 + 2] &lt;&lt;  8 |</span>
<span class="gi">+                      plaintext[i * 4 + 3]        ) ^ Ke[0][i])</span>
<span class="gi">+        # apply round transforms</span>
<span class="gi">+        for r in range(1, ROUNDS):</span>
<span class="gi">+            for i in range(BC):</span>
<span class="gi">+                a[i] = (T1[(t[ i           ] &gt;&gt; 24) &amp; 0xFF] ^</span>
<span class="gi">+                        T2[(t[(i + s1) % BC] &gt;&gt; 16) &amp; 0xFF] ^</span>
<span class="gi">+                        T3[(t[(i + s2) % BC] &gt;&gt;  8) &amp; 0xFF] ^</span>
<span class="gi">+                        T4[ t[(i + s3) % BC]        &amp; 0xFF]  ) ^ Ke[r][i]</span>
<span class="gi">+            t = a[:]</span>
<span class="gi">+        # last round is special</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for i in range(BC):</span>
<span class="gi">+            tt = Ke[ROUNDS][i]</span>
<span class="gi">+            result.append((S[(t[ i         ] &gt;&gt; 24) &amp; 0xFF] ^ (tt&gt;&gt;24)) &amp; 0xFF)</span>
<span class="gi">+            result.append((S[(t[(i+s1) % BC] &gt;&gt; 16) &amp; 0xFF] ^ (tt&gt;&gt;16)) &amp; 0xFF)</span>
<span class="gi">+            result.append((S[(t[(i+s2) % BC] &gt;&gt;  8) &amp; 0xFF] ^ (tt&gt;&gt; 8)) &amp; 0xFF)</span>
<span class="gi">+            result.append((S[ t[(i+s3) % BC]        &amp; 0xFF] ^  tt     ) &amp; 0xFF)</span>
<span class="gi">+        return bytearray(result)</span>

<span class="w"> </span>    def decrypt(self, ciphertext):
<span class="w"> </span>        &quot;&quot;&quot;Decrypt a block of ciphertext.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(ciphertext) != self.block_size:</span>
<span class="gi">+            raise ValueError(&#39;wrong block length, expected {0} got {1}&#39;</span>
<span class="gi">+                             .format(self.block_size, len(ciphertext)))</span>
<span class="gi">+        Kd = self.Kd</span>
<span class="gi">+</span>
<span class="gi">+        BC = self.block_size // 4</span>
<span class="gi">+        ROUNDS = len(Kd) - 1</span>
<span class="gi">+        if BC == 4:</span>
<span class="gi">+            SC = 0</span>
<span class="gi">+        elif BC == 6:</span>
<span class="gi">+            SC = 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            SC = 2</span>
<span class="gi">+        s1 = shifts[SC][1][1]</span>
<span class="gi">+        s2 = shifts[SC][2][1]</span>
<span class="gi">+        s3 = shifts[SC][3][1]</span>
<span class="gi">+        a = [0] * BC</span>
<span class="gi">+        # temporary work array</span>
<span class="gi">+        t = [0] * BC</span>
<span class="gi">+        # ciphertext to ints + key</span>
<span class="gi">+        for i in range(BC):</span>
<span class="gi">+            t[i] = (ciphertext[i * 4    ] &lt;&lt; 24 |</span>
<span class="gi">+                    ciphertext[i * 4 + 1] &lt;&lt; 16 |</span>
<span class="gi">+                    ciphertext[i * 4 + 2] &lt;&lt;  8 |</span>
<span class="gi">+                    ciphertext[i * 4 + 3]        ) ^ Kd[0][i]</span>
<span class="gi">+        # apply round transforms</span>
<span class="gi">+        for r in range(1, ROUNDS):</span>
<span class="gi">+            for i in range(BC):</span>
<span class="gi">+                a[i] = (T5[(t[ i           ] &gt;&gt; 24) &amp; 0xFF] ^</span>
<span class="gi">+                        T6[(t[(i + s1) % BC] &gt;&gt; 16) &amp; 0xFF] ^</span>
<span class="gi">+                        T7[(t[(i + s2) % BC] &gt;&gt;  8) &amp; 0xFF] ^</span>
<span class="gi">+                        T8[ t[(i + s3) % BC]        &amp; 0xFF]  ) ^ Kd[r][i]</span>
<span class="gi">+            t = a[:]</span>
<span class="gi">+        # last round is special</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for i in range(BC):</span>
<span class="gi">+            tt = Kd[ROUNDS][i]</span>
<span class="gi">+            result.append((Si[(t[ i         ] &gt;&gt; 24) &amp; 0xFF] ^ (tt&gt;&gt;24)) &amp;0xFF)</span>
<span class="gi">+            result.append((Si[(t[(i+s1) % BC] &gt;&gt; 16) &amp; 0xFF] ^ (tt&gt;&gt;16)) &amp;0xFF)</span>
<span class="gi">+            result.append((Si[(t[(i+s2) % BC] &gt;&gt;  8) &amp; 0xFF] ^ (tt&gt;&gt; 8)) &amp;0xFF)</span>
<span class="gi">+            result.append((Si[ t[(i+s3) % BC]        &amp; 0xFF] ^  tt     ) &amp;0xFF)</span>
<span class="gi">+        return bytearray(result)</span>
<span class="gi">+</span>
<span class="gi">+def encrypt(key, block):</span>
<span class="gi">+    return Rijndael(key, len(block)).encrypt(block)</span>
<span class="gi">+</span>
<span class="gi">+def decrypt(key, block):</span>
<span class="gi">+    return Rijndael(key, len(block)).decrypt(block)</span>
<span class="gi">+</span>
<span class="gi">+def test():</span>
<span class="gi">+    def t(kl, bl):</span>
<span class="gi">+        b = &#39;b&#39; * bl</span>
<span class="gi">+        r = Rijndael(&#39;a&#39; * kl, bl)</span>
<span class="gi">+        assert r.decrypt(r.encrypt(b)) == b</span>
<span class="gi">+    t(16, 16)</span>
<span class="gi">+    t(16, 24)</span>
<span class="gi">+    t(16, 32)</span>
<span class="gi">+    t(24, 16)</span>
<span class="gi">+    t(24, 24)</span>
<span class="gi">+    t(24, 32)</span>
<span class="gi">+    t(32, 16)</span>
<span class="gi">+    t(32, 24)</span>
<span class="gi">+    t(32, 32)</span>
<span class="gi">+</span>
<span class="gh">diff --git a/tlslite/utils/rsakey.py b/tlslite/utils/rsakey.py</span>
<span class="gh">index f5fe68d..7e08582 100644</span>
<span class="gd">--- a/tlslite/utils/rsakey.py</span>
<span class="gi">+++ b/tlslite/utils/rsakey.py</span>
<span class="gu">@@ -1,8 +1,14 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Abstract class for RSA.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import *
<span class="w"> </span>from . import tlshashlib as hashlib
<span class="gd">-from ..errors import MaskTooLongError, MessageTooLongError, EncodingError, InvalidSignature, UnknownRSAType</span>
<span class="gd">-from .constanttime import ct_isnonzero_u32, ct_neq_u32, ct_lsb_prop_u8, ct_lsb_prop_u16, ct_lt_u32</span>
<span class="gi">+from ..errors import MaskTooLongError, MessageTooLongError, EncodingError, \</span>
<span class="gi">+    InvalidSignature, UnknownRSAType</span>
<span class="gi">+from .constanttime import ct_isnonzero_u32, ct_neq_u32, ct_lsb_prop_u8, \</span>
<span class="gi">+    ct_lsb_prop_u16, ct_lt_u32</span>


<span class="w"> </span>class RSAKey(object):
<span class="gu">@@ -19,7 +25,7 @@ class RSAKey(object):</span>
<span class="w"> </span>    :py:class:`~tlslite.utils.keyfactory`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, n=0, e=0, key_type=&#39;rsa&#39;):</span>
<span class="gi">+    def __init__(self, n=0, e=0, key_type=&quot;rsa&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new RSA key.

<span class="w"> </span>        If n and e are passed in, the new key will be initialized.
<span class="gu">@@ -36,8 +42,10 @@ class RSAKey(object):</span>
<span class="w"> </span>            RSASSA-PSS key (able to perform only RSA-PSS signature verification
<span class="w"> </span>            and creation)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # pylint: disable=invalid-name</span>
<span class="w"> </span>        self.n = n
<span class="w"> </span>        self.e = e
<span class="gi">+        # pylint: enable=invalid-name</span>
<span class="w"> </span>        self.key_type = key_type
<span class="w"> </span>        self._key_hash = None
<span class="w"> </span>        raise NotImplementedError()
<span class="gu">@@ -54,7 +62,7 @@ class RSAKey(object):</span>

<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    def hashAndSign(self, bytes, rsaScheme=&#39;PKCS1&#39;, hAlg=&#39;sha1&#39;, sLen=0):
<span class="w"> </span>        &quot;&quot;&quot;Hash and sign the passed-in bytes.
<span class="gu">@@ -81,10 +89,14 @@ class RSAKey(object):</span>
<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        :returns: A PKCS1 or PSS signature on the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rsaScheme = rsaScheme.lower()</span>
<span class="gi">+        hAlg = hAlg.lower()</span>
<span class="gi">+        hashBytes = secureHash(bytearray(bytes), hAlg)</span>
<span class="gi">+        return self.sign(hashBytes, padding=rsaScheme, hashAlg=hAlg,</span>
<span class="gi">+                         saltLen=sLen)</span>

<span class="w"> </span>    def hashAndVerify(self, sigBytes, bytes, rsaScheme=&#39;PKCS1&#39;, hAlg=&#39;sha1&#39;,
<span class="gd">-        sLen=0):</span>
<span class="gi">+                      sLen=0):</span>
<span class="w"> </span>        &quot;&quot;&quot;Hash and verify the passed-in bytes with the signature.

<span class="w"> </span>        This verifies a PKCS1 or PSS signature on the passed-in data
<span class="gu">@@ -111,7 +123,11 @@ class RSAKey(object):</span>
<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        :returns: Whether the signature matches the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rsaScheme = rsaScheme.lower()</span>
<span class="gi">+        hAlg = hAlg.lower()</span>
<span class="gi">+</span>
<span class="gi">+        hashBytes = secureHash(bytearray(bytes), hAlg)</span>
<span class="gi">+        return self.verify(sigBytes, hashBytes, rsaScheme, hAlg, sLen)</span>

<span class="w"> </span>    def MGF1(self, mgfSeed, maskLen, hAlg):
<span class="w"> </span>        &quot;&quot;&quot;Generate mask from passed-in seed.
<span class="gu">@@ -127,7 +143,15 @@ class RSAKey(object):</span>
<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        :returns: Mask
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hashLen = getattr(hashlib, hAlg)().digest_size</span>
<span class="gi">+        if maskLen &gt; (2 ** 32) * hashLen:</span>
<span class="gi">+            raise MaskTooLongError(&quot;Incorrect parameter maskLen&quot;)</span>
<span class="gi">+        T = bytearray()</span>
<span class="gi">+        end = divceil(maskLen, hashLen)</span>
<span class="gi">+        for x in range(0, end):</span>
<span class="gi">+            C = numberToByteArray(x, 4)</span>
<span class="gi">+            T += secureHash(mgfSeed + C, hAlg)</span>
<span class="gi">+        return T[:maskLen]</span>

<span class="w"> </span>    def EMSA_PSS_encode(self, mHash, emBits, hAlg, sLen=0):
<span class="w"> </span>        &quot;&quot;&quot;Encode the passed in message
<span class="gu">@@ -145,7 +169,23 @@ class RSAKey(object):</span>

<span class="w"> </span>        :type sLen: int
<span class="w"> </span>        :param sLen: length of salt&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hashLen = getattr(hashlib, hAlg)().digest_size</span>
<span class="gi">+        emLen = divceil(emBits, 8)</span>
<span class="gi">+        if emLen &lt; hashLen + sLen + 2:</span>
<span class="gi">+            raise EncodingError(&quot;The ending limit too short for &quot; +</span>
<span class="gi">+                                &quot;selected hash and salt length&quot;)</span>
<span class="gi">+        salt = getRandomBytes(sLen)</span>
<span class="gi">+        M2 = bytearray(8) + mHash + salt</span>
<span class="gi">+        H = secureHash(M2, hAlg)</span>
<span class="gi">+        PS = bytearray(emLen - sLen - hashLen - 2)</span>
<span class="gi">+        DB = PS + bytearray(b&#39;\x01&#39;) + salt</span>
<span class="gi">+        dbMask = self.MGF1(H, emLen - hashLen - 1, hAlg)</span>
<span class="gi">+        maskedDB = bytearray(i ^ j for i, j in zip(DB, dbMask))</span>
<span class="gi">+        mLen = emLen*8 - emBits</span>
<span class="gi">+        mask = (1 &lt;&lt; 8 - mLen) - 1</span>
<span class="gi">+        maskedDB[0] &amp;= mask</span>
<span class="gi">+        EM = maskedDB + H + bytearray(b&#39;\xbc&#39;)</span>
<span class="gi">+        return EM</span>

<span class="w"> </span>    def RSASSA_PSS_sign(self, mHash, hAlg, sLen=0):
<span class="w"> </span>        &quot;&quot;&quot;&quot;Sign the passed in message
<span class="gu">@@ -160,7 +200,12 @@ class RSAKey(object):</span>

<span class="w"> </span>        :type sLen: int
<span class="w"> </span>        :param sLen: length of salt&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        EM = self.EMSA_PSS_encode(mHash, numBits(self.n) - 1, hAlg, sLen)</span>
<span class="gi">+        try:</span>
<span class="gi">+            ret = self._raw_private_key_op_bytes(EM)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise MessageTooLongError(&quot;Encode output too long&quot;)</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def EMSA_PSS_verify(self, mHash, EM, emBits, hAlg, sLen=0):
<span class="w"> </span>        &quot;&quot;&quot;Verify signature in passed in encoded message
<span class="gu">@@ -182,7 +227,38 @@ class RSAKey(object):</span>
<span class="w"> </span>        :type sLen: int
<span class="w"> </span>        :param sLen: Length of salt
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hashLen = getattr(hashlib, hAlg)().digest_size</span>
<span class="gi">+        emLen = divceil(emBits, 8)</span>
<span class="gi">+        if emLen &lt; hashLen + sLen + 2:</span>
<span class="gi">+            raise InvalidSignature(&quot;Invalid signature&quot;)</span>
<span class="gi">+        if EM[-1] != 0xbc:</span>
<span class="gi">+            raise InvalidSignature(&quot;Invalid signature&quot;)</span>
<span class="gi">+        maskedDB = EM[0:emLen - hashLen - 1]</span>
<span class="gi">+        H = EM[emLen - hashLen - 1:emLen - hashLen - 1 + hashLen]</span>
<span class="gi">+        DBHelpMask = 1 &lt;&lt; 8 - (8*emLen - emBits)</span>
<span class="gi">+        DBHelpMask -= 1</span>
<span class="gi">+        DBHelpMask = (~DBHelpMask) &amp; 0xff</span>
<span class="gi">+        if maskedDB[0] &amp; DBHelpMask != 0:</span>
<span class="gi">+            raise InvalidSignature(&quot;Invalid signature&quot;)</span>
<span class="gi">+        dbMask = self.MGF1(H, emLen - hashLen - 1, hAlg)</span>
<span class="gi">+        DB = bytearray(i ^ j for i, j in zip(maskedDB, dbMask))</span>
<span class="gi">+        mLen = emLen*8 - emBits</span>
<span class="gi">+        mask = (1 &lt;&lt; 8 - mLen) - 1</span>
<span class="gi">+        DB[0] &amp;= mask</span>
<span class="gi">+        if any(x != 0 for x in DB[0:emLen - hashLen - sLen - 2]):</span>
<span class="gi">+            raise InvalidSignature(&quot;Invalid signature&quot;)</span>
<span class="gi">+        if DB[emLen - hashLen - sLen - 2] != 0x01:</span>
<span class="gi">+            raise InvalidSignature(&quot;Invalid signature&quot;)</span>
<span class="gi">+        if sLen != 0:</span>
<span class="gi">+            salt = DB[-sLen:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            salt = bytearray()</span>
<span class="gi">+        newM = bytearray(8) + mHash + salt</span>
<span class="gi">+        newH = secureHash(newM, hAlg)</span>
<span class="gi">+        if H == newH:</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise InvalidSignature(&quot;Invalid signature&quot;)</span>

<span class="w"> </span>    def RSASSA_PSS_verify(self, mHash, S, hAlg, sLen=0):
<span class="w"> </span>        &quot;&quot;&quot;Verify the signature in passed in message
<span class="gu">@@ -201,11 +277,23 @@ class RSAKey(object):</span>
<span class="w"> </span>        :type sLen: int
<span class="w"> </span>        :param sLen: Length of salt
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            EM = self._raw_public_key_op_bytes(S)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise InvalidSignature(&quot;Invalid signature&quot;)</span>
<span class="gi">+        result = self.EMSA_PSS_verify(mHash, EM, numBits(self.n) - 1,</span>
<span class="gi">+                                      hAlg, sLen)</span>
<span class="gi">+        if result:</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise InvalidSignature(&quot;Invalid signature&quot;)</span>

<span class="w"> </span>    def _raw_pkcs1_sign(self, bytes):
<span class="w"> </span>        &quot;&quot;&quot;Perform signature on raw data, add PKCS#1 padding.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.hasPrivateKey():</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+        paddedBytes = self._addPKCS1Padding(bytes, 1)</span>
<span class="gi">+        return self._raw_private_key_op_bytes(paddedBytes)</span>

<span class="w"> </span>    def sign(self, bytes, padding=&#39;pkcs1&#39;, hashAlg=None, saltLen=None):
<span class="w"> </span>        &quot;&quot;&quot;Sign the passed-in bytes.
<span class="gu">@@ -232,14 +320,28 @@ class RSAKey(object):</span>
<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        :returns: A PKCS1 signature on the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        padding = padding.lower()</span>
<span class="gi">+        if padding == &#39;pkcs1&#39;:</span>
<span class="gi">+            if hashAlg is not None:</span>
<span class="gi">+                bytes = self.addPKCS1Prefix(bytes, hashAlg)</span>
<span class="gi">+            sigBytes = self._raw_pkcs1_sign(bytes)</span>
<span class="gi">+        elif padding == &quot;pss&quot;:</span>
<span class="gi">+            sigBytes = self.RSASSA_PSS_sign(bytes, hashAlg, saltLen)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise UnknownRSAType(&quot;Unknown RSA algorithm type&quot;)</span>
<span class="gi">+        return sigBytes</span>

<span class="w"> </span>    def _raw_pkcs1_verify(self, sigBytes, bytes):
<span class="w"> </span>        &quot;&quot;&quot;Perform verification operation on raw PKCS#1 padded signature&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            checkBytes = self._raw_public_key_op_bytes(sigBytes)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return False</span>
<span class="gi">+        paddedBytes = self._addPKCS1Padding(bytes, 1)</span>
<span class="gi">+        return checkBytes == paddedBytes</span>

<span class="w"> </span>    def verify(self, sigBytes, bytes, padding=&#39;pkcs1&#39;, hashAlg=None,
<span class="gd">-        saltLen=None):</span>
<span class="gi">+               saltLen=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify the passed-in bytes with the signature.

<span class="w"> </span>        This verifies a PKCS1 signature on the passed-in data.
<span class="gu">@@ -253,7 +355,28 @@ class RSAKey(object):</span>
<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        :returns: Whether the signature matches the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if padding == &quot;pkcs1&quot; and self.key_type == &quot;rsa-pss&quot;:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if padding == &quot;pkcs1&quot; and hashAlg == &#39;sha1&#39;:</span>
<span class="gi">+            # Try it with/without the embedded NULL</span>
<span class="gi">+            prefixedHashBytes1 = self.addPKCS1SHA1Prefix(bytes, False)</span>
<span class="gi">+            prefixedHashBytes2 = self.addPKCS1SHA1Prefix(bytes, True)</span>
<span class="gi">+            result1 = self._raw_pkcs1_verify(sigBytes, prefixedHashBytes1)</span>
<span class="gi">+            result2 = self._raw_pkcs1_verify(sigBytes, prefixedHashBytes2)</span>
<span class="gi">+            return (result1 or result2)</span>
<span class="gi">+        elif padding == &#39;pkcs1&#39;:</span>
<span class="gi">+            if hashAlg is not None:</span>
<span class="gi">+                bytes = self.addPKCS1Prefix(bytes, hashAlg)</span>
<span class="gi">+            res = self._raw_pkcs1_verify(sigBytes, bytes)</span>
<span class="gi">+            return res</span>
<span class="gi">+        elif padding == &quot;pss&quot;:</span>
<span class="gi">+            try:</span>
<span class="gi">+                res = self.RSASSA_PSS_verify(bytes, sigBytes, hashAlg, saltLen)</span>
<span class="gi">+            except InvalidSignature:</span>
<span class="gi">+                res = False</span>
<span class="gi">+            return res</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise UnknownRSAType(&quot;Unknown RSA algorithm type&quot;)</span>

<span class="w"> </span>    def encrypt(self, bytes):
<span class="w"> </span>        &quot;&quot;&quot;Encrypt the passed-in bytes.
<span class="gu">@@ -266,7 +389,8 @@ class RSAKey(object):</span>
<span class="w"> </span>        :rtype: bytearray
<span class="w"> </span>        :returns: A PKCS1 encryption of the passed-in data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        paddedBytes = self._addPKCS1Padding(bytes, 2)</span>
<span class="gi">+        return self._raw_public_key_op_bytes(paddedBytes)</span>

<span class="w"> </span>    def _dec_prf(self, key, label, out_len):
<span class="w"> </span>        &quot;&quot;&quot;PRF for deterministic implicit rejection in the RSA decryption.
<span class="gu">@@ -277,7 +401,21 @@ class RSAKey(object):</span>
<span class="w"> </span>        :rtype: bytes
<span class="w"> </span>        :returns: a random bytestring
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        out = bytearray()</span>
<span class="gi">+</span>
<span class="gi">+        if out_len % 8 != 0:</span>
<span class="gi">+            raise ValueError(&quot;only multiples of 8 supported as output size&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        iterator = 0</span>
<span class="gi">+        while len(out) &lt; out_len // 8:</span>
<span class="gi">+            out += secureHMAC(</span>
<span class="gi">+                key,</span>
<span class="gi">+                numberToByteArray(iterator, 2) + label +</span>
<span class="gi">+                numberToByteArray(out_len, 2),</span>
<span class="gi">+                &quot;sha256&quot;)</span>
<span class="gi">+            iterator += 1</span>
<span class="gi">+</span>
<span class="gi">+        return out[:out_len//8]</span>

<span class="w"> </span>    def decrypt(self, encBytes):
<span class="w"> </span>        &quot;&quot;&quot;Decrypt the passed-in bytes.
<span class="gu">@@ -300,7 +438,157 @@ class RSAKey(object):</span>
<span class="w"> </span>            an empty string is correct, so it may return an empty bytearray
<span class="w"> </span>            for some ciphertexts.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.hasPrivateKey():</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+        if self.key_type != &quot;rsa&quot;:</span>
<span class="gi">+            raise ValueError(&quot;Decryption requires RSA key, \&quot;{0}\&quot; present&quot;</span>
<span class="gi">+                             .format(self.key_type))</span>
<span class="gi">+        try:</span>
<span class="gi">+            dec_bytes = self._raw_private_key_op_bytes(encBytes)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            # _raw_private_key_op_bytes fails only when encBytes &gt;= self.n,</span>
<span class="gi">+            # or when len(encBytes) != numBytes(self.n) and that&#39;s public</span>
<span class="gi">+            # information, so we don&#39;t have to handle it</span>
<span class="gi">+            # in sidechannel secure way</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        ###################</span>
<span class="gi">+        # here be dragons #</span>
<span class="gi">+        ###################</span>
<span class="gi">+        # While the code is written as-if it was side-channel secure, in</span>
<span class="gi">+        # practice, because of cPython implementation details IT IS NOT</span>
<span class="gi">+        # see:</span>
<span class="gi">+        # https://securitypitfalls.wordpress.com/2018/08/03/constant-time-compare-in-python/</span>
<span class="gi">+</span>
<span class="gi">+        n = self.n</span>
<span class="gi">+</span>
<span class="gi">+        # maximum length we can return is reduced by the mandatory prefix:</span>
<span class="gi">+        # (0x00 0x02), 8 bytes of padding, so this is the position of the</span>
<span class="gi">+        # null separator byte, as counted from the last position</span>
<span class="gi">+        max_sep_offset = numBytes(n) - 10</span>
<span class="gi">+</span>
<span class="gi">+        # the private exponent (d) doesn&#39;t change so `_key_hash` doesn&#39;t</span>
<span class="gi">+        # change, calculate it only once</span>
<span class="gi">+        if not hasattr(self, &#39;_key_hash&#39;) or not self._key_hash:</span>
<span class="gi">+            self._key_hash = secureHash(numberToByteArray(self.d, numBytes(n)),</span>
<span class="gi">+                                        &quot;sha256&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        kdk = secureHMAC(self._key_hash, encBytes, &quot;sha256&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # we need 128 2-byte numbers, encoded as the number of bits</span>
<span class="gi">+        length_randoms = self._dec_prf(kdk, b&quot;length&quot;, 128 * 2 * 8)</span>
<span class="gi">+</span>
<span class="gi">+        message_random = self._dec_prf(kdk, b&quot;message&quot;, numBytes(n) * 8)</span>
<span class="gi">+</span>
<span class="gi">+        # select the last length that&#39;s not too large to return</span>
<span class="gi">+        synth_length = 0</span>
<span class="gi">+        length_rand_iter = iter(length_randoms)</span>
<span class="gi">+        length_mask = (1 &lt;&lt; numBits(max_sep_offset)) - 1</span>
<span class="gi">+        for high, low in zip(length_rand_iter, length_rand_iter):</span>
<span class="gi">+            # interpret the two bytes from the PRF output as 16-bit big-endian</span>
<span class="gi">+            # integer</span>
<span class="gi">+            len_candidate = (high &lt;&lt; 8) + low</span>
<span class="gi">+            len_candidate &amp;= length_mask</span>
<span class="gi">+            # equivalent to:</span>
<span class="gi">+            # if len_candidate &lt; max_sep_offset:</span>
<span class="gi">+            #    synth_length = len_candidate</span>
<span class="gi">+            mask = ct_lt_u32(len_candidate, max_sep_offset)</span>
<span class="gi">+            mask = ct_lsb_prop_u16(mask)</span>
<span class="gi">+            synth_length = synth_length &amp; (0xffff ^ mask) \</span>
<span class="gi">+                | len_candidate &amp; mask</span>
<span class="gi">+</span>
<span class="gi">+        synth_msg_start = numBytes(n) - synth_length</span>
<span class="gi">+</span>
<span class="gi">+        error_detected = 0</span>
<span class="gi">+</span>
<span class="gi">+        # enumerate over all decrypted bytes</span>
<span class="gi">+        em_bytes = enumerate(dec_bytes)</span>
<span class="gi">+        # first check if first two bytes specify PKCS#1 v1.5 encryption padding</span>
<span class="gi">+        _, val = next(em_bytes)</span>
<span class="gi">+        error_detected |= ct_isnonzero_u32(val)</span>
<span class="gi">+        _, val = next(em_bytes)</span>
<span class="gi">+        error_detected |= ct_neq_u32(val, 0x02)</span>
<span class="gi">+        # then look for for the null separator byte among the padding bytes</span>
<span class="gi">+        # but inspect all decrypted bytes, even if we already find the</span>
<span class="gi">+        # separator earlier</span>
<span class="gi">+        msg_start = 0</span>
<span class="gi">+        for pos, val in em_bytes:</span>
<span class="gi">+            # padding must be at least 8 bytes long, fail if any of the first</span>
<span class="gi">+            # 8 bytes of it are zero</span>
<span class="gi">+            # equivalent to:</span>
<span class="gi">+            # if pos &lt; 10 and not val:</span>
<span class="gi">+            #     error_detected = 0x01</span>
<span class="gi">+            error_detected |= ct_lt_u32(pos, 10) &amp; (1 ^ ct_isnonzero_u32(val))</span>
<span class="gi">+</span>
<span class="gi">+            # update the msg_start only once; when it&#39;s 0</span>
<span class="gi">+            # (pos+1) because we want to skip the null separator</span>
<span class="gi">+            # equivalent to:</span>
<span class="gi">+            # if pos &gt;= 10 and not msg_start and not val:</span>
<span class="gi">+            #     msg_start = pos+1</span>
<span class="gi">+            mask = (1 ^ ct_lt_u32(pos, 10)) &amp; (1 ^ ct_isnonzero_u32(val)) \</span>
<span class="gi">+                &amp; (1 ^ ct_isnonzero_u32(msg_start))</span>
<span class="gi">+            mask = ct_lsb_prop_u16(mask)</span>
<span class="gi">+            msg_start = msg_start &amp; (0xffff ^ mask) | (pos+1) &amp; mask</span>
<span class="gi">+</span>
<span class="gi">+        # if separator wasn&#39;t found, it&#39;s an error</span>
<span class="gi">+        # equivalent to:</span>
<span class="gi">+        # if not msg_start:</span>
<span class="gi">+        #     error_detected = 0x01</span>
<span class="gi">+        error_detected |= 1 ^ ct_isnonzero_u32(msg_start)</span>
<span class="gi">+</span>
<span class="gi">+        # equivalent to:</span>
<span class="gi">+        # if error_detected:</span>
<span class="gi">+        #     ret_msg_start = synth_msg_start</span>
<span class="gi">+        # else:</span>
<span class="gi">+        #     ret_msg_start = msg_start</span>
<span class="gi">+        mask = ct_lsb_prop_u16(error_detected)</span>
<span class="gi">+        ret_msg_start = msg_start &amp; (0xffff ^ mask) | synth_msg_start &amp; mask</span>
<span class="gi">+</span>
<span class="gi">+        # as at this point the length doesn&#39;t leak the information if the</span>
<span class="gi">+        # padding was correct or not, we don&#39;t have to worry about the</span>
<span class="gi">+        # length of the returned value (and thus the size of the buffer we</span>
<span class="gi">+        # pass to the caller); but we still need to read both buffers</span>
<span class="gi">+        # to ensure that the memory access patern is preserved (that both</span>
<span class="gi">+        # buffers are accessed, not just the one we return)</span>
<span class="gi">+</span>
<span class="gi">+        # equivalent to:</span>
<span class="gi">+        # if error_detected:</span>
<span class="gi">+        #     return message_random[ret_msg_start:]</span>
<span class="gi">+        # else:</span>
<span class="gi">+        #     return dec_bytes[ret_msg_start:]</span>
<span class="gi">+        mask = ct_lsb_prop_u8(error_detected)</span>
<span class="gi">+        not_mask = 0xff ^ mask</span>
<span class="gi">+        ret = bytearray(</span>
<span class="gi">+            x &amp; not_mask | y &amp; mask for x, y in</span>
<span class="gi">+            zip(dec_bytes[ret_msg_start:], message_random[ret_msg_start:]))</span>
<span class="gi">+</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+    def _rawPrivateKeyOp(self, message):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _rawPublicKeyOp(self, ciphertext):</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+    def _raw_private_key_op_bytes(self, message):</span>
<span class="gi">+        n = self.n</span>
<span class="gi">+        if len(message) != numBytes(n):</span>
<span class="gi">+            raise ValueError(&quot;Message has incorrect length for the key size&quot;)</span>
<span class="gi">+        m_int = bytesToNumber(message)</span>
<span class="gi">+        if m_int &gt;= n:</span>
<span class="gi">+            raise ValueError(&quot;Provided message value exceeds modulus&quot;)</span>
<span class="gi">+        dec_int = self._rawPrivateKeyOp(m_int)</span>
<span class="gi">+        return numberToByteArray(dec_int, numBytes(n))</span>
<span class="gi">+</span>
<span class="gi">+    def _raw_public_key_op_bytes(self, ciphertext):</span>
<span class="gi">+        n = self.n</span>
<span class="gi">+        if len(ciphertext) != numBytes(n):</span>
<span class="gi">+            raise ValueError(&quot;Message has incorrect length for the key size&quot;)</span>
<span class="gi">+        c_int = bytesToNumber(ciphertext)</span>
<span class="gi">+        if c_int &gt;= n:</span>
<span class="gi">+            raise ValueError(&quot;Provided message value exceeds modulus&quot;)</span>
<span class="gi">+        enc_int = self._rawPublicKeyOp(c_int)</span>
<span class="gi">+        return numberToByteArray(enc_int, numBytes(n))</span>

<span class="w"> </span>    def acceptsPassword(self):
<span class="w"> </span>        &quot;&quot;&quot;Return True if the write() method accepts a password for use
<span class="gu">@@ -308,7 +596,7 @@ class RSAKey(object):</span>

<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    def write(self, password=None):
<span class="w"> </span>        &quot;&quot;&quot;Return a string containing the key.
<span class="gu">@@ -317,30 +605,83 @@ class RSAKey(object):</span>
<span class="w"> </span>        :returns: A string describing the key, in whichever format (PEM)
<span class="w"> </span>            is native to the implementation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def generate(bits, key_type=&#39;rsa&#39;):</span>
<span class="gi">+    def generate(bits, key_type=&quot;rsa&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a new key with the specified bit length.

<span class="w"> </span>        :rtype: ~tlslite.utils.RSAKey.RSAKey
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    # **************************************************************************</span>
<span class="gi">+    # Helper Functions for RSA Keys</span>
<span class="gi">+    # **************************************************************************</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def addPKCS1SHA1Prefix(cls, hashBytes, withNULL=True):
<span class="w"> </span>        &quot;&quot;&quot;Add PKCS#1 v1.5 algorithm identifier prefix to SHA1 hash bytes&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    _pkcs1Prefixes = {&#39;md5&#39;: bytearray([48, 32, 48, 12, 6, 8, 42, 134, 72, </span>
<span class="gd">-        134, 247, 13, 2, 5, 5, 0, 4, 16]), &#39;sha1&#39;: bytearray([48, 33, 48, 9,</span>
<span class="gd">-        6, 5, 43, 14, 3, 2, 26, 5, 0, 4, 20]), &#39;sha224&#39;: bytearray([48, 45,</span>
<span class="gd">-        48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 4, 5, 0, 4, 28]),</span>
<span class="gd">-        &#39;sha256&#39;: bytearray([48, 49, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, </span>
<span class="gd">-        4, 2, 1, 5, 0, 4, 32]), &#39;sha384&#39;: bytearray([48, 65, 48, 13, 6, 9, </span>
<span class="gd">-        96, 134, 72, 1, 101, 3, 4, 2, 2, 5, 0, 4, 48]), &#39;sha512&#39;: bytearray</span>
<span class="gd">-        ([48, 81, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 3, 5, 0, 4, 64])}</span>
<span class="gi">+        # There is a long history of confusion over whether the SHA1 </span>
<span class="gi">+        # algorithmIdentifier should be encoded with a NULL parameter or </span>
<span class="gi">+        # with the parameter omitted.  While the original intention was </span>
<span class="gi">+        # apparently to omit it, many toolkits went the other way.  TLS 1.2</span>
<span class="gi">+        # specifies the NULL should be included, and this behavior is also</span>
<span class="gi">+        # mandated in recent versions of PKCS #1, and is what tlslite has</span>
<span class="gi">+        # always implemented.  Anyways, verification code should probably </span>
<span class="gi">+        # accept both.</span>
<span class="gi">+        if not withNULL:</span>
<span class="gi">+            prefixBytes = bytearray([0x30, 0x1f, 0x30, 0x07, 0x06, 0x05, 0x2b,</span>
<span class="gi">+                                     0x0e, 0x03, 0x02, 0x1a, 0x04, 0x14])</span>
<span class="gi">+        else:</span>
<span class="gi">+            prefixBytes = cls._pkcs1Prefixes[&#39;sha1&#39;]</span>
<span class="gi">+        prefixedBytes = prefixBytes + hashBytes</span>
<span class="gi">+        return prefixedBytes</span>
<span class="gi">+</span>
<span class="gi">+    _pkcs1Prefixes = {&#39;md5&#39; : bytearray([0x30, 0x20, 0x30, 0x0c, 0x06, 0x08,</span>
<span class="gi">+                                         0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,</span>
<span class="gi">+                                         0x02, 0x05, 0x05, 0x00, 0x04, 0x10]),</span>
<span class="gi">+                      &#39;sha1&#39; : bytearray([0x30, 0x21, 0x30, 0x09, 0x06, 0x05,</span>
<span class="gi">+                                          0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05,</span>
<span class="gi">+                                          0x00, 0x04, 0x14]),</span>
<span class="gi">+                      &#39;sha224&#39; : bytearray([0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09,</span>
<span class="gi">+                                            0x60, 0x86, 0x48, 0x01, 0x65, 0x03,</span>
<span class="gi">+                                            0x04, 0x02, 0x04, 0x05, 0x00, 0x04,</span>
<span class="gi">+                                            0x1c]),</span>
<span class="gi">+                      &#39;sha256&#39; : bytearray([0x30, 0x31, 0x30, 0x0d, 0x06, 0x09,</span>
<span class="gi">+                                            0x60, 0x86, 0x48, 0x01, 0x65, 0x03,</span>
<span class="gi">+                                            0x04, 0x02, 0x01, 0x05, 0x00, 0x04,</span>
<span class="gi">+                                            0x20]),</span>
<span class="gi">+                      &#39;sha384&#39; : bytearray([0x30, 0x41, 0x30, 0x0d, 0x06, 0x09,</span>
<span class="gi">+                                            0x60, 0x86, 0x48, 0x01, 0x65, 0x03,</span>
<span class="gi">+                                            0x04, 0x02, 0x02, 0x05, 0x00, 0x04,</span>
<span class="gi">+                                            0x30]),</span>
<span class="gi">+                      &#39;sha512&#39; : bytearray([0x30, 0x51, 0x30, 0x0d, 0x06, 0x09,</span>
<span class="gi">+                                            0x60, 0x86, 0x48, 0x01, 0x65, 0x03,</span>
<span class="gi">+                                            0x04, 0x02, 0x03, 0x05, 0x00, 0x04,</span>
<span class="gi">+                                            0x40])}</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def addPKCS1Prefix(cls, data, hashName):
<span class="w"> </span>        &quot;&quot;&quot;Add the PKCS#1 v1.5 algorithm identifier prefix to hash bytes&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hashName = hashName.lower()</span>
<span class="gi">+        assert hashName in cls._pkcs1Prefixes</span>
<span class="gi">+        prefixBytes = cls._pkcs1Prefixes[hashName]</span>
<span class="gi">+        return prefixBytes + data</span>
<span class="gi">+</span>
<span class="gi">+    def _addPKCS1Padding(self, bytes, blockType):</span>
<span class="gi">+        padLength = (numBytes(self.n) - (len(bytes)+3))</span>
<span class="gi">+        if blockType == 1: #Signature padding</span>
<span class="gi">+            pad = [0xFF] * padLength</span>
<span class="gi">+        elif blockType == 2: #Encryption padding</span>
<span class="gi">+            pad = bytearray(0)</span>
<span class="gi">+            while len(pad) &lt; padLength:</span>
<span class="gi">+                padBytes = getRandomBytes(padLength * 2)</span>
<span class="gi">+                pad = [b for b in padBytes if b]</span>
<span class="gi">+                pad = pad[:padLength]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+</span>
<span class="gi">+        padding = bytearray([0,blockType] + pad + [0])</span>
<span class="gi">+        return padding + bytes</span>
<span class="gh">diff --git a/tlslite/utils/tackwrapper.py b/tlslite/utils/tackwrapper.py</span>
<span class="gh">index d9bb9c4..4eb39ef 100644</span>
<span class="gd">--- a/tlslite/utils/tackwrapper.py</span>
<span class="gi">+++ b/tlslite/utils/tackwrapper.py</span>
<span class="gu">@@ -1,7 +1,11 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from tack.structures.Tack import Tack
<span class="w"> </span>    from tack.structures.TackExtension import TackExtension
<span class="w"> </span>    from tack.tls.TlsCertificate import TlsCertificate
<span class="gi">+    </span>
<span class="w"> </span>    tackpyLoaded = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    tackpyLoaded = False
<span class="gh">diff --git a/tlslite/utils/tlshashlib.py b/tlslite/utils/tlshashlib.py</span>
<span class="gh">index 080311b..346f545 100644</span>
<span class="gd">--- a/tlslite/utils/tlshashlib.py</span>
<span class="gi">+++ b/tlslite/utils/tlshashlib.py</span>
<span class="gu">@@ -1,18 +1,32 @@</span>
<span class="gi">+# Author: Hubert Kario (c) 2015</span>
<span class="gi">+# see LICENCE file for legal information regarding use of this file</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;hashlib that handles FIPS mode.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# Because we are extending the hashlib module, we need to import all its</span>
<span class="gi">+# fields to suppport the same uses</span>
<span class="gi">+# pylint: disable=unused-wildcard-import, wildcard-import</span>
<span class="w"> </span>from hashlib import *
<span class="gi">+# pylint: enable=unused-wildcard-import, wildcard-import</span>
<span class="w"> </span>import hashlib


<span class="w"> </span>def _fipsFunction(func, *args, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;Make hash function support FIPS mode.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return func(*args, **kwargs)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return func(*args, usedforsecurity=False, **kwargs)</span>


<span class="gi">+# redefining the function is exactly what we intend to do</span>
<span class="gi">+# pylint: disable=function-redefined</span>
<span class="w"> </span>def md5(*args, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;MD5 constructor that works in FIPS mode.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _fipsFunction(hashlib.md5, *args, **kwargs)</span>


<span class="w"> </span>def new(*args, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;General constructor that works in FIPS mode.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _fipsFunction(hashlib.new, *args, **kwargs)</span>
<span class="gi">+# pylint: enable=function-redefined</span>
<span class="gh">diff --git a/tlslite/utils/tlshmac.py b/tlslite/utils/tlshmac.py</span>
<span class="gh">index 02030ea..789df72 100644</span>
<span class="gd">--- a/tlslite/utils/tlshmac.py</span>
<span class="gi">+++ b/tlslite/utils/tlshmac.py</span>
<span class="gu">@@ -1,23 +1,31 @@</span>
<span class="gi">+# Author: Hubert Kario (c) 2019</span>
<span class="gi">+# see LICENCE file for legal information regarding use of this file</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>HMAC module that works in FIPS mode.

<span class="w"> </span>Note that this makes this code FIPS non-compliant!
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# Because we are extending the hashlib module, we need to import all its</span>
<span class="gi">+# fields to suppport the same uses</span>
<span class="w"> </span>from . import tlshashlib
<span class="w"> </span>from .compat import compatHMAC
<span class="w"> </span>try:
<span class="w"> </span>    from hmac import compare_digest
<span class="gd">-    __all__ = [&#39;new&#39;, &#39;compare_digest&#39;, &#39;HMAC&#39;]</span>
<span class="gi">+    __all__ = [&quot;new&quot;, &quot;compare_digest&quot;, &quot;HMAC&quot;]</span>
<span class="w"> </span>except ImportError:
<span class="gd">-    __all__ = [&#39;new&#39;, &#39;HMAC&#39;]</span>
<span class="gi">+    __all__ = [&quot;new&quot;, &quot;HMAC&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from hmac import HMAC, new
<span class="gi">+    # if we can calculate HMAC on MD5, then use the built-in HMAC</span>
<span class="gi">+    # implementation</span>
<span class="w"> </span>    _val = HMAC(b&#39;some key&#39;, b&#39;msg&#39;, &#39;md5&#39;)
<span class="w"> </span>    _val.digest()
<span class="w"> </span>    del _val
<span class="w"> </span>except Exception:
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    # fallback only when MD5 doesn&#39;t work</span>
<span class="w"> </span>    class HMAC(object):
<span class="w"> </span>        &quot;&quot;&quot;Hacked version of HMAC that works in FIPS mode even with MD5.&quot;&quot;&quot;

<span class="gu">@@ -45,8 +53,8 @@ except Exception:</span>
<span class="w"> </span>            if len(key) &lt; self.block_size:
<span class="w"> </span>                key = key + b&#39;\x00&#39; * (self.block_size - len(key))
<span class="w"> </span>            key = bytearray(key)
<span class="gd">-            ipad = bytearray(b&#39;6&#39; * self.block_size)</span>
<span class="gd">-            opad = bytearray(b&#39;\\&#39; * self.block_size)</span>
<span class="gi">+            ipad = bytearray(b&#39;\x36&#39; * self.block_size)</span>
<span class="gi">+            opad = bytearray(b&#39;\x5c&#39; * self.block_size)</span>
<span class="w"> </span>            i_key = bytearray(i ^ j for i, j in zip(key, ipad))
<span class="w"> </span>            self._o_key = bytearray(i ^ j for i, j in zip(key, opad))
<span class="w"> </span>            self._context = digestmod.copy()
<span class="gu">@@ -54,6 +62,27 @@ except Exception:</span>
<span class="w"> </span>            if msg:
<span class="w"> </span>                self._context.update(compatHMAC(msg))

<span class="gi">+        def update(self, msg):</span>
<span class="gi">+            self._context.update(compatHMAC(msg))</span>
<span class="gi">+</span>
<span class="gi">+        def digest(self):</span>
<span class="gi">+            i_digest = self._context.digest()</span>
<span class="gi">+            o_hash = self.digestmod.copy()</span>
<span class="gi">+            o_hash.update(compatHMAC(self._o_key))</span>
<span class="gi">+            o_hash.update(compatHMAC(i_digest))</span>
<span class="gi">+            return o_hash.digest()</span>
<span class="gi">+</span>
<span class="gi">+        def copy(self):</span>
<span class="gi">+            new = HMAC.__new__(HMAC)</span>
<span class="gi">+            new.key = self.key</span>
<span class="gi">+            new.digestmod = self.digestmod</span>
<span class="gi">+            new.block_size = self.block_size</span>
<span class="gi">+            new.digest_size = self.digest_size</span>
<span class="gi">+            new._o_key = self._o_key</span>
<span class="gi">+            new._context = self._context.copy()</span>
<span class="gi">+            return new</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>    def new(*args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;General constructor that works in FIPS mode.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return HMAC(*args, **kwargs)</span>
<span class="gh">diff --git a/tlslite/utils/tripledes.py b/tlslite/utils/tripledes.py</span>
<span class="gh">index 70cffe5..ddcdcad 100644</span>
<span class="gd">--- a/tlslite/utils/tripledes.py</span>
<span class="gi">+++ b/tlslite/utils/tripledes.py</span>
<span class="gu">@@ -1,8 +1,9 @@</span>
<span class="gd">-&quot;&quot;&quot;Abstract class for 3DES.&quot;&quot;&quot;</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>

<span class="gi">+&quot;&quot;&quot;Abstract class for 3DES.&quot;&quot;&quot;</span>

<span class="w"> </span>class TripleDES(object):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, key, mode, IV, implementation):
<span class="w"> </span>        if len(key) != 24:
<span class="w"> </span>            raise ValueError()
<span class="gu">@@ -14,4 +15,14 @@ class TripleDES(object):</span>
<span class="w"> </span>        self.isAEAD = False
<span class="w"> </span>        self.block_size = 8
<span class="w"> </span>        self.implementation = implementation
<span class="gd">-        self.name = &#39;3des&#39;</span>
<span class="gi">+        self.name = &quot;3des&quot;</span>
<span class="gi">+</span>
<span class="gi">+    #CBC-Mode encryption, returns ciphertext</span>
<span class="gi">+    #WARNING: *MAY* modify the input as well</span>
<span class="gi">+    def encrypt(self, plaintext):</span>
<span class="gi">+        assert(len(plaintext) % 8 == 0)</span>
<span class="gi">+</span>
<span class="gi">+    #CBC-Mode decryption, returns plaintext</span>
<span class="gi">+    #WARNING: *MAY* modify the input as well</span>
<span class="gi">+    def decrypt(self, ciphertext):</span>
<span class="gi">+        assert(len(ciphertext) % 8 == 0)</span>
<span class="gh">diff --git a/tlslite/utils/x25519.py b/tlslite/utils/x25519.py</span>
<span class="gh">index c8f6173..334daad 100644</span>
<span class="gd">--- a/tlslite/utils/x25519.py</span>
<span class="gi">+++ b/tlslite/utils/x25519.py</span>
<span class="gu">@@ -1,28 +1,51 @@</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Hubert Kario (2017)</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Handling X25519 and X448 curve based key agreement protocol.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .cryptomath import bytesToNumber, numberToByteArray, divceil
<span class="gi">+# the names of the variables come directly from RFC 7748 so changing them</span>
<span class="gi">+# would make the code harder to audit/compare</span>
<span class="gi">+# pylint: disable=invalid-name</span>


<span class="w"> </span>def decodeUCoordinate(u, bits):
<span class="w"> </span>    &quot;&quot;&quot;Function to decode the public U coordinate of X25519-family curves.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if bits not in (255, 448):</span>
<span class="gi">+        raise ValueError(&quot;Invalid number of expected bits&quot;)</span>
<span class="gi">+    if bits % 8:</span>
<span class="gi">+        u[-1] &amp;= (1 &lt;&lt; (bits % 8)) - 1</span>
<span class="gi">+    return bytesToNumber(u, endian=&quot;little&quot;)</span>


<span class="w"> </span>def decodeScalar22519(k):
<span class="w"> </span>    &quot;&quot;&quot;Function to decode the private K parameter of the x25519 function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    k[0] &amp;= 248</span>
<span class="gi">+    k[31] &amp;= 127</span>
<span class="gi">+    k[31] |= 64</span>
<span class="gi">+    return bytesToNumber(k, endian=&quot;little&quot;)</span>


<span class="w"> </span>def decodeScalar448(k):
<span class="w"> </span>    &quot;&quot;&quot;Function to decode the private K parameter of the X448 function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    k[0] &amp;= 252</span>
<span class="gi">+    k[55] |= 128</span>
<span class="gi">+    return bytesToNumber(k, endian=&quot;little&quot;)</span>


<span class="w"> </span>def cswap(swap, x_2, x_3):
<span class="w"> </span>    &quot;&quot;&quot;Conditional swap function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if swap:</span>
<span class="gi">+        return x_3, x_2</span>
<span class="gi">+    else:</span>
<span class="gi">+        return x_2, x_3</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+X25519_G = numberToByteArray(9, 32, endian=&quot;little&quot;)</span>


<span class="gd">-X25519_G = numberToByteArray(9, 32, endian=&#39;little&#39;)</span>
<span class="w"> </span>X25519_ORDER_SIZE = 32


<span class="gu">@@ -38,10 +61,19 @@ def x25519(k, u):</span>

<span class="w"> </span>    :rtype: bytearray
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bits = 255</span>
<span class="gi">+    k = decodeScalar22519(k)</span>
<span class="gi">+    u = decodeUCoordinate(u, bits)</span>
<span class="gi">+</span>
<span class="gi">+    a24 = 121665</span>
<span class="gi">+    p = 2**255 - 19</span>
<span class="gi">+</span>
<span class="gi">+    return _x25519_generic(k, u, bits, a24, p)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+X448_G = numberToByteArray(5, 56, endian=&quot;little&quot;)</span>


<span class="gd">-X448_G = numberToByteArray(5, 56, endian=&#39;little&#39;)</span>
<span class="w"> </span>X448_ORDER_SIZE = 56


<span class="gu">@@ -57,9 +89,48 @@ def x448(k, u):</span>

<span class="w"> </span>    :rtype: bytearray
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bits = 448</span>
<span class="gi">+    k = decodeScalar448(k)</span>
<span class="gi">+    u = decodeUCoordinate(u, bits)</span>
<span class="gi">+</span>
<span class="gi">+    a24 = 39081</span>
<span class="gi">+    p = 2**448 - 2**224 - 1</span>
<span class="gi">+</span>
<span class="gi">+    return _x25519_generic(k, u, bits, a24, p)</span>


<span class="w"> </span>def _x25519_generic(k, u, bits, a24, p):
<span class="w"> </span>    &quot;&quot;&quot;Generic Montgomery ladder implementation of the x25519 algorithm.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    x_1 = u</span>
<span class="gi">+    x_2 = 1</span>
<span class="gi">+    z_2 = 0</span>
<span class="gi">+    x_3 = u</span>
<span class="gi">+    z_3 = 1</span>
<span class="gi">+    swap = 0</span>
<span class="gi">+</span>
<span class="gi">+    for t in range(bits-1, -1, -1):</span>
<span class="gi">+        k_t = (k &gt;&gt; t) &amp; 1</span>
<span class="gi">+        swap ^= k_t</span>
<span class="gi">+        x_2, x_3 = cswap(swap, x_2, x_3)</span>
<span class="gi">+        z_2, z_3 = cswap(swap, z_2, z_3)</span>
<span class="gi">+        swap = k_t</span>
<span class="gi">+</span>
<span class="gi">+        A = (x_2 + z_2) % p</span>
<span class="gi">+        AA = pow(A, 2, p)</span>
<span class="gi">+        B = (x_2 - z_2) % p</span>
<span class="gi">+        BB = pow(B, 2, p)</span>
<span class="gi">+        E = (AA - BB) % p</span>
<span class="gi">+        C = (x_3 + z_3) % p</span>
<span class="gi">+        D = (x_3 - z_3) % p</span>
<span class="gi">+        DA = (D * A) % p</span>
<span class="gi">+        CB = (C * B) % p</span>
<span class="gi">+        x_3 = pow(DA + CB, 2, p)</span>
<span class="gi">+        z_3 = (x_1 * pow(DA - CB, 2, p)) % p</span>
<span class="gi">+        x_2 = (AA * BB) % p</span>
<span class="gi">+        z_2 = (E * (AA + a24 * E)) % p</span>
<span class="gi">+</span>
<span class="gi">+    x_2, x_3 = cswap(swap, x_2, x_3)</span>
<span class="gi">+    z_2, z_3 = cswap(swap, z_2, z_3)</span>
<span class="gi">+    ret = (x_2 * pow(z_2, p - 2, p)) % p</span>
<span class="gi">+    return numberToByteArray(ret, divceil(bits, 8), endian=&quot;little&quot;)</span>
<span class="gi">+# pylint: enable=invalid-name</span>
<span class="gh">diff --git a/tlslite/verifierdb.py b/tlslite/verifierdb.py</span>
<span class="gh">index 4264045..0711170 100644</span>
<span class="gd">--- a/tlslite/verifierdb.py</span>
<span class="gi">+++ b/tlslite/verifierdb.py</span>
<span class="gu">@@ -1,10 +1,13 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Class for storing SRP password verifiers.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .utils.cryptomath import *
<span class="w"> </span>from .utils.compat import *
<span class="w"> </span>from tlslite import mathtls
<span class="w"> </span>from .basedb import BaseDB

<span class="gd">-</span>
<span class="w"> </span>class VerifierDB(BaseDB):
<span class="w"> </span>    &quot;&quot;&quot;This class represent an in-memory or on-disk database of SRP
<span class="w"> </span>    password verifiers.
<span class="gu">@@ -14,7 +17,6 @@ class VerifierDB(BaseDB):</span>

<span class="w"> </span>    This class is thread-safe.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, filename=None):
<span class="w"> </span>        &quot;&quot;&quot;Create a new VerifierDB instance.

<span class="gu">@@ -24,7 +26,15 @@ class VerifierDB(BaseDB):</span>
<span class="w"> </span>            this with a call to open().  To create a new on-disk database,
<span class="w"> </span>            follow this with a call to create().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        BaseDB.__init__(self, filename, b&#39;verifier&#39;)</span>
<span class="gi">+        BaseDB.__init__(self, filename, b&quot;verifier&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _getItem(self, username, valueStr):</span>
<span class="gi">+        (N, g, salt, verifier) = valueStr.split(b&quot; &quot;)</span>
<span class="gi">+        N = bytesToNumber(a2b_base64(N))</span>
<span class="gi">+        g = bytesToNumber(a2b_base64(g))</span>
<span class="gi">+        salt = a2b_base64(salt)</span>
<span class="gi">+        verifier = bytesToNumber(a2b_base64(verifier))</span>
<span class="gi">+        return (N, g, salt, verifier)</span>

<span class="w"> </span>    def __setitem__(self, username, verifierEntry):
<span class="w"> </span>        &quot;&quot;&quot;Add a verifier entry to the database.
<span class="gu">@@ -41,6 +51,24 @@ class VerifierDB(BaseDB):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        BaseDB.__setitem__(self, username, verifierEntry)

<span class="gi">+</span>
<span class="gi">+    def _setItem(self, username, value):</span>
<span class="gi">+        if len(username)&gt;=256:</span>
<span class="gi">+            raise ValueError(&quot;username too long&quot;)</span>
<span class="gi">+        N, g, salt, verifier = value</span>
<span class="gi">+        N = b2a_base64(numberToByteArray(N)).encode(&quot;ascii&quot;)</span>
<span class="gi">+        g = b2a_base64(numberToByteArray(g)).encode(&quot;ascii&quot;)</span>
<span class="gi">+        salt = b2a_base64(salt).encode(&quot;ascii&quot;)</span>
<span class="gi">+        verifier = b2a_base64(numberToByteArray(verifier)).encode(&quot;ascii&quot;)</span>
<span class="gi">+        valueStr = b&quot; &quot;.join((N, g, salt, verifier))</span>
<span class="gi">+        return valueStr</span>
<span class="gi">+</span>
<span class="gi">+    def _checkItem(self, value, username, param):</span>
<span class="gi">+        (N, g, salt, verifier) = value</span>
<span class="gi">+        x = mathtls.makeX(salt, username, param)</span>
<span class="gi">+        v = powMod(g, x, N)</span>
<span class="gi">+        return (verifier == v)</span>
<span class="gi">+</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def makeVerifier(username, password, bits):
<span class="w"> </span>        &quot;&quot;&quot;Create a verifier entry which can be stored in a VerifierDB.
<span class="gu">@@ -61,4 +89,12 @@ class VerifierDB(BaseDB):</span>
<span class="w"> </span>        :rtype: tuple
<span class="w"> </span>        :returns: A tuple which may be stored in a VerifierDB.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(username, str):</span>
<span class="gi">+            usernameBytes = bytearray(username, &quot;utf-8&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            usernameBytes = bytearray(username)</span>
<span class="gi">+        if isinstance(password, str):</span>
<span class="gi">+            passwordBytes = bytearray(password, &quot;utf-8&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            passwordBytes = bytearray(password)</span>
<span class="gi">+        return mathtls.makeVerifier(usernameBytes, passwordBytes, bits)</span>
<span class="gh">diff --git a/tlslite/x509.py b/tlslite/x509.py</span>
<span class="gh">index 5c37622..5fe53f8 100644</span>
<span class="gd">--- a/tlslite/x509.py</span>
<span class="gi">+++ b/tlslite/x509.py</span>
<span class="gu">@@ -1,8 +1,17 @@</span>
<span class="gi">+# Authors:</span>
<span class="gi">+#   Trevor Perrin</span>
<span class="gi">+#   Google - parsing subject field</span>
<span class="gi">+#</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Class representing an X.509 certificate.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from ecdsa.keys import VerifyingKey
<span class="gi">+</span>
<span class="w"> </span>from .utils.asn1parser import ASN1Parser
<span class="w"> </span>from .utils.cryptomath import *
<span class="gd">-from .utils.keyfactory import _createPublicRSAKey, _create_public_ecdsa_key, _create_public_dsa_key, _create_public_eddsa_key</span>
<span class="gi">+from .utils.keyfactory import _createPublicRSAKey, _create_public_ecdsa_key, \</span>
<span class="gi">+    _create_public_dsa_key, _create_public_eddsa_key</span>
<span class="w"> </span>from .utils.pem import *
<span class="w"> </span>from .utils.compat import compatHMAC, b2a_hex
<span class="w"> </span>from .constants import AlgorithmOID, RSA_PSS_OID
<span class="gu">@@ -43,13 +52,13 @@ class X509(object):</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Compare other object for equality.&quot;&quot;&quot;
<span class="gd">-        if not hasattr(other, &#39;bytes&#39;):</span>
<span class="gi">+        if not hasattr(other, &quot;bytes&quot;):</span>
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.bytes == other.bytes

<span class="w"> </span>    def __ne__(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Compare with other object for inequality.&quot;&quot;&quot;
<span class="gd">-        if not hasattr(other, &#39;bytes&#39;):</span>
<span class="gi">+        if not hasattr(other, &quot;bytes&quot;):</span>
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return not self == other

<span class="gu">@@ -62,7 +71,9 @@ class X509(object):</span>
<span class="w"> </span>            certificate wrapped with &quot;-----BEGIN CERTIFICATE-----&quot; and
<span class="w"> </span>            &quot;-----END CERTIFICATE-----&quot; tags).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        bytes = dePem(s, &quot;CERTIFICATE&quot;)</span>
<span class="gi">+        self.parseBinary(bytes)</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def parseBinary(self, cert_bytes):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -71,7 +82,94 @@ class X509(object):</span>
<span class="w"> </span>        :type bytes: L{str} (in python2) or L{bytearray} of unsigned bytes
<span class="w"> </span>        :param bytes: A DER-encoded X.509 certificate.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.bytes = bytearray(cert_bytes)</span>
<span class="gi">+        parser = ASN1Parser(self.bytes)</span>
<span class="gi">+</span>
<span class="gi">+        # Get the SignatureAlgorithm</span>
<span class="gi">+        signature_algorithm_identifier = parser.getChild(1)</span>
<span class="gi">+        self.sigalg = bytes(signature_algorithm_identifier.getChildBytes(0))</span>
<span class="gi">+</span>
<span class="gi">+        # Finally get the (hash, signature) pair coresponding to it</span>
<span class="gi">+        # If it is rsa-pss we need to check the aditional parameters field</span>
<span class="gi">+        # to extract the hash algorithm</span>
<span class="gi">+        if self.sigalg == RSA_PSS_OID:</span>
<span class="gi">+            sigalg_hash = signature_algorithm_identifier.getChild(1)</span>
<span class="gi">+            sigalg_hash = bytes(sigalg_hash.getChild(0).value)</span>
<span class="gi">+            self.sigalg = AlgorithmOID.oid[sigalg_hash]</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.sigalg = AlgorithmOID.oid[self.sigalg]</span>
<span class="gi">+</span>
<span class="gi">+        # Get the tbsCertificate</span>
<span class="gi">+        tbs_certificate = parser.getChild(0)</span>
<span class="gi">+        # Is the optional version field present?</span>
<span class="gi">+        # This determines which index the key is at.</span>
<span class="gi">+        if tbs_certificate.value[0] == 0xA0:</span>
<span class="gi">+            serial_number_index = 1</span>
<span class="gi">+            subject_public_key_info_index = 6</span>
<span class="gi">+        else:</span>
<span class="gi">+            serial_number_index = 0</span>
<span class="gi">+            subject_public_key_info_index = 5</span>
<span class="gi">+</span>
<span class="gi">+        # Get serial number</span>
<span class="gi">+        self.serial_number = bytesToNumber(tbs_certificate.getChild(serial_number_index).value)</span>
<span class="gi">+</span>
<span class="gi">+        # Get the issuer</span>
<span class="gi">+        self.issuer = tbs_certificate.getChildBytes(</span>
<span class="gi">+            subject_public_key_info_index - 3)</span>
<span class="gi">+</span>
<span class="gi">+        # Get the subject</span>
<span class="gi">+        self.subject = tbs_certificate.getChildBytes(</span>
<span class="gi">+            subject_public_key_info_index - 1)</span>
<span class="gi">+</span>
<span class="gi">+        # Get the subjectPublicKeyInfo</span>
<span class="gi">+        subject_public_key_info = tbs_certificate.getChild(</span>
<span class="gi">+            subject_public_key_info_index)</span>
<span class="gi">+</span>
<span class="gi">+        # Get the AlgorithmIdentifier</span>
<span class="gi">+        alg_identifier = subject_public_key_info.getChild(0)</span>
<span class="gi">+        alg_identifier_len = alg_identifier.getChildCount()</span>
<span class="gi">+</span>
<span class="gi">+        # first item of AlgorithmIdentifier is the algorithm</span>
<span class="gi">+        alg = alg_identifier.getChild(0)</span>
<span class="gi">+        alg_oid = alg.value</span>
<span class="gi">+        if list(alg_oid) == [42, 134, 72, 134, 247, 13, 1, 1, 1]:</span>
<span class="gi">+            self.certAlg = &quot;rsa&quot;</span>
<span class="gi">+        elif list(alg_oid) == [42, 134, 72, 134, 247, 13, 1, 1, 10]:</span>
<span class="gi">+            self.certAlg = &quot;rsa-pss&quot;</span>
<span class="gi">+        elif list(alg_oid) == [42, 134, 72, 206, 56, 4, 1]:</span>
<span class="gi">+            self.certAlg = &quot;dsa&quot;</span>
<span class="gi">+        elif list(alg_oid) == [42, 134, 72, 206, 61, 2, 1]:</span>
<span class="gi">+            self.certAlg = &quot;ecdsa&quot;</span>
<span class="gi">+        elif list(alg_oid) == [43, 101, 112]:</span>
<span class="gi">+            self.certAlg = &quot;Ed25519&quot;</span>
<span class="gi">+        elif list(alg_oid) == [43, 101, 113]:</span>
<span class="gi">+            self.certAlg = &quot;Ed448&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise SyntaxError(&quot;Unrecognized AlgorithmIdentifier&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # for RSA the parameters of AlgorithmIdentifier shuld be a NULL</span>
<span class="gi">+        if self.certAlg == &quot;rsa&quot;:</span>
<span class="gi">+            if alg_identifier_len != 2:</span>
<span class="gi">+                raise SyntaxError(&quot;Missing parameters in AlgorithmIdentifier&quot;)</span>
<span class="gi">+            params = alg_identifier.getChild(1)</span>
<span class="gi">+            if params.value != bytearray(0):</span>
<span class="gi">+                raise SyntaxError(&quot;Unexpected non-NULL parameters in &quot;</span>
<span class="gi">+                                  &quot;AlgorithmIdentifier&quot;)</span>
<span class="gi">+        elif self.certAlg == &quot;ecdsa&quot;:</span>
<span class="gi">+            self._ecdsa_pubkey_parsing(</span>
<span class="gi">+                tbs_certificate.getChildBytes(subject_public_key_info_index))</span>
<span class="gi">+            return</span>
<span class="gi">+        elif self.certAlg == &quot;dsa&quot;:</span>
<span class="gi">+            self._dsa_pubkey_parsing(subject_public_key_info)</span>
<span class="gi">+            return</span>
<span class="gi">+        elif self.certAlg == &quot;Ed25519&quot; or self.certAlg == &quot;Ed448&quot;:</span>
<span class="gi">+            self._eddsa_pubkey_parsing(</span>
<span class="gi">+                tbs_certificate.getChildBytes(subject_public_key_info_index))</span>
<span class="gi">+            return</span>
<span class="gi">+        else:  # rsa-pss</span>
<span class="gi">+            pass  # ignore parameters, if any - don&#39;t apply key restrictions</span>
<span class="gi">+</span>
<span class="gi">+        self._rsa_pubkey_parsing(subject_public_key_info)</span>

<span class="w"> </span>    def _eddsa_pubkey_parsing(self, subject_public_key_info):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -80,7 +178,15 @@ class X509(object):</span>
<span class="w"> </span>        :param subject_public_key_info: bytes like object with the DER encoded
<span class="w"> </span>            public key in it
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            # python ecdsa knows how to parse curve OIDs so re-use that</span>
<span class="gi">+            # code</span>
<span class="gi">+            public_key = VerifyingKey.from_der(compatHMAC(</span>
<span class="gi">+                subject_public_key_info))</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise SyntaxError(&quot;Malformed or unsupported public key in &quot;</span>
<span class="gi">+                              &quot;certificate&quot;)</span>
<span class="gi">+        self.publicKey = _create_public_eddsa_key(public_key)</span>

<span class="w"> </span>    def _rsa_pubkey_parsing(self, subject_public_key_info):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -89,7 +195,31 @@ class X509(object):</span>
<span class="w"> </span>        :param subject_public_key_info: ASN1Parser object with subject
<span class="w"> </span>            public key info of X.509 certificate
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # Get the subjectPublicKey</span>
<span class="gi">+        subject_public_key = subject_public_key_info.getChild(1)</span>
<span class="gi">+        self.subject_public_key = subject_public_key_info.getChildBytes(1)</span>
<span class="gi">+        self.subject_public_key = ASN1Parser(self.subject_public_key).value[1:]</span>
<span class="gi">+</span>
<span class="gi">+        # Adjust for BIT STRING encapsulation</span>
<span class="gi">+        if subject_public_key.value[0]:</span>
<span class="gi">+            raise SyntaxError()</span>
<span class="gi">+        subject_public_key = ASN1Parser(subject_public_key.value[1:])</span>
<span class="gi">+</span>
<span class="gi">+        # Get the modulus and exponent</span>
<span class="gi">+        modulus = subject_public_key.getChild(0)</span>
<span class="gi">+        public_exponent = subject_public_key.getChild(1)</span>
<span class="gi">+</span>
<span class="gi">+        # Decode them into numbers</span>
<span class="gi">+        # pylint: disable=invalid-name</span>
<span class="gi">+        # &#39;n&#39; and &#39;e&#39; are the universally used parameters in RSA algorithm</span>
<span class="gi">+        # definition</span>
<span class="gi">+        n = bytesToNumber(modulus.value)</span>
<span class="gi">+        e = bytesToNumber(public_exponent.value)</span>
<span class="gi">+</span>
<span class="gi">+        # Create a public key instance</span>
<span class="gi">+        self.publicKey = _createPublicRSAKey(n, e, self.certAlg)</span>
<span class="gi">+        # pylint: enable=invalid-name</span>

<span class="w"> </span>    def _ecdsa_pubkey_parsing(self, subject_public_key_info):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -98,7 +228,18 @@ class X509(object):</span>
<span class="w"> </span>        :param subject_public_key_info: bytes like object with DER encoded
<span class="w"> </span>            public key in it
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            # python ecdsa knows how to parse curve OIDs so re-use that</span>
<span class="gi">+            # code</span>
<span class="gi">+            public_key = VerifyingKey.from_der(compatHMAC(</span>
<span class="gi">+                subject_public_key_info))</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise SyntaxError(&quot;Malformed or unsupported public key in &quot;</span>
<span class="gi">+                              &quot;certificate&quot;)</span>
<span class="gi">+        x = public_key.pubkey.point.x()</span>
<span class="gi">+        y = public_key.pubkey.point.y()</span>
<span class="gi">+        curve_name = public_key.curve.name</span>
<span class="gi">+        self.publicKey = _create_public_ecdsa_key(x, y, curve_name)</span>

<span class="w"> </span>    def _dsa_pubkey_parsing(self, subject_public_key_info):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -107,7 +248,28 @@ class X509(object):</span>
<span class="w"> </span>        :param subject_public_key_info: bytes like object with DER encoded
<span class="w"> </span>          global parameters and public key in it
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        global_parameters = (subject_public_key_info.getChild(0)).getChild(1)</span>
<span class="gi">+        # Get the subjectPublicKey</span>
<span class="gi">+        public_key = subject_public_key_info.getChild(1)</span>
<span class="gi">+</span>
<span class="gi">+        # Adjust for BIT STRING encapsulation and get hex value</span>
<span class="gi">+        if public_key.value[0]:</span>
<span class="gi">+            raise SyntaxError()</span>
<span class="gi">+        y = ASN1Parser(public_key.value[1:])</span>
<span class="gi">+</span>
<span class="gi">+        # Get the {A, p, q}</span>
<span class="gi">+        p = global_parameters.getChild(0)</span>
<span class="gi">+        q = global_parameters.getChild(1)</span>
<span class="gi">+        g = global_parameters.getChild(2)</span>
<span class="gi">+</span>
<span class="gi">+        # Decode them into numbers</span>
<span class="gi">+        y = bytesToNumber(y.value)</span>
<span class="gi">+        p = bytesToNumber(p.value)</span>
<span class="gi">+        q = bytesToNumber(q.value)</span>
<span class="gi">+        g = bytesToNumber(g.value)</span>
<span class="gi">+</span>
<span class="gi">+        # Create a public key instance</span>
<span class="gi">+        self.publicKey = _create_public_dsa_key(p, q, g, y)</span>

<span class="w"> </span>    def getFingerprint(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -116,8 +278,10 @@ class X509(object):</span>
<span class="w"> </span>        :rtype: str
<span class="w"> </span>        :returns: A hex-encoded fingerprint.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return b2a_hex(SHA1(self.bytes))</span>

<span class="w"> </span>    def writeBytes(self):
<span class="w"> </span>        &quot;&quot;&quot;Serialise object to a DER encoded string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.bytes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gh">diff --git a/tlslite/x509certchain.py b/tlslite/x509certchain.py</span>
<span class="gh">index 54183ce..0d1232b 100644</span>
<span class="gd">--- a/tlslite/x509certchain.py</span>
<span class="gi">+++ b/tlslite/x509certchain.py</span>
<span class="gu">@@ -1,10 +1,13 @@</span>
<span class="gi">+# Author: Trevor Perrin</span>
<span class="gi">+# See the LICENSE file for legal information regarding use of this file.</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Class representing an X.509 certificate chain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .utils import cryptomath
<span class="w"> </span>from .utils.tackwrapper import *
<span class="w"> </span>from .utils.pem import *
<span class="w"> </span>from .x509 import X509

<span class="gd">-</span>
<span class="w"> </span>class X509CertChain(object):
<span class="w"> </span>    &quot;&quot;&quot;This class represents a chain of X.509 certificates.

<span class="gu">@@ -33,13 +36,13 @@ class X509CertChain(object):</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Compare objects with each-other.&quot;&quot;&quot;
<span class="gd">-        if not hasattr(other, &#39;x509List&#39;):</span>
<span class="gi">+        if not hasattr(other, &quot;x509List&quot;):</span>
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.x509List == other.x509List

<span class="w"> </span>    def __ne__(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Compare object for inequality.&quot;&quot;&quot;
<span class="gd">-        if not hasattr(other, &#39;x509List&#39;):</span>
<span class="gi">+        if not hasattr(other, &quot;x509List&quot;):</span>
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.x509List != other.x509List

<span class="gu">@@ -48,21 +51,29 @@ class X509CertChain(object):</span>

<span class="w"> </span>        Raise a SyntaxError if input is malformed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x509List = []</span>
<span class="gi">+        bList = dePemList(s, &quot;CERTIFICATE&quot;)</span>
<span class="gi">+        for b in bList:</span>
<span class="gi">+            x509 = X509()</span>
<span class="gi">+            x509.parseBinary(b)</span>
<span class="gi">+            x509List.append(x509)</span>
<span class="gi">+        self.x509List = x509List</span>

<span class="w"> </span>    def getNumCerts(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the number of certificates in this chain.

<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.x509List)</span>

<span class="w"> </span>    def getEndEntityPublicKey(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the public key from the end-entity certificate.

<span class="w"> </span>        :rtype: ~tlslite.utils.rsakey.RSAKey`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.getNumCerts() == 0:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+        return self.x509List[0].publicKey</span>

<span class="w"> </span>    def getFingerprint(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the hex-encoded fingerprint of the end-entity certificate.
<span class="gu">@@ -70,8 +81,27 @@ class X509CertChain(object):</span>
<span class="w"> </span>        :rtype: str
<span class="w"> </span>        :returns: A hex-encoded fingerprint.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        if self.getNumCerts() == 0:</span>
<span class="gi">+            raise AssertionError()</span>
<span class="gi">+        return self.x509List[0].getFingerprint()</span>
<span class="gi">+</span>
<span class="gi">+    def checkTack(self, tack):</span>
<span class="gi">+        if self.x509List:</span>
<span class="gi">+            tlsCert = TlsCertificate(self.x509List[0].bytes)</span>
<span class="gi">+            if tlsCert.matches(tack):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+        </span>
<span class="w"> </span>    def getTackExt(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the TACK and/or Break Sigs from a TACK Cert in the chain.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tackExt = None</span>
<span class="gi">+        # Search list in backwards order</span>
<span class="gi">+        for x509 in self.x509List[::-1]:</span>
<span class="gi">+            tlsCert = TlsCertificate(x509.bytes)</span>
<span class="gi">+            if tlsCert.tackExt:</span>
<span class="gi">+                if tackExt:</span>
<span class="gi">+                    raise SyntaxError(&quot;Multiple TACK Extensions&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    tackExt = tlsCert.tackExt</span>
<span class="gi">+        return tackExt</span>
<span class="gi">+                </span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>