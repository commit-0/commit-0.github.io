
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands joblib - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-joblib" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands joblib
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-test" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test test
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-joblib"><strong>OpenHands</strong>: joblib</h1>
<h2 id="failed-to-run-pytests-for-test-test">Failed to run pytests for test <code>test</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/conftest.py&#39;.
conftest.py:9: in &lt;module&gt;
    from joblib.parallel import mp
joblib/__init__.py:129: in &lt;module&gt;
    from .parallel import Parallel
joblib/parallel.py:23: in &lt;module&gt;
    from ._parallel_backends import FallbackToBackend, MultiprocessingBackend, ThreadingBackend, SequentialBackend, LokyBackend
joblib/_parallel_backends.py:10: in &lt;module&gt;
    from ._utils import _TracebackCapturingWrapper, _retrieve_traceback_capturing_wrapped_call
joblib/_utils.py:6: in &lt;module&gt;
    from .externals.loky.process_executor import _ExceptionWithTraceback
joblib/externals/loky/__init__.py:19: in &lt;module&gt;
    from .backend.reduction import set_loky_pickler
joblib/externals/loky/backend/reduction.py:49: in &lt;module&gt;
    from joblib.externals import cloudpickle
joblib/externals/cloudpickle/__init__.py:1: in &lt;module&gt;
    from . import cloudpickle
joblib/externals/cloudpickle/cloudpickle.py:501: in &lt;module&gt;
    class Pickler(pickle.Pickler):
joblib/externals/cloudpickle/cloudpickle.py:503: in Pickler
    _dispatch_table[classmethod] = _classmethod_reduce
E   NameError: name &#39;_classmethod_reduce&#39; is not defined
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/joblib/backports.py b/joblib/backports.py</span>
<span class="gh">index ed11ccb..63a9151 100644</span>
<span class="gd">--- a/joblib/backports.py</span>
<span class="gi">+++ b/joblib/backports.py</span>
<span class="gu">@@ -74,6 +74,33 @@ class LooseVersion(Version):</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &quot;LooseVersion (&#39;%s&#39;)&quot; % str(self)
<span class="gi">+def _concurrency_safe_rename_win32(src, dst):</span>
<span class="gi">+    &quot;&quot;&quot;Renames ``src`` into ``dst`` overwriting ``dst`` if it exists.</span>
<span class="gi">+</span>
<span class="gi">+    On Windows os.replace can yield permission errors if executed by two</span>
<span class="gi">+    different processes.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    max_retries = 10</span>
<span class="gi">+    retry_delay = 0.001  # Initial delay set to 1ms</span>
<span class="gi">+    for i in range(max_retries):</span>
<span class="gi">+        try:</span>
<span class="gi">+            replace(src, dst)</span>
<span class="gi">+            break</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            if e.winerror not in access_denied_errors:</span>
<span class="gi">+                raise</span>
<span class="gi">+            if i == max_retries - 1:</span>
<span class="gi">+                raise</span>
<span class="gi">+            time.sleep(retry_delay)</span>
<span class="gi">+            retry_delay *= 1.5</span>
<span class="gi">+</span>
<span class="gi">+if os.name == &#39;nt&#39;:</span>
<span class="gi">+    access_denied_errors = (5, 13)</span>
<span class="gi">+    from os import replace</span>
<span class="gi">+    concurrency_safe_rename = _concurrency_safe_rename_win32</span>
<span class="gi">+else:</span>
<span class="gi">+    from os import replace as concurrency_safe_rename</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import numpy as np

<span class="gu">@@ -90,18 +117,12 @@ try:</span>
<span class="w"> </span>          newly-created memmap that sends a maybe_unlink request for the
<span class="w"> </span>          memmaped file to resource_tracker.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if unlink_on_gc_collect:</span>
<span class="gi">+            util.finalize(np.memmap(filename, dtype=dtype, mode=mode,</span>
<span class="gi">+                                  offset=offset, shape=shape, order=order),</span>
<span class="gi">+                        util.get_context().resource_tracker.maybe_unlink,</span>
<span class="gi">+                        [filename])</span>
<span class="gi">+        return np.memmap(filename, dtype=dtype, mode=mode,</span>
<span class="gi">+                        offset=offset, shape=shape, order=order)</span>
<span class="w"> </span>except ImportError:
<span class="gd">-if os.name == &#39;nt&#39;:</span>
<span class="gd">-    access_denied_errors = (5, 13)</span>
<span class="gd">-    from os import replace</span>
<span class="gd">-</span>
<span class="gd">-    def concurrency_safe_rename(src, dst):</span>
<span class="gd">-        &quot;&quot;&quot;Renames ``src`` into ``dst`` overwriting ``dst`` if it exists.</span>
<span class="gd">-</span>
<span class="gd">-        On Windows os.replace can yield permission errors if executed by two</span>
<span class="gd">-        different processes.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-else:</span>
<span class="gd">-    from os import replace as concurrency_safe_rename</span>
\ No newline at end of file
<span class="gi">+    make_memmap = None</span>
\ No newline at end of file
<span class="gh">diff --git a/joblib/externals/cloudpickle/cloudpickle.py b/joblib/externals/cloudpickle/cloudpickle.py</span>
<span class="gh">index 2c5102a..7d05776 100644</span>
<span class="gd">--- a/joblib/externals/cloudpickle/cloudpickle.py</span>
<span class="gi">+++ b/joblib/externals/cloudpickle/cloudpickle.py</span>
<span class="gu">@@ -118,7 +118,24 @@ def _whichmodule(obj, name):</span>
<span class="w"> </span>    - Errors arising during module introspection are ignored, as those errors
<span class="w"> </span>      are considered unwanted side effects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(obj, type) and obj.__module__ == &#39;__main__&#39;:</span>
<span class="gi">+        return obj.__module__</span>
<span class="gi">+</span>
<span class="gi">+    module_name = getattr(obj, &#39;__module__&#39;, None)</span>
<span class="gi">+    if module_name is not None:</span>
<span class="gi">+        return module_name</span>
<span class="gi">+</span>
<span class="gi">+    # Protect the iteration by using a copy of sys.modules against dynamic</span>
<span class="gi">+    # modules that trigger imports of other modules upon calls to getattr</span>
<span class="gi">+    for module_name, module in list(sys.modules.items()):</span>
<span class="gi">+        if module_name == &#39;__main__&#39; or module is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            if _getattribute(module, name)[0] is obj:</span>
<span class="gi">+                return module_name</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+    return None</span>

<span class="w"> </span>def _should_pickle_by_reference(obj, name=None):
<span class="w"> </span>    &quot;&quot;&quot;Test whether an function or a class should be pickled by reference
<span class="gu">@@ -134,11 +151,58 @@ def _should_pickle_by_reference(obj, name=None):</span>
<span class="w"> </span>    functions and classes or for attributes of modules that have been
<span class="w"> </span>    explicitly registered to be pickled by value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name is None:</span>
<span class="gi">+        name = getattr(obj, &#39;__name__&#39;, None)</span>
<span class="gi">+    if name is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    module_name = _whichmodule(obj, name)</span>
<span class="gi">+    if module_name is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if module_name == &quot;__main__&quot;:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    module = sys.modules.get(module_name, None)</span>
<span class="gi">+    if module is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if module_name in _PICKLE_BY_VALUE_MODULES:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if not hasattr(module, &quot;__file__&quot;):</span>
<span class="gi">+        # Module is not a regular Python module with source code, for instance</span>
<span class="gi">+        # it could live in a zip file as this is the case for stdlib modules in</span>
<span class="gi">+        # the Windows binary distribution of Python.</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # Check if the module has been explicitly registered to be pickled by value</span>
<span class="gi">+    if module.__file__ is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>

<span class="w"> </span>def _extract_code_globals(co):
<span class="w"> </span>    &quot;&quot;&quot;Find all globals names read or written to by codeblock co.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if co in _extract_code_globals_cache:</span>
<span class="gi">+        return _extract_code_globals_cache[co]</span>
<span class="gi">+</span>
<span class="gi">+    out_names = set()</span>
<span class="gi">+    for instr in _walk_global_ops(co):</span>
<span class="gi">+        if instr.opname in (&quot;LOAD_GLOBAL&quot;, &quot;STORE_GLOBAL&quot;, &quot;DELETE_GLOBAL&quot;):</span>
<span class="gi">+            # Extract the names of globals that are read/written to by adding</span>
<span class="gi">+            # `LOAD_GLOBAL`, `STORE_GLOBAL`, `DELETE_GLOBAL` opcodes</span>
<span class="gi">+            # to `out_names`.</span>
<span class="gi">+            out_names.add(co.co_names[instr.arg])</span>
<span class="gi">+</span>
<span class="gi">+    # Add the names of the global variables used in nested functions</span>
<span class="gi">+    if co.co_consts:</span>
<span class="gi">+        for const in co.co_consts:</span>
<span class="gi">+            if isinstance(const, types.CodeType):</span>
<span class="gi">+                out_names.update(_extract_code_globals(const))</span>
<span class="gi">+</span>
<span class="gi">+    _extract_code_globals_cache[co] = out_names</span>
<span class="gi">+    return out_names</span>

<span class="w"> </span>def _find_imported_submodules(code, top_level_dependencies):
<span class="w"> </span>    &quot;&quot;&quot;Find currently imported submodules used by a function.
<span class="gu">@@ -165,7 +229,34 @@ def _find_imported_submodules(code, top_level_dependencies):</span>
<span class="w"> </span>    that calling func once depickled does not fail due to concurrent.futures
<span class="w"> </span>    not being imported
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    submodules = []</span>
<span class="gi">+    for name in code.co_names:</span>
<span class="gi">+        for module_name, module in list(sys.modules.items()):</span>
<span class="gi">+            if module_name == &#39;__main__&#39; or module is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Skip modules that are not in the top-level dependencies</span>
<span class="gi">+            is_dependency = False</span>
<span class="gi">+            for dependency in top_level_dependencies:</span>
<span class="gi">+                if module_name == dependency.__name__:</span>
<span class="gi">+                    is_dependency = True</span>
<span class="gi">+                    break</span>
<span class="gi">+                if module_name.startswith(dependency.__name__ + &#39;.&#39;):</span>
<span class="gi">+                    is_dependency = True</span>
<span class="gi">+                    break</span>
<span class="gi">+            if not is_dependency:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if hasattr(module, name) and getattr(module, name) is not None:</span>
<span class="gi">+                submodules.append(module)</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    # Find submodules in nested code objects</span>
<span class="gi">+    for const in code.co_consts:</span>
<span class="gi">+        if isinstance(const, types.CodeType):</span>
<span class="gi">+            submodules.extend(_find_imported_submodules(const, top_level_dependencies))</span>
<span class="gi">+</span>
<span class="gi">+    return submodules</span>
<span class="w"> </span>STORE_GLOBAL = opcode.opmap[&#39;STORE_GLOBAL&#39;]
<span class="w"> </span>DELETE_GLOBAL = opcode.opmap[&#39;DELETE_GLOBAL&#39;]
<span class="w"> </span>LOAD_GLOBAL = opcode.opmap[&#39;LOAD_GLOBAL&#39;]
<span class="gu">@@ -179,18 +270,27 @@ for k, v in types.__dict__.items():</span>

<span class="w"> </span>def _walk_global_ops(code):
<span class="w"> </span>    &quot;&quot;&quot;Yield referenced name for global-referencing instructions in code.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for instr in dis.get_instructions(code):</span>
<span class="gi">+        op = instr.opcode</span>
<span class="gi">+        if op in GLOBAL_OPS:</span>
<span class="gi">+            yield instr</span>

<span class="w"> </span>def _extract_class_dict(cls):
<span class="w"> </span>    &quot;&quot;&quot;Retrieve a copy of the dict of a class without the inherited method.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    clsdict = dict(cls.__dict__)</span>
<span class="gi">+    if len(cls.__bases__) == 1:</span>
<span class="gi">+        inherited_dict = cls.__bases__[0].__dict__</span>
<span class="gi">+        for name, value in inherited_dict.items():</span>
<span class="gi">+            if name in clsdict and clsdict[name] is value:</span>
<span class="gi">+                clsdict.pop(name)</span>
<span class="gi">+    return clsdict</span>

<span class="w"> </span>def is_tornado_coroutine(func):
<span class="w"> </span>    &quot;&quot;&quot;Return whether `func` is a Tornado coroutine function.

<span class="w"> </span>    Running coroutines are not supported.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return getattr(func, &#39;_is_coroutine&#39;, False)</span>

<span class="w"> </span>def instance(cls):
<span class="w"> </span>    &quot;&quot;&quot;Create a new instance of a class.
<span class="gu">@@ -205,7 +305,7 @@ def instance(cls):</span>
<span class="w"> </span>    instance : cls
<span class="w"> </span>        A new instance of ``cls``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return cls()</span>

<span class="w"> </span>@instance
<span class="w"> </span>class _empty_cell_value:
<span class="gu">@@ -226,7 +326,28 @@ def _make_skeleton_class(type_constructor, name, bases, type_kwargs, class_track</span>
<span class="w"> </span>    The &quot;extra&quot; variable is meant to be a dict (or None) that can be used for
<span class="w"> </span>    forward compatibility shall the need arise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if class_tracker_id is not None:</span>
<span class="gi">+        if class_tracker_id in _DYNAMIC_CLASS_TRACKER_BY_ID:</span>
<span class="gi">+            return _DYNAMIC_CLASS_TRACKER_BY_ID[class_tracker_id]</span>
<span class="gi">+</span>
<span class="gi">+    # Build a new class with a custom metaclass that will make the class</span>
<span class="gi">+    # definition available via the class tracker at unpickling time.</span>
<span class="gi">+    class Meta(type):</span>
<span class="gi">+        def __new__(metacls, name, bases, clsdict):</span>
<span class="gi">+            return super().__new__(metacls, name, bases, clsdict)</span>
<span class="gi">+</span>
<span class="gi">+    # Create a new class with an empty dictionary</span>
<span class="gi">+    clsdict = {}</span>
<span class="gi">+    for k, v in type_kwargs.items():</span>
<span class="gi">+        clsdict[k] = v</span>
<span class="gi">+</span>
<span class="gi">+    cls = Meta(name, bases, clsdict)</span>
<span class="gi">+</span>
<span class="gi">+    if class_tracker_id is not None:</span>
<span class="gi">+        _DYNAMIC_CLASS_TRACKER_BY_ID[class_tracker_id] = cls</span>
<span class="gi">+        _DYNAMIC_CLASS_TRACKER_BY_CLASS[cls] = class_tracker_id</span>
<span class="gi">+</span>
<span class="gi">+    return cls</span>

<span class="w"> </span>def _make_skeleton_enum(bases, name, qualname, members, module, class_tracker_id, extra):
<span class="w"> </span>    &quot;&quot;&quot;Build dynamic enum with an empty __dict__ to be filled once memoized
<span class="gu">@@ -242,19 +363,70 @@ def _make_skeleton_enum(bases, name, qualname, members, module, class_tracker_id</span>
<span class="w"> </span>    The &quot;extra&quot; variable is meant to be a dict (or None) that can be used for
<span class="w"> </span>    forward compatibility shall the need arise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if class_tracker_id is not None:</span>
<span class="gi">+        if class_tracker_id in _DYNAMIC_CLASS_TRACKER_BY_ID:</span>
<span class="gi">+            return _DYNAMIC_CLASS_TRACKER_BY_ID[class_tracker_id]</span>
<span class="gi">+</span>
<span class="gi">+    metacls = type(bases[0]) if bases else type(Enum)</span>
<span class="gi">+    classdict = metacls.__prepare__(name, bases)</span>
<span class="gi">+</span>
<span class="gi">+    # Create a new Enum class</span>
<span class="gi">+    enum_class = metacls.__new__(metacls, name, bases, classdict)</span>
<span class="gi">+    enum_class.__module__ = module</span>
<span class="gi">+    enum_class.__qualname__ = qualname</span>
<span class="gi">+</span>
<span class="gi">+    # Create the enum members</span>
<span class="gi">+    for member_name, member_value in members:</span>
<span class="gi">+        enum_member = enum_class._member_type_.__new__(</span>
<span class="gi">+            enum_class._member_type_, member_name)</span>
<span class="gi">+        enum_member._name_ = member_name</span>
<span class="gi">+        enum_member._value_ = member_value</span>
<span class="gi">+        setattr(enum_class, member_name, enum_member)</span>
<span class="gi">+</span>
<span class="gi">+    if class_tracker_id is not None:</span>
<span class="gi">+        _DYNAMIC_CLASS_TRACKER_BY_ID[class_tracker_id] = enum_class</span>
<span class="gi">+        _DYNAMIC_CLASS_TRACKER_BY_CLASS[enum_class] = class_tracker_id</span>
<span class="gi">+</span>
<span class="gi">+    return enum_class</span>

<span class="w"> </span>def _code_reduce(obj):
<span class="w"> </span>    &quot;&quot;&quot;code object reducer.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(obj, &quot;co_posonlyargcount&quot;):</span>
<span class="gi">+        args = (</span>
<span class="gi">+            obj.co_argcount, obj.co_posonlyargcount,</span>
<span class="gi">+            obj.co_kwonlyargcount, obj.co_nlocals,</span>
<span class="gi">+            obj.co_stacksize, obj.co_flags, obj.co_code,</span>
<span class="gi">+            obj.co_consts, obj.co_names, obj.co_varnames,</span>
<span class="gi">+            obj.co_filename, obj.co_name, obj.co_firstlineno,</span>
<span class="gi">+            obj.co_lnotab, obj.co_freevars, obj.co_cellvars,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        args = (</span>
<span class="gi">+            obj.co_argcount, obj.co_kwonlyargcount,</span>
<span class="gi">+            obj.co_nlocals, obj.co_stacksize, obj.co_flags,</span>
<span class="gi">+            obj.co_code, obj.co_consts, obj.co_names,</span>
<span class="gi">+            obj.co_varnames, obj.co_filename,</span>
<span class="gi">+            obj.co_name, obj.co_firstlineno, obj.co_lnotab,</span>
<span class="gi">+            obj.co_freevars, obj.co_cellvars,</span>
<span class="gi">+        )</span>
<span class="gi">+    return types.CodeType, args</span>

<span class="w"> </span>def _cell_reduce(obj):
<span class="w"> </span>    &quot;&quot;&quot;Cell (containing values of a function&#39;s free variables) reducer.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f = obj.cell_contents</span>
<span class="gi">+    return _empty_cell_value if f is None else f</span>

<span class="w"> </span>def _file_reduce(obj):
<span class="w"> </span>    &quot;&quot;&quot;Save a file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import io</span>
<span class="gi">+</span>
<span class="gi">+    if obj.closed:</span>
<span class="gi">+        raise pickle.PicklingError(&quot;Cannot pickle closed files&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if obj.mode == &#39;r&#39;:</span>
<span class="gi">+        return io.StringIO, (obj.read(),)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise pickle.PicklingError(&quot;Cannot pickle files in write mode&quot;)</span>

<span class="w"> </span>def _dynamic_class_reduce(obj):
<span class="w"> </span>    &quot;&quot;&quot;Save a class that can&#39;t be referenced as a module attribute.
<span class="gu">@@ -263,11 +435,53 @@ def _dynamic_class_reduce(obj):</span>
<span class="w"> </span>    functions, or that otherwise can&#39;t be serialized as attribute lookups
<span class="w"> </span>    from importable modules.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if obj is type(None):</span>
<span class="gi">+        return type, (None,)</span>
<span class="gi">+</span>
<span class="gi">+    # Get the type of the class</span>
<span class="gi">+    type_constructor = type(obj)</span>
<span class="gi">+</span>
<span class="gi">+    # Get the class name</span>
<span class="gi">+    name = obj.__name__</span>
<span class="gi">+</span>
<span class="gi">+    # Get the class bases</span>
<span class="gi">+    bases = obj.__bases__</span>
<span class="gi">+</span>
<span class="gi">+    # Get the class dict</span>
<span class="gi">+    dict_items = _extract_class_dict(obj).items()</span>
<span class="gi">+</span>
<span class="gi">+    # Get the class module</span>
<span class="gi">+    module = obj.__module__</span>
<span class="gi">+</span>
<span class="gi">+    # Get the class qualname</span>
<span class="gi">+    qualname = getattr(obj, &quot;__qualname__&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+    # Get the class tracker id</span>
<span class="gi">+    class_tracker_id = _DYNAMIC_CLASS_TRACKER_BY_CLASS.get(obj)</span>
<span class="gi">+</span>
<span class="gi">+    # Build the type kwargs</span>
<span class="gi">+    type_kwargs = {</span>
<span class="gi">+        &quot;__module__&quot;: module,</span>
<span class="gi">+        &quot;__qualname__&quot;: qualname,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    # Return the class constructor and its arguments</span>
<span class="gi">+    return _make_skeleton_class, (type_constructor, name, bases, type_kwargs,</span>
<span class="gi">+                                class_tracker_id, None)</span>

<span class="w"> </span>def _class_reduce(obj):
<span class="w"> </span>    &quot;&quot;&quot;Select the reducer depending on the dynamic nature of the class obj.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if obj is type(None):</span>
<span class="gi">+        return type, (None,)</span>
<span class="gi">+    elif obj is type(Ellipsis):</span>
<span class="gi">+        return type, (Ellipsis,)</span>
<span class="gi">+    elif obj is type(NotImplemented):</span>
<span class="gi">+        return type, (NotImplemented,)</span>
<span class="gi">+    elif obj in _BUILTIN_TYPE_NAMES:</span>
<span class="gi">+        return obj.__name__</span>
<span class="gi">+    elif not _should_pickle_by_reference(obj):</span>
<span class="gi">+        return _dynamic_class_reduce(obj)</span>
<span class="gi">+    return NotImplemented</span>

<span class="w"> </span>def _function_setstate(obj, state):
<span class="w"> </span>    &quot;&quot;&quot;Update the state of a dynamic function.
<span class="gu">@@ -276,7 +490,12 @@ def _function_setstate(obj, state):</span>
<span class="w"> </span>    cannot rely on the native setstate routine of pickle.load_build, that calls
<span class="w"> </span>    setattr on items of the slotstate. Instead, we have to modify them inplace.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    state, slotstate = state</span>
<span class="gi">+    obj.__dict__.update(state)</span>
<span class="gi">+</span>
<span class="gi">+    obj_globals = obj.__globals__</span>
<span class="gi">+    obj_globals.clear()</span>
<span class="gi">+    obj_globals.update(slotstate)</span>
<span class="w"> </span>_DATACLASSE_FIELD_TYPE_SENTINELS = {dataclasses._FIELD.name: dataclasses._FIELD, dataclasses._FIELD_CLASSVAR.name: dataclasses._FIELD_CLASSVAR, dataclasses._FIELD_INITVAR.name: dataclasses._FIELD_INITVAR}

<span class="w"> </span>class Pickler(pickle.Pickler):
<span class="gu">@@ -311,7 +530,21 @@ class Pickler(pickle.Pickler):</span>

<span class="w"> </span>    def _dynamic_function_reduce(self, func):
<span class="w"> </span>        &quot;&quot;&quot;Reduce a function that is not pickleable via attribute lookup.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if is_tornado_coroutine(func):</span>
<span class="gi">+            return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+        if PYPY:</span>
<span class="gi">+            # PyPy does not have the concept of builtin-functions, so</span>
<span class="gi">+            # reduce them as normal functions.</span>
<span class="gi">+            return self._function_reduce(func)</span>
<span class="gi">+</span>
<span class="gi">+        # Handle builtin functions</span>
<span class="gi">+        if hasattr(func, &#39;__code__&#39;) and isinstance(func.__code__, builtin_code_type):</span>
<span class="gi">+            return self._builtin_function_reduce(func)</span>
<span class="gi">+</span>
<span class="gi">+        # Handle normal functions</span>
<span class="gi">+        state = _function_getstate(func)</span>
<span class="gi">+        return _function_setstate, (func.__new__(type(func)), state)</span>

<span class="w"> </span>    def _function_reduce(self, obj):
<span class="w"> </span>        &quot;&quot;&quot;Reducer for function objects.
<span class="gu">@@ -322,7 +555,13 @@ class Pickler(pickle.Pickler):</span>
<span class="w"> </span>        obj using a custom cloudpickle reducer designed specifically to handle
<span class="w"> </span>        dynamic functions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if obj.__module__ == &quot;__main__&quot;:</span>
<span class="gi">+            return self._dynamic_function_reduce(obj)</span>
<span class="gi">+</span>
<span class="gi">+        if _should_pickle_by_reference(obj):</span>
<span class="gi">+            return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+        return self._dynamic_function_reduce(obj)</span>

<span class="w"> </span>    def __init__(self, file, protocol=None, buffer_callback=None):
<span class="w"> </span>        if protocol is None:
<span class="gu">@@ -364,7 +603,12 @@ class Pickler(pickle.Pickler):</span>
<span class="w"> </span>              reducers, such as Exceptions. See
<span class="w"> </span>              https://github.com/cloudpipe/cloudpickle/issues/248
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if isinstance(obj, type):</span>
<span class="gi">+                return _class_reduce(obj)</span>
<span class="gi">+            elif isinstance(obj, types.FunctionType):</span>
<span class="gi">+                return self._function_reduce(obj)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return NotImplemented</span>
<span class="w"> </span>    else:
<span class="w"> </span>        dispatch = pickle.Pickler.dispatch.copy()

<span class="gu">@@ -374,7 +618,12 @@ class Pickler(pickle.Pickler):</span>
<span class="w"> </span>            The name of this method is somewhat misleading: all types get
<span class="w"> </span>            dispatched here.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if isinstance(obj, type):</span>
<span class="gi">+                return self.save_reduce(_class_reduce(obj), obj=obj)</span>
<span class="gi">+            elif isinstance(obj, types.FunctionType):</span>
<span class="gi">+                return self.save_reduce(self._function_reduce(obj), obj=obj)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return super().save_global(obj, name=name, pack=pack)</span>
<span class="w"> </span>        dispatch[type] = save_global

<span class="w"> </span>        def save_function(self, obj, name=None):
<span class="gu">@@ -383,7 +632,10 @@ class Pickler(pickle.Pickler):</span>
<span class="w"> </span>            Determines what kind of function obj is (e.g. lambda, defined at
<span class="w"> </span>            interactive prompt, etc) and handles the pickling appropriately.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if isinstance(obj, types.FunctionType):</span>
<span class="gi">+                return self.save_reduce(self._function_reduce(obj), obj=obj)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return super().save_function(obj, name=name)</span>

<span class="w"> </span>        def save_pypy_builtin_func(self, obj):
<span class="w"> </span>            &quot;&quot;&quot;Save pypy equivalent of builtin functions.
<span class="gh">diff --git a/joblib/externals/loky/backend/_posix_reduction.py b/joblib/externals/loky/backend/_posix_reduction.py</span>
<span class="gh">index c0cc3ed..0e94840 100644</span>
<span class="gd">--- a/joblib/externals/loky/backend/_posix_reduction.py</span>
<span class="gi">+++ b/joblib/externals/loky/backend/_posix_reduction.py</span>
<span class="gu">@@ -6,9 +6,47 @@ from multiprocessing.context import get_spawning_popen</span>
<span class="w"> </span>from .reduction import register
<span class="w"> </span>HAVE_SEND_HANDLE = hasattr(socket, &#39;CMSG_LEN&#39;) and hasattr(socket, &#39;SCM_RIGHTS&#39;) and hasattr(socket.socket, &#39;sendmsg&#39;)

<span class="gi">+def _mk_inheritable(fd):</span>
<span class="gi">+    &quot;&quot;&quot;Make a file descriptor inheritable by child processes.&quot;&quot;&quot;</span>
<span class="gi">+    os.set_inheritable(fd, True)</span>
<span class="gi">+    return fd</span>
<span class="gi">+</span>
<span class="w"> </span>def DupFd(fd):
<span class="w"> </span>    &quot;&quot;&quot;Return a wrapper for an fd.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    popen = get_spawning_popen()</span>
<span class="gi">+    if popen is not None:</span>
<span class="gi">+        return popen.DupFd(fd)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _mk_inheritable(os.dup(fd))</span>
<span class="gi">+</span>
<span class="gi">+def _reduce_socket(s):</span>
<span class="gi">+    &quot;&quot;&quot;Reduce a socket object.&quot;&quot;&quot;</span>
<span class="gi">+    if HAVE_SEND_HANDLE and getattr(s, &#39;_inheritable&#39;, False):</span>
<span class="gi">+        return s, (None,)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _rebuild_socket, (DupFd(s.fileno()),</span>
<span class="gi">+                               s.family, s.type, s.proto)</span>
<span class="gi">+</span>
<span class="gi">+def _rebuild_socket(fd, family, type, proto):</span>
<span class="gi">+    &quot;&quot;&quot;Rebuild a socket object.&quot;&quot;&quot;</span>
<span class="gi">+    s = socket.socket(family, type, proto, fileno=fd)</span>
<span class="gi">+    if HAVE_SEND_HANDLE:</span>
<span class="gi">+        s._inheritable = True</span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+def rebuild_connection(df, readable, writable):</span>
<span class="gi">+    &quot;&quot;&quot;Rebuild a connection object.&quot;&quot;&quot;</span>
<span class="gi">+    fd = df</span>
<span class="gi">+    if not isinstance(fd, int):</span>
<span class="gi">+        fd = fd.detach()</span>
<span class="gi">+    conn = Connection(fd, readable, writable)</span>
<span class="gi">+    conn._inheritable = True</span>
<span class="gi">+    return conn</span>
<span class="gi">+</span>
<span class="gi">+def reduce_connection(conn):</span>
<span class="gi">+    &quot;&quot;&quot;Reduce a connection object.&quot;&quot;&quot;</span>
<span class="gi">+    df = DupFd(conn.fileno())</span>
<span class="gi">+    return rebuild_connection, (df, conn.readable, conn.writable)</span>
<span class="w"> </span>register(socket.socket, _reduce_socket)
<span class="w"> </span>register(_socket.socket, _reduce_socket)
<span class="w"> </span>register(Connection, reduce_connection)
\ No newline at end of file
<span class="gh">diff --git a/joblib/externals/loky/backend/context.py b/joblib/externals/loky/backend/context.py</span>
<span class="gh">index 31567b1..0543686 100644</span>
<span class="gd">--- a/joblib/externals/loky/backend/context.py</span>
<span class="gi">+++ b/joblib/externals/loky/backend/context.py</span>
<span class="gu">@@ -46,11 +46,43 @@ def cpu_count(only_physical_cores=False):</span>

<span class="w"> </span>    It is also always larger or equal to 1.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get the number of logical cores</span>
<span class="gi">+    try:</span>
<span class="gi">+        os_cpu_count = mp.cpu_count()</span>
<span class="gi">+    except NotImplementedError:</span>
<span class="gi">+        os_cpu_count = 1</span>
<span class="gi">+</span>
<span class="gi">+    if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        os_cpu_count = min(os_cpu_count, _MAX_WINDOWS_WORKERS)</span>
<span class="gi">+</span>
<span class="gi">+    cpu_count_user = _cpu_count_user(os_cpu_count)</span>
<span class="gi">+    if cpu_count_user is not None:</span>
<span class="gi">+        return cpu_count_user</span>
<span class="gi">+</span>
<span class="gi">+    if only_physical_cores:</span>
<span class="gi">+        physical_cores, exception = _count_physical_cores()</span>
<span class="gi">+        if physical_cores != &quot;not found&quot;:</span>
<span class="gi">+            return max(1, physical_cores)</span>
<span class="gi">+</span>
<span class="gi">+    return max(1, os_cpu_count)</span>

<span class="w"> </span>def _cpu_count_user(os_cpu_count):
<span class="w"> </span>    &quot;&quot;&quot;Number of user defined available CPUs&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cpu_count_user = os.environ.get(&#39;LOKY_MAX_CPU_COUNT&#39;, None)</span>
<span class="gi">+    if cpu_count_user is not None:</span>
<span class="gi">+        if cpu_count_user.strip() == &#39;&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        try:</span>
<span class="gi">+            cpu_count_user = float(cpu_count_user)</span>
<span class="gi">+            if cpu_count_user &gt; 0:</span>
<span class="gi">+                return int(min(cpu_count_user, os_cpu_count))</span>
<span class="gi">+            else:</span>
<span class="gi">+                return max(1, int(cpu_count_user * os_cpu_count))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            warnings.warn(&quot;LOKY_MAX_CPU_COUNT should be an integer or a float.&quot;</span>
<span class="gi">+                        &quot; Got &#39;{}&#39;. Using {} CPUs.&quot;</span>
<span class="gi">+                        .format(cpu_count_user, os_cpu_count))</span>
<span class="gi">+    return None</span>

<span class="w"> </span>def _count_physical_cores():
<span class="w"> </span>    &quot;&quot;&quot;Return a tuple (number of physical cores, exception)
<span class="gu">@@ -60,7 +92,60 @@ def _count_physical_cores():</span>

<span class="w"> </span>    The number of physical cores is cached to avoid repeating subprocess calls.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global physical_cores_cache</span>
<span class="gi">+    if physical_cores_cache is not None:</span>
<span class="gi">+        return physical_cores_cache</span>
<span class="gi">+</span>
<span class="gi">+    if sys.platform == &#39;linux&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Try to get the number of physical cores from /proc/cpuinfo</span>
<span class="gi">+            with open(&#39;/proc/cpuinfo&#39;, &#39;rb&#39;) as f:</span>
<span class="gi">+                cpuinfo = f.read().decode(&#39;ascii&#39;)</span>
<span class="gi">+            cores = set()</span>
<span class="gi">+            for line in cpuinfo.split(&#39;\n&#39;):</span>
<span class="gi">+                if line.startswith(&#39;physical id&#39;):</span>
<span class="gi">+                    phys_id = line.split(&#39;:&#39;)[1].strip()</span>
<span class="gi">+                elif line.startswith(&#39;cpu cores&#39;):</span>
<span class="gi">+                    nb_cores = int(line.split(&#39;:&#39;)[1].strip())</span>
<span class="gi">+                    cores.add((phys_id, nb_cores))</span>
<span class="gi">+            if cores:</span>
<span class="gi">+                physical_cores_cache = (sum(nb_cores for _, nb_cores in cores), None)</span>
<span class="gi">+                return physical_cores_cache</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            physical_cores_cache = (&quot;not found&quot;, e)</span>
<span class="gi">+            return physical_cores_cache</span>
<span class="gi">+</span>
<span class="gi">+    elif sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Try to get the number of physical cores from wmic</span>
<span class="gi">+            cmd = [&#39;wmic&#39;, &#39;cpu&#39;, &#39;get&#39;, &#39;NumberOfCores&#39;]</span>
<span class="gi">+            p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span>
<span class="gi">+            stdout, stderr = p.communicate()</span>
<span class="gi">+            if p.returncode == 0:</span>
<span class="gi">+                stdout = stdout.decode(&#39;ascii&#39;)</span>
<span class="gi">+                cores = [int(l) for l in stdout.split(&#39;\n&#39;)[1:] if l.strip()]</span>
<span class="gi">+                if cores:</span>
<span class="gi">+                    physical_cores_cache = (sum(cores), None)</span>
<span class="gi">+                    return physical_cores_cache</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            physical_cores_cache = (&quot;not found&quot;, e)</span>
<span class="gi">+            return physical_cores_cache</span>
<span class="gi">+</span>
<span class="gi">+    elif sys.platform == &#39;darwin&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Try to get the number of physical cores from sysctl</span>
<span class="gi">+            cmd = [&#39;sysctl&#39;, &#39;-n&#39;, &#39;hw.physicalcpu&#39;]</span>
<span class="gi">+            p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span>
<span class="gi">+            stdout, stderr = p.communicate()</span>
<span class="gi">+            if p.returncode == 0:</span>
<span class="gi">+                physical_cores_cache = (int(stdout.strip()), None)</span>
<span class="gi">+                return physical_cores_cache</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            physical_cores_cache = (&quot;not found&quot;, e)</span>
<span class="gi">+            return physical_cores_cache</span>
<span class="gi">+</span>
<span class="gi">+    physical_cores_cache = (&quot;not found&quot;, &quot;unknown platform&quot;)</span>
<span class="gi">+    return physical_cores_cache</span>

<span class="w"> </span>class LokyContext(BaseContext):
<span class="w"> </span>    &quot;&quot;&quot;Context relying on the LokyProcess.&quot;&quot;&quot;
<span class="gu">@@ -70,37 +155,45 @@ class LokyContext(BaseContext):</span>

<span class="w"> </span>    def Queue(self, maxsize=0, reducers=None):
<span class="w"> </span>        &quot;&quot;&quot;Returns a queue object&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .queues import Queue</span>
<span class="gi">+        return Queue(maxsize, reducers=reducers, ctx=self.get_context())</span>

<span class="w"> </span>    def SimpleQueue(self, reducers=None):
<span class="w"> </span>        &quot;&quot;&quot;Returns a queue object&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .queues import SimpleQueue</span>
<span class="gi">+        return SimpleQueue(reducers=reducers, ctx=self.get_context())</span>
<span class="w"> </span>    if sys.platform != &#39;win32&#39;:
<span class="w"> </span>        &#39;For Unix platform, use our custom implementation of synchronize\n        ensuring that we use the loky.backend.resource_tracker to clean-up\n        the semaphores in case of a worker crash.\n        &#39;

<span class="w"> </span>        def Semaphore(self, value=1):
<span class="w"> </span>            &quot;&quot;&quot;Returns a semaphore object&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            from .synchronize import Semaphore</span>
<span class="gi">+            return Semaphore(value, ctx=self.get_context())</span>

<span class="w"> </span>        def BoundedSemaphore(self, value):
<span class="w"> </span>            &quot;&quot;&quot;Returns a bounded semaphore object&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            from .synchronize import BoundedSemaphore</span>
<span class="gi">+            return BoundedSemaphore(value, ctx=self.get_context())</span>

<span class="w"> </span>        def Lock(self):
<span class="w"> </span>            &quot;&quot;&quot;Returns a lock object&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            from .synchronize import Lock</span>
<span class="gi">+            return Lock(ctx=self.get_context())</span>

<span class="w"> </span>        def RLock(self):
<span class="w"> </span>            &quot;&quot;&quot;Returns a recurrent lock object&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            from .synchronize import RLock</span>
<span class="gi">+            return RLock(ctx=self.get_context())</span>

<span class="w"> </span>        def Condition(self, lock=None):
<span class="w"> </span>            &quot;&quot;&quot;Returns a condition object&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            from .synchronize import Condition</span>
<span class="gi">+            return Condition(lock, ctx=self.get_context())</span>

<span class="w"> </span>        def Event(self):
<span class="w"> </span>            &quot;&quot;&quot;Returns an event object&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            from .synchronize import Event</span>
<span class="gi">+            return Event(ctx=self.get_context())</span>

<span class="w"> </span>class LokyInitMainContext(LokyContext):
<span class="w"> </span>    &quot;&quot;&quot;Extra context with LokyProcess, which does load the main module
<span class="gu">@@ -118,6 +211,30 @@ class LokyInitMainContext(LokyContext):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    _name = &#39;loky_init_main&#39;
<span class="w"> </span>    Process = LokyInitMainProcess
<span class="gi">+def get_context(method=None):</span>
<span class="gi">+    &quot;&quot;&quot;Returns a BaseContext or instance of subclass of BaseContext.</span>
<span class="gi">+    </span>
<span class="gi">+    method parameter can be &#39;fork&#39;, &#39;spawn&#39;, &#39;forkserver&#39;, &#39;loky&#39; or None.</span>
<span class="gi">+    If None, the default context is returned.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if method is None:</span>
<span class="gi">+        # Get the default context</span>
<span class="gi">+        if _DEFAULT_START_METHOD is None:</span>
<span class="gi">+            _DEFAULT_START_METHOD = &#39;loky&#39;</span>
<span class="gi">+        method = _DEFAULT_START_METHOD</span>
<span class="gi">+    </span>
<span class="gi">+    if method not in START_METHODS:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &quot;Method &#39;{}&#39; not in available methods {}&quot;.format(</span>
<span class="gi">+                method, START_METHODS))</span>
<span class="gi">+    </span>
<span class="gi">+    if method == &#39;loky&#39;:</span>
<span class="gi">+        return ctx_loky</span>
<span class="gi">+    elif method == &#39;loky_init_main&#39;:</span>
<span class="gi">+        return mp.context._concrete_contexts[&#39;loky_init_main&#39;]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return mp_get_context(method)</span>
<span class="gi">+</span>
<span class="w"> </span>ctx_loky = LokyContext()
<span class="w"> </span>mp.context._concrete_contexts[&#39;loky&#39;] = ctx_loky
<span class="w"> </span>mp.context._concrete_contexts[&#39;loky_init_main&#39;] = LokyInitMainContext()
\ No newline at end of file
<span class="gh">diff --git a/joblib/externals/loky/backend/reduction.py b/joblib/externals/loky/backend/reduction.py</span>
<span class="gh">index 4b3cb7a..c41eb8f 100644</span>
<span class="gd">--- a/joblib/externals/loky/backend/reduction.py</span>
<span class="gi">+++ b/joblib/externals/loky/backend/reduction.py</span>
<span class="gu">@@ -6,10 +6,35 @@ import sys</span>
<span class="w"> </span>import os
<span class="w"> </span>from multiprocessing import util
<span class="w"> </span>from pickle import loads, HIGHEST_PROTOCOL
<span class="gi">+from multiprocessing.reduction import register</span>
<span class="gi">+</span>
<span class="w"> </span>_dispatch_table = {}

<span class="gi">+def _reduce_method(m):</span>
<span class="gi">+    &quot;&quot;&quot;Helper function for pickling methods.&quot;&quot;&quot;</span>
<span class="gi">+    if m.__self__ is None:</span>
<span class="gi">+        return getattr, (m.__self__.__class__, m.__func__.__name__)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return getattr, (m.__self__, m.__func__.__name__)</span>
<span class="gi">+</span>
<span class="gi">+def _reduce_method_descriptor(m):</span>
<span class="gi">+    &quot;&quot;&quot;Helper function for pickling method descriptors.&quot;&quot;&quot;</span>
<span class="gi">+    return getattr, (m.__objclass__, m.__name__)</span>
<span class="gi">+</span>
<span class="gi">+def _reduce_partial(p):</span>
<span class="gi">+    &quot;&quot;&quot;Helper function for pickling partial functions.&quot;&quot;&quot;</span>
<span class="gi">+    return _rebuild_partial, (p.func, p.args, p.keywords or {})</span>
<span class="gi">+</span>
<span class="gi">+def _rebuild_partial(func, args, keywords):</span>
<span class="gi">+    &quot;&quot;&quot;Helper function for rebuilding partial functions.&quot;&quot;&quot;</span>
<span class="gi">+    return functools.partial(func, *args, **keywords)</span>
<span class="gi">+</span>
<span class="w"> </span>class _C:
<span class="gd">-    pass</span>
<span class="gi">+    def f(self):</span>
<span class="gi">+        pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def h(cls):</span>
<span class="gi">+        pass</span>
<span class="w"> </span>register(type(_C().f), _reduce_method)
<span class="w"> </span>register(type(_C.h), _reduce_method)
<span class="w"> </span>if not hasattr(sys, &#39;pypy_version_info&#39;):
<span class="gu">@@ -30,9 +55,47 @@ _LokyPickler = None</span>
<span class="w"> </span>_loky_pickler_name = None
<span class="w"> </span>set_loky_pickler()

<span class="gi">+def set_loky_pickler(loky_pickler=None):</span>
<span class="gi">+    &quot;&quot;&quot;Select the pickler to use in loky.</span>
<span class="gi">+</span>
<span class="gi">+    Parameters</span>
<span class="gi">+    ----------</span>
<span class="gi">+    loky_pickler: str in {&#39;pickle&#39;, &#39;cloudpickle&#39;, None}, default=None</span>
<span class="gi">+        If None, use the value of the environment variable LOKY_PICKLER.</span>
<span class="gi">+        If &#39;pickle&#39;, use the standard pickle module.</span>
<span class="gi">+        If &#39;cloudpickle&#39;, use the cloudpickle module.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    global _LokyPickler, _loky_pickler_name</span>
<span class="gi">+</span>
<span class="gi">+    if loky_pickler is None:</span>
<span class="gi">+        loky_pickler = ENV_LOKY_PICKLER</span>
<span class="gi">+</span>
<span class="gi">+    if loky_pickler == _loky_pickler_name:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if loky_pickler == &#39;pickle&#39;:</span>
<span class="gi">+        from pickle import Pickler</span>
<span class="gi">+        _LokyPickler = Pickler</span>
<span class="gi">+    elif loky_pickler == &#39;cloudpickle&#39;:</span>
<span class="gi">+        from joblib.externals.cloudpickle import CloudPickler</span>
<span class="gi">+        _LokyPickler = CloudPickler</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &quot;Invalid value for LOKY_PICKLER: &#39;{}&#39;. Supported values are &quot;</span>
<span class="gi">+            &quot;&#39;pickle&#39; and &#39;cloudpickle&#39;&quot;.format(loky_pickler))</span>
<span class="gi">+    _loky_pickler_name = loky_pickler</span>
<span class="gi">+</span>
<span class="w"> </span>def dump(obj, file, reducers=None, protocol=None):
<span class="w"> </span>    &quot;&quot;&quot;Replacement for pickle.dump() using _LokyPickler.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if protocol is None:</span>
<span class="gi">+        protocol = HIGHEST_PROTOCOL</span>
<span class="gi">+    _LokyPickler(file, protocol=protocol).dump(obj)</span>
<span class="gi">+</span>
<span class="gi">+def dumps(obj, reducers=None, protocol=None):</span>
<span class="gi">+    &quot;&quot;&quot;Replacement for pickle.dumps() using _LokyPickler.&quot;&quot;&quot;</span>
<span class="gi">+    buf = io.BytesIO()</span>
<span class="gi">+    dump(obj, buf, reducers=reducers, protocol=protocol)</span>
<span class="gi">+    return buf.getbuffer()</span>
<span class="w"> </span>__all__ = [&#39;dump&#39;, &#39;dumps&#39;, &#39;loads&#39;, &#39;register&#39;, &#39;set_loky_pickler&#39;]
<span class="w"> </span>if sys.platform == &#39;win32&#39;:
<span class="w"> </span>    from multiprocessing.reduction import duplicate
<span class="gh">diff --git a/joblib/func_inspect.py b/joblib/func_inspect.py</span>
<span class="gh">index 239018a..4c125e0 100644</span>
<span class="gd">--- a/joblib/func_inspect.py</span>
<span class="gi">+++ b/joblib/func_inspect.py</span>
<span class="gu">@@ -33,11 +33,36 @@ def get_func_code(func):</span>
<span class="w"> </span>        This function does a bit more magic than inspect, and is thus
<span class="w"> </span>        more robust.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    source_file = None</span>
<span class="gi">+    try:</span>
<span class="gi">+        source_file = inspect.getsourcefile(func)</span>
<span class="gi">+    except:</span>
<span class="gi">+        source_file = None</span>
<span class="gi">+</span>
<span class="gi">+    if source_file is None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            source_file = inspect.getfile(func)</span>
<span class="gi">+        except:</span>
<span class="gi">+            source_file = None</span>
<span class="gi">+</span>
<span class="gi">+    if source_file is None:</span>
<span class="gi">+        return None, None, None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        source_lines = inspect.findsource(func)</span>
<span class="gi">+        source_lines, first_line = source_lines</span>
<span class="gi">+        source_lines = &#39;&#39;.join(source_lines)</span>
<span class="gi">+    except:</span>
<span class="gi">+        return None, None, None</span>
<span class="gi">+</span>
<span class="gi">+    return source_lines, source_file, first_line</span>

<span class="w"> </span>def _clean_win_chars(string):
<span class="w"> </span>    &quot;&quot;&quot;Windows cannot encode some characters in filename.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import urllib.parse</span>
<span class="gi">+    if os.name == &#39;nt&#39;:</span>
<span class="gi">+        return urllib.parse.quote(string, safe=&#39;&#39;)</span>
<span class="gi">+    return string</span>

<span class="w"> </span>def get_func_name(func, resolv_alias=True, win_characters=True):
<span class="w"> </span>    &quot;&quot;&quot; Return the function import path (as a list of module names), and
<span class="gu">@@ -53,15 +78,62 @@ def get_func_name(func, resolv_alias=True, win_characters=True):</span>
<span class="w"> </span>            If true, substitute special characters using urllib.quote
<span class="w"> </span>            This is useful in Windows, as it cannot encode some filenames
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(func, &#39;__module__&#39;):</span>
<span class="gi">+        module = func.__module__</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            module = inspect.getmodule(func)</span>
<span class="gi">+            if module is not None:</span>
<span class="gi">+                module = module.__name__</span>
<span class="gi">+        except:</span>
<span class="gi">+            module = None</span>
<span class="gi">+    if module is None:</span>
<span class="gi">+        module = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    module_parts = module.split(&#39;.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(func, &#39;__name__&#39;):</span>
<span class="gi">+        name = func.__name__</span>
<span class="gi">+    else:</span>
<span class="gi">+        name = &#39;unknown&#39;</span>
<span class="gi">+        if hasattr(func, &#39;__class__&#39;):</span>
<span class="gi">+            name = func.__class__.__name__</span>
<span class="gi">+</span>
<span class="gi">+    if win_characters:</span>
<span class="gi">+        name = _clean_win_chars(name)</span>
<span class="gi">+</span>
<span class="gi">+    if resolv_alias:</span>
<span class="gi">+        # Attempt to resolve name aliases using inspect</span>
<span class="gi">+        if hasattr(func, &#39;__code__&#39;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                code = func.__code__</span>
<span class="gi">+                filename = code.co_filename</span>
<span class="gi">+                first_line = code.co_firstlineno</span>
<span class="gi">+                name = &#39;%s-%d&#39; % (name, first_line)</span>
<span class="gi">+            except:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+    return module_parts, name</span>

<span class="w"> </span>def _signature_str(function_name, arg_sig):
<span class="w"> </span>    &quot;&quot;&quot;Helper function to output a function signature&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    args = []</span>
<span class="gi">+    if arg_sig.args:</span>
<span class="gi">+        args.extend(arg_sig.args)</span>
<span class="gi">+    if arg_sig.varargs:</span>
<span class="gi">+        args.append(&#39;*&#39; + arg_sig.varargs)</span>
<span class="gi">+    if arg_sig.varkw:</span>
<span class="gi">+        args.append(&#39;**&#39; + arg_sig.varkw)</span>
<span class="gi">+    return &#39;%s(%s)&#39; % (function_name, &#39;, &#39;.join(args))</span>

<span class="w"> </span>def _function_called_str(function_name, args, kwargs):
<span class="w"> </span>    &quot;&quot;&quot;Helper function to output a function call&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = []</span>
<span class="gi">+    if args:</span>
<span class="gi">+        parts.extend(repr(arg) for arg in args)</span>
<span class="gi">+    if kwargs:</span>
<span class="gi">+        parts.extend(&#39;%s=%r&#39; % (k, v) for k, v in sorted(kwargs.items()))</span>
<span class="gi">+    return &#39;%s(%s)&#39; % (function_name, &#39;, &#39;.join(parts))</span>

<span class="w"> </span>def filter_args(func, ignore_lst, args=(), kwargs=dict()):
<span class="w"> </span>    &quot;&quot;&quot; Filters the given args and kwargs using a list of arguments to
<span class="gu">@@ -84,10 +156,46 @@ def filter_args(func, ignore_lst, args=(), kwargs=dict()):</span>
<span class="w"> </span>        filtered_args: list
<span class="w"> </span>            List of filtered positional and keyword arguments.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    arg_spec = inspect.getfullargspec(func)</span>
<span class="gi">+    arg_names = list(arg_spec.args)</span>
<span class="gi">+    output_args = list()</span>
<span class="gi">+</span>
<span class="gi">+    # Filter positional arguments</span>
<span class="gi">+    if &#39;*&#39; not in ignore_lst:</span>
<span class="gi">+        for arg_name, arg in zip(arg_names, args):</span>
<span class="gi">+            if arg_name not in ignore_lst:</span>
<span class="gi">+                output_args.append(arg)</span>
<span class="gi">+</span>
<span class="gi">+    # Filter keyword arguments</span>
<span class="gi">+    if &#39;**&#39; not in ignore_lst:</span>
<span class="gi">+        for arg_name in arg_names[len(args):]:</span>
<span class="gi">+            if arg_name in kwargs:</span>
<span class="gi">+                if arg_name not in ignore_lst:</span>
<span class="gi">+                    output_args.append(kwargs[arg_name])</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Check if the parameter has a default value</span>
<span class="gi">+                default_arg = arg_spec.defaults[arg_names.index(arg_name) - len(arg_names)]</span>
<span class="gi">+                if default_arg not in ignore_lst:</span>
<span class="gi">+                    output_args.append(default_arg)</span>
<span class="gi">+</span>
<span class="gi">+    return output_args</span>

<span class="w"> </span>def format_call(func, args, kwargs, object_name=&#39;Memory&#39;):
<span class="w"> </span>    &quot;&quot;&quot; Returns a nicely formatted statement displaying the function
<span class="w"> </span>        call with the given arguments.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    path, name = get_func_name(func)</span>
<span class="gi">+    path = [object_name] + list(path)</span>
<span class="gi">+    module_path = &#39;.&#39;.join(path)</span>
<span class="gi">+</span>
<span class="gi">+    arg_str = _function_called_str(name, args, kwargs)</span>
<span class="gi">+    return &#39;%s.%s&#39; % (module_path, arg_str)</span>
<span class="gi">+</span>
<span class="gi">+def format_signature(func):</span>
<span class="gi">+    &quot;&quot;&quot;Return a formatted signature for the function.&quot;&quot;&quot;</span>
<span class="gi">+    arg_spec = inspect.getfullargspec(func)</span>
<span class="gi">+    path, name = get_func_name(func)</span>
<span class="gi">+    module_path = &#39;.&#39;.join(path)</span>
<span class="gi">+</span>
<span class="gi">+    signature = _signature_str(name, arg_spec)</span>
<span class="gi">+    return &#39;%s.%s&#39; % (module_path, signature)</span>
\ No newline at end of file
<span class="gh">diff --git a/joblib/hashing.py b/joblib/hashing.py</span>
<span class="gh">index 410eaeb..938c489 100644</span>
<span class="gd">--- a/joblib/hashing.py</span>
<span class="gi">+++ b/joblib/hashing.py</span>
<span class="gu">@@ -38,6 +38,15 @@ class Hasher(Pickler):</span>
<span class="w"> </span>        protocol = 3
<span class="w"> </span>        Pickler.__init__(self, self.stream, protocol=protocol)
<span class="w"> </span>        self._hash = hashlib.new(hash_name)
<span class="gi">+</span>
<span class="gi">+    def save_global(self, obj, name=None, pack=struct.pack):</span>
<span class="gi">+        &quot;&quot;&quot;Save a global object&quot;&quot;&quot;</span>
<span class="gi">+        self._hash.update(str(obj).encode(&#39;utf-8&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def save_set(self, obj, pack=struct.pack):</span>
<span class="gi">+        &quot;&quot;&quot;Save a set object&quot;&quot;&quot;</span>
<span class="gi">+        self._hash.update(str(_ConsistentSet(obj)).encode(&#39;utf-8&#39;))</span>
<span class="gi">+</span>
<span class="w"> </span>    dispatch = Pickler.dispatch.copy()
<span class="w"> </span>    dispatch[type(len)] = save_global
<span class="w"> </span>    dispatch[type(object)] = save_global
<span class="gu">@@ -73,7 +82,24 @@ class NumpyHasher(Hasher):</span>
<span class="w"> </span>            than pickling them. Off course, this is a total abuse of
<span class="w"> </span>            the Pickler class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(obj, type):</span>
<span class="gi">+            return Hasher.save_global(self, obj)</span>
<span class="gi">+        if isinstance(obj, self.np.ndarray) and not obj.dtype.hasobject:</span>
<span class="gi">+            # Compute a hash of the object</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._hash.update(self._getbuffer(obj))</span>
<span class="gi">+            except (TypeError, BufferError):</span>
<span class="gi">+                # Cater for non-single-segment arrays: this creates a</span>
<span class="gi">+                # copy, and thus aleviates this issue.</span>
<span class="gi">+                # XXX: There might be a more efficient way of doing this</span>
<span class="gi">+                self._hash.update(self._getbuffer(obj.flatten()))</span>
<span class="gi">+</span>
<span class="gi">+            # We also hash the dtype and the shape to distinguish</span>
<span class="gi">+            # different views of the same data with different dtypes.</span>
<span class="gi">+            self._hash.update(str(obj.dtype).encode(&#39;utf-8&#39;))</span>
<span class="gi">+            self._hash.update(str(obj.shape).encode(&#39;utf-8&#39;))</span>
<span class="gi">+            return</span>
<span class="gi">+        return Hasher.save(self, obj)</span>

<span class="w"> </span>def hash(obj, hash_name=&#39;md5&#39;, coerce_mmap=False):
<span class="w"> </span>    &quot;&quot;&quot; Quick calculation of a hash to identify uniquely Python objects
<span class="gu">@@ -87,4 +113,10 @@ def hash(obj, hash_name=&#39;md5&#39;, coerce_mmap=False):</span>
<span class="w"> </span>        coerce_mmap: boolean
<span class="w"> </span>            Make no difference between np.memmap and np.ndarray
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    try:</span>
<span class="gi">+        import numpy as np</span>
<span class="gi">+        hasher = NumpyHasher(hash_name=hash_name, coerce_mmap=coerce_mmap)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        hasher = Hasher(hash_name=hash_name)</span>
<span class="gi">+    hasher.save(obj)</span>
<span class="gi">+    return hasher._hash.hexdigest()</span>
\ No newline at end of file
<span class="gh">diff --git a/joblib/logger.py b/joblib/logger.py</span>
<span class="gh">index 3de4188..f2107a8 100644</span>
<span class="gd">--- a/joblib/logger.py</span>
<span class="gi">+++ b/joblib/logger.py</span>
<span class="gu">@@ -9,15 +9,38 @@ import sys</span>
<span class="w"> </span>import os
<span class="w"> </span>import shutil
<span class="w"> </span>import logging
<span class="gd">-import pprint</span>
<span class="gi">+import pprint as _pprint</span>
<span class="w"> </span>from .disk import mkdirp

<span class="gi">+def pformat(obj, depth=3):</span>
<span class="gi">+    &quot;&quot;&quot;Return a formatted representation of the object.&quot;&quot;&quot;</span>
<span class="gi">+    return _pprint.pformat(obj, depth=depth)</span>
<span class="gi">+</span>
<span class="w"> </span>def _squeeze_time(t):
<span class="w"> </span>    &quot;&quot;&quot;Remove .1s to the time under Windows: this is the time it take to
<span class="w"> </span>    stat files. This is needed to make results similar to timings under
<span class="w"> </span>    Unix, for tests
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.platform.startswith(&#39;win&#39;):</span>
<span class="gi">+        return max(0, t - .1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return t</span>
<span class="gi">+</span>
<span class="gi">+def format_time(t):</span>
<span class="gi">+    &quot;&quot;&quot;Format time in seconds for human-readable output&quot;&quot;&quot;</span>
<span class="gi">+    t = _squeeze_time(t)</span>
<span class="gi">+    if t &gt; 60:</span>
<span class="gi">+        return &quot;%.1f min&quot; % (t / 60.)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &quot;%.2f s&quot; % t</span>
<span class="gi">+</span>
<span class="gi">+def short_format_time(t):</span>
<span class="gi">+    &quot;&quot;&quot;Format time in seconds for short human-readable output&quot;&quot;&quot;</span>
<span class="gi">+    t = _squeeze_time(t)</span>
<span class="gi">+    if t &gt; 60:</span>
<span class="gi">+        return &quot;%.1fm&quot; % (t / 60.)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &quot;%.1fs&quot; % t</span>

<span class="w"> </span>class Logger(object):
<span class="w"> </span>    &quot;&quot;&quot; Base class for logging messages.
<span class="gu">@@ -37,7 +60,11 @@ class Logger(object):</span>

<span class="w"> </span>    def format(self, obj, indent=0):
<span class="w"> </span>        &quot;&quot;&quot;Return the formatted representation of the object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if indent == 0:</span>
<span class="gi">+            prefix = &#39;&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            prefix = &#39; &#39; * indent</span>
<span class="gi">+        return prefix + pprint.pformat(obj, depth=self.depth)</span>

<span class="w"> </span>class PrintTime(object):
<span class="w"> </span>    &quot;&quot;&quot; Print and log messages while keeping track of time.
<span class="gh">diff --git a/joblib/numpy_pickle_compat.py b/joblib/numpy_pickle_compat.py</span>
<span class="gh">index 65e3046..d46bbc9 100644</span>
<span class="gd">--- a/joblib/numpy_pickle_compat.py</span>
<span class="gi">+++ b/joblib/numpy_pickle_compat.py</span>
<span class="gu">@@ -10,7 +10,7 @@ from .numpy_pickle_utils import _ensure_native_byte_order</span>

<span class="w"> </span>def hex_str(an_int):
<span class="w"> </span>    &quot;&quot;&quot;Convert an int to an hexadecimal string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hex(an_int)[2:]</span>
<span class="w"> </span>_MAX_LEN = len(hex_str(2 ** 64))
<span class="w"> </span>_CHUNK_SIZE = 64 * 1024

<span class="gu">@@ -21,7 +21,26 @@ def read_zfile(file_handle):</span>
<span class="w"> </span>    for persistence. Backward compatibility is not guaranteed. Do not
<span class="w"> </span>    use for external purposes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    file_handle.seek(0)</span>
<span class="gi">+    header = file_handle.read(len(_ZFILE_PREFIX))</span>
<span class="gi">+    if header != _ZFILE_PREFIX:</span>
<span class="gi">+        raise ValueError(&quot;Unknown file type&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    length = file_handle.read(_MAX_LEN)</span>
<span class="gi">+    length = int(length, 16)</span>
<span class="gi">+</span>
<span class="gi">+    # Decompress small files in memory</span>
<span class="gi">+    data = BytesIO()</span>
<span class="gi">+    chunk = file_handle.read(_CHUNK_SIZE)</span>
<span class="gi">+    decompressor = zlib.decompressobj()</span>
<span class="gi">+    while chunk:</span>
<span class="gi">+        data.write(decompressor.decompress(chunk))</span>
<span class="gi">+        chunk = file_handle.read(_CHUNK_SIZE)</span>
<span class="gi">+    data.write(decompressor.flush())</span>
<span class="gi">+    data = data.getvalue()</span>
<span class="gi">+    if len(data) != length:</span>
<span class="gi">+        raise ValueError(&quot;File corrupted&quot;)</span>
<span class="gi">+    return data</span>

<span class="w"> </span>def write_zfile(file_handle, data, compress=1):
<span class="w"> </span>    &quot;&quot;&quot;Write the data in the given file as a Z-file.
<span class="gu">@@ -30,7 +49,18 @@ def write_zfile(file_handle, data, compress=1):</span>
<span class="w"> </span>    for persistence. Backward compatibility is not guaranteed. Do not
<span class="w"> </span>    use for external purposes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    file_handle.write(_ZFILE_PREFIX)</span>
<span class="gi">+    length = hex_str(len(data))</span>
<span class="gi">+    # Add padding to length to make it fixed width</span>
<span class="gi">+    file_handle.write(length.zfill(_MAX_LEN).encode(&#39;ascii&#39;))</span>
<span class="gi">+    compressor = zlib.compressobj(compress)</span>
<span class="gi">+    chunk = data[0:_CHUNK_SIZE]</span>
<span class="gi">+    pos = _CHUNK_SIZE</span>
<span class="gi">+    while chunk:</span>
<span class="gi">+        file_handle.write(compressor.compress(chunk))</span>
<span class="gi">+        chunk = data[pos:pos + _CHUNK_SIZE]</span>
<span class="gi">+        pos += _CHUNK_SIZE</span>
<span class="gi">+    file_handle.write(compressor.flush())</span>

<span class="w"> </span>class NDArrayWrapper(object):
<span class="w"> </span>    &quot;&quot;&quot;An object to be persisted instead of numpy arrays.
<span class="gu">@@ -47,7 +77,23 @@ class NDArrayWrapper(object):</span>

<span class="w"> </span>    def read(self, unpickler):
<span class="w"> </span>        &quot;&quot;&quot;Reconstruct the array.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        filename = os.path.join(unpickler._dirname, self.filename)</span>
<span class="gi">+        # Load the array from the disk</span>
<span class="gi">+        np = unpickler.np</span>
<span class="gi">+        if np is None:</span>
<span class="gi">+            raise ImportError(&quot;Trying to unpickle an ndarray, &quot;</span>
<span class="gi">+                            &quot;but numpy is not available&quot;)</span>
<span class="gi">+        array = _ensure_native_byte_order(np.load(filename, mmap_mode=unpickler.mmap_mode if self.allow_mmap else None))</span>
<span class="gi">+        # Reconstruct subclasses. This does not work with old</span>
<span class="gi">+        # versions of numpy</span>
<span class="gi">+        if (not np.issubdtype(array.dtype, np.dtype(&#39;O&#39;)) and</span>
<span class="gi">+                self.subclass not in (type(None), type(array))):</span>
<span class="gi">+            new_array = np.ndarray.__new__(self.subclass, array.shape,</span>
<span class="gi">+                                         array.dtype, buffer=array)</span>
<span class="gi">+            # Preserve side effects of viewing arrays</span>
<span class="gi">+            new_array.__array_finalize__(array)</span>
<span class="gi">+            array = new_array</span>
<span class="gi">+        return array</span>

<span class="w"> </span>class ZNDArrayWrapper(NDArrayWrapper):
<span class="w"> </span>    &quot;&quot;&quot;An object to be persisted instead of numpy arrays.
<span class="gu">@@ -72,7 +118,23 @@ class ZNDArrayWrapper(NDArrayWrapper):</span>

<span class="w"> </span>    def read(self, unpickler):
<span class="w"> </span>        &quot;&quot;&quot;Reconstruct the array from the meta-information and the z-file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Get the array parameters</span>
<span class="gi">+        init_args, state = self.init_args, self.state</span>
<span class="gi">+</span>
<span class="gi">+        # Read the array data from the z-file</span>
<span class="gi">+        filename = os.path.join(unpickler._dirname, self.filename)</span>
<span class="gi">+        with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+            array_bytes = read_zfile(f)</span>
<span class="gi">+</span>
<span class="gi">+        # Reconstruct the array</span>
<span class="gi">+        np = unpickler.np</span>
<span class="gi">+        if np is None:</span>
<span class="gi">+            raise ImportError(&quot;Trying to unpickle an ndarray, &quot;</span>
<span class="gi">+                            &quot;but numpy is not available&quot;)</span>
<span class="gi">+        array = np.ndarray(*init_args)</span>
<span class="gi">+        array.__setstate__(state)</span>
<span class="gi">+        array.data = np.frombuffer(array_bytes, dtype=array.dtype)</span>
<span class="gi">+        return array</span>

<span class="w"> </span>class ZipNumpyUnpickler(Unpickler):
<span class="w"> </span>    &quot;&quot;&quot;A subclass of the Unpickler to unpickle our numpy pickles.&quot;&quot;&quot;
<span class="gu">@@ -98,7 +160,28 @@ class ZipNumpyUnpickler(Unpickler):</span>
<span class="w"> </span>        NDArrayWrapper, by the array we are interested in. We
<span class="w"> </span>        replace them directly in the stack of pickler.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stack = self.stack</span>
<span class="gi">+        state = stack.pop()</span>
<span class="gi">+        instance = stack[-1]</span>
<span class="gi">+        if isinstance(instance, NDArrayWrapper):</span>
<span class="gi">+            # We replace the wrapper by the array</span>
<span class="gi">+            array = instance.read(self)</span>
<span class="gi">+            stack[-1] = array</span>
<span class="gi">+            return</span>
<span class="gi">+        setstate = getattr(instance, &quot;__setstate__&quot;, None)</span>
<span class="gi">+        if setstate is not None:</span>
<span class="gi">+            setstate(state)</span>
<span class="gi">+            return</span>
<span class="gi">+        slotstate = None</span>
<span class="gi">+        if isinstance(state, tuple) and len(state) == 2:</span>
<span class="gi">+            state, slotstate = state</span>
<span class="gi">+        if state:</span>
<span class="gi">+            instance_dict = instance.__dict__</span>
<span class="gi">+            for k, v in state.items():</span>
<span class="gi">+                instance_dict[k] = v</span>
<span class="gi">+        if slotstate:</span>
<span class="gi">+            for k, v in slotstate.items():</span>
<span class="gi">+                setattr(instance, k, v)</span>
<span class="w"> </span>    dispatch[pickle.BUILD[0]] = load_build

<span class="w"> </span>def load_compatibility(filename):
<span class="gu">@@ -127,4 +210,10 @@ def load_compatibility(filename):</span>
<span class="w"> </span>    This function can load numpy array files saved separately during the
<span class="w"> </span>    dump.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    with open(filename, &#39;rb&#39;) as file_handle:</span>
<span class="gi">+        # We are careful to open the file handle early and keep it open to</span>
<span class="gi">+        # avoid race-conditions on renames.</span>
<span class="gi">+        # XXX: This code should be refactored to use a context handler</span>
<span class="gi">+        unpickler = ZipNumpyUnpickler(filename, file_handle)</span>
<span class="gi">+        obj = unpickler.load()</span>
<span class="gi">+    return obj</span>
\ No newline at end of file
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>