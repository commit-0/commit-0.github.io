
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 reference imapclient - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-reference" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 reference imapclient
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytest" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytest:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pytest-summary_1" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytest_1" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytest:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pytest-summary_2" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytest_2" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytest:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pytest-summary_3" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytest_3" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytest:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytest:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_table_integritypytest_verify_table_integrity" class="md-nav__link">
    <span class="md-ellipsis">
      test_table_integrity.py::test_verify_table_integrity
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pytest-summary_4" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytest_4" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytest:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-reference"><strong>Reference (Gold)</strong>: reference</h1>
<h2 id="pytest-summary">Pytest Summary</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">140</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">140</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">150</td>
</tr>
<tr>
<td style="text-align: left;">deselected</td>
<td style="text-align: center;">10</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest">Failed pytest:</h2>
<h2 id="pytest-summary_1">Pytest Summary</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">201</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">201</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">201</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest_1">Failed pytest:</h2>
<h2 id="pytest-summary_2">Pytest Summary</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">1229</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">1229</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">1229</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest_2">Failed pytest:</h2>
<h2 id="pytest-summary_3">Pytest Summary</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">38</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">39</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">39</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest_3">Failed pytest:</h2>
<h3 id="test_table_integritypytest_verify_table_integrity">test_table_integrity.py::test_verify_table_integrity</h3>
<details><summary> <pre>test_table_integrity.py::test_verify_table_integrity</pre></summary><pre>
('/testbed/tests/test_table_integrity.py', 10, 'Skipped: Test only with a single version of python')
</pre>
</details>

<h2 id="pytest-summary_4">Pytest Summary</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">267</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">267</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">267</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest_4">Failed pytest:</h2>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/imapclient/config.py b/imapclient/config.py</span>
<span class="gh">index f098591..76e8dc8 100644</span>
<span class="gd">--- a/imapclient/config.py</span>
<span class="gi">+++ b/imapclient/config.py</span>
<span class="gu">@@ -1,3 +1,7 @@</span>
<span class="gi">+# Copyright (c) 2015, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import configparser
<span class="w"> </span>import json
<span class="gu">@@ -6,19 +10,210 @@ import ssl</span>
<span class="w"> </span>import urllib.parse
<span class="w"> </span>import urllib.request
<span class="w"> </span>from typing import Any, Callable, Dict, Optional, Tuple, TYPE_CHECKING, TypeVar
<span class="gi">+</span>
<span class="w"> </span>import imapclient


<span class="gd">-def parse_config_file(filename: str) -&gt;argparse.Namespace:</span>
<span class="gi">+def getenv(name: str, default: Optional[str]) -&gt; Optional[str]:</span>
<span class="gi">+    return os.environ.get(&quot;imapclient_&quot; + name, default)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_config_defaults() -&gt; Dict[str, Any]:</span>
<span class="gi">+    return {</span>
<span class="gi">+        &quot;username&quot;: getenv(&quot;username&quot;, None),</span>
<span class="gi">+        &quot;password&quot;: getenv(&quot;password&quot;, None),</span>
<span class="gi">+        &quot;ssl&quot;: True,</span>
<span class="gi">+        &quot;ssl_check_hostname&quot;: True,</span>
<span class="gi">+        &quot;ssl_verify_cert&quot;: True,</span>
<span class="gi">+        &quot;ssl_ca_file&quot;: None,</span>
<span class="gi">+        &quot;timeout&quot;: None,</span>
<span class="gi">+        &quot;starttls&quot;: False,</span>
<span class="gi">+        &quot;stream&quot;: False,</span>
<span class="gi">+        &quot;oauth2&quot;: False,</span>
<span class="gi">+        &quot;oauth2_client_id&quot;: getenv(&quot;oauth2_client_id&quot;, None),</span>
<span class="gi">+        &quot;oauth2_client_secret&quot;: getenv(&quot;oauth2_client_secret&quot;, None),</span>
<span class="gi">+        &quot;oauth2_refresh_token&quot;: getenv(&quot;oauth2_refresh_token&quot;, None),</span>
<span class="gi">+        &quot;expect_failure&quot;: None,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_config_file(filename: str) -&gt; argparse.Namespace:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse INI files containing IMAP connection details.

<span class="w"> </span>    Used by livetest.py and interact.py
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    parser = configparser.ConfigParser(get_string_config_defaults())</span>
<span class="gi">+    parser.read(filename)</span>
<span class="gi">+</span>
<span class="gi">+    conf = _read_config_section(parser, &quot;DEFAULT&quot;)</span>
<span class="gi">+    if conf.expect_failure:</span>
<span class="gi">+        raise ValueError(&quot;expect_failure should not be set for the DEFAULT section&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    conf.alternates = {}</span>
<span class="gi">+    for section in parser.sections():</span>
<span class="gi">+        # pylint: disable=no-member</span>
<span class="gi">+        conf.alternates[section] = _read_config_section(parser, section)</span>
<span class="gi">+</span>
<span class="gi">+    return conf</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_string_config_defaults() -&gt; Dict[str, str]:</span>
<span class="gi">+    out = {}</span>
<span class="gi">+    for k, v in get_config_defaults().items():</span>
<span class="gi">+        if v is True:</span>
<span class="gi">+            v = &quot;true&quot;</span>
<span class="gi">+        elif v is False:</span>
<span class="gi">+            v = &quot;false&quot;</span>
<span class="gi">+        elif not v:</span>
<span class="gi">+            v = &quot;&quot;</span>
<span class="gi">+        out[k] = v</span>
<span class="gi">+    return out</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+T = TypeVar(&quot;T&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _read_config_section(</span>
<span class="gi">+    parser: configparser.ConfigParser, section: str</span>
<span class="gi">+) -&gt; argparse.Namespace:</span>
<span class="gi">+    def get(name: str) -&gt; str:</span>
<span class="gi">+        return parser.get(section, name)</span>
<span class="gi">+</span>
<span class="gi">+    def getboolean(name: str) -&gt; bool:</span>
<span class="gi">+        return parser.getboolean(section, name)</span>
<span class="gi">+</span>
<span class="gi">+    def get_allowing_none(name: str, typefunc: Callable[[str], T]) -&gt; Optional[T]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            v = parser.get(section, name)</span>
<span class="gi">+        except configparser.NoOptionError:</span>
<span class="gi">+            return None</span>
<span class="gi">+        if not v:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return typefunc(v)</span>
<span class="gi">+</span>
<span class="gi">+    def getint(name: str) -&gt; Optional[int]:</span>
<span class="gi">+        return get_allowing_none(name, int)</span>
<span class="gi">+</span>
<span class="gi">+    def getfloat(name: str) -&gt; Optional[float]:</span>
<span class="gi">+        return get_allowing_none(name, float)</span>

<span class="gd">-T = TypeVar(&#39;T&#39;)</span>
<span class="gd">-OAUTH2_REFRESH_URLS = {&#39;imap.gmail.com&#39;:</span>
<span class="gd">-    &#39;https://accounts.google.com/o/oauth2/token&#39;, &#39;imap.mail.yahoo.com&#39;:</span>
<span class="gd">-    &#39;https://api.login.yahoo.com/oauth2/get_token&#39;}</span>
<span class="gi">+    ssl_ca_file = get(&quot;ssl_ca_file&quot;)</span>
<span class="gi">+    if ssl_ca_file:</span>
<span class="gi">+        ssl_ca_file = os.path.expanduser(ssl_ca_file)</span>
<span class="gi">+</span>
<span class="gi">+    return argparse.Namespace(</span>
<span class="gi">+        host=get(&quot;host&quot;),</span>
<span class="gi">+        port=getint(&quot;port&quot;),</span>
<span class="gi">+        ssl=getboolean(&quot;ssl&quot;),</span>
<span class="gi">+        starttls=getboolean(&quot;starttls&quot;),</span>
<span class="gi">+        ssl_check_hostname=getboolean(&quot;ssl_check_hostname&quot;),</span>
<span class="gi">+        ssl_verify_cert=getboolean(&quot;ssl_verify_cert&quot;),</span>
<span class="gi">+        ssl_ca_file=ssl_ca_file,</span>
<span class="gi">+        timeout=getfloat(&quot;timeout&quot;),</span>
<span class="gi">+        stream=getboolean(&quot;stream&quot;),</span>
<span class="gi">+        username=get(&quot;username&quot;),</span>
<span class="gi">+        password=get(&quot;password&quot;),</span>
<span class="gi">+        oauth2=getboolean(&quot;oauth2&quot;),</span>
<span class="gi">+        oauth2_client_id=get(&quot;oauth2_client_id&quot;),</span>
<span class="gi">+        oauth2_client_secret=get(&quot;oauth2_client_secret&quot;),</span>
<span class="gi">+        oauth2_refresh_token=get(&quot;oauth2_refresh_token&quot;),</span>
<span class="gi">+        expect_failure=get(&quot;expect_failure&quot;),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+OAUTH2_REFRESH_URLS = {</span>
<span class="gi">+    &quot;imap.gmail.com&quot;: &quot;https://accounts.google.com/o/oauth2/token&quot;,</span>
<span class="gi">+    &quot;imap.mail.yahoo.com&quot;: &quot;https://api.login.yahoo.com/oauth2/get_token&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def refresh_oauth2_token(</span>
<span class="gi">+    hostname: str, client_id: str, client_secret: str, refresh_token: str</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    url = OAUTH2_REFRESH_URLS.get(hostname)</span>
<span class="gi">+    if not url:</span>
<span class="gi">+        raise ValueError(&quot;don&#39;t know where to refresh OAUTH2 token for %r&quot; % hostname)</span>
<span class="gi">+</span>
<span class="gi">+    post = {</span>
<span class="gi">+        &quot;client_id&quot;: client_id.encode(&quot;ascii&quot;),</span>
<span class="gi">+        &quot;client_secret&quot;: client_secret.encode(&quot;ascii&quot;),</span>
<span class="gi">+        &quot;refresh_token&quot;: refresh_token.encode(&quot;ascii&quot;),</span>
<span class="gi">+        &quot;grant_type&quot;: b&quot;refresh_token&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+    with urllib.request.urlopen(</span>
<span class="gi">+        url, urllib.parse.urlencode(post).encode(&quot;ascii&quot;)</span>
<span class="gi">+    ) as request:</span>
<span class="gi">+        response = request.read()</span>
<span class="gi">+    result = json.loads(response.decode(&quot;ascii&quot;))[&quot;access_token&quot;]</span>
<span class="gi">+    if TYPE_CHECKING:</span>
<span class="gi">+        assert isinstance(result, str)</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Tokens are expensive to refresh so use the same one for the duration of the process.</span>
<span class="w"> </span>_oauth2_cache: Dict[Tuple[str, str, str, str], str] = {}
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_oauth2_token(</span>
<span class="gi">+    hostname: str, client_id: str, client_secret: str, refresh_token: str</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    cache_key = (hostname, client_id, client_secret, refresh_token)</span>
<span class="gi">+    token = _oauth2_cache.get(cache_key)</span>
<span class="gi">+    if token:</span>
<span class="gi">+        return token</span>
<span class="gi">+</span>
<span class="gi">+    token = refresh_oauth2_token(hostname, client_id, client_secret, refresh_token)</span>
<span class="gi">+    _oauth2_cache[cache_key] = token</span>
<span class="gi">+    return token</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_client_from_config(</span>
<span class="gi">+    conf: argparse.Namespace, login: bool = True</span>
<span class="gi">+) -&gt; imapclient.IMAPClient:</span>
<span class="gi">+    assert conf.host, &quot;missing host&quot;</span>
<span class="gi">+</span>
<span class="gi">+    ssl_context = None</span>
<span class="gi">+    if conf.ssl:</span>
<span class="gi">+        ssl_context = ssl.create_default_context()</span>
<span class="gi">+        ssl_context.check_hostname = conf.ssl_check_hostname</span>
<span class="gi">+        if not conf.ssl_verify_cert:</span>
<span class="gi">+            ssl_context.verify_mode = ssl.CERT_NONE</span>
<span class="gi">+        if conf.ssl_ca_file:</span>
<span class="gi">+            ssl_context.load_verify_locations(cafile=conf.ssl_ca_file)</span>
<span class="gi">+</span>
<span class="gi">+    client = imapclient.IMAPClient(</span>
<span class="gi">+        conf.host,</span>
<span class="gi">+        port=conf.port,</span>
<span class="gi">+        ssl=conf.ssl,</span>
<span class="gi">+        ssl_context=ssl_context,</span>
<span class="gi">+        stream=conf.stream,</span>
<span class="gi">+        timeout=conf.timeout,</span>
<span class="gi">+    )</span>
<span class="gi">+    if not login:</span>
<span class="gi">+        return client</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if conf.starttls:</span>
<span class="gi">+            client.starttls()</span>
<span class="gi">+</span>
<span class="gi">+        if conf.oauth2:</span>
<span class="gi">+            assert conf.oauth2_client_id, &quot;missing oauth2 id&quot;</span>
<span class="gi">+            assert conf.oauth2_client_secret, &quot;missing oauth2 secret&quot;</span>
<span class="gi">+            assert conf.oauth2_refresh_token, &quot;missing oauth2 refresh token&quot;</span>
<span class="gi">+            access_token = get_oauth2_token(</span>
<span class="gi">+                conf.host,</span>
<span class="gi">+                conf.oauth2_client_id,</span>
<span class="gi">+                conf.oauth2_client_secret,</span>
<span class="gi">+                conf.oauth2_refresh_token,</span>
<span class="gi">+            )</span>
<span class="gi">+            client.oauth2_login(conf.username, access_token)</span>
<span class="gi">+</span>
<span class="gi">+        elif not conf.stream:</span>
<span class="gi">+            assert conf.username, &quot;missing username&quot;</span>
<span class="gi">+            assert conf.password, &quot;missing password&quot;</span>
<span class="gi">+            client.login(conf.username, conf.password)</span>
<span class="gi">+        return client</span>
<span class="gi">+    except:  # noqa: E722</span>
<span class="gi">+        client.shutdown()</span>
<span class="gi">+        raise</span>
<span class="gh">diff --git a/imapclient/datetime_util.py b/imapclient/datetime_util.py</span>
<span class="gh">index 57a44c4..060f889 100644</span>
<span class="gd">--- a/imapclient/datetime_util.py</span>
<span class="gi">+++ b/imapclient/datetime_util.py</span>
<span class="gu">@@ -1,11 +1,17 @@</span>
<span class="gi">+# Copyright (c) 2014, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from datetime import datetime
<span class="w"> </span>from email.utils import parsedate_tz
<span class="gi">+</span>
<span class="w"> </span>from .fixed_offset import FixedOffset
<span class="gd">-_SHORT_MONTHS = &#39; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&#39;.split(&#39; &#39;)</span>
<span class="gi">+</span>
<span class="gi">+_SHORT_MONTHS = &quot; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&quot;.split(&quot; &quot;)</span>


<span class="gd">-def parse_to_datetime(timestamp: bytes, normalise: bool=True) -&gt;datetime:</span>
<span class="gi">+def parse_to_datetime(timestamp: bytes, normalise: bool = True) -&gt; datetime:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an IMAP datetime string to a datetime.

<span class="w"> </span>    If normalise is True (the default), then the returned datetime
<span class="gu">@@ -14,22 +20,51 @@ def parse_to_datetime(timestamp: bytes, normalise: bool=True) -&gt;datetime:</span>
<span class="w"> </span>    If normalise is False, then the returned datetime will be
<span class="w"> </span>    unadjusted but will contain timezone information as per the input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    time_tuple = parsedate_tz(_munge(timestamp))</span>
<span class="gi">+    if time_tuple is None:</span>
<span class="gi">+        raise ValueError(&quot;couldn&#39;t parse datetime %r&quot; % timestamp)</span>
<span class="gi">+</span>
<span class="gi">+    tz_offset_seconds = time_tuple[-1]</span>
<span class="gi">+    tz = None</span>
<span class="gi">+    if tz_offset_seconds is not None:</span>
<span class="gi">+        tz = FixedOffset(tz_offset_seconds / 60)</span>
<span class="gi">+</span>
<span class="gi">+    dt = datetime(*time_tuple[:6], tzinfo=tz)</span>
<span class="gi">+    if normalise and tz:</span>
<span class="gi">+        dt = datetime_to_native(dt)</span>

<span class="gi">+    return dt</span>

<span class="gd">-def datetime_to_INTERNALDATE(dt: datetime) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def datetime_to_native(dt: datetime) -&gt; datetime:</span>
<span class="gi">+    return dt.astimezone(FixedOffset.for_system()).replace(tzinfo=None)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def datetime_to_INTERNALDATE(dt: datetime) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a datetime instance to a IMAP INTERNALDATE string.

<span class="w"> </span>    If timezone information is missing the current system
<span class="w"> </span>    timezone is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not dt.tzinfo:</span>
<span class="gi">+        dt = dt.replace(tzinfo=FixedOffset.for_system())</span>
<span class="gi">+    fmt = &quot;%d-&quot; + _SHORT_MONTHS[dt.month] + &quot;-%Y %H:%M:%S %z&quot;</span>
<span class="gi">+    return dt.strftime(fmt)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Matches timestamp strings where the time separator is a dot (see</span>
<span class="gi">+# issue #154). For example: &#39;Sat, 8 May 2010 16.03.09 +0200&#39;</span>
<span class="gi">+_rfc822_dotted_time = re.compile(r&quot;\w+, ?\d{1,2} \w+ \d\d(\d\d)? \d\d?\.\d\d?\.\d\d?.*&quot;)</span>


<span class="gd">-_rfc822_dotted_time = re.compile(</span>
<span class="gd">-    &#39;\\w+, ?\\d{1,2} \\w+ \\d\\d(\\d\\d)? \\d\\d?\\.\\d\\d?\\.\\d\\d?.*&#39;)</span>
<span class="gi">+def _munge(timestamp: bytes) -&gt; str:</span>
<span class="gi">+    s = timestamp.decode(&quot;latin-1&quot;)  # parsedate_tz only works with strings</span>
<span class="gi">+    if _rfc822_dotted_time.match(s):</span>
<span class="gi">+        return s.replace(&quot;.&quot;, &quot;:&quot;)</span>
<span class="gi">+    return s</span>


<span class="gd">-def format_criteria_date(dt: datetime) -&gt;bytes:</span>
<span class="gi">+def format_criteria_date(dt: datetime) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Format a date or datetime instance for use in IMAP search criteria.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    out = &quot;%02d-%s-%d&quot; % (dt.day, _SHORT_MONTHS[dt.month], dt.year)</span>
<span class="gi">+    return out.encode(&quot;ascii&quot;)</span>
<span class="gh">diff --git a/imapclient/exceptions.py b/imapclient/exceptions.py</span>
<span class="gh">index a29d919..725af2f 100644</span>
<span class="gd">--- a/imapclient/exceptions.py</span>
<span class="gi">+++ b/imapclient/exceptions.py</span>
<span class="gu">@@ -1,4 +1,10 @@</span>
<span class="w"> </span>import imaplib
<span class="gi">+</span>
<span class="gi">+# Base class allowing to catch any IMAPClient related exceptions</span>
<span class="gi">+# To ensure backward compatibility, we &quot;rename&quot; the imaplib general</span>
<span class="gi">+# exception class, so we can catch its exceptions without having to</span>
<span class="gi">+# deal with it in IMAPClient codebase</span>
<span class="gi">+</span>
<span class="w"> </span>IMAPClientError = imaplib.IMAP4.error
<span class="w"> </span>IMAPClientAbortError = imaplib.IMAP4.abort
<span class="w"> </span>IMAPClientReadOnlyError = imaplib.IMAP4.readonly
<span class="gh">diff --git a/imapclient/fixed_offset.py b/imapclient/fixed_offset.py</span>
<span class="gh">index b9e7df9..344df46 100644</span>
<span class="gd">--- a/imapclient/fixed_offset.py</span>
<span class="gi">+++ b/imapclient/fixed_offset.py</span>
<span class="gu">@@ -1,6 +1,11 @@</span>
<span class="gi">+# Copyright (c) 2014, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import time
<span class="w"> </span>from typing import Optional
<span class="gi">+</span>
<span class="w"> </span>ZERO = datetime.timedelta(0)


<span class="gu">@@ -10,17 +15,31 @@ class FixedOffset(datetime.tzinfo):</span>
<span class="w"> </span>    east from UTC
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, minutes: float) -&gt;None:</span>
<span class="gi">+    def __init__(self, minutes: float) -&gt; None:</span>
<span class="w"> </span>        self.__offset = datetime.timedelta(minutes=minutes)
<span class="gd">-        sign = &#39;+&#39;</span>
<span class="gi">+</span>
<span class="gi">+        sign = &quot;+&quot;</span>
<span class="w"> </span>        if minutes &lt; 0:
<span class="gd">-            sign = &#39;-&#39;</span>
<span class="gi">+            sign = &quot;-&quot;</span>
<span class="w"> </span>        hours, remaining_mins = divmod(abs(minutes), 60)
<span class="gd">-        self.__name = &#39;%s%02d%02d&#39; % (sign, hours, remaining_mins)</span>
<span class="gi">+        self.__name = &quot;%s%02d%02d&quot; % (sign, hours, remaining_mins)</span>
<span class="gi">+</span>
<span class="gi">+    def utcoffset(self, _: Optional[datetime.datetime]) -&gt; datetime.timedelta:</span>
<span class="gi">+        return self.__offset</span>
<span class="gi">+</span>
<span class="gi">+    def tzname(self, _: Optional[datetime.datetime]) -&gt; str:</span>
<span class="gi">+        return self.__name</span>
<span class="gi">+</span>
<span class="gi">+    def dst(self, _: Optional[datetime.datetime]) -&gt; datetime.timedelta:</span>
<span class="gi">+        return ZERO</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def for_system(cls) -&gt;&#39;FixedOffset&#39;:</span>
<span class="gi">+    def for_system(cls) -&gt; &quot;FixedOffset&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a FixedOffset instance for the current working timezone and
<span class="w"> </span>        DST conditions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if time.localtime().tm_isdst and time.daylight:</span>
<span class="gi">+            offset = time.altzone</span>
<span class="gi">+        else:</span>
<span class="gi">+            offset = time.timezone</span>
<span class="gi">+        return cls(-offset // 60)</span>
<span class="gh">diff --git a/imapclient/imap4.py b/imapclient/imap4.py</span>
<span class="gh">index 2a45702..d07515e 100644</span>
<span class="gd">--- a/imapclient/imap4.py</span>
<span class="gi">+++ b/imapclient/imap4.py</span>
<span class="gu">@@ -1,11 +1,27 @@</span>
<span class="gi">+# Copyright (c) 2015, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>import imaplib
<span class="w"> </span>import socket
<span class="w"> </span>from typing import Optional


<span class="w"> </span>class IMAP4WithTimeout(imaplib.IMAP4):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, address: str, port: int, timeout: Optional[float]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, address: str, port: int, timeout: Optional[float]) -&gt; None:</span>
<span class="w"> </span>        self._timeout = timeout
<span class="w"> </span>        imaplib.IMAP4.__init__(self, address, port)
<span class="gi">+</span>
<span class="gi">+    def open(</span>
<span class="gi">+        self, host: str = &quot;&quot;, port: int = 143, timeout: Optional[float] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # This is overridden to make it consistent across Python versions.</span>
<span class="gi">+        self.host = host</span>
<span class="gi">+        self.port = port</span>
<span class="gi">+        self.sock = self._create_socket(timeout)</span>
<span class="gi">+        self.file = self.sock.makefile(&quot;rb&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_socket(self, timeout: Optional[float] = None) -&gt; socket.socket:</span>
<span class="gi">+        return socket.create_connection(</span>
<span class="gi">+            (self.host, self.port), timeout if timeout is not None else self._timeout</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/imapclient/imap_utf7.py b/imapclient/imap_utf7.py</span>
<span class="gh">index 7a795b2..021c564 100644</span>
<span class="gd">--- a/imapclient/imap_utf7.py</span>
<span class="gi">+++ b/imapclient/imap_utf7.py</span>
<span class="gu">@@ -1,25 +1,108 @@</span>
<span class="gi">+# This file contains two main methods used to encode and decode UTF-7</span>
<span class="gi">+# string, described in the RFC 3501. There are some variations specific</span>
<span class="gi">+# to IMAP4rev1, so the built-in Python UTF-7 codec can&#39;t be used instead.</span>
<span class="gi">+#</span>
<span class="gi">+# The main difference is the shift character (used to switch from ASCII to</span>
<span class="gi">+# base64 encoding context), which is &amp; in this modified UTF-7 convention,</span>
<span class="gi">+# since + is considered as mainly used in mailbox names.</span>
<span class="gi">+# Other variations and examples can be found in the RFC 3501, section 5.1.3.</span>
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>from typing import List, Union


<span class="gd">-def encode(s: Union[str, bytes]) -&gt;bytes:</span>
<span class="gi">+def encode(s: Union[str, bytes]) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Encode a folder name using IMAP modified UTF-7 encoding.

<span class="w"> </span>    Input is unicode; output is bytes (Python 3) or str (Python 2). If
<span class="w"> </span>    non-unicode input is provided, the input is returned unchanged.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(s, str):</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    res = bytearray()</span>
<span class="gi">+</span>
<span class="gi">+    b64_buffer: List[str] = []</span>
<span class="gi">+</span>
<span class="gi">+    def consume_b64_buffer(buf: List[str]) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Consume the buffer by encoding it into a modified base 64 representation</span>
<span class="gi">+        and surround it with shift characters &amp; and -</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if buf:</span>
<span class="gi">+            res.extend(b&quot;&amp;&quot; + base64_utf7_encode(buf) + b&quot;-&quot;)</span>
<span class="gi">+            del buf[:]</span>
<span class="gi">+</span>
<span class="gi">+    for c in s:</span>
<span class="gi">+        # printable ascii case should not be modified</span>
<span class="gi">+        o = ord(c)</span>
<span class="gi">+        if 0x20 &lt;= o &lt;= 0x7E:</span>
<span class="gi">+            consume_b64_buffer(b64_buffer)</span>
<span class="gi">+            # Special case: &amp; is used as shift character so we need to escape it in ASCII</span>
<span class="gi">+            if o == 0x26:  # &amp; = 0x26</span>
<span class="gi">+                res.extend(b&quot;&amp;-&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                res.append(o)</span>
<span class="gi">+</span>
<span class="gi">+        # Bufferize characters that will be encoded in base64 and append them later</span>
<span class="gi">+        # in the result, when iterating over ASCII character or the end of string</span>
<span class="gi">+        else:</span>
<span class="gi">+            b64_buffer.append(c)</span>
<span class="gi">+</span>
<span class="gi">+    # Consume the remaining buffer if the string finish with non-ASCII characters</span>
<span class="gi">+    consume_b64_buffer(b64_buffer)</span>
<span class="gi">+</span>
<span class="gi">+    return bytes(res)</span>


<span class="gd">-AMPERSAND_ORD = ord(&#39;&amp;&#39;)</span>
<span class="gd">-DASH_ORD = ord(&#39;-&#39;)</span>
<span class="gi">+AMPERSAND_ORD = ord(&quot;&amp;&quot;)</span>
<span class="gi">+DASH_ORD = ord(&quot;-&quot;)</span>


<span class="gd">-def decode(s: Union[bytes, str]) -&gt;str:</span>
<span class="gi">+def decode(s: Union[bytes, str]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decode a folder name from IMAP modified UTF-7 encoding to unicode.

<span class="w"> </span>    Input is bytes (Python 3) or str (Python 2); output is always
<span class="w"> </span>    unicode. If non-bytes/str input is provided, the input is returned
<span class="w"> </span>    unchanged.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(s, bytes):</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    res = []</span>
<span class="gi">+    # Store base64 substring that will be decoded once stepping on end shift character</span>
<span class="gi">+    b64_buffer = bytearray()</span>
<span class="gi">+    for c in s:</span>
<span class="gi">+        # Shift character without anything in buffer -&gt; starts storing base64 substring</span>
<span class="gi">+        if c == AMPERSAND_ORD and not b64_buffer:</span>
<span class="gi">+            b64_buffer.append(c)</span>
<span class="gi">+        # End shift char. -&gt; append the decoded buffer to the result and reset it</span>
<span class="gi">+        elif c == DASH_ORD and b64_buffer:</span>
<span class="gi">+            # Special case &amp;-, representing &quot;&amp;&quot; escaped</span>
<span class="gi">+            if len(b64_buffer) == 1:</span>
<span class="gi">+                res.append(&quot;&amp;&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                res.append(base64_utf7_decode(b64_buffer[1:]))</span>
<span class="gi">+            b64_buffer = bytearray()</span>
<span class="gi">+        # Still buffering between the shift character and the shift back to ASCII</span>
<span class="gi">+        elif b64_buffer:</span>
<span class="gi">+            b64_buffer.append(c)</span>
<span class="gi">+        # No buffer initialized yet, should be an ASCII printable char</span>
<span class="gi">+        else:</span>
<span class="gi">+            res.append(chr(c))</span>
<span class="gi">+</span>
<span class="gi">+    # Decode the remaining buffer if any</span>
<span class="gi">+    if b64_buffer:</span>
<span class="gi">+        res.append(base64_utf7_decode(b64_buffer[1:]))</span>
<span class="gi">+</span>
<span class="gi">+    return &quot;&quot;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def base64_utf7_encode(buffer: List[str]) -&gt; bytes:</span>
<span class="gi">+    s = &quot;&quot;.join(buffer).encode(&quot;utf-16be&quot;)</span>
<span class="gi">+    return binascii.b2a_base64(s).rstrip(b&quot;\n=&quot;).replace(b&quot;/&quot;, b&quot;,&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def base64_utf7_decode(s: bytearray) -&gt; str:</span>
<span class="gi">+    s_utf7 = b&quot;+&quot; + s.replace(b&quot;,&quot;, b&quot;/&quot;) + b&quot;-&quot;</span>
<span class="gi">+    return s_utf7.decode(&quot;utf-7&quot;)</span>
<span class="gh">diff --git a/imapclient/imapclient.py b/imapclient/imapclient.py</span>
<span class="gh">index 1b399f1..eea281a 100644</span>
<span class="gd">--- a/imapclient/imapclient.py</span>
<span class="gi">+++ b/imapclient/imapclient.py</span>
<span class="gu">@@ -1,3 +1,7 @@</span>
<span class="gi">+# Copyright (c) 2015, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import functools
<span class="w"> </span>import imaplib
<span class="gu">@@ -12,57 +16,103 @@ from datetime import date, datetime</span>
<span class="w"> </span>from logging import getLogger, LoggerAdapter
<span class="w"> </span>from operator import itemgetter
<span class="w"> </span>from typing import List, Optional
<span class="gi">+</span>
<span class="w"> </span>from . import exceptions, imap4, response_lexer, tls
<span class="w"> </span>from .datetime_util import datetime_to_INTERNALDATE, format_criteria_date
<span class="w"> </span>from .imap_utf7 import decode as decode_utf7
<span class="w"> </span>from .imap_utf7 import encode as encode_utf7
<span class="w"> </span>from .response_parser import parse_fetch_response, parse_message_list, parse_response
<span class="w"> </span>from .util import assert_imap_protocol, chunk, to_bytes, to_unicode
<span class="gd">-if hasattr(select, &#39;poll&#39;):</span>
<span class="gi">+</span>
<span class="gi">+if hasattr(select, &quot;poll&quot;):</span>
<span class="w"> </span>    POLL_SUPPORT = True
<span class="w"> </span>else:
<span class="gi">+    # Fallback to select() on systems that don&#39;t support poll()</span>
<span class="w"> </span>    POLL_SUPPORT = False
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = getLogger(__name__)
<span class="gd">-__all__ = [&#39;IMAPClient&#39;, &#39;SocketTimeout&#39;, &#39;DELETED&#39;, &#39;SEEN&#39;, &#39;ANSWERED&#39;,</span>
<span class="gd">-    &#39;FLAGGED&#39;, &#39;DRAFT&#39;, &#39;RECENT&#39;]</span>
<span class="gd">-if &#39;XLIST&#39; not in imaplib.Commands:</span>
<span class="gd">-    imaplib.Commands[&#39;XLIST&#39;] = &#39;NONAUTH&#39;, &#39;AUTH&#39;, &#39;SELECTED&#39;</span>
<span class="gd">-if &#39;IDLE&#39; not in imaplib.Commands:</span>
<span class="gd">-    imaplib.Commands[&#39;IDLE&#39;] = &#39;NONAUTH&#39;, &#39;AUTH&#39;, &#39;SELECTED&#39;</span>
<span class="gd">-if &#39;STARTTLS&#39; not in imaplib.Commands:</span>
<span class="gd">-    imaplib.Commands[&#39;STARTTLS&#39;] = &#39;NONAUTH&#39;,</span>
<span class="gd">-if &#39;ID&#39; not in imaplib.Commands:</span>
<span class="gd">-    imaplib.Commands[&#39;ID&#39;] = &#39;NONAUTH&#39;, &#39;AUTH&#39;, &#39;SELECTED&#39;</span>
<span class="gd">-if &#39;UNSELECT&#39; not in imaplib.Commands:</span>
<span class="gd">-    imaplib.Commands[&#39;UNSELECT&#39;] = &#39;AUTH&#39;, &#39;SELECTED&#39;</span>
<span class="gd">-if &#39;ENABLE&#39; not in imaplib.Commands:</span>
<span class="gd">-    imaplib.Commands[&#39;ENABLE&#39;] = &#39;AUTH&#39;,</span>
<span class="gd">-if &#39;MOVE&#39; not in imaplib.Commands:</span>
<span class="gd">-    imaplib.Commands[&#39;MOVE&#39;] = &#39;AUTH&#39;, &#39;SELECTED&#39;</span>
<span class="gd">-DELETED = b&#39;\\Deleted&#39;</span>
<span class="gd">-SEEN = b&#39;\\Seen&#39;</span>
<span class="gd">-ANSWERED = b&#39;\\Answered&#39;</span>
<span class="gd">-FLAGGED = b&#39;\\Flagged&#39;</span>
<span class="gd">-DRAFT = b&#39;\\Draft&#39;</span>
<span class="gd">-RECENT = b&#39;\\Recent&#39;</span>
<span class="gd">-ALL = b&#39;\\All&#39;</span>
<span class="gd">-ARCHIVE = b&#39;\\Archive&#39;</span>
<span class="gd">-DRAFTS = b&#39;\\Drafts&#39;</span>
<span class="gd">-JUNK = b&#39;\\Junk&#39;</span>
<span class="gd">-SENT = b&#39;\\Sent&#39;</span>
<span class="gd">-TRASH = b&#39;\\Trash&#39;</span>
<span class="gd">-_POPULAR_PERSONAL_NAMESPACES = (&#39;&#39;, &#39;&#39;), (&#39;INBOX.&#39;, &#39;.&#39;)</span>
<span class="gd">-_POPULAR_SPECIAL_FOLDERS = {SENT: (&#39;Sent&#39;, &#39;Sent Items&#39;, &#39;Sent items&#39;),</span>
<span class="gd">-    DRAFTS: (&#39;Drafts&#39;,), ARCHIVE: (&#39;Archive&#39;,), TRASH: (&#39;Trash&#39;,</span>
<span class="gd">-    &#39;Deleted Items&#39;, &#39;Deleted Messages&#39;, &#39;Deleted&#39;), JUNK: (&#39;Junk&#39;, &#39;Spam&#39;)}</span>
<span class="gd">-_RE_SELECT_RESPONSE = re.compile(</span>
<span class="gd">-    b&#39;\\[(?P&lt;key&gt;[A-Z-]+)( \\((?P&lt;data&gt;.*)\\))?\\]&#39;)</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;IMAPClient&quot;,</span>
<span class="gi">+    &quot;SocketTimeout&quot;,</span>
<span class="gi">+    &quot;DELETED&quot;,</span>
<span class="gi">+    &quot;SEEN&quot;,</span>
<span class="gi">+    &quot;ANSWERED&quot;,</span>
<span class="gi">+    &quot;FLAGGED&quot;,</span>
<span class="gi">+    &quot;DRAFT&quot;,</span>
<span class="gi">+    &quot;RECENT&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# We also offer the gmail-specific XLIST command...</span>
<span class="gi">+if &quot;XLIST&quot; not in imaplib.Commands:</span>
<span class="gi">+    imaplib.Commands[&quot;XLIST&quot;] = (&quot;NONAUTH&quot;, &quot;AUTH&quot;, &quot;SELECTED&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# ...and IDLE</span>
<span class="gi">+if &quot;IDLE&quot; not in imaplib.Commands:</span>
<span class="gi">+    imaplib.Commands[&quot;IDLE&quot;] = (&quot;NONAUTH&quot;, &quot;AUTH&quot;, &quot;SELECTED&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# ..and STARTTLS</span>
<span class="gi">+if &quot;STARTTLS&quot; not in imaplib.Commands:</span>
<span class="gi">+    imaplib.Commands[&quot;STARTTLS&quot;] = (&quot;NONAUTH&quot;,)</span>
<span class="gi">+</span>
<span class="gi">+# ...and ID. RFC2971 says that this command is valid in all states,</span>
<span class="gi">+# but not that some servers (*cough* FastMail *cough*) don&#39;t seem to</span>
<span class="gi">+# accept it in state NONAUTH.</span>
<span class="gi">+if &quot;ID&quot; not in imaplib.Commands:</span>
<span class="gi">+    imaplib.Commands[&quot;ID&quot;] = (&quot;NONAUTH&quot;, &quot;AUTH&quot;, &quot;SELECTED&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# ... and UNSELECT. RFC3691 does not specify the state but there is no</span>
<span class="gi">+# reason to use the command without AUTH state and a mailbox selected.</span>
<span class="gi">+if &quot;UNSELECT&quot; not in imaplib.Commands:</span>
<span class="gi">+    imaplib.Commands[&quot;UNSELECT&quot;] = (&quot;AUTH&quot;, &quot;SELECTED&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# .. and ENABLE.</span>
<span class="gi">+if &quot;ENABLE&quot; not in imaplib.Commands:</span>
<span class="gi">+    imaplib.Commands[&quot;ENABLE&quot;] = (&quot;AUTH&quot;,)</span>
<span class="gi">+</span>
<span class="gi">+# .. and MOVE for RFC6851.</span>
<span class="gi">+if &quot;MOVE&quot; not in imaplib.Commands:</span>
<span class="gi">+    imaplib.Commands[&quot;MOVE&quot;] = (&quot;AUTH&quot;, &quot;SELECTED&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# System flags</span>
<span class="gi">+DELETED = rb&quot;\Deleted&quot;</span>
<span class="gi">+SEEN = rb&quot;\Seen&quot;</span>
<span class="gi">+ANSWERED = rb&quot;\Answered&quot;</span>
<span class="gi">+FLAGGED = rb&quot;\Flagged&quot;</span>
<span class="gi">+DRAFT = rb&quot;\Draft&quot;</span>
<span class="gi">+RECENT = rb&quot;\Recent&quot;  # This flag is read-only</span>
<span class="gi">+</span>
<span class="gi">+# Special folders, see RFC6154</span>
<span class="gi">+# \Flagged is omitted because it is the same as the flag defined above</span>
<span class="gi">+ALL = rb&quot;\All&quot;</span>
<span class="gi">+ARCHIVE = rb&quot;\Archive&quot;</span>
<span class="gi">+DRAFTS = rb&quot;\Drafts&quot;</span>
<span class="gi">+JUNK = rb&quot;\Junk&quot;</span>
<span class="gi">+SENT = rb&quot;\Sent&quot;</span>
<span class="gi">+TRASH = rb&quot;\Trash&quot;</span>
<span class="gi">+</span>
<span class="gi">+# Personal namespaces that are common among providers</span>
<span class="gi">+# used as a fallback when the server does not support the NAMESPACE capability</span>
<span class="gi">+_POPULAR_PERSONAL_NAMESPACES = ((&quot;&quot;, &quot;&quot;), (&quot;INBOX.&quot;, &quot;.&quot;))</span>
<span class="gi">+</span>
<span class="gi">+# Names of special folders that are common among providers</span>
<span class="gi">+_POPULAR_SPECIAL_FOLDERS = {</span>
<span class="gi">+    SENT: (&quot;Sent&quot;, &quot;Sent Items&quot;, &quot;Sent items&quot;),</span>
<span class="gi">+    DRAFTS: (&quot;Drafts&quot;,),</span>
<span class="gi">+    ARCHIVE: (&quot;Archive&quot;,),</span>
<span class="gi">+    TRASH: (&quot;Trash&quot;, &quot;Deleted Items&quot;, &quot;Deleted Messages&quot;, &quot;Deleted&quot;),</span>
<span class="gi">+    JUNK: (&quot;Junk&quot;, &quot;Spam&quot;),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+_RE_SELECT_RESPONSE = re.compile(rb&quot;\[(?P&lt;key&gt;[A-Z-]+)( \((?P&lt;data&gt;.*)\))?\]&quot;)</span>

<span class="gd">-class Namespace(tuple):</span>

<span class="gi">+class Namespace(tuple):</span>
<span class="w"> </span>    def __new__(cls, personal, other, shared):
<span class="w"> </span>        return tuple.__new__(cls, (personal, other, shared))
<span class="gi">+</span>
<span class="w"> </span>    personal = property(itemgetter(0))
<span class="w"> </span>    other = property(itemgetter(1))
<span class="w"> </span>    shared = property(itemgetter(2))
<span class="gu">@@ -79,6 +129,7 @@ class SocketTimeout:</span>
<span class="w"> </span>    timeout if the connection takes more than 15 seconds to establish but
<span class="w"> </span>    read/write operations can take up to 60 seconds once the connection is done.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    connect: float
<span class="w"> </span>    read: float

<span class="gu">@@ -92,6 +143,7 @@ class MailboxQuotaRoots:</span>
<span class="w"> </span>    :ivar mailbox: the mailbox
<span class="w"> </span>    :ivar quota_roots: list of quota roots associated with the mailbox
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    mailbox: str
<span class="w"> </span>    quota_roots: List[str]

<span class="gu">@@ -107,6 +159,7 @@ class Quota:</span>
<span class="w"> </span>    :ivar usage: the current usage of the resource
<span class="w"> </span>    :ivar limit: the maximum allowed usage of the resource
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    quota_root: str
<span class="w"> </span>    resource: str
<span class="w"> </span>    usage: bytes
<span class="gu">@@ -115,7 +168,19 @@ class Quota:</span>

<span class="w"> </span>def require_capability(capability):
<span class="w"> </span>    &quot;&quot;&quot;Decorator raising CapabilityError when a capability is not available.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def actual_decorator(func):</span>
<span class="gi">+        @functools.wraps(func)</span>
<span class="gi">+        def wrapper(client, *args, **kwargs):</span>
<span class="gi">+            if not client.has_capability(capability):</span>
<span class="gi">+                raise exceptions.CapabilityError(</span>
<span class="gi">+                    &quot;Server does not support {} capability&quot;.format(capability)</span>
<span class="gi">+                )</span>
<span class="gi">+            return func(client, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+</span>
<span class="gi">+    return actual_decorator</span>


<span class="w"> </span>class IMAPClient:
<span class="gu">@@ -168,13 +233,24 @@ class IMAPClient:</span>
<span class="w"> </span>    ...     client.login(&quot;bar@foo.org&quot;, &quot;passwd&quot;)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # Those exceptions are kept for backward-compatibility, since</span>
<span class="gi">+    # previous versions included these attributes as references to</span>
<span class="gi">+    # imaplib original exceptions</span>
<span class="w"> </span>    Error = exceptions.IMAPClientError
<span class="w"> </span>    AbortError = exceptions.IMAPClientAbortError
<span class="w"> </span>    ReadOnlyError = exceptions.IMAPClientReadOnlyError

<span class="gd">-    def __init__(self, host: str, port: int=None, use_uid: bool=True, ssl:</span>
<span class="gd">-        bool=True, stream: bool=False, ssl_context: Optional[ssl_lib.</span>
<span class="gd">-        SSLContext]=None, timeout: Optional[float]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host: str,</span>
<span class="gi">+        port: int = None,</span>
<span class="gi">+        use_uid: bool = True,</span>
<span class="gi">+        ssl: bool = True,</span>
<span class="gi">+        stream: bool = False,</span>
<span class="gi">+        ssl_context: Optional[ssl_lib.SSLContext] = None,</span>
<span class="gi">+        timeout: Optional[float] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if stream:
<span class="w"> </span>            if port is not None:
<span class="w"> </span>                raise ValueError(&quot;can&#39;t set &#39;port&#39; when &#39;stream&#39; True&quot;)
<span class="gu">@@ -182,10 +258,14 @@ class IMAPClient:</span>
<span class="w"> </span>                raise ValueError(&quot;can&#39;t use &#39;ssl&#39; when &#39;stream&#39; is True&quot;)
<span class="w"> </span>        elif port is None:
<span class="w"> </span>            port = ssl and 993 or 143
<span class="gi">+</span>
<span class="w"> </span>        if ssl and port == 143:
<span class="w"> </span>            logger.warning(
<span class="gd">-                &#39;Attempting to establish an encrypted connection to a port (143) often used for unencrypted connections&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                &quot;Attempting to establish an encrypted connection &quot;</span>
<span class="gi">+                &quot;to a port (143) often used for unencrypted &quot;</span>
<span class="gi">+                &quot;connections&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.host = host
<span class="w"> </span>        self.port = port
<span class="w"> </span>        self.ssl = ssl
<span class="gu">@@ -194,18 +274,27 @@ class IMAPClient:</span>
<span class="w"> </span>        self.use_uid = use_uid
<span class="w"> </span>        self.folder_encode = True
<span class="w"> </span>        self.normalise_times = True
<span class="gi">+</span>
<span class="gi">+        # If the user gives a single timeout value, assume it is the same for</span>
<span class="gi">+        # connection and read/write operations</span>
<span class="w"> </span>        if not isinstance(timeout, SocketTimeout):
<span class="w"> </span>            timeout = SocketTimeout(timeout, timeout)
<span class="gi">+</span>
<span class="w"> </span>        self._timeout = timeout
<span class="w"> </span>        self._starttls_done = False
<span class="w"> </span>        self._cached_capabilities = None
<span class="w"> </span>        self._idle_tag = None
<span class="gi">+</span>
<span class="w"> </span>        self._imap = self._create_IMAP4()
<span class="gd">-        logger.debug(&#39;Connected to host %s over %s&#39;, self.host, &#39;SSL/TLS&#39; if</span>
<span class="gd">-            ssl else &#39;plain text&#39;)</span>
<span class="gi">+        logger.debug(</span>
<span class="gi">+            &quot;Connected to host %s over %s&quot;,</span>
<span class="gi">+            self.host,</span>
<span class="gi">+            &quot;SSL/TLS&quot; if ssl else &quot;plain text&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self._set_read_timeout()
<span class="gd">-        imaplib_logger = IMAPlibLoggerAdapter(getLogger(</span>
<span class="gd">-            &#39;imapclient.imaplib&#39;), {})</span>
<span class="gi">+        # Small hack to make imaplib log everything to its own logger</span>
<span class="gi">+        imaplib_logger = IMAPlibLoggerAdapter(getLogger(&quot;imapclient.imaplib&quot;), {})</span>
<span class="w"> </span>        self._imap.debug = 5
<span class="w"> </span>        self._imap._mesg = imaplib_logger.debug

<span class="gu">@@ -224,7 +313,32 @@ class IMAPClient:</span>
<span class="w"> </span>            try:
<span class="w"> </span>                self.shutdown()
<span class="w"> </span>            except Exception as e:
<span class="gd">-                logger.info(&#39;Could not close the connection cleanly: %s&#39;, e)</span>
<span class="gi">+                logger.info(&quot;Could not close the connection cleanly: %s&quot;, e)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_IMAP4(self):</span>
<span class="gi">+        if self.stream:</span>
<span class="gi">+            return imaplib.IMAP4_stream(self.host)</span>
<span class="gi">+</span>
<span class="gi">+        connect_timeout = getattr(self._timeout, &quot;connect&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        if self.ssl:</span>
<span class="gi">+            return tls.IMAP4_TLS(</span>
<span class="gi">+                self.host,</span>
<span class="gi">+                self.port,</span>
<span class="gi">+                self.ssl_context,</span>
<span class="gi">+                connect_timeout,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return imap4.IMAP4WithTimeout(self.host, self.port, connect_timeout)</span>
<span class="gi">+</span>
<span class="gi">+    def _set_read_timeout(self):</span>
<span class="gi">+        if self._timeout is not None:</span>
<span class="gi">+            self.socket().settimeout(self._timeout.read)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _sock(self):</span>
<span class="gi">+        warnings.warn(&quot;_sock is deprecated. Use socket().&quot;, DeprecationWarning)</span>
<span class="gi">+        return self.socket()</span>

<span class="w"> </span>    def socket(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns socket used to connect to server.
<span class="gu">@@ -239,9 +353,11 @@ class IMAPClient:</span>
<span class="w"> </span>           This includes reading from and writing to the socket,
<span class="w"> </span>           as they are likely to break internal bookkeeping of messages.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # In py2, imaplib has sslobj (for SSL connections), and sock for non-SSL.</span>
<span class="gi">+        # In the py3 version it&#39;s just sock.</span>
<span class="gi">+        return getattr(self._imap, &quot;sslobj&quot;, self._imap.sock)</span>

<span class="gd">-    @require_capability(&#39;STARTTLS&#39;)</span>
<span class="gi">+    @require_capability(&quot;STARTTLS&quot;)</span>
<span class="w"> </span>    def starttls(self, ssl_context=None):
<span class="w"> </span>        &quot;&quot;&quot;Switch to an SSL encrypted connection by sending a STARTTLS command.

<span class="gu">@@ -259,22 +375,55 @@ class IMAPClient:</span>
<span class="w"> </span>        Raises :py:exc:`AbortError` if the server does not support STARTTLS
<span class="w"> </span>        or an SSL connection is already established.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ssl or self._starttls_done:</span>
<span class="gi">+            raise exceptions.IMAPClientAbortError(&quot;TLS session already established&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        typ, data = self._imap._simple_command(&quot;STARTTLS&quot;)</span>
<span class="gi">+        self._checkok(&quot;starttls&quot;, typ, data)</span>
<span class="gi">+</span>
<span class="gi">+        self._starttls_done = True</span>
<span class="gi">+</span>
<span class="gi">+        self._imap.sock = tls.wrap_socket(self._imap.sock, ssl_context, self.host)</span>
<span class="gi">+        self._imap.file = self._imap.sock.makefile(&quot;rb&quot;)</span>
<span class="gi">+        return data[0]</span>

<span class="w"> </span>    def login(self, username: str, password: str):
<span class="w"> </span>        &quot;&quot;&quot;Login using *username* and *password*, returning the
<span class="w"> </span>        server response.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def oauth2_login(self, user: str, access_token: str, mech: str=</span>
<span class="gd">-        &#39;XOAUTH2&#39;, vendor: Optional[str]=None):</span>
<span class="gi">+        try:</span>
<span class="gi">+            rv = self._command_and_check(</span>
<span class="gi">+                &quot;login&quot;,</span>
<span class="gi">+                to_unicode(username),</span>
<span class="gi">+                to_unicode(password),</span>
<span class="gi">+                unpack=True,</span>
<span class="gi">+            )</span>
<span class="gi">+        except exceptions.IMAPClientError as e:</span>
<span class="gi">+            raise exceptions.LoginError(str(e))</span>
<span class="gi">+</span>
<span class="gi">+        logger.debug(&quot;Logged in as %s&quot;, username)</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def oauth2_login(</span>
<span class="gi">+        self,</span>
<span class="gi">+        user: str,</span>
<span class="gi">+        access_token: str,</span>
<span class="gi">+        mech: str = &quot;XOAUTH2&quot;,</span>
<span class="gi">+        vendor: Optional[str] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Authenticate using the OAUTH2 or XOAUTH2 methods.

<span class="w"> </span>        Gmail and Yahoo both support the &#39;XOAUTH2&#39; mechanism, but Yahoo requires
<span class="w"> </span>        the &#39;vendor&#39; portion in the payload.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        auth_string = &quot;user=%s\1auth=Bearer %s\1&quot; % (user, access_token)</span>
<span class="gi">+        if vendor:</span>
<span class="gi">+            auth_string += &quot;vendor=%s\1&quot; % vendor</span>
<span class="gi">+        auth_string += &quot;\1&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._command_and_check(&quot;authenticate&quot;, mech, lambda x: auth_string)</span>
<span class="gi">+        except exceptions.IMAPClientError as e:</span>
<span class="gi">+            raise exceptions.LoginError(str(e))</span>

<span class="w"> </span>    def oauthbearer_login(self, identity, access_token):
<span class="w"> </span>        &quot;&quot;&quot;Authenticate using the OAUTHBEARER method.
<span class="gu">@@ -282,11 +431,35 @@ class IMAPClient:</span>
<span class="w"> </span>        This is supported by Gmail and is meant to supersede the non-standard
<span class="w"> </span>        &#39;OAUTH2&#39; and &#39;XOAUTH2&#39; mechanisms.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # https://tools.ietf.org/html/rfc5801#section-4</span>
<span class="gi">+        # Technically this is the authorization_identity, but at least for Gmail it&#39;s</span>
<span class="gi">+        # mandatory and practically behaves like the regular username/identity.</span>
<span class="gi">+        if identity:</span>
<span class="gi">+            gs2_header = &quot;n,a=%s,&quot; % identity.replace(&quot;=&quot;, &quot;=3D&quot;).replace(&quot;,&quot;, &quot;=2C&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            gs2_header = &quot;n,,&quot;</span>
<span class="gi">+        # https://tools.ietf.org/html/rfc6750#section-2.1</span>
<span class="gi">+        http_authz = &quot;Bearer %s&quot; % access_token</span>
<span class="gi">+        # https://tools.ietf.org/html/rfc7628#section-3.1</span>
<span class="gi">+        auth_string = &quot;%s\1auth=%s\1\1&quot; % (gs2_header, http_authz)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._command_and_check(</span>
<span class="gi">+                &quot;authenticate&quot;, &quot;OAUTHBEARER&quot;, lambda x: auth_string</span>
<span class="gi">+            )</span>
<span class="gi">+        except exceptions.IMAPClientError as e:</span>
<span class="gi">+            raise exceptions.LoginError(str(e))</span>

<span class="w"> </span>    def plain_login(self, identity, password, authorization_identity=None):
<span class="w"> </span>        &quot;&quot;&quot;Authenticate using the PLAIN method (requires server support).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not authorization_identity:</span>
<span class="gi">+            authorization_identity = &quot;&quot;</span>
<span class="gi">+        auth_string = &quot;%s\0%s\0%s&quot; % (authorization_identity, identity, password)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._command_and_check(</span>
<span class="gi">+                &quot;authenticate&quot;, &quot;PLAIN&quot;, lambda _: auth_string, unpack=True</span>
<span class="gi">+            )</span>
<span class="gi">+        except exceptions.IMAPClientError as e:</span>
<span class="gi">+            raise exceptions.LoginError(str(e))</span>

<span class="w"> </span>    def sasl_login(self, mech_name, mech_callable):
<span class="w"> </span>        &quot;&quot;&quot;Authenticate using a provided SASL mechanism (requires server support).
<span class="gu">@@ -337,21 +510,30 @@ class IMAPClient:</span>

<span class="w"> </span>            imap.sasl_login(&quot;SCRAM-SHA-256&quot;, scram_mech)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._command_and_check(</span>
<span class="gi">+                &quot;authenticate&quot;, mech_name, mech_callable, unpack=True</span>
<span class="gi">+            )</span>
<span class="gi">+        except exceptions.IMAPClientError as e:</span>
<span class="gi">+            raise exceptions.LoginError(str(e))</span>

<span class="w"> </span>    def logout(self):
<span class="w"> </span>        &quot;&quot;&quot;Logout, returning the server response.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        typ, data = self._imap.logout()</span>
<span class="gi">+        self._check_resp(&quot;BYE&quot;, &quot;logout&quot;, typ, data)</span>
<span class="gi">+        logger.debug(&quot;Logged out, connection closed&quot;)</span>
<span class="gi">+        return data[0]</span>

<span class="gd">-    def shutdown(self) -&gt;None:</span>
<span class="gi">+    def shutdown(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Close the connection to the IMAP server (without logging out)

<span class="w"> </span>        In most cases, :py:meth:`.logout` should be used instead of
<span class="w"> </span>        this. The logout method also shutdown down the connection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._imap.shutdown()</span>
<span class="gi">+        logger.info(&quot;Connection closed&quot;)</span>

<span class="gd">-    @require_capability(&#39;ENABLE&#39;)</span>
<span class="gi">+    @require_capability(&quot;ENABLE&quot;)</span>
<span class="w"> </span>    def enable(self, *capabilities):
<span class="w"> </span>        &quot;&quot;&quot;Activate one or more server side capability extensions.

<span class="gu">@@ -368,9 +550,23 @@ class IMAPClient:</span>

<span class="w"> </span>        See :rfc:`5161` for more details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @require_capability(&#39;ID&#39;)</span>
<span class="gi">+        if self._imap.state != &quot;AUTH&quot;:</span>
<span class="gi">+            raise exceptions.IllegalStateError(</span>
<span class="gi">+                &quot;ENABLE command illegal in state %s&quot; % self._imap.state</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        resp = self._raw_command_untagged(</span>
<span class="gi">+            b&quot;ENABLE&quot;,</span>
<span class="gi">+            [to_bytes(c) for c in capabilities],</span>
<span class="gi">+            uid=False,</span>
<span class="gi">+            response_name=&quot;ENABLED&quot;,</span>
<span class="gi">+            unpack=True,</span>
<span class="gi">+        )</span>
<span class="gi">+        if not resp:</span>
<span class="gi">+            return []</span>
<span class="gi">+        return resp.split()</span>
<span class="gi">+</span>
<span class="gi">+    @require_capability(&quot;ID&quot;)</span>
<span class="w"> </span>    def id_(self, parameters=None):
<span class="w"> </span>        &quot;&quot;&quot;Issue the ID command, returning a dict of server implementation
<span class="w"> </span>        fields.
<span class="gu">@@ -378,7 +574,19 @@ class IMAPClient:</span>
<span class="w"> </span>        *parameters* should be specified as a dictionary of field/value pairs,
<span class="w"> </span>        for example: ``{&quot;name&quot;: &quot;IMAPClient&quot;, &quot;version&quot;: &quot;0.12&quot;}``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if parameters is None:</span>
<span class="gi">+            args = &quot;NIL&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not isinstance(parameters, dict):</span>
<span class="gi">+                raise TypeError(&quot;&#39;parameters&#39; should be a dictionary&quot;)</span>
<span class="gi">+            args = seq_to_parenstr(</span>
<span class="gi">+                _quote(v) for v in itertools.chain.from_iterable(parameters.items())</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        typ, data = self._imap._simple_command(&quot;ID&quot;, args)</span>
<span class="gi">+        self._checkok(&quot;id&quot;, typ, data)</span>
<span class="gi">+        typ, data = self._imap._untagged_response(typ, data, &quot;ID&quot;)</span>
<span class="gi">+        return parse_response(data)</span>

<span class="w"> </span>    def capabilities(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the server capability list.
<span class="gu">@@ -392,13 +600,51 @@ class IMAPClient:</span>
<span class="w"> </span>        If the session is not yet authenticated, the capabilities
<span class="w"> </span>        requested at connection time will be returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Ensure cached capabilities aren&#39;t used post-STARTTLS. As per</span>
<span class="gi">+        # https://tools.ietf.org/html/rfc2595#section-3.1</span>
<span class="gi">+        if self._starttls_done and self._imap.state == &quot;NONAUTH&quot;:</span>
<span class="gi">+            self._cached_capabilities = None</span>
<span class="gi">+            return self._do_capabilites()</span>
<span class="gi">+</span>
<span class="gi">+        # If a capability response has been cached, use that.</span>
<span class="gi">+        if self._cached_capabilities:</span>
<span class="gi">+            return self._cached_capabilities</span>
<span class="gi">+</span>
<span class="gi">+        # If the server returned an untagged CAPABILITY response</span>
<span class="gi">+        # (during authentication), cache it and return that.</span>
<span class="gi">+        untagged = _dict_bytes_normaliser(self._imap.untagged_responses)</span>
<span class="gi">+        response = untagged.pop(&quot;CAPABILITY&quot;, None)</span>
<span class="gi">+        if response:</span>
<span class="gi">+            self._cached_capabilities = self._normalise_capabilites(response[0])</span>
<span class="gi">+            return self._cached_capabilities</span>
<span class="gi">+</span>
<span class="gi">+        # If authenticated, but don&#39;t have a capability response, ask for one</span>
<span class="gi">+        if self._imap.state in (&quot;SELECTED&quot;, &quot;AUTH&quot;):</span>
<span class="gi">+            self._cached_capabilities = self._do_capabilites()</span>
<span class="gi">+            return self._cached_capabilities</span>
<span class="gi">+</span>
<span class="gi">+        # Return capabilities that imaplib requested at connection</span>
<span class="gi">+        # time (pre-auth)</span>
<span class="gi">+        return tuple(to_bytes(c) for c in self._imap.capabilities)</span>
<span class="gi">+</span>
<span class="gi">+    def _do_capabilites(self):</span>
<span class="gi">+        raw_response = self._command_and_check(&quot;capability&quot;, unpack=True)</span>
<span class="gi">+        return self._normalise_capabilites(raw_response)</span>
<span class="gi">+</span>
<span class="gi">+    def _normalise_capabilites(self, raw_response):</span>
<span class="gi">+        raw_response = to_bytes(raw_response)</span>
<span class="gi">+        return tuple(raw_response.upper().split())</span>

<span class="w"> </span>    def has_capability(self, capability):
<span class="w"> </span>        &quot;&quot;&quot;Return ``True`` if the IMAP server has the given *capability*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @require_capability(&#39;NAMESPACE&#39;)</span>
<span class="gi">+        # FIXME: this will not detect capabilities that are backwards</span>
<span class="gi">+        # compatible with the current level. For instance the SORT</span>
<span class="gi">+        # capabilities may in the future be named SORT2 which is</span>
<span class="gi">+        # still compatible with the current standard and will not</span>
<span class="gi">+        # be detected by this method.</span>
<span class="gi">+        return to_bytes(capability).upper() in self.capabilities()</span>
<span class="gi">+</span>
<span class="gi">+    @require_capability(&quot;NAMESPACE&quot;)</span>
<span class="w"> </span>    def namespace(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the namespace for the account as a (personal, other,
<span class="w"> </span>        shared) tuple.
<span class="gu">@@ -412,9 +658,21 @@ class IMAPClient:</span>

<span class="w"> </span>        See :rfc:`2342` for more details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def list_folders(self, directory=&#39;&#39;, pattern=&#39;*&#39;):</span>
<span class="gi">+        data = self._command_and_check(&quot;namespace&quot;)</span>
<span class="gi">+        parts = []</span>
<span class="gi">+        for item in parse_response(data):</span>
<span class="gi">+            if item is None:</span>
<span class="gi">+                parts.append(item)</span>
<span class="gi">+            else:</span>
<span class="gi">+                converted = []</span>
<span class="gi">+                for prefix, separator in item:</span>
<span class="gi">+                    if self.folder_encode:</span>
<span class="gi">+                        prefix = decode_utf7(prefix)</span>
<span class="gi">+                    converted.append((prefix, to_unicode(separator)))</span>
<span class="gi">+                parts.append(tuple(converted))</span>
<span class="gi">+        return Namespace(*parts)</span>
<span class="gi">+</span>
<span class="gi">+    def list_folders(self, directory=&quot;&quot;, pattern=&quot;*&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a listing of folders on the server as a list of
<span class="w"> </span>        ``(flags, delimiter, name)`` tuples.

<span class="gu">@@ -435,10 +693,10 @@ class IMAPClient:</span>
<span class="w"> </span>        decoded from modified UTF-7, except if folder_decode is not
<span class="w"> </span>        set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._do_list(&quot;LIST&quot;, directory, pattern)</span>

<span class="gd">-    @require_capability(&#39;XLIST&#39;)</span>
<span class="gd">-    def xlist_folders(self, directory=&#39;&#39;, pattern=&#39;*&#39;):</span>
<span class="gi">+    @require_capability(&quot;XLIST&quot;)</span>
<span class="gi">+    def xlist_folders(self, directory=&quot;&quot;, pattern=&quot;*&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Execute the XLIST command, returning ``(flags, delimiter,
<span class="w"> </span>        name)`` tuples.

<span class="gu">@@ -467,16 +725,44 @@ class IMAPClient:</span>
<span class="w"> </span>        The *directory* and *pattern* arguments are as per
<span class="w"> </span>        list_folders().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._do_list(&quot;XLIST&quot;, directory, pattern)</span>

<span class="gd">-    def list_sub_folders(self, directory=&#39;&#39;, pattern=&#39;*&#39;):</span>
<span class="gi">+    def list_sub_folders(self, directory=&quot;&quot;, pattern=&quot;*&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of subscribed folders on the server as
<span class="w"> </span>        ``(flags, delimiter, name)`` tuples.

<span class="w"> </span>        The default behaviour will list all subscribed folders. The
<span class="w"> </span>        *directory* and *pattern* arguments are as per list_folders().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._do_list(&quot;LSUB&quot;, directory, pattern)</span>
<span class="gi">+</span>
<span class="gi">+    def _do_list(self, cmd, directory, pattern):</span>
<span class="gi">+        directory = self._normalise_folder(directory)</span>
<span class="gi">+        pattern = self._normalise_folder(pattern)</span>
<span class="gi">+        typ, dat = self._imap._simple_command(cmd, directory, pattern)</span>
<span class="gi">+        self._checkok(cmd, typ, dat)</span>
<span class="gi">+        typ, dat = self._imap._untagged_response(typ, dat, cmd)</span>
<span class="gi">+        return self._proc_folder_list(dat)</span>
<span class="gi">+</span>
<span class="gi">+    def _proc_folder_list(self, folder_data):</span>
<span class="gi">+        # Filter out empty strings and None&#39;s.</span>
<span class="gi">+        # This also deals with the special case of - no &#39;untagged&#39;</span>
<span class="gi">+        # responses (ie, no folders). This comes back as [None].</span>
<span class="gi">+        folder_data = [item for item in folder_data if item not in (b&quot;&quot;, None)]</span>
<span class="gi">+</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        parsed = parse_response(folder_data)</span>
<span class="gi">+        for flags, delim, name in chunk(parsed, size=3):</span>
<span class="gi">+            if isinstance(name, int):</span>
<span class="gi">+                # Some IMAP implementations return integer folder names</span>
<span class="gi">+                # with quotes. These get parsed to ints so convert them</span>
<span class="gi">+                # back to strings.</span>
<span class="gi">+                name = str(name)</span>
<span class="gi">+            elif self.folder_encode:</span>
<span class="gi">+                name = decode_utf7(name)</span>
<span class="gi">+</span>
<span class="gi">+            ret.append((flags, delim, name))</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def find_special_folder(self, folder_flag):
<span class="w"> </span>        &quot;&quot;&quot;Try to locate a special folder, like the Sent or Trash folder.
<span class="gu">@@ -490,7 +776,27 @@ class IMAPClient:</span>

<span class="w"> </span>        Returns the name of the folder if found, or None otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Detect folder by looking for known attributes</span>
<span class="gi">+        # TODO: avoid listing all folders by using extended LIST (RFC6154)</span>
<span class="gi">+        for folder in self.list_folders():</span>
<span class="gi">+            if folder and len(folder[0]) &gt; 0 and folder_flag in folder[0]:</span>
<span class="gi">+                return folder[2]</span>
<span class="gi">+</span>
<span class="gi">+        # Detect folder by looking for common names</span>
<span class="gi">+        # We only look for folders in the &quot;personal&quot; namespace of the user</span>
<span class="gi">+        if self.has_capability(&quot;NAMESPACE&quot;):</span>
<span class="gi">+            personal_namespaces = self.namespace().personal</span>
<span class="gi">+        else:</span>
<span class="gi">+            personal_namespaces = _POPULAR_PERSONAL_NAMESPACES</span>
<span class="gi">+</span>
<span class="gi">+        for personal_namespace in personal_namespaces:</span>
<span class="gi">+            for pattern in _POPULAR_SPECIAL_FOLDERS.get(folder_flag, tuple()):</span>
<span class="gi">+                pattern = personal_namespace[0] + pattern</span>
<span class="gi">+                sent_folders = self.list_folders(pattern=pattern)</span>
<span class="gi">+                if sent_folders:</span>
<span class="gi">+                    return sent_folders[0][2]</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def select_folder(self, folder, readonly=False):
<span class="w"> </span>        &quot;&quot;&quot;Set the current folder on the server.
<span class="gu">@@ -510,18 +816,54 @@ class IMAPClient:</span>
<span class="w"> </span>             b&#39;UIDNEXT&#39;: 11,
<span class="w"> </span>             b&#39;UIDVALIDITY&#39;: 1239278212}
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._command_and_check(&quot;select&quot;, self._normalise_folder(folder), readonly)</span>
<span class="gi">+        return self._process_select_response(self._imap.untagged_responses)</span>

<span class="gd">-    @require_capability(&#39;UNSELECT&#39;)</span>
<span class="gi">+    @require_capability(&quot;UNSELECT&quot;)</span>
<span class="w"> </span>    def unselect_folder(self):
<span class="gd">-        &quot;&quot;&quot;Unselect the current folder and release associated resources.</span>
<span class="gi">+        r&quot;&quot;&quot;Unselect the current folder and release associated resources.</span>

<span class="w"> </span>        Unlike ``close_folder``, the ``UNSELECT`` command does not expunge
<span class="gd">-        the mailbox, keeping messages with \\Deleted flag set for example.</span>
<span class="gi">+        the mailbox, keeping messages with \Deleted flag set for example.</span>

<span class="w"> </span>        Returns the UNSELECT response string returned by the server.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&quot;&lt; UNSELECT&quot;)</span>
<span class="gi">+        # IMAP4 class has no `unselect` method so we can&#39;t use `_command_and_check` there</span>
<span class="gi">+        _typ, data = self._imap._simple_command(&quot;UNSELECT&quot;)</span>
<span class="gi">+        return data[0]</span>
<span class="gi">+</span>
<span class="gi">+    def _process_select_response(self, resp):</span>
<span class="gi">+        untagged = _dict_bytes_normaliser(resp)</span>
<span class="gi">+        out = {}</span>
<span class="gi">+</span>
<span class="gi">+        # imaplib doesn&#39;t parse these correctly (broken regex) so replace</span>
<span class="gi">+        # with the raw values out of the OK section</span>
<span class="gi">+        for line in untagged.get(&quot;OK&quot;, []):</span>
<span class="gi">+            match = _RE_SELECT_RESPONSE.match(line)</span>
<span class="gi">+            if match:</span>
<span class="gi">+                key = match.group(&quot;key&quot;)</span>
<span class="gi">+                if key == b&quot;PERMANENTFLAGS&quot;:</span>
<span class="gi">+                    out[key] = tuple(match.group(&quot;data&quot;).split())</span>
<span class="gi">+</span>
<span class="gi">+        for key, value in untagged.items():</span>
<span class="gi">+            key = key.upper()</span>
<span class="gi">+            if key in (b&quot;OK&quot;, b&quot;PERMANENTFLAGS&quot;):</span>
<span class="gi">+                continue  # already handled above</span>
<span class="gi">+            if key in (</span>
<span class="gi">+                b&quot;EXISTS&quot;,</span>
<span class="gi">+                b&quot;RECENT&quot;,</span>
<span class="gi">+                b&quot;UIDNEXT&quot;,</span>
<span class="gi">+                b&quot;UIDVALIDITY&quot;,</span>
<span class="gi">+                b&quot;HIGHESTMODSEQ&quot;,</span>
<span class="gi">+            ):</span>
<span class="gi">+                value = int(value[0])</span>
<span class="gi">+            elif key == b&quot;READ-WRITE&quot;:</span>
<span class="gi">+                value = True</span>
<span class="gi">+            elif key == b&quot;FLAGS&quot;:</span>
<span class="gi">+                value = tuple(value[0][1:-1].split())</span>
<span class="gi">+            out[key] = value</span>
<span class="gi">+        return out</span>

<span class="w"> </span>    def noop(self):
<span class="w"> </span>        &quot;&quot;&quot;Execute the NOOP command.
<span class="gu">@@ -539,9 +881,10 @@ class IMAPClient:</span>
<span class="w"> </span>              (6, b&#39;FETCH&#39;, (b&#39;FLAGS&#39;, (b&#39;sne&#39;,)))])

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tag = self._imap._command(&quot;NOOP&quot;)</span>
<span class="gi">+        return self._consume_until_tagged_response(tag, &quot;NOOP&quot;)</span>

<span class="gd">-    @require_capability(&#39;IDLE&#39;)</span>
<span class="gi">+    @require_capability(&quot;IDLE&quot;)</span>
<span class="w"> </span>    def idle(self):
<span class="w"> </span>        &quot;&quot;&quot;Put the server into IDLE mode.

<span class="gu">@@ -557,7 +900,10 @@ class IMAPClient:</span>

<span class="w"> </span>        See :rfc:`2177` for more information about the IDLE extension.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._idle_tag = self._imap._command(&quot;IDLE&quot;)</span>
<span class="gi">+        resp = self._imap._get_response()</span>
<span class="gi">+        if resp is not None:</span>
<span class="gi">+            raise exceptions.IMAPClientError(&quot;Unexpected IDLE response: %s&quot; % resp)</span>

<span class="w"> </span>    def _poll_socket(self, sock, timeout=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -565,7 +911,10 @@ class IMAPClient:</span>
<span class="w"> </span>        This implementation is more scalable because it ALLOWS your process
<span class="w"> </span>        to have more than 1024 file descriptors.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        poller = select.poll()</span>
<span class="gi">+        poller.register(sock.fileno(), select.POLLIN)</span>
<span class="gi">+        timeout = timeout * 1000 if timeout is not None else None</span>
<span class="gi">+        return poller.poll(timeout)</span>

<span class="w"> </span>    def _select_poll_socket(self, sock, timeout=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -574,9 +923,9 @@ class IMAPClient:</span>
<span class="w"> </span>        has more than 1024 file descriptors.
<span class="w"> </span>        We still need this for Windows and some other niche systems.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return select.select([sock], [], [], timeout)[0]</span>

<span class="gd">-    @require_capability(&#39;IDLE&#39;)</span>
<span class="gi">+    @require_capability(&quot;IDLE&quot;)</span>
<span class="w"> </span>    def idle_check(self, timeout=None):
<span class="w"> </span>        &quot;&quot;&quot;Check for any IDLE responses sent by the server.

<span class="gu">@@ -595,9 +944,42 @@ class IMAPClient:</span>
<span class="w"> </span>             (1, b&#39;EXISTS&#39;),
<span class="w"> </span>             (1, b&#39;FETCH&#39;, (b&#39;FLAGS&#39;, (b&#39;\\NotJunk&#39;,)))]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sock = self.socket()</span>
<span class="gi">+</span>
<span class="gi">+        # make the socket non-blocking so the timeout can be</span>
<span class="gi">+        # implemented for this call</span>
<span class="gi">+        sock.settimeout(None)</span>
<span class="gi">+        sock.setblocking(0)</span>
<span class="gi">+</span>
<span class="gi">+        if POLL_SUPPORT:</span>
<span class="gi">+            poll_func = self._poll_socket</span>
<span class="gi">+        else:</span>
<span class="gi">+            poll_func = self._select_poll_socket</span>

<span class="gd">-    @require_capability(&#39;IDLE&#39;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            resps = []</span>
<span class="gi">+            events = poll_func(sock, timeout)</span>
<span class="gi">+            if events:</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        line = self._imap._get_line()</span>
<span class="gi">+                    except (socket.timeout, socket.error):</span>
<span class="gi">+                        break</span>
<span class="gi">+                    except IMAPClient.AbortError:</span>
<span class="gi">+                        # An imaplib.IMAP4.abort with &quot;EOF&quot; is raised</span>
<span class="gi">+                        # under Python 3</span>
<span class="gi">+                        err = sys.exc_info()[1]</span>
<span class="gi">+                        if &quot;EOF&quot; in err.args[0]:</span>
<span class="gi">+                            break</span>
<span class="gi">+                        raise</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        resps.append(_parse_untagged_response(line))</span>
<span class="gi">+            return resps</span>
<span class="gi">+        finally:</span>
<span class="gi">+            sock.setblocking(1)</span>
<span class="gi">+            self._set_read_timeout()</span>
<span class="gi">+</span>
<span class="gi">+    @require_capability(&quot;IDLE&quot;)</span>
<span class="w"> </span>    def idle_done(self):
<span class="w"> </span>        &quot;&quot;&quot;Take the server out of IDLE mode.

<span class="gu">@@ -612,7 +994,9 @@ class IMAPClient:</span>
<span class="w"> </span>        any). These are returned in parsed form as per
<span class="w"> </span>        ``idle_check()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&quot;&lt; DONE&quot;)</span>
<span class="gi">+        self._imap.send(b&quot;DONE\r\n&quot;)</span>
<span class="gi">+        return self._consume_until_tagged_response(self._idle_tag, &quot;IDLE&quot;)</span>

<span class="w"> </span>    def folder_status(self, folder, what=None):
<span class="w"> </span>        &quot;&quot;&quot;Return the status of *folder*.
<span class="gu">@@ -624,39 +1008,58 @@ class IMAPClient:</span>
<span class="w"> </span>        Returns a dictionary of the status items for the folder with
<span class="w"> </span>        keys matching *what*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if what is None:</span>
<span class="gi">+            what = (&quot;MESSAGES&quot;, &quot;RECENT&quot;, &quot;UIDNEXT&quot;, &quot;UIDVALIDITY&quot;, &quot;UNSEEN&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            what = normalise_text_list(what)</span>
<span class="gi">+        what_ = &quot;(%s)&quot; % (&quot; &quot;.join(what))</span>
<span class="gi">+</span>
<span class="gi">+        fname = self._normalise_folder(folder)</span>
<span class="gi">+        data = self._command_and_check(&quot;status&quot;, fname, what_)</span>
<span class="gi">+        response = parse_response(data)</span>
<span class="gi">+        status_items = response[-1]</span>
<span class="gi">+        return dict(as_pairs(status_items))</span>

<span class="w"> </span>    def close_folder(self):
<span class="w"> </span>        &quot;&quot;&quot;Close the currently selected folder, returning the server
<span class="w"> </span>        response string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._command_and_check(&quot;close&quot;, unpack=True)</span>

<span class="w"> </span>    def create_folder(self, folder):
<span class="w"> </span>        &quot;&quot;&quot;Create *folder* on the server returning the server response string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._command_and_check(</span>
<span class="gi">+            &quot;create&quot;, self._normalise_folder(folder), unpack=True</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def rename_folder(self, old_name, new_name):
<span class="w"> </span>        &quot;&quot;&quot;Change the name of a folder on the server.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._command_and_check(</span>
<span class="gi">+            &quot;rename&quot;,</span>
<span class="gi">+            self._normalise_folder(old_name),</span>
<span class="gi">+            self._normalise_folder(new_name),</span>
<span class="gi">+            unpack=True,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def delete_folder(self, folder):
<span class="w"> </span>        &quot;&quot;&quot;Delete *folder* on the server returning the server response string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._command_and_check(</span>
<span class="gi">+            &quot;delete&quot;, self._normalise_folder(folder), unpack=True</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def folder_exists(self, folder):
<span class="w"> </span>        &quot;&quot;&quot;Return ``True`` if *folder* exists on the server.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.list_folders(&quot;&quot;, folder)) &gt; 0</span>

<span class="w"> </span>    def subscribe_folder(self, folder):
<span class="w"> </span>        &quot;&quot;&quot;Subscribe to *folder*, returning the server response string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._command_and_check(&quot;subscribe&quot;, self._normalise_folder(folder))</span>

<span class="w"> </span>    def unsubscribe_folder(self, folder):
<span class="w"> </span>        &quot;&quot;&quot;Unsubscribe to *folder*, returning the server response string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._command_and_check(&quot;unsubscribe&quot;, self._normalise_folder(folder))</span>

<span class="gd">-    def search(self, criteria=&#39;ALL&#39;, charset=None):</span>
<span class="gi">+    def search(self, criteria=&quot;ALL&quot;, charset=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of messages ids from the currently selected
<span class="w"> </span>        folder matching *criteria*.

<span class="gu">@@ -716,10 +1119,10 @@ class IMAPClient:</span>
<span class="w"> </span>        in the search).

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._search(criteria, charset)</span>

<span class="gd">-    @require_capability(&#39;X-GM-EXT-1&#39;)</span>
<span class="gd">-    def gmail_search(self, query, charset=&#39;UTF-8&#39;):</span>
<span class="gi">+    @require_capability(&quot;X-GM-EXT-1&quot;)</span>
<span class="gi">+    def gmail_search(self, query, charset=&quot;UTF-8&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Search using Gmail&#39;s X-GM-RAW attribute.

<span class="w"> </span>        *query* should be a valid Gmail search query string. For
<span class="gu">@@ -733,10 +1136,40 @@ class IMAPClient:</span>
<span class="w"> </span>        See https://developers.google.com/gmail/imap_extensions#extension_of_the_search_command_x-gm-raw
<span class="w"> </span>        for more info.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._search([b&quot;X-GM-RAW&quot;, query], charset)</span>
<span class="gi">+</span>
<span class="gi">+    def _search(self, criteria, charset):</span>
<span class="gi">+        args = []</span>
<span class="gi">+        if charset:</span>
<span class="gi">+            args.extend([b&quot;CHARSET&quot;, to_bytes(charset)])</span>
<span class="gi">+        args.extend(_normalise_search_criteria(criteria, charset))</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            data = self._raw_command_untagged(b&quot;SEARCH&quot;, args)</span>
<span class="gi">+        except imaplib.IMAP4.error as e:</span>
<span class="gi">+            # Make BAD IMAP responses easier to understand to the user, with a link to the docs</span>
<span class="gi">+            m = re.match(r&quot;SEARCH command error: BAD \[(.+)\]&quot;, str(e))</span>
<span class="gi">+            if m:</span>
<span class="gi">+                raise exceptions.InvalidCriteriaError(</span>
<span class="gi">+                    &quot;{original_msg}\n\n&quot;</span>
<span class="gi">+                    &quot;This error may have been caused by a syntax error in the criteria: &quot;</span>
<span class="gi">+                    &quot;{criteria}\nPlease refer to the documentation for more information &quot;</span>
<span class="gi">+                    &quot;about search criteria syntax..\n&quot;</span>
<span class="gi">+                    &quot;https://imapclient.readthedocs.io/en/master/#imapclient.IMAPClient.search&quot;.format(</span>
<span class="gi">+                        original_msg=m.group(1),</span>
<span class="gi">+                        criteria=&#39;&quot;%s&quot;&#39; % criteria</span>
<span class="gi">+                        if not isinstance(criteria, list)</span>
<span class="gi">+                        else criteria,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # If the exception is not from a BAD IMAP response, re-raise as-is</span>
<span class="gi">+            raise</span>

<span class="gd">-    @require_capability(&#39;SORT&#39;)</span>
<span class="gd">-    def sort(self, sort_criteria, criteria=&#39;ALL&#39;, charset=&#39;UTF-8&#39;):</span>
<span class="gi">+        return parse_message_list(data)</span>
<span class="gi">+</span>
<span class="gi">+    @require_capability(&quot;SORT&quot;)</span>
<span class="gi">+    def sort(self, sort_criteria, criteria=&quot;ALL&quot;, charset=&quot;UTF-8&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of message ids from the currently selected
<span class="w"> </span>        folder, sorted by *sort_criteria* and optionally filtered by
<span class="w"> </span>        *criteria*.
<span class="gu">@@ -758,9 +1191,15 @@ class IMAPClient:</span>
<span class="w"> </span>        Note that SORT is an extension to the IMAP4 standard so it may
<span class="w"> </span>        not be supported by all IMAP servers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def thread(self, algorithm=&#39;REFERENCES&#39;, criteria=&#39;ALL&#39;, charset=&#39;UTF-8&#39;):</span>
<span class="gi">+        args = [</span>
<span class="gi">+            _normalise_sort_criteria(sort_criteria),</span>
<span class="gi">+            to_bytes(charset),</span>
<span class="gi">+        ]</span>
<span class="gi">+        args.extend(_normalise_search_criteria(criteria, charset))</span>
<span class="gi">+        ids = self._raw_command_untagged(b&quot;SORT&quot;, args, unpack=True)</span>
<span class="gi">+        return [int(i) for i in ids.split()]</span>
<span class="gi">+</span>
<span class="gi">+    def thread(self, algorithm=&quot;REFERENCES&quot;, criteria=&quot;ALL&quot;, charset=&quot;UTF-8&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of messages threads from the currently
<span class="w"> </span>        selected folder which match *criteria*.

<span class="gu">@@ -777,7 +1216,17 @@ class IMAPClient:</span>

<span class="w"> </span>        See :rfc:`5256` for more details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        algorithm = to_bytes(algorithm)</span>
<span class="gi">+        if not self.has_capability(b&quot;THREAD=&quot; + algorithm):</span>
<span class="gi">+            raise exceptions.CapabilityError(</span>
<span class="gi">+                &quot;The server does not support %s threading algorithm&quot; % algorithm</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        args = [algorithm, to_bytes(charset)] + _normalise_search_criteria(</span>
<span class="gi">+            criteria, charset</span>
<span class="gi">+        )</span>
<span class="gi">+        data = self._raw_command_untagged(b&quot;THREAD&quot;, args)</span>
<span class="gi">+        return parse_response(data)</span>

<span class="w"> </span>    def get_flags(self, messages):
<span class="w"> </span>        &quot;&quot;&quot;Return the flags set for each message in *messages* from
<span class="gu">@@ -786,7 +1235,8 @@ class IMAPClient:</span>
<span class="w"> </span>        The return value is a dictionary structured like this: ``{
<span class="w"> </span>        msgid1: (flag1, flag2, ... ), }``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        response = self.fetch(messages, [&quot;FLAGS&quot;])</span>
<span class="gi">+        return self._filter_fetch_dict(response, b&quot;FLAGS&quot;)</span>

<span class="w"> </span>    def add_flags(self, messages, flags, silent=False):
<span class="w"> </span>        &quot;&quot;&quot;Add *flags* to *messages* in the currently selected folder.
<span class="gu">@@ -796,7 +1246,7 @@ class IMAPClient:</span>
<span class="w"> </span>        Returns the flags set for each modified message (see
<span class="w"> </span>        *get_flags*), or None if *silent* is true.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._store(b&quot;+FLAGS&quot;, messages, flags, b&quot;FLAGS&quot;, silent=silent)</span>

<span class="w"> </span>    def remove_flags(self, messages, flags, silent=False):
<span class="w"> </span>        &quot;&quot;&quot;Remove one or more *flags* from *messages* in the currently
<span class="gu">@@ -807,7 +1257,7 @@ class IMAPClient:</span>
<span class="w"> </span>        Returns the flags set for each modified message (see
<span class="w"> </span>        *get_flags*), or None if *silent* is true.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._store(b&quot;-FLAGS&quot;, messages, flags, b&quot;FLAGS&quot;, silent=silent)</span>

<span class="w"> </span>    def set_flags(self, messages, flags, silent=False):
<span class="w"> </span>        &quot;&quot;&quot;Set the *flags* for *messages* in the currently selected
<span class="gu">@@ -818,7 +1268,7 @@ class IMAPClient:</span>
<span class="w"> </span>        Returns the flags set for each modified message (see
<span class="w"> </span>        *get_flags*), or None if *silent* is true.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._store(b&quot;FLAGS&quot;, messages, flags, b&quot;FLAGS&quot;, silent=silent)</span>

<span class="w"> </span>    def get_gmail_labels(self, messages):
<span class="w"> </span>        &quot;&quot;&quot;Return the label set for each message in *messages* in the
<span class="gu">@@ -830,7 +1280,9 @@ class IMAPClient:</span>
<span class="w"> </span>        This only works with IMAP servers that support the X-GM-LABELS
<span class="w"> </span>        attribute (eg. Gmail).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        response = self.fetch(messages, [b&quot;X-GM-LABELS&quot;])</span>
<span class="gi">+        response = self._filter_fetch_dict(response, b&quot;X-GM-LABELS&quot;)</span>
<span class="gi">+        return {msg: utf7_decode_sequence(labels) for msg, labels in response.items()}</span>

<span class="w"> </span>    def add_gmail_labels(self, messages, labels, silent=False):
<span class="w"> </span>        &quot;&quot;&quot;Add *labels* to *messages* in the currently selected folder.
<span class="gu">@@ -843,7 +1295,7 @@ class IMAPClient:</span>
<span class="w"> </span>        This only works with IMAP servers that support the X-GM-LABELS
<span class="w"> </span>        attribute (eg. Gmail).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._gm_label_store(b&quot;+X-GM-LABELS&quot;, messages, labels, silent=silent)</span>

<span class="w"> </span>    def remove_gmail_labels(self, messages, labels, silent=False):
<span class="w"> </span>        &quot;&quot;&quot;Remove one or more *labels* from *messages* in the
<span class="gu">@@ -857,7 +1309,7 @@ class IMAPClient:</span>
<span class="w"> </span>        This only works with IMAP servers that support the X-GM-LABELS
<span class="w"> </span>        attribute (eg. Gmail).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._gm_label_store(b&quot;-X-GM-LABELS&quot;, messages, labels, silent=silent)</span>

<span class="w"> </span>    def set_gmail_labels(self, messages, labels, silent=False):
<span class="w"> </span>        &quot;&quot;&quot;Set the *labels* for *messages* in the currently selected
<span class="gu">@@ -871,7 +1323,7 @@ class IMAPClient:</span>
<span class="w"> </span>        This only works with IMAP servers that support the X-GM-LABELS
<span class="w"> </span>        attribute (eg. Gmail).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._gm_label_store(b&quot;X-GM-LABELS&quot;, messages, labels, silent=silent)</span>

<span class="w"> </span>    def delete_messages(self, messages, silent=False):
<span class="w"> </span>        &quot;&quot;&quot;Delete one or more *messages* from the currently selected
<span class="gu">@@ -880,7 +1332,7 @@ class IMAPClient:</span>
<span class="w"> </span>        Returns the flags set for each modified message (see
<span class="w"> </span>        *get_flags*).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.add_flags(messages, DELETED, silent=silent)</span>

<span class="w"> </span>    def fetch(self, messages, data, modifiers=None):
<span class="w"> </span>        &quot;&quot;&quot;Retrieve selected *data* associated with one or more
<span class="gu">@@ -922,7 +1374,22 @@ class IMAPClient:</span>
<span class="w"> </span>                    b&#39;SEQ&#39;: 110}}

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not messages:</span>
<span class="gi">+            return {}</span>
<span class="gi">+</span>
<span class="gi">+        args = [</span>
<span class="gi">+            &quot;FETCH&quot;,</span>
<span class="gi">+            join_message_ids(messages),</span>
<span class="gi">+            seq_to_parenstr_upper(data),</span>
<span class="gi">+            seq_to_parenstr_upper(modifiers) if modifiers else None,</span>
<span class="gi">+        ]</span>
<span class="gi">+        if self.use_uid:</span>
<span class="gi">+            args.insert(0, &quot;UID&quot;)</span>
<span class="gi">+        tag = self._imap._command(*args)</span>
<span class="gi">+        typ, data = self._imap._command_complete(&quot;FETCH&quot;, tag)</span>
<span class="gi">+        self._checkok(&quot;fetch&quot;, typ, data)</span>
<span class="gi">+        typ, data = self._imap._untagged_response(typ, data, &quot;FETCH&quot;)</span>
<span class="gi">+        return parse_fetch_response(data, self.normalise_times, self.use_uid)</span>

<span class="w"> </span>    def append(self, folder, msg, flags=(), msg_time=None):
<span class="w"> </span>        &quot;&quot;&quot;Append a message to *folder*.
<span class="gu">@@ -941,9 +1408,21 @@ class IMAPClient:</span>

<span class="w"> </span>        Returns the APPEND response as returned by the server.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @require_capability(&#39;MULTIAPPEND&#39;)</span>
<span class="gi">+        if msg_time:</span>
<span class="gi">+            time_val = &#39;&quot;%s&quot;&#39; % datetime_to_INTERNALDATE(msg_time)</span>
<span class="gi">+            time_val = to_unicode(time_val)</span>
<span class="gi">+        else:</span>
<span class="gi">+            time_val = None</span>
<span class="gi">+        return self._command_and_check(</span>
<span class="gi">+            &quot;append&quot;,</span>
<span class="gi">+            self._normalise_folder(folder),</span>
<span class="gi">+            seq_to_parenstr(flags),</span>
<span class="gi">+            time_val,</span>
<span class="gi">+            to_bytes(msg),</span>
<span class="gi">+            unpack=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @require_capability(&quot;MULTIAPPEND&quot;)</span>
<span class="w"> </span>    def multiappend(self, folder, msgs):
<span class="w"> </span>        &quot;&quot;&quot;Append messages to *folder* using the MULTIAPPEND feature from :rfc:`3502`.

<span class="gu">@@ -955,16 +1434,40 @@ class IMAPClient:</span>

<span class="w"> </span>        Returns the APPEND response from the server.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def chunks():</span>
<span class="gi">+            for m in msgs:</span>
<span class="gi">+                if isinstance(m, dict):</span>
<span class="gi">+                    if &quot;flags&quot; in m:</span>
<span class="gi">+                        yield to_bytes(seq_to_parenstr(m[&quot;flags&quot;]))</span>
<span class="gi">+                    if &quot;date&quot; in m:</span>
<span class="gi">+                        yield to_bytes(&#39;&quot;%s&quot;&#39; % datetime_to_INTERNALDATE(m[&quot;date&quot;]))</span>
<span class="gi">+                    yield _literal(to_bytes(m[&quot;msg&quot;]))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield _literal(to_bytes(m))</span>
<span class="gi">+</span>
<span class="gi">+        msgs = list(chunks())</span>
<span class="gi">+</span>
<span class="gi">+        return self._raw_command(</span>
<span class="gi">+            b&quot;APPEND&quot;,</span>
<span class="gi">+            [self._normalise_folder(folder)] + msgs,</span>
<span class="gi">+            uid=False,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def copy(self, messages, folder):
<span class="w"> </span>        &quot;&quot;&quot;Copy one or more messages from the current folder to
<span class="w"> </span>        *folder*. Returns the COPY response string returned by the
<span class="w"> </span>        server.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @require_capability(&#39;MOVE&#39;)</span>
<span class="gi">+        return self._command_and_check(</span>
<span class="gi">+            &quot;copy&quot;,</span>
<span class="gi">+            join_message_ids(messages),</span>
<span class="gi">+            self._normalise_folder(folder),</span>
<span class="gi">+            uid=True,</span>
<span class="gi">+            unpack=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @require_capability(&quot;MOVE&quot;)</span>
<span class="w"> </span>    def move(self, messages, folder):
<span class="w"> </span>        &quot;&quot;&quot;Atomically move messages to another folder.

<span class="gu">@@ -973,7 +1476,13 @@ class IMAPClient:</span>
<span class="w"> </span>        :param messages: List of message UIDs to move.
<span class="w"> </span>        :param folder: The destination folder name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._command_and_check(</span>
<span class="gi">+            &quot;move&quot;,</span>
<span class="gi">+            join_message_ids(messages),</span>
<span class="gi">+            self._normalise_folder(folder),</span>
<span class="gi">+            uid=True,</span>
<span class="gi">+            unpack=True,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def expunge(self, messages=None):
<span class="w"> </span>        &quot;&quot;&quot;Use of the *messages* argument is discouraged.
<span class="gu">@@ -1008,9 +1517,16 @@ class IMAPClient:</span>

<span class="w"> </span>        See :rfc:`4315#section-2.1` section 2.1 for more details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @require_capability(&#39;UIDPLUS&#39;)</span>
<span class="gi">+        if messages:</span>
<span class="gi">+            if not self.use_uid:</span>
<span class="gi">+                raise ValueError(&quot;cannot EXPUNGE by ID when not using uids&quot;)</span>
<span class="gi">+            return self._command_and_check(</span>
<span class="gi">+                &quot;EXPUNGE&quot;, join_message_ids(messages), uid=True</span>
<span class="gi">+            )</span>
<span class="gi">+        tag = self._imap._command(&quot;EXPUNGE&quot;)</span>
<span class="gi">+        return self._consume_until_tagged_response(tag, &quot;EXPUNGE&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @require_capability(&quot;UIDPLUS&quot;)</span>
<span class="w"> </span>    def uid_expunge(self, messages):
<span class="w"> </span>        &quot;&quot;&quot;Expunge deleted messages with the specified message ids from the
<span class="w"> </span>        folder.
<span class="gu">@@ -1019,34 +1535,39 @@ class IMAPClient:</span>

<span class="w"> </span>        See :rfc:`4315#section-2.1` section 2.1 for more details.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._command_and_check(&quot;EXPUNGE&quot;, join_message_ids(messages), uid=True)</span>

<span class="gd">-    @require_capability(&#39;ACL&#39;)</span>
<span class="gi">+    @require_capability(&quot;ACL&quot;)</span>
<span class="w"> </span>    def getacl(self, folder):
<span class="w"> </span>        &quot;&quot;&quot;Returns a list of ``(who, acl)`` tuples describing the
<span class="w"> </span>        access controls for *folder*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = self._command_and_check(&quot;getacl&quot;, self._normalise_folder(folder))</span>
<span class="gi">+        parts = list(response_lexer.TokenSource(data))</span>
<span class="gi">+        parts = parts[1:]  # First item is folder name</span>
<span class="gi">+        return [(parts[i], parts[i + 1]) for i in range(0, len(parts), 2)]</span>

<span class="gd">-    @require_capability(&#39;ACL&#39;)</span>
<span class="gi">+    @require_capability(&quot;ACL&quot;)</span>
<span class="w"> </span>    def setacl(self, folder, who, what):
<span class="w"> </span>        &quot;&quot;&quot;Set an ACL (*what*) for user (*who*) for a folder.

<span class="w"> </span>        Set *what* to an empty string to remove an ACL. Returns the
<span class="w"> </span>        server response string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._command_and_check(</span>
<span class="gi">+            &quot;setacl&quot;, self._normalise_folder(folder), who, what, unpack=True</span>
<span class="gi">+        )</span>

<span class="gd">-    @require_capability(&#39;QUOTA&#39;)</span>
<span class="gd">-    def get_quota(self, mailbox=&#39;INBOX&#39;):</span>
<span class="gi">+    @require_capability(&quot;QUOTA&quot;)</span>
<span class="gi">+    def get_quota(self, mailbox=&quot;INBOX&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the quotas associated with a mailbox.

<span class="w"> </span>        Returns a list of Quota objects.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_quota_root(mailbox)[1]</span>

<span class="gd">-    @require_capability(&#39;QUOTA&#39;)</span>
<span class="gd">-    def _get_quota(self, quota_root=&#39;&#39;):</span>
<span class="gi">+    @require_capability(&quot;QUOTA&quot;)</span>
<span class="gi">+    def _get_quota(self, quota_root=&quot;&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the quotas associated with a quota root.

<span class="w"> </span>        This method is not private but put behind an underscore to show that
<span class="gu">@@ -1055,9 +1576,9 @@ class IMAPClient:</span>

<span class="w"> </span>        Returns a list of Quota objects.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _parse_quota(self._command_and_check(&quot;getquota&quot;, _quote(quota_root)))</span>

<span class="gd">-    @require_capability(&#39;QUOTA&#39;)</span>
<span class="gi">+    @require_capability(&quot;QUOTA&quot;)</span>
<span class="w"> </span>    def get_quota_root(self, mailbox):
<span class="w"> </span>        &quot;&quot;&quot;Get the quota roots for a mailbox.

<span class="gu">@@ -1068,22 +1589,78 @@ class IMAPClient:</span>

<span class="w"> </span>        Return a tuple of MailboxQuotaRoots and list of Quota associated
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @require_capability(&#39;QUOTA&#39;)</span>
<span class="gi">+        quota_root_rep = self._raw_command_untagged(</span>
<span class="gi">+            b&quot;GETQUOTAROOT&quot;, to_bytes(mailbox), uid=False, response_name=&quot;QUOTAROOT&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        quota_rep = self._imap.untagged_responses.pop(&quot;QUOTA&quot;, [])</span>
<span class="gi">+        quota_root_rep = parse_response(quota_root_rep)</span>
<span class="gi">+        quota_root = MailboxQuotaRoots(</span>
<span class="gi">+            to_unicode(quota_root_rep[0]), [to_unicode(q) for q in quota_root_rep[1:]]</span>
<span class="gi">+        )</span>
<span class="gi">+        return quota_root, _parse_quota(quota_rep)</span>
<span class="gi">+</span>
<span class="gi">+    @require_capability(&quot;QUOTA&quot;)</span>
<span class="w"> </span>    def set_quota(self, quotas):
<span class="w"> </span>        &quot;&quot;&quot;Set one or more quotas on resources.

<span class="w"> </span>        :param quotas: list of Quota objects
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not quotas:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        quota_root = None</span>
<span class="gi">+        set_quota_args = []</span>
<span class="gi">+</span>
<span class="gi">+        for quota in quotas:</span>
<span class="gi">+            if quota_root is None:</span>
<span class="gi">+                quota_root = quota.quota_root</span>
<span class="gi">+            elif quota_root != quota.quota_root:</span>
<span class="gi">+                raise ValueError(&quot;set_quota only accepts a single quota root&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            set_quota_args.append(&quot;{} {}&quot;.format(quota.resource, quota.limit))</span>
<span class="gi">+</span>
<span class="gi">+        set_quota_args = &quot; &quot;.join(set_quota_args)</span>
<span class="gi">+        args = [to_bytes(_quote(quota_root)), to_bytes(&quot;({})&quot;.format(set_quota_args))]</span>
<span class="gi">+</span>
<span class="gi">+        response = self._raw_command_untagged(</span>
<span class="gi">+            b&quot;SETQUOTA&quot;, args, uid=False, response_name=&quot;QUOTA&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        return _parse_quota(response)</span>

<span class="w"> </span>    def _check_resp(self, expected, command, typ, data):
<span class="w"> </span>        &quot;&quot;&quot;Check command responses for errors.

<span class="w"> </span>        Raises IMAPClient.Error if the command fails.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if typ != expected:</span>
<span class="gi">+            raise exceptions.IMAPClientError(</span>
<span class="gi">+                &quot;%s failed: %s&quot; % (command, to_unicode(data[0]))</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_until_tagged_response(self, tag, command):</span>
<span class="gi">+        tagged_commands = self._imap.tagged_commands</span>
<span class="gi">+        resps = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            line = self._imap._get_response()</span>
<span class="gi">+            if tagged_commands[tag]:</span>
<span class="gi">+                break</span>
<span class="gi">+            resps.append(_parse_untagged_response(line))</span>
<span class="gi">+        typ, data = tagged_commands.pop(tag)</span>
<span class="gi">+        self._checkok(command, typ, data)</span>
<span class="gi">+        return data[0], resps</span>
<span class="gi">+</span>
<span class="gi">+    def _raw_command_untagged(</span>
<span class="gi">+        self, command, args, response_name=None, unpack=False, uid=True</span>
<span class="gi">+    ):</span>
<span class="gi">+        # TODO: eventually this should replace _command_and_check (call it _command)</span>
<span class="gi">+        typ, data = self._raw_command(command, args, uid=uid)</span>
<span class="gi">+        if response_name is None:</span>
<span class="gi">+            response_name = command</span>
<span class="gi">+        typ, data = self._imap._untagged_response(typ, data, to_unicode(response_name))</span>
<span class="gi">+        self._checkok(to_unicode(command), typ, data)</span>
<span class="gi">+        if unpack:</span>
<span class="gi">+            return data[0]</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    def _raw_command(self, command, args, uid=True):
<span class="w"> </span>        &quot;&quot;&quot;Run the specific command with the arguments given. 8-bit arguments
<span class="gu">@@ -1096,23 +1673,184 @@ class IMAPClient:</span>
<span class="w"> </span>        *command* should be specified as bytes.
<span class="w"> </span>        *args* should be specified as a list of bytes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        command = command.upper()</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(args, tuple):</span>
<span class="gi">+            args = list(args)</span>
<span class="gi">+        if not isinstance(args, list):</span>
<span class="gi">+            args = [args]</span>
<span class="gi">+</span>
<span class="gi">+        tag = self._imap._new_tag()</span>
<span class="gi">+        prefix = [to_bytes(tag)]</span>
<span class="gi">+        if uid and self.use_uid:</span>
<span class="gi">+            prefix.append(b&quot;UID&quot;)</span>
<span class="gi">+        prefix.append(command)</span>
<span class="gi">+</span>
<span class="gi">+        line = []</span>
<span class="gi">+        for item, is_last in _iter_with_last(prefix + args):</span>
<span class="gi">+            if not isinstance(item, bytes):</span>
<span class="gi">+                raise ValueError(&quot;command args must be passed as bytes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if _is8bit(item):</span>
<span class="gi">+                # If a line was already started send it</span>
<span class="gi">+                if line:</span>
<span class="gi">+                    out = b&quot; &quot;.join(line)</span>
<span class="gi">+                    logger.debug(&quot;&gt; %s&quot;, out)</span>
<span class="gi">+                    self._imap.send(out)</span>
<span class="gi">+                    line = []</span>
<span class="gi">+</span>
<span class="gi">+                # Now send the (unquoted) literal</span>
<span class="gi">+                if isinstance(item, _quoted):</span>
<span class="gi">+                    item = item.original</span>
<span class="gi">+                self._send_literal(tag, item)</span>
<span class="gi">+                if not is_last:</span>
<span class="gi">+                    self._imap.send(b&quot; &quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                line.append(item)</span>
<span class="gi">+</span>
<span class="gi">+        if line:</span>
<span class="gi">+            out = b&quot; &quot;.join(line)</span>
<span class="gi">+            logger.debug(&quot;&gt; %s&quot;, out)</span>
<span class="gi">+            self._imap.send(out)</span>
<span class="gi">+</span>
<span class="gi">+        self._imap.send(b&quot;\r\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self._imap._command_complete(to_unicode(command), tag)</span>

<span class="w"> </span>    def _send_literal(self, tag, item):
<span class="w"> </span>        &quot;&quot;&quot;Send a single literal for the command with *tag*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if b&quot;LITERAL+&quot; in self._cached_capabilities:</span>
<span class="gi">+            out = b&quot; {&quot; + str(len(item)).encode(&quot;ascii&quot;) + b&quot;+}\r\n&quot; + item</span>
<span class="gi">+            logger.debug(&quot;&gt; %s&quot;, debug_trunc(out, 64))</span>
<span class="gi">+            self._imap.send(out)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        out = b&quot; {&quot; + str(len(item)).encode(&quot;ascii&quot;) + b&quot;}\r\n&quot;</span>
<span class="gi">+        logger.debug(&quot;&gt; %s&quot;, out)</span>
<span class="gi">+        self._imap.send(out)</span>
<span class="gi">+</span>
<span class="gi">+        # Wait for continuation response</span>
<span class="gi">+        while self._imap._get_response():</span>
<span class="gi">+            tagged_resp = self._imap.tagged_commands.get(tag)</span>
<span class="gi">+            if tagged_resp:</span>
<span class="gi">+                raise exceptions.IMAPClientAbortError(</span>
<span class="gi">+                    &quot;unexpected response while waiting for continuation response: &quot;</span>
<span class="gi">+                    + repr(tagged_resp)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        logger.debug(&quot;   (literal) &gt; %s&quot;, debug_trunc(item, 256))</span>
<span class="gi">+        self._imap.send(item)</span>
<span class="gi">+</span>
<span class="gi">+    def _command_and_check(</span>
<span class="gi">+        self, command, *args, unpack: bool = False, uid: bool = False</span>
<span class="gi">+    ):</span>
<span class="gi">+        if uid and self.use_uid:</span>
<span class="gi">+            command = to_unicode(command)  # imaplib must die</span>
<span class="gi">+            typ, data = self._imap.uid(command, *args)</span>
<span class="gi">+        else:</span>
<span class="gi">+            meth = getattr(self._imap, to_unicode(command))</span>
<span class="gi">+            typ, data = meth(*args)</span>
<span class="gi">+        self._checkok(command, typ, data)</span>
<span class="gi">+        if unpack:</span>
<span class="gi">+            return data[0]</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def _checkok(self, command, typ, data):</span>
<span class="gi">+        self._check_resp(&quot;OK&quot;, command, typ, data)</span>
<span class="gi">+</span>
<span class="gi">+    def _gm_label_store(self, cmd, messages, labels, silent):</span>
<span class="gi">+        response = self._store(</span>
<span class="gi">+            cmd, messages, self._normalise_labels(labels), b&quot;X-GM-LABELS&quot;, silent=silent</span>
<span class="gi">+        )</span>
<span class="gi">+        return (</span>
<span class="gi">+            {msg: utf7_decode_sequence(labels) for msg, labels in response.items()}</span>
<span class="gi">+            if response</span>
<span class="gi">+            else None</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _store(self, cmd, messages, flags, fetch_key, silent):
<span class="w"> </span>        &quot;&quot;&quot;Worker function for the various flag manipulation methods.

<span class="w"> </span>        *cmd* is the STORE command to use (eg. &#39;+FLAGS&#39;).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not messages:</span>
<span class="gi">+            return {}</span>
<span class="gi">+        if silent:</span>
<span class="gi">+            cmd += b&quot;.SILENT&quot;</span>
<span class="gi">+</span>
<span class="gi">+        data = self._command_and_check(</span>
<span class="gi">+            &quot;store&quot;, join_message_ids(messages), cmd, seq_to_parenstr(flags), uid=True</span>
<span class="gi">+        )</span>
<span class="gi">+        if silent:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self._filter_fetch_dict(parse_fetch_response(data), fetch_key)</span>
<span class="gi">+</span>
<span class="gi">+    def _filter_fetch_dict(self, fetch_dict, key):</span>
<span class="gi">+        return dict((msgid, data[key]) for msgid, data in fetch_dict.items())</span>
<span class="gi">+</span>
<span class="gi">+    def _normalise_folder(self, folder_name):</span>
<span class="gi">+        if isinstance(folder_name, bytes):</span>
<span class="gi">+            folder_name = folder_name.decode(&quot;ascii&quot;)</span>
<span class="gi">+        if self.folder_encode:</span>
<span class="gi">+            folder_name = encode_utf7(folder_name)</span>
<span class="gi">+        return _quote(folder_name)</span>
<span class="gi">+</span>
<span class="gi">+    def _normalise_labels(self, labels):</span>
<span class="gi">+        if isinstance(labels, (str, bytes)):</span>
<span class="gi">+            labels = (labels,)</span>
<span class="gi">+        return [_quote(encode_utf7(label)) for label in labels]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def welcome(self):
<span class="w"> </span>        &quot;&quot;&quot;access the server greeting message&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._imap.welcome</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _quote(arg):</span>
<span class="gi">+    if isinstance(arg, str):</span>
<span class="gi">+        arg = arg.replace(&quot;\\&quot;, &quot;\\\\&quot;)</span>
<span class="gi">+        arg = arg.replace(&#39;&quot;&#39;, &#39;\\&quot;&#39;)</span>
<span class="gi">+        q = &#39;&quot;&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        arg = arg.replace(b&quot;\\&quot;, b&quot;\\\\&quot;)</span>
<span class="gi">+        arg = arg.replace(b&#39;&quot;&#39;, b&#39;\\&quot;&#39;)</span>
<span class="gi">+        q = b&#39;&quot;&#39;</span>
<span class="gi">+    return q + arg + q</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _normalise_search_criteria(criteria, charset=None):</span>
<span class="gi">+    if not criteria:</span>
<span class="gi">+        raise exceptions.InvalidCriteriaError(&quot;no criteria specified&quot;)</span>
<span class="gi">+    if not charset:</span>
<span class="gi">+        charset = &quot;us-ascii&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(criteria, (str, bytes)):</span>
<span class="gi">+        return [to_bytes(criteria, charset)]</span>
<span class="gi">+</span>
<span class="gi">+    out = []</span>
<span class="gi">+    for item in criteria:</span>
<span class="gi">+        if isinstance(item, int):</span>
<span class="gi">+            out.append(str(item).encode(&quot;ascii&quot;))</span>
<span class="gi">+        elif isinstance(item, (datetime, date)):</span>
<span class="gi">+            out.append(format_criteria_date(item))</span>
<span class="gi">+        elif isinstance(item, (list, tuple)):</span>
<span class="gi">+            # Process nested criteria list and wrap in parens.</span>
<span class="gi">+            inner = _normalise_search_criteria(item)</span>
<span class="gi">+            inner[0] = b&quot;(&quot; + inner[0]</span>
<span class="gi">+            inner[-1] = inner[-1] + b&quot;)&quot;</span>
<span class="gi">+            out.extend(inner)  # flatten</span>
<span class="gi">+        else:</span>
<span class="gi">+            out.append(_quoted.maybe(to_bytes(item, charset)))</span>
<span class="gi">+    return out</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _normalise_sort_criteria(criteria, charset=None):</span>
<span class="gi">+    if isinstance(criteria, (str, bytes)):</span>
<span class="gi">+        criteria = [criteria]</span>
<span class="gi">+    return b&quot;(&quot; + b&quot; &quot;.join(to_bytes(item).upper() for item in criteria) + b&quot;)&quot;</span>


<span class="w"> </span>class _literal(bytes):
<span class="gu">@@ -1137,14 +1875,87 @@ class _quoted(bytes):</span>
<span class="w"> </span>        holds the quoted version of the input while also providing
<span class="w"> </span>        access to the original unquoted source.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        quoted = original.replace(b&quot;\\&quot;, b&quot;\\\\&quot;)</span>
<span class="gi">+        quoted = quoted.replace(b&#39;&quot;&#39;, b&#39;\\&quot;&#39;)</span>
<span class="gi">+        if quoted != original or b&quot; &quot; in quoted or not quoted:</span>
<span class="gi">+            out = cls(b&#39;&quot;&#39; + quoted + b&#39;&quot;&#39;)</span>
<span class="gi">+            out.original = original</span>
<span class="gi">+            return out</span>
<span class="gi">+        return original</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# normalise_text_list, seq_to_parentstr etc have to return unicode</span>
<span class="gi">+# because imaplib handles flags and sort criteria assuming these are</span>
<span class="gi">+# passed as unicode</span>
<span class="gi">+def normalise_text_list(items):</span>
<span class="gi">+    return list(_normalise_text_list(items))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def seq_to_parenstr(items):</span>
<span class="gi">+    return _join_and_paren(_normalise_text_list(items))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def seq_to_parenstr_upper(items):</span>
<span class="gi">+    return _join_and_paren(item.upper() for item in _normalise_text_list(items))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _join_and_paren(items):</span>
<span class="gi">+    return &quot;(&quot; + &quot; &quot;.join(items) + &quot;)&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _normalise_text_list(items):</span>
<span class="gi">+    if isinstance(items, (str, bytes)):</span>
<span class="gi">+        items = (items,)</span>
<span class="gi">+    return (to_unicode(c) for c in items)</span>


<span class="w"> </span>def join_message_ids(messages):
<span class="w"> </span>    &quot;&quot;&quot;Convert a sequence of messages ids or a single integer message id
<span class="w"> </span>    into an id byte string for use with IMAP commands
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(messages, (str, bytes, int)):</span>
<span class="gi">+        messages = (to_bytes(messages),)</span>
<span class="gi">+    return b&quot;,&quot;.join(_maybe_int_to_bytes(m) for m in messages)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _maybe_int_to_bytes(val):</span>
<span class="gi">+    if isinstance(val, int):</span>
<span class="gi">+        return str(val).encode(&quot;us-ascii&quot;)</span>
<span class="gi">+    return to_bytes(val)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_untagged_response(text):</span>
<span class="gi">+    assert_imap_protocol(text.startswith(b&quot;* &quot;))</span>
<span class="gi">+    text = text[2:]</span>
<span class="gi">+    if text.startswith((b&quot;OK &quot;, b&quot;NO &quot;)):</span>
<span class="gi">+        return tuple(text.split(b&quot; &quot;, 1))</span>
<span class="gi">+    return parse_response([text])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def as_pairs(items):</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    last_item = None</span>
<span class="gi">+    for item in items:</span>
<span class="gi">+        if i % 2:</span>
<span class="gi">+            yield last_item, item</span>
<span class="gi">+        else:</span>
<span class="gi">+            last_item = item</span>
<span class="gi">+        i += 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def as_triplets(items):</span>
<span class="gi">+    a = iter(items)</span>
<span class="gi">+    return zip(a, a, a)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is8bit(data):</span>
<span class="gi">+    return isinstance(data, _literal) or any(b &gt; 127 for b in data)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _iter_with_last(items):</span>
<span class="gi">+    last_i = len(items) - 1</span>
<span class="gi">+    for i, item in enumerate(items):</span>
<span class="gi">+        yield item, i == last_i</span>


<span class="w"> </span>_not_present = object()
<span class="gu">@@ -1157,6 +1968,12 @@ class _dict_bytes_normaliser:</span>

<span class="w"> </span>    def __init__(self, d):
<span class="w"> </span>        self._d = d
<span class="gi">+</span>
<span class="gi">+    def iteritems(self):</span>
<span class="gi">+        for key, value in self._d.items():</span>
<span class="gi">+            yield to_bytes(key), value</span>
<span class="gi">+</span>
<span class="gi">+    # For Python 3 compatibility.</span>
<span class="w"> </span>    items = iteritems

<span class="w"> </span>    def __contains__(self, ink):
<span class="gu">@@ -1165,6 +1982,73 @@ class _dict_bytes_normaliser:</span>
<span class="w"> </span>                return True
<span class="w"> </span>        return False

<span class="gi">+    def get(self, ink, default=_not_present):</span>
<span class="gi">+        for k in self._gen_keys(ink):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self._d[k]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        if default == _not_present:</span>
<span class="gi">+            raise KeyError(ink)</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    def pop(self, ink, default=_not_present):</span>
<span class="gi">+        for k in self._gen_keys(ink):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self._d.pop(k)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        if default == _not_present:</span>
<span class="gi">+            raise KeyError(ink)</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    def _gen_keys(self, k):</span>
<span class="gi">+        yield k</span>
<span class="gi">+        if isinstance(k, bytes):</span>
<span class="gi">+            yield to_unicode(k)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield to_bytes(k)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def debug_trunc(v, maxlen):</span>
<span class="gi">+    if len(v) &lt; maxlen:</span>
<span class="gi">+        return repr(v)</span>
<span class="gi">+    hl = maxlen // 2</span>
<span class="gi">+    return repr(v[:hl]) + &quot;...&quot; + repr(v[-hl:])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def utf7_decode_sequence(seq):</span>
<span class="gi">+    return [decode_utf7(s) for s in seq]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_quota(quota_rep):</span>
<span class="gi">+    quota_rep = parse_response(quota_rep)</span>
<span class="gi">+    rv = []</span>
<span class="gi">+    for quota_root, quota_resource_infos in as_pairs(quota_rep):</span>
<span class="gi">+        for quota_resource_info in as_triplets(quota_resource_infos):</span>
<span class="gi">+            rv.append(</span>
<span class="gi">+                Quota(</span>
<span class="gi">+                    quota_root=to_unicode(quota_root),</span>
<span class="gi">+                    resource=to_unicode(quota_resource_info[0]),</span>
<span class="gi">+                    usage=quota_resource_info[1],</span>
<span class="gi">+                    limit=quota_resource_info[2],</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+    return rv</span>
<span class="gi">+</span>

<span class="w"> </span>class IMAPlibLoggerAdapter(LoggerAdapter):
<span class="w"> </span>    &quot;&quot;&quot;Adapter preventing IMAP secrets from going to the logging facility.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def process(self, msg, kwargs):</span>
<span class="gi">+        # msg is usually unicode but see #367. Convert bytes to</span>
<span class="gi">+        # unicode if required.</span>
<span class="gi">+        if isinstance(msg, bytes):</span>
<span class="gi">+            msg = msg.decode(&quot;ascii&quot;, &quot;ignore&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for command in (&quot;LOGIN&quot;, &quot;AUTHENTICATE&quot;):</span>
<span class="gi">+            if msg.startswith(&quot;&gt;&quot;) and command in msg:</span>
<span class="gi">+                msg_start = msg.split(command)[0]</span>
<span class="gi">+                msg = &quot;{}{} **REDACTED**&quot;.format(msg_start, command)</span>
<span class="gi">+                break</span>
<span class="gi">+        return super().process(msg, kwargs)</span>
<span class="gh">diff --git a/imapclient/interact.py b/imapclient/interact.py</span>
<span class="gh">index a57a825..7abdbaa 100644</span>
<span class="gd">--- a/imapclient/interact.py</span>
<span class="gi">+++ b/imapclient/interact.py</span>
<span class="gu">@@ -1,6 +1,155 @@</span>
<span class="gi">+#!/usr/bin/python</span>
<span class="gi">+</span>
<span class="gi">+# Copyright (c) 2020, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>from getpass import getpass
<span class="gi">+</span>
<span class="w"> </span>from . import imapclient
<span class="w"> </span>from .config import create_client_from_config, get_config_defaults, parse_config_file
<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def command_line() -&gt; argparse.Namespace:</span>
<span class="gi">+    parser = argparse.ArgumentParser()</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &quot;-H&quot;, &quot;--host&quot;, dest=&quot;host&quot;, action=&quot;store&quot;, help=&quot;IMAP host connect to&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &quot;-u&quot;,</span>
<span class="gi">+        &quot;--username&quot;,</span>
<span class="gi">+        dest=&quot;username&quot;,</span>
<span class="gi">+        action=&quot;store&quot;,</span>
<span class="gi">+        help=&quot;Username to login with&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &quot;-p&quot;,</span>
<span class="gi">+        &quot;--password&quot;,</span>
<span class="gi">+        dest=&quot;password&quot;,</span>
<span class="gi">+        action=&quot;store&quot;,</span>
<span class="gi">+        help=&quot;Password to login with&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &quot;-P&quot;,</span>
<span class="gi">+        &quot;--port&quot;,</span>
<span class="gi">+        dest=&quot;port&quot;,</span>
<span class="gi">+        action=&quot;store&quot;,</span>
<span class="gi">+        type=int,</span>
<span class="gi">+        default=None,</span>
<span class="gi">+        help=&quot;IMAP port to use (default is 993 for TLS, or 143 otherwise)&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    ssl_group = parser.add_mutually_exclusive_group()</span>
<span class="gi">+    ssl_group.add_argument(</span>
<span class="gi">+        &quot;-s&quot;,</span>
<span class="gi">+        &quot;--ssl&quot;,</span>
<span class="gi">+        dest=&quot;ssl&quot;,</span>
<span class="gi">+        action=&quot;store_true&quot;,</span>
<span class="gi">+        default=None,</span>
<span class="gi">+        help=&quot;Use SSL/TLS connection (default)&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    ssl_group.add_argument(</span>
<span class="gi">+        &quot;--insecure&quot;,</span>
<span class="gi">+        dest=&quot;insecure&quot;,</span>
<span class="gi">+        action=&quot;store_true&quot;,</span>
<span class="gi">+        default=False,</span>
<span class="gi">+        help=&quot;Use insecure connection (i.e. without SSL/TLS)&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &quot;-f&quot;,</span>
<span class="gi">+        &quot;--file&quot;,</span>
<span class="gi">+        dest=&quot;file&quot;,</span>
<span class="gi">+        action=&quot;store&quot;,</span>
<span class="gi">+        default=None,</span>
<span class="gi">+        help=&quot;Config file (same as livetest)&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    args = parser.parse_args()</span>
<span class="gi">+</span>
<span class="gi">+    if args.file:</span>
<span class="gi">+        if (</span>
<span class="gi">+            args.host</span>
<span class="gi">+            or args.username</span>
<span class="gi">+            or args.password</span>
<span class="gi">+            or args.port</span>
<span class="gi">+            or args.ssl</span>
<span class="gi">+            or args.insecure</span>
<span class="gi">+        ):</span>
<span class="gi">+            parser.error(&quot;If -f/--file is given no other options can be used&quot;)</span>
<span class="gi">+        # Use the options in the config file</span>
<span class="gi">+        args = parse_config_file(args.file)</span>
<span class="gi">+        return args</span>
<span class="gi">+</span>
<span class="gi">+    args.ssl = not args.insecure</span>
<span class="gi">+</span>
<span class="gi">+    # Scan through arguments, filling in defaults and prompting when</span>
<span class="gi">+    # a compulsory argument wasn&#39;t provided.</span>
<span class="gi">+    compulsory_args = (&quot;host&quot;, &quot;username&quot;, &quot;password&quot;)</span>
<span class="gi">+    for name, default_value in get_config_defaults().items():</span>
<span class="gi">+        value = getattr(args, name, default_value)</span>
<span class="gi">+        if name in compulsory_args and value is None:</span>
<span class="gi">+            value = getpass(name + &quot;: &quot;)</span>
<span class="gi">+        setattr(args, name, value)</span>
<span class="gi">+</span>
<span class="gi">+    return args</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def main() -&gt; int:</span>
<span class="gi">+    args = command_line()</span>
<span class="gi">+    print(&quot;Connecting...&quot;)</span>
<span class="gi">+    client = create_client_from_config(args)</span>
<span class="gi">+    print(&quot;Connected.&quot;)</span>
<span class="gi">+    banner = &#39;\nIMAPClient instance is &quot;c&quot;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def ptpython(c: imapclient.IMAPClient) -&gt; None:</span>
<span class="gi">+        from ptpython.repl import embed  # type: ignore[import-not-found]</span>
<span class="gi">+</span>
<span class="gi">+        embed(globals(), locals())</span>
<span class="gi">+</span>
<span class="gi">+    def ipython_400(c: imapclient.IMAPClient) -&gt; None:</span>
<span class="gi">+        from IPython.terminal.embed import (  # type: ignore[import-not-found]</span>
<span class="gi">+            InteractiveShellEmbed,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        ipshell = InteractiveShellEmbed(banner1=banner)</span>
<span class="gi">+        ipshell(&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def ipython_011(c: imapclient.IMAPClient) -&gt; None:</span>
<span class="gi">+        from IPython.frontend.terminal.embed import (  # type: ignore[import-not-found]</span>
<span class="gi">+            InteractiveShellEmbed,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        ipshell = InteractiveShellEmbed(banner1=banner)</span>
<span class="gi">+        ipshell(&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def ipython_010(c: imapclient.IMAPClient) -&gt; None:</span>
<span class="gi">+        from IPython.Shell import IPShellEmbed  # type: ignore[import-not-found]</span>
<span class="gi">+</span>
<span class="gi">+        IPShellEmbed(&quot;&quot;, banner=banner)()</span>
<span class="gi">+</span>
<span class="gi">+    def builtin(c: imapclient.IMAPClient) -&gt; None:</span>
<span class="gi">+        import code</span>
<span class="gi">+</span>
<span class="gi">+        code.interact(banner, local={&quot;c&quot;: c})</span>
<span class="gi">+</span>
<span class="gi">+    shell_attempts = (</span>
<span class="gi">+        ptpython,</span>
<span class="gi">+        ipython_400,</span>
<span class="gi">+        ipython_011,</span>
<span class="gi">+        ipython_010,</span>
<span class="gi">+        builtin,</span>
<span class="gi">+    )</span>
<span class="gi">+    for shell in shell_attempts:</span>
<span class="gi">+        try:</span>
<span class="gi">+            shell(client)</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            break</span>
<span class="gi">+    return 0</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    main()
<span class="gh">diff --git a/imapclient/response_lexer.py b/imapclient/response_lexer.py</span>
<span class="gh">index cd54a2b..1b7d8da 100644</span>
<span class="gd">--- a/imapclient/response_lexer.py</span>
<span class="gi">+++ b/imapclient/response_lexer.py</span>
<span class="gu">@@ -1,20 +1,29 @@</span>
<span class="gi">+# Copyright (c) 2014, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>A lexical analyzer class for IMAP responses.

<span class="w"> </span>Although Lexer does all the work, TokenSource is the class to use for
<span class="w"> </span>external callers.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from typing import Iterator, List, Optional, Tuple, TYPE_CHECKING, Union
<span class="gi">+</span>
<span class="w"> </span>from .util import assert_imap_protocol
<span class="gd">-__all__ = [&#39;TokenSource&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;TokenSource&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>CTRL_CHARS = frozenset(c for c in range(32))
<span class="w"> </span>ALL_CHARS = frozenset(c for c in range(256))
<span class="w"> </span>SPECIALS = frozenset(c for c in b&#39; ()%&quot;[&#39;)
<span class="w"> </span>NON_SPECIALS = ALL_CHARS - SPECIALS - CTRL_CHARS
<span class="gd">-WHITESPACE = frozenset(c for c in b&#39; \t\r\n&#39;)</span>
<span class="gd">-BACKSLASH = ord(&#39;\\&#39;)</span>
<span class="gd">-OPEN_SQUARE = ord(&#39;[&#39;)</span>
<span class="gd">-CLOSE_SQUARE = ord(&#39;]&#39;)</span>
<span class="gi">+WHITESPACE = frozenset(c for c in b&quot; \t\r\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+BACKSLASH = ord(&quot;\\&quot;)</span>
<span class="gi">+OPEN_SQUARE = ord(&quot;[&quot;)</span>
<span class="gi">+CLOSE_SQUARE = ord(&quot;]&quot;)</span>
<span class="w"> </span>DOUBLE_QUOTE = ord(&#39;&quot;&#39;)


<span class="gu">@@ -28,7 +37,13 @@ class TokenSource:</span>
<span class="w"> </span>        self.lex = Lexer(text)
<span class="w"> </span>        self.src = iter(self.lex)

<span class="gd">-    def __iter__(self) -&gt;Iterator[bytes]:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def current_literal(self) -&gt; Optional[bytes]:</span>
<span class="gi">+        if TYPE_CHECKING:</span>
<span class="gi">+            assert self.lex.current_source is not None</span>
<span class="gi">+        return self.lex.current_source.literal</span>
<span class="gi">+</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[bytes]:</span>
<span class="w"> </span>        return self.src


<span class="gu">@@ -41,26 +56,99 @@ class Lexer:</span>
<span class="w"> </span>        self.sources = (LiteralHandlingIter(chunk) for chunk in text)
<span class="w"> </span>        self.current_source: Optional[LiteralHandlingIter] = None

<span class="gd">-    def __iter__(self) -&gt;Iterator[bytes]:</span>
<span class="gi">+    def read_until(</span>
<span class="gi">+        self, stream_i: &quot;PushableIterator&quot;, end_char: int, escape: bool = True</span>
<span class="gi">+    ) -&gt; bytearray:</span>
<span class="gi">+        token = bytearray()</span>
<span class="gi">+        try:</span>
<span class="gi">+            for nextchar in stream_i:</span>
<span class="gi">+                if escape and nextchar == BACKSLASH:</span>
<span class="gi">+                    escaper = nextchar</span>
<span class="gi">+                    nextchar = next(stream_i)</span>
<span class="gi">+                    if nextchar not in (escaper, end_char):</span>
<span class="gi">+                        token.append(escaper)  # Don&#39;t touch invalid escaping</span>
<span class="gi">+                elif nextchar == end_char:</span>
<span class="gi">+                    break</span>
<span class="gi">+                token.append(nextchar)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&quot;No closing &#39;%s&#39;&quot; % chr(end_char))</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            raise ValueError(&quot;No closing &#39;%s&#39;&quot; % chr(end_char))</span>
<span class="gi">+        token.append(end_char)</span>
<span class="gi">+        return token</span>
<span class="gi">+</span>
<span class="gi">+    def read_token_stream(self, stream_i: &quot;PushableIterator&quot;) -&gt; Iterator[bytearray]:</span>
<span class="gi">+        whitespace = WHITESPACE</span>
<span class="gi">+        wordchars = NON_SPECIALS</span>
<span class="gi">+        read_until = self.read_until</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            # Whitespace</span>
<span class="gi">+            for nextchar in stream_i:</span>
<span class="gi">+                if nextchar not in whitespace:</span>
<span class="gi">+                    stream_i.push(nextchar)</span>
<span class="gi">+                    break  # done skipping over the whitespace</span>
<span class="gi">+</span>
<span class="gi">+            # Non-whitespace</span>
<span class="gi">+            token = bytearray()</span>
<span class="gi">+            for nextchar in stream_i:</span>
<span class="gi">+                if nextchar in wordchars:</span>
<span class="gi">+                    token.append(nextchar)</span>
<span class="gi">+                elif nextchar == OPEN_SQUARE:</span>
<span class="gi">+                    token.append(nextchar)</span>
<span class="gi">+                    token.extend(read_until(stream_i, CLOSE_SQUARE, escape=False))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if nextchar in whitespace:</span>
<span class="gi">+                        yield token</span>
<span class="gi">+                    elif nextchar == DOUBLE_QUOTE:</span>
<span class="gi">+                        assert_imap_protocol(not token)</span>
<span class="gi">+                        token.append(nextchar)</span>
<span class="gi">+                        token.extend(read_until(stream_i, nextchar))</span>
<span class="gi">+                        yield token</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # Other punctuation, eg. &quot;(&quot;. This ends the current token.</span>
<span class="gi">+                        if token:</span>
<span class="gi">+                            yield token</span>
<span class="gi">+                        yield bytearray([nextchar])</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                if token:</span>
<span class="gi">+                    yield token</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[bytes]:</span>
<span class="w"> </span>        for source in self.sources:
<span class="w"> </span>            self.current_source = source
<span class="w"> </span>            for tok in self.read_token_stream(iter(source)):
<span class="w"> </span>                yield bytes(tok)


<span class="gi">+# imaplib has poor handling of &#39;literals&#39; - it both fails to remove the</span>
<span class="gi">+# {size} marker, and fails to keep responses grouped into the same logical</span>
<span class="gi">+# &#39;line&#39;.  What we end up with is a list of response &#39;records&#39;, where each</span>
<span class="gi">+# record is either a simple string, or tuple of (str_with_lit, literal) -</span>
<span class="gi">+# where str_with_lit is a string with the {xxx} marker at its end.  Note</span>
<span class="gi">+# that each element of this list does *not* correspond 1:1 with the</span>
<span class="gi">+# untagged responses.</span>
<span class="gi">+# (http://bugs.python.org/issue5045 also has comments about this)</span>
<span class="gi">+# So: we have a special object for each of these records.  When a</span>
<span class="gi">+# string literal is processed, we peek into this object to grab the</span>
<span class="gi">+# literal.</span>
<span class="w"> </span>class LiteralHandlingIter:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, resp_record: Union[Tuple[bytes, bytes], bytes]):
<span class="w"> </span>        self.literal: Optional[bytes]
<span class="w"> </span>        if isinstance(resp_record, tuple):
<span class="gi">+            # A &#39;record&#39; with a string which includes a literal marker, and</span>
<span class="gi">+            # the literal itself.</span>
<span class="w"> </span>            self.src_text = resp_record[0]
<span class="gd">-            assert_imap_protocol(self.src_text.endswith(b&#39;}&#39;), self.src_text)</span>
<span class="gi">+            assert_imap_protocol(self.src_text.endswith(b&quot;}&quot;), self.src_text)</span>
<span class="w"> </span>            self.literal = resp_record[1]
<span class="w"> </span>        else:
<span class="gi">+            # just a line with no literals.</span>
<span class="w"> </span>            self.src_text = resp_record
<span class="w"> </span>            self.literal = None

<span class="gd">-    def __iter__(self) -&gt;&#39;PushableIterator&#39;:</span>
<span class="gi">+    def __iter__(self) -&gt; &quot;PushableIterator&quot;:</span>
<span class="w"> </span>        return PushableIterator(self.src_text)


<span class="gu">@@ -71,11 +159,16 @@ class PushableIterator:</span>
<span class="w"> </span>        self.it = iter(it)
<span class="w"> </span>        self.pushed: List[int] = []

<span class="gd">-    def __iter__(self) -&gt;&#39;PushableIterator&#39;:</span>
<span class="gi">+    def __iter__(self) -&gt; &quot;PushableIterator&quot;:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __next__(self) -&gt;int:</span>
<span class="gi">+    def __next__(self) -&gt; int:</span>
<span class="w"> </span>        if self.pushed:
<span class="w"> </span>            return self.pushed.pop()
<span class="w"> </span>        return next(self.it)
<span class="gi">+</span>
<span class="gi">+    # For Python 2 compatibility</span>
<span class="w"> </span>    next = __next__
<span class="gi">+</span>
<span class="gi">+    def push(self, item: int) -&gt; None:</span>
<span class="gi">+        self.pushed.append(item)</span>
<span class="gh">diff --git a/imapclient/response_parser.py b/imapclient/response_parser.py</span>
<span class="gh">index f632411..9f29e4c 100644</span>
<span class="gd">--- a/imapclient/response_parser.py</span>
<span class="gi">+++ b/imapclient/response_parser.py</span>
<span class="gu">@@ -1,34 +1,45 @@</span>
<span class="gi">+# Copyright (c) 2014, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Parsing for IMAP command responses with focus on FETCH responses as
<span class="w"> </span>returned by imaplib.

<span class="w"> </span>Initially inspired by http://effbot.org/zone/simple-iterator-parser.htm
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# TODO more exact error reporting</span>
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from typing import cast, Dict, Iterator, List, Optional, Tuple, TYPE_CHECKING, Union
<span class="gi">+</span>
<span class="w"> </span>from .datetime_util import parse_to_datetime
<span class="w"> </span>from .exceptions import ProtocolError
<span class="w"> </span>from .response_lexer import TokenSource
<span class="w"> </span>from .response_types import Address, BodyData, Envelope, SearchIds
<span class="w"> </span>from .typing_imapclient import _Atom
<span class="gd">-__all__ = [&#39;parse_response&#39;, &#39;parse_message_list&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;parse_response&quot;, &quot;parse_message_list&quot;]</span>


<span class="gd">-def parse_response(data: List[bytes]) -&gt;Tuple[_Atom, ...]:</span>
<span class="gi">+def parse_response(data: List[bytes]) -&gt; Tuple[_Atom, ...]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pull apart IMAP command responses.

<span class="w"> </span>    Returns nested tuples of appropriately typed objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if data == [None]:</span>
<span class="gi">+        return tuple()</span>
<span class="gi">+    return tuple(gen_parsed_response(data))</span>


<span class="gd">-_msg_id_pattern = re.compile(&#39;(\\d+(?: +\\d+)*)&#39;)</span>
<span class="gi">+_msg_id_pattern = re.compile(r&quot;(\d+(?: +\d+)*)&quot;)</span>


<span class="gd">-def parse_message_list(data: List[Union[bytes, str]]) -&gt;SearchIds:</span>
<span class="gi">+def parse_message_list(data: List[Union[bytes, str]]) -&gt; SearchIds:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a list of message ids and return them as a list.

<span class="w"> </span>    parse_response is also capable of doing this but this is
<span class="gu">@@ -39,18 +50,238 @@ def parse_message_list(data: List[Union[bytes, str]]) -&gt;SearchIds:</span>
<span class="w"> </span>    attribute which contains the MODSEQ response (if returned by the
<span class="w"> </span>    server).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(data) != 1:</span>
<span class="gi">+        raise ValueError(&quot;unexpected message list data&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    message_data = data[0]</span>
<span class="gi">+    if not message_data:</span>
<span class="gi">+        return SearchIds()</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(message_data, bytes):</span>
<span class="gi">+        message_data = message_data.decode(&quot;ascii&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    m = _msg_id_pattern.match(message_data)</span>
<span class="gi">+    if not m:</span>
<span class="gi">+        raise ValueError(&quot;unexpected message list format&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    ids = SearchIds(int(n) for n in m.group(1).split())</span>

<span class="gi">+    # Parse any non-numeric part on the end using parse_response (this</span>
<span class="gi">+    # is likely to be the MODSEQ section).</span>
<span class="gi">+    extra = message_data[m.end(1) :]</span>
<span class="gi">+    if extra:</span>
<span class="gi">+        for item in parse_response([extra.encode(&quot;ascii&quot;)]):</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(item, tuple)</span>
<span class="gi">+                and len(item) == 2</span>
<span class="gi">+                and cast(bytes, item[0]).lower() == b&quot;modseq&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                if TYPE_CHECKING:</span>
<span class="gi">+                    assert isinstance(item[1], int)</span>
<span class="gi">+                ids.modseq = item[1]</span>
<span class="gi">+            elif isinstance(item, int):</span>
<span class="gi">+                ids.append(item)</span>
<span class="gi">+    return ids</span>

<span class="gd">-_ParseFetchResponseInnerDict = Dict[bytes, Optional[Union[datetime.datetime,</span>
<span class="gd">-    int, BodyData, Envelope, _Atom]]]</span>

<span class="gi">+def gen_parsed_response(text: List[bytes]) -&gt; Iterator[_Atom]:</span>
<span class="gi">+    if not text:</span>
<span class="gi">+        return</span>
<span class="gi">+    src = TokenSource(text)</span>

<span class="gd">-def parse_fetch_response(text: List[bytes], normalise_times: bool=True,</span>
<span class="gd">-    uid_is_key: bool=True) -&gt;&#39;defaultdict[int, _ParseFetchResponseInnerDict]&#39;:</span>
<span class="gi">+    token = None</span>
<span class="gi">+    try:</span>
<span class="gi">+        for token in src:</span>
<span class="gi">+            yield atom(src, token)</span>
<span class="gi">+    except ProtocolError:</span>
<span class="gi">+        raise</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        _, err, _ = sys.exc_info()</span>
<span class="gi">+        raise ProtocolError(&quot;%s: %r&quot; % (str(err), token))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_ParseFetchResponseInnerDict = Dict[</span>
<span class="gi">+    bytes, Optional[Union[datetime.datetime, int, BodyData, Envelope, _Atom]]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_fetch_response(</span>
<span class="gi">+    text: List[bytes], normalise_times: bool = True, uid_is_key: bool = True</span>
<span class="gi">+) -&gt; &quot;defaultdict[int, _ParseFetchResponseInnerDict]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pull apart IMAP FETCH responses as returned by imaplib.

<span class="w"> </span>    Returns a dictionary, keyed by message ID. Each value a dictionary
<span class="w"> </span>    keyed by FETCH field type (eg.&quot;RFC822&quot;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if text == [None]:</span>
<span class="gi">+        return defaultdict()</span>
<span class="gi">+    response = gen_parsed_response(text)</span>
<span class="gi">+</span>
<span class="gi">+    parsed_response: &quot;defaultdict[int, _ParseFetchResponseInnerDict]&quot; = defaultdict(</span>
<span class="gi">+        dict</span>
<span class="gi">+    )</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            msg_id = seq = _int_or_error(next(response), &quot;invalid message ID&quot;)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            msg_response = next(response)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            raise ProtocolError(&quot;unexpected EOF&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(msg_response, tuple):</span>
<span class="gi">+            raise ProtocolError(&quot;bad response type: %s&quot; % repr(msg_response))</span>
<span class="gi">+        if len(msg_response) % 2:</span>
<span class="gi">+            raise ProtocolError(</span>
<span class="gi">+                &quot;uneven number of response items: %s&quot; % repr(msg_response)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # always return the sequence of the message, so it is available</span>
<span class="gi">+        # even if we return keyed by UID.</span>
<span class="gi">+        msg_data: _ParseFetchResponseInnerDict = {b&quot;SEQ&quot;: seq}</span>
<span class="gi">+        for i in range(0, len(msg_response), 2):</span>
<span class="gi">+            msg_attribute = msg_response[i]</span>
<span class="gi">+            if TYPE_CHECKING:</span>
<span class="gi">+                assert isinstance(msg_attribute, bytes)</span>
<span class="gi">+            word = msg_attribute.upper()</span>
<span class="gi">+            value = msg_response[i + 1]</span>
<span class="gi">+</span>
<span class="gi">+            if word == b&quot;UID&quot;:</span>
<span class="gi">+                uid = _int_or_error(value, &quot;invalid UID&quot;)</span>
<span class="gi">+                if uid_is_key:</span>
<span class="gi">+                    msg_id = uid</span>
<span class="gi">+                else:</span>
<span class="gi">+                    msg_data[word] = uid</span>
<span class="gi">+            elif word == b&quot;INTERNALDATE&quot;:</span>
<span class="gi">+                msg_data[word] = _convert_INTERNALDATE(value, normalise_times)</span>
<span class="gi">+            elif word == b&quot;ENVELOPE&quot;:</span>
<span class="gi">+                msg_data[word] = _convert_ENVELOPE(value, normalise_times)</span>
<span class="gi">+            elif word in (b&quot;BODY&quot;, b&quot;BODYSTRUCTURE&quot;):</span>
<span class="gi">+                if TYPE_CHECKING:</span>
<span class="gi">+                    assert isinstance(value, tuple)</span>
<span class="gi">+                msg_data[word] = BodyData.create(value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg_data[word] = value</span>
<span class="gi">+</span>
<span class="gi">+        parsed_response[msg_id].update(msg_data)</span>
<span class="gi">+</span>
<span class="gi">+    return parsed_response</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _int_or_error(value: _Atom, error_text: str) -&gt; int:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return int(value)  # type: ignore[arg-type]</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        raise ProtocolError(&quot;%s: %s&quot; % (error_text, repr(value)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _convert_INTERNALDATE(</span>
<span class="gi">+    date_string: _Atom, normalise_times: bool = True</span>
<span class="gi">+) -&gt; Optional[datetime.datetime]:</span>
<span class="gi">+    if date_string is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if TYPE_CHECKING:</span>
<span class="gi">+            assert isinstance(date_string, bytes)</span>
<span class="gi">+        return parse_to_datetime(date_string, normalise=normalise_times)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _convert_ENVELOPE(</span>
<span class="gi">+    envelope_response: _Atom, normalise_times: bool = True</span>
<span class="gi">+) -&gt; Envelope:</span>
<span class="gi">+    if TYPE_CHECKING:</span>
<span class="gi">+        assert isinstance(envelope_response, tuple)</span>
<span class="gi">+    dt = None</span>
<span class="gi">+    if envelope_response[0]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if TYPE_CHECKING:</span>
<span class="gi">+                assert isinstance(envelope_response[0], bytes)</span>
<span class="gi">+            dt = parse_to_datetime(</span>
<span class="gi">+                envelope_response[0],</span>
<span class="gi">+                normalise=normalise_times,</span>
<span class="gi">+            )</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    subject = envelope_response[1]</span>
<span class="gi">+    in_reply_to = envelope_response[8]</span>
<span class="gi">+    message_id = envelope_response[9]</span>
<span class="gi">+    if TYPE_CHECKING:</span>
<span class="gi">+        assert isinstance(subject, bytes)</span>
<span class="gi">+        assert isinstance(in_reply_to, bytes)</span>
<span class="gi">+        assert isinstance(message_id, bytes)</span>
<span class="gi">+</span>
<span class="gi">+    # addresses contains a tuple of addresses</span>
<span class="gi">+    # from, sender, reply_to, to, cc, bcc headers</span>
<span class="gi">+    addresses: List[Optional[Tuple[Address, ...]]] = []</span>
<span class="gi">+    for addr_list in envelope_response[2:8]:</span>
<span class="gi">+        addrs = []</span>
<span class="gi">+        if addr_list:</span>
<span class="gi">+            if TYPE_CHECKING:</span>
<span class="gi">+                assert isinstance(addr_list, tuple)</span>
<span class="gi">+            for addr_tuple in addr_list:</span>
<span class="gi">+                if TYPE_CHECKING:</span>
<span class="gi">+                    assert isinstance(addr_tuple, tuple)</span>
<span class="gi">+                if addr_tuple:</span>
<span class="gi">+                    if TYPE_CHECKING:</span>
<span class="gi">+                        addr_tuple = cast(Tuple[bytes, bytes, bytes, bytes], addr_tuple)</span>
<span class="gi">+                    addrs.append(Address(*addr_tuple))</span>
<span class="gi">+            addresses.append(tuple(addrs))</span>
<span class="gi">+        else:</span>
<span class="gi">+            addresses.append(None)</span>
<span class="gi">+</span>
<span class="gi">+    return Envelope(</span>
<span class="gi">+        date=dt,</span>
<span class="gi">+        subject=subject,</span>
<span class="gi">+        from_=addresses[0],</span>
<span class="gi">+        sender=addresses[1],</span>
<span class="gi">+        reply_to=addresses[2],</span>
<span class="gi">+        to=addresses[3],</span>
<span class="gi">+        cc=addresses[4],</span>
<span class="gi">+        bcc=addresses[5],</span>
<span class="gi">+        in_reply_to=in_reply_to,</span>
<span class="gi">+        message_id=message_id,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def atom(src: TokenSource, token: bytes) -&gt; _Atom:</span>
<span class="gi">+    if token == b&quot;(&quot;:</span>
<span class="gi">+        return parse_tuple(src)</span>
<span class="gi">+    if token == b&quot;NIL&quot;:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if token[:1] == b&quot;{&quot;:</span>
<span class="gi">+        literal_len = int(token[1:-1])</span>
<span class="gi">+        literal_text = src.current_literal</span>
<span class="gi">+        if literal_text is None:</span>
<span class="gi">+            raise ProtocolError(&quot;No literal corresponds to %r&quot; % token)</span>
<span class="gi">+        if len(literal_text) != literal_len:</span>
<span class="gi">+            raise ProtocolError(</span>
<span class="gi">+                &quot;Expecting literal of size %d, got %d&quot;</span>
<span class="gi">+                % (literal_len, len(literal_text))</span>
<span class="gi">+            )</span>
<span class="gi">+        return literal_text</span>
<span class="gi">+    if len(token) &gt;= 2 and (token[:1] == token[-1:] == b&#39;&quot;&#39;):</span>
<span class="gi">+        return token[1:-1]</span>
<span class="gi">+    if token.isdigit() and (token[:1] != b&quot;0&quot; or len(token) == 1):</span>
<span class="gi">+        # this prevents converting items like 0123 to 123</span>
<span class="gi">+        return int(token)</span>
<span class="gi">+    return token</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_tuple(src: TokenSource) -&gt; _Atom:</span>
<span class="gi">+    out: List[_Atom] = []</span>
<span class="gi">+    for token in src:</span>
<span class="gi">+        if token == b&quot;)&quot;:</span>
<span class="gi">+            return tuple(out)</span>
<span class="gi">+        out.append(atom(src, token))</span>
<span class="gi">+    # no terminator</span>
<span class="gi">+    raise ProtocolError(&#39;Tuple incomplete before &quot;(%s&quot;&#39; % _fmt_tuple(out))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _fmt_tuple(t: List[_Atom]) -&gt; str:</span>
<span class="gi">+    return &quot; &quot;.join(str(item) for item in t)</span>
<span class="gh">diff --git a/imapclient/response_types.py b/imapclient/response_types.py</span>
<span class="gh">index 7d95b73..cd4631d 100644</span>
<span class="gd">--- a/imapclient/response_types.py</span>
<span class="gi">+++ b/imapclient/response_types.py</span>
<span class="gu">@@ -1,25 +1,30 @@</span>
<span class="gi">+# Copyright (c) 2014, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import datetime
<span class="w"> </span>from email.utils import formataddr
<span class="w"> </span>from typing import Any, List, Optional, Tuple, TYPE_CHECKING, Union
<span class="gi">+</span>
<span class="w"> </span>from .typing_imapclient import _Atom
<span class="w"> </span>from .util import to_unicode


<span class="w"> </span>@dataclasses.dataclass
<span class="w"> </span>class Envelope:
<span class="gd">-    &quot;&quot;&quot;Represents envelope structures of messages. Returned when parsing</span>
<span class="gi">+    r&quot;&quot;&quot;Represents envelope structures of messages. Returned when parsing</span>
<span class="w"> </span>    ENVELOPE responses.

<span class="w"> </span>    :ivar date: A datetime instance that represents the &quot;Date&quot; header.
<span class="w"> </span>    :ivar subject: A string that contains the &quot;Subject&quot; header.
<span class="gd">-    :ivar from\\_: A tuple of Address objects that represent one or more</span>
<span class="gi">+    :ivar from\_: A tuple of Address objects that represent one or more</span>
<span class="w"> </span>      addresses from the &quot;From&quot; header, or None if header does not exist.
<span class="gd">-    :ivar sender: As for from\\_ but represents the &quot;Sender&quot; header.</span>
<span class="gd">-    :ivar reply_to: As for from\\_ but represents the &quot;Reply-To&quot; header.</span>
<span class="gd">-    :ivar to: As for from\\_ but represents the &quot;To&quot; header.</span>
<span class="gd">-    :ivar cc: As for from\\_ but represents the &quot;Cc&quot; header.</span>
<span class="gd">-    :ivar bcc: As for from\\_ but represents the &quot;Bcc&quot; recipients.</span>
<span class="gi">+    :ivar sender: As for from\_ but represents the &quot;Sender&quot; header.</span>
<span class="gi">+    :ivar reply_to: As for from\_ but represents the &quot;Reply-To&quot; header.</span>
<span class="gi">+    :ivar to: As for from\_ but represents the &quot;To&quot; header.</span>
<span class="gi">+    :ivar cc: As for from\_ but represents the &quot;Cc&quot; header.</span>
<span class="gi">+    :ivar bcc: As for from\_ but represents the &quot;Bcc&quot; recipients.</span>
<span class="w"> </span>    :ivar in_reply_to: A string that contains the &quot;In-Reply-To&quot; header.
<span class="w"> </span>    :ivar message_id: A string that contains the &quot;Message-Id&quot; header.

<span class="gu">@@ -50,12 +55,12 @@ class Envelope:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    date: Optional[datetime.datetime]
<span class="w"> </span>    subject: bytes
<span class="gd">-    from_: Optional[Tuple[&#39;Address&#39;, ...]]</span>
<span class="gd">-    sender: Optional[Tuple[&#39;Address&#39;, ...]]</span>
<span class="gd">-    reply_to: Optional[Tuple[&#39;Address&#39;, ...]]</span>
<span class="gd">-    to: Optional[Tuple[&#39;Address&#39;, ...]]</span>
<span class="gd">-    cc: Optional[Tuple[&#39;Address&#39;, ...]]</span>
<span class="gd">-    bcc: Optional[Tuple[&#39;Address&#39;, ...]]</span>
<span class="gi">+    from_: Optional[Tuple[&quot;Address&quot;, ...]]</span>
<span class="gi">+    sender: Optional[Tuple[&quot;Address&quot;, ...]]</span>
<span class="gi">+    reply_to: Optional[Tuple[&quot;Address&quot;, ...]]</span>
<span class="gi">+    to: Optional[Tuple[&quot;Address&quot;, ...]]</span>
<span class="gi">+    cc: Optional[Tuple[&quot;Address&quot;, ...]]</span>
<span class="gi">+    bcc: Optional[Tuple[&quot;Address&quot;, ...]]</span>
<span class="w"> </span>    in_reply_to: bytes
<span class="w"> </span>    message_id: bytes

<span class="gu">@@ -83,16 +88,18 @@ class Address:</span>
<span class="w"> </span>    See also :py:class:`Envelope` for information about handling of
<span class="w"> </span>    &quot;group syntax&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name: bytes
<span class="w"> </span>    route: bytes
<span class="w"> </span>    mailbox: bytes
<span class="w"> </span>    host: bytes

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        if self.mailbox and self.host:
<span class="gd">-            address = to_unicode(self.mailbox) + &#39;@&#39; + to_unicode(self.host)</span>
<span class="gi">+            address = to_unicode(self.mailbox) + &quot;@&quot; + to_unicode(self.host)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            address = to_unicode(self.mailbox or self.host)
<span class="gi">+</span>
<span class="w"> </span>        return formataddr((to_unicode(self.name), address))


<span class="gu">@@ -110,10 +117,32 @@ class SearchIds(List[int]):</span>
<span class="w"> </span>        self.modseq: Optional[int] = None


<span class="gd">-_BodyDataType = Tuple[Union[bytes, int, &#39;BodyData&#39;], &#39;_BodyDataType&#39;]</span>
<span class="gi">+_BodyDataType = Tuple[Union[bytes, int, &quot;BodyData&quot;], &quot;_BodyDataType&quot;]</span>


<span class="w"> </span>class BodyData(_BodyDataType):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returned when parsing BODY and BODYSTRUCTURE responses.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def create(cls, response: Tuple[_Atom, ...]) -&gt; &quot;BodyData&quot;:</span>
<span class="gi">+        # In case of multipart messages we will see at least 2 tuples</span>
<span class="gi">+        # at the start. Nest these in to a list so that the returned</span>
<span class="gi">+        # response tuple always has a consistent number of elements</span>
<span class="gi">+        # regardless of whether the message is multipart or not.</span>
<span class="gi">+        if isinstance(response[0], tuple):</span>
<span class="gi">+            # Multipart, find where the message part tuples stop</span>
<span class="gi">+            parts = []</span>
<span class="gi">+            for i, part in enumerate(response):</span>
<span class="gi">+                if isinstance(part, bytes):</span>
<span class="gi">+                    break</span>
<span class="gi">+                if TYPE_CHECKING:</span>
<span class="gi">+                    assert isinstance(part, tuple)</span>
<span class="gi">+                parts.append(part)</span>
<span class="gi">+            return cls(([cls.create(part) for part in parts],) + response[i:])</span>
<span class="gi">+        return cls(response)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def is_multipart(self) -&gt; bool:</span>
<span class="gi">+        return isinstance(self[0], list)</span>
<span class="gh">diff --git a/imapclient/testable_imapclient.py b/imapclient/testable_imapclient.py</span>
<span class="gh">index c605b90..c583274 100644</span>
<span class="gd">--- a/imapclient/testable_imapclient.py</span>
<span class="gi">+++ b/imapclient/testable_imapclient.py</span>
<span class="gu">@@ -1,5 +1,10 @@</span>
<span class="gi">+# Copyright (c) 2014, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, Dict
<span class="w"> </span>from unittest.mock import Mock
<span class="gi">+</span>
<span class="w"> </span>from .imapclient import IMAPClient


<span class="gu">@@ -12,15 +17,23 @@ class TestableIMAPClient(IMAPClient):</span>
<span class="w"> </span>    IMAP account.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        super().__init__(&#39;somehost&#39;)</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        super().__init__(&quot;somehost&quot;)</span>

<span class="gi">+    def _create_IMAP4(self) -&gt; &quot;MockIMAP4&quot;:</span>
<span class="gi">+        return MockIMAP4()</span>

<span class="gd">-class MockIMAP4(Mock):</span>

<span class="gi">+class MockIMAP4(Mock):</span>
<span class="w"> </span>    def __init__(self, *args: Any, **kwargs: Any):
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self.use_uid = True
<span class="gd">-        self.sent = b&#39;&#39;</span>
<span class="gi">+        self.sent = b&quot;&quot;  # Accumulates what was given to send()</span>
<span class="w"> </span>        self.tagged_commands: Dict[Any, Any] = {}
<span class="w"> </span>        self._starttls_done = False
<span class="gi">+</span>
<span class="gi">+    def send(self, data: bytes) -&gt; None:</span>
<span class="gi">+        self.sent += data</span>
<span class="gi">+</span>
<span class="gi">+    def _new_tag(self) -&gt; str:</span>
<span class="gi">+        return &quot;tag&quot;</span>
<span class="gh">diff --git a/imapclient/tls.py b/imapclient/tls.py</span>
<span class="gh">index a700b1a..fe9671e 100644</span>
<span class="gd">--- a/imapclient/tls.py</span>
<span class="gi">+++ b/imapclient/tls.py</span>
<span class="gu">@@ -1,25 +1,68 @@</span>
<span class="gi">+# Copyright (c) 2023, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>This module contains IMAPClient&#39;s functionality related to Transport
<span class="w"> </span>Layer Security (TLS a.k.a. SSL).
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import imaplib
<span class="w"> </span>import io
<span class="w"> </span>import socket
<span class="w"> </span>import ssl
<span class="w"> </span>from typing import Optional, TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing_extensions import Buffer


<span class="gi">+def wrap_socket(</span>
<span class="gi">+    sock: socket.socket, ssl_context: Optional[ssl.SSLContext], host: str</span>
<span class="gi">+) -&gt; socket.socket:</span>
<span class="gi">+    if ssl_context is None:</span>
<span class="gi">+        ssl_context = ssl.create_default_context(purpose=ssl.Purpose.SERVER_AUTH)</span>
<span class="gi">+</span>
<span class="gi">+    return ssl_context.wrap_socket(sock, server_hostname=host)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class IMAP4_TLS(imaplib.IMAP4):
<span class="w"> </span>    &quot;&quot;&quot;IMAP4 client class for TLS/SSL connections.

<span class="w"> </span>    Adapted from imaplib.IMAP4_SSL.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, host: str, port: int, ssl_context: Optional[ssl.</span>
<span class="gd">-        SSLContext], timeout: Optional[float]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host: str,</span>
<span class="gi">+        port: int,</span>
<span class="gi">+        ssl_context: Optional[ssl.SSLContext],</span>
<span class="gi">+        timeout: Optional[float] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.ssl_context = ssl_context
<span class="w"> </span>        self._timeout = timeout
<span class="w"> </span>        imaplib.IMAP4.__init__(self, host, port)
<span class="w"> </span>        self.file: io.BufferedReader
<span class="gi">+</span>
<span class="gi">+    def open(</span>
<span class="gi">+        self, host: str = &quot;&quot;, port: int = 993, timeout: Optional[float] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.host = host</span>
<span class="gi">+        self.port = port</span>
<span class="gi">+        sock = socket.create_connection(</span>
<span class="gi">+            (host, port), timeout if timeout is not None else self._timeout</span>
<span class="gi">+        )</span>
<span class="gi">+        self.sock = wrap_socket(sock, self.ssl_context, host)</span>
<span class="gi">+        self.file = self.sock.makefile(&quot;rb&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def read(self, size: int) -&gt; bytes:</span>
<span class="gi">+        return self.file.read(size)</span>
<span class="gi">+</span>
<span class="gi">+    def readline(self) -&gt; bytes:</span>
<span class="gi">+        return self.file.readline()</span>
<span class="gi">+</span>
<span class="gi">+    def send(self, data: &quot;Buffer&quot;) -&gt; None:</span>
<span class="gi">+        self.sock.sendall(data)</span>
<span class="gi">+</span>
<span class="gi">+    def shutdown(self) -&gt; None:</span>
<span class="gi">+        imaplib.IMAP4.shutdown(self)</span>
<span class="gh">diff --git a/imapclient/typing_imapclient.py b/imapclient/typing_imapclient.py</span>
<span class="gh">index 2fcbe01..a9fc1af 100644</span>
<span class="gd">--- a/imapclient/typing_imapclient.py</span>
<span class="gi">+++ b/imapclient/typing_imapclient.py</span>
<span class="gu">@@ -1,3 +1,4 @@</span>
<span class="w"> </span>from typing import Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>_AtomPart = Union[None, int, bytes]
<span class="gd">-_Atom = Union[_AtomPart, Tuple[&#39;_Atom&#39;, ...]]</span>
<span class="gi">+_Atom = Union[_AtomPart, Tuple[&quot;_Atom&quot;, ...]]</span>
<span class="gh">diff --git a/imapclient/util.py b/imapclient/util.py</span>
<span class="gh">index 5e3fab3..8f9aa35 100644</span>
<span class="gd">--- a/imapclient/util.py</span>
<span class="gi">+++ b/imapclient/util.py</span>
<span class="gu">@@ -1,6 +1,50 @@</span>
<span class="gi">+# Copyright (c) 2015, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>from typing import Iterator, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>from . import exceptions
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_unicode(s: Union[bytes, str]) -&gt; str:</span>
<span class="gi">+    if isinstance(s, bytes):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return s.decode(&quot;ascii&quot;)</span>
<span class="gi">+        except UnicodeDecodeError:</span>
<span class="gi">+            logger.warning(</span>
<span class="gi">+                &quot;An error occurred while decoding %s in ASCII &#39;strict&#39; mode. Fallback to &quot;</span>
<span class="gi">+                &quot;&#39;ignore&#39; errors handling, some characters might have been stripped&quot;,</span>
<span class="gi">+                s,</span>
<span class="gi">+            )</span>
<span class="gi">+            return s.decode(&quot;ascii&quot;, &quot;ignore&quot;)</span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_bytes(s: Union[bytes, str], charset: str = &quot;ascii&quot;) -&gt; bytes:</span>
<span class="gi">+    if isinstance(s, str):</span>
<span class="gi">+        return s.encode(charset)</span>
<span class="gi">+    return s</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def assert_imap_protocol(condition: bool, message: Optional[bytes] = None) -&gt; None:</span>
<span class="gi">+    if not condition:</span>
<span class="gi">+        msg = &quot;Server replied with a response that violates the IMAP protocol&quot;</span>
<span class="gi">+        if message:</span>
<span class="gi">+            # FIXME(jlvillal): This looks wrong as it repeats `msg` twice</span>
<span class="gi">+            msg += &quot;{}: {}&quot;.format(</span>
<span class="gi">+                msg, message.decode(encoding=&quot;ascii&quot;, errors=&quot;ignore&quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+        raise exceptions.ProtocolError(msg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_TupleAtomPart = Union[None, int, bytes]
<span class="gd">-_TupleAtom = Tuple[Union[_TupleAtomPart, &#39;_TupleAtom&#39;], ...]</span>
<span class="gi">+_TupleAtom = Tuple[Union[_TupleAtomPart, &quot;_TupleAtom&quot;], ...]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def chunk(lst: _TupleAtom, size: int) -&gt; Iterator[_TupleAtom]:</span>
<span class="gi">+    for i in range(0, len(lst), size):</span>
<span class="gi">+        yield lst[i : i + size]</span>
<span class="gh">diff --git a/imapclient/version.py b/imapclient/version.py</span>
<span class="gh">index 9e7d8dc..c97dfb6 100644</span>
<span class="gd">--- a/imapclient/version.py</span>
<span class="gi">+++ b/imapclient/version.py</span>
<span class="gu">@@ -1,7 +1,24 @@</span>
<span class="gi">+# Copyright (c) 2022, Menno Smits</span>
<span class="gi">+# Released subject to the New BSD License</span>
<span class="gi">+# Please see http://en.wikipedia.org/wiki/BSD_licenses</span>
<span class="gi">+</span>
<span class="w"> </span>from typing import Tuple
<span class="gd">-version_info = 3, 0, 1, &#39;final&#39;</span>
<span class="gi">+</span>
<span class="gi">+version_info = (3, 0, 1, &quot;final&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _imapclient_version_string(vinfo: Tuple[int, int, int, str]) -&gt; str:</span>
<span class="gi">+    major, minor, micro, releaselevel = vinfo</span>
<span class="gi">+    v = &quot;%d.%d.%d&quot; % (major, minor, micro)</span>
<span class="gi">+    if releaselevel != &quot;final&quot;:</span>
<span class="gi">+        v += &quot;-&quot; + releaselevel</span>
<span class="gi">+    return v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>version = _imapclient_version_string(version_info)
<span class="gd">-maintainer = &#39;IMAPClient Maintainers&#39;</span>
<span class="gd">-maintainer_email = &#39;imapclient@groups.io&#39;</span>
<span class="gd">-author = &#39;Menno Finlay-Smits&#39;</span>
<span class="gd">-author_email = &#39;inbox@menno.io&#39;</span>
<span class="gi">+</span>
<span class="gi">+maintainer = &quot;IMAPClient Maintainers&quot;</span>
<span class="gi">+maintainer_email = &quot;imapclient@groups.io&quot;</span>
<span class="gi">+</span>
<span class="gi">+author = &quot;Menno Finlay-Smits&quot;</span>
<span class="gi">+author_email = &quot;inbox@menno.io&quot;</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>