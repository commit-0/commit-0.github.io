
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference pexpect - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-pexpect" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference pexpect
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_ctrl_charspytestctrlcharstest_control_chars" class="md-nav__link">
    <span class="md-ellipsis">
      test_ctrl_chars.py::TestCtrlChars::test_control_chars
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ctrl_charspytestctrlcharstest_sendcontrol" class="md-nav__link">
    <span class="md-ellipsis">
      test_ctrl_chars.py::TestCtrlChars::test_sendcontrol
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_expectpyexpecttestcasetest_expect" class="md-nav__link">
    <span class="md-ellipsis">
      test_expect.py::ExpectTestCase::test_expect
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_expectpyexpecttestcasetest_expect_eof" class="md-nav__link">
    <span class="md-ellipsis">
      test_expect.py::ExpectTestCase::test_expect_eof
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_expectpyexpecttestcasetest_expect_exact" class="md-nav__link">
    <span class="md-ellipsis">
      test_expect.py::ExpectTestCase::test_expect_exact
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_popen_spawnpyexpecttestcasetest_expect" class="md-nav__link">
    <span class="md-ellipsis">
      test_popen_spawn.py::ExpectTestCase::test_expect
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_popen_spawnpyexpecttestcasetest_expect_eof" class="md-nav__link">
    <span class="md-ellipsis">
      test_popen_spawn.py::ExpectTestCase::test_expect_eof
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_popen_spawnpyexpecttestcasetest_expect_exact" class="md-nav__link">
    <span class="md-ellipsis">
      test_popen_spawn.py::ExpectTestCase::test_expect_exact
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_replwrappyreplwraptestcasetest_existing_spawn" class="md-nav__link">
    <span class="md-ellipsis">
      test_replwrap.py::REPLWrapTestCase::test_existing_spawn
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_replwrappyreplwraptestcasetest_pager_as_cat" class="md-nav__link">
    <span class="md-ellipsis">
      test_replwrap.py::REPLWrapTestCase::test_pager_as_cat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_replwrappyreplwraptestcasetest_zsh" class="md-nav__link">
    <span class="md-ellipsis">
      test_replwrap.py::REPLWrapTestCase::test_zsh
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_winsizepytestcasewinsizetest_setwinsize" class="md-nav__link">
    <span class="md-ellipsis">
      test_winsize.py::TestCaseWinsize::test_setwinsize
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-pexpect"><strong>Reference (Gold)</strong>: pexpect</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">245</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">12</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">257</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">257</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_ctrl_charspytestctrlcharstest_control_chars">test_ctrl_chars.py::TestCtrlChars::test_control_chars</h3>
<details><summary> <pre>test_ctrl_chars.py::TestCtrlChars::test_control_chars</pre></summary><pre>
self = <tests.test_ctrl_chars.TestCtrlChars testMethod=test_control_chars>

    def test_control_chars(self):
        '''This tests that we can send all 256 8-bit characters to a child
        process.'''
        child = pexpect.spawn(self.getch_cmd, echo=False, timeout=5)
        child.expect('READY')
        for i in range(1, 256):
            child.send(byte(i))
>           child.expect ('%d<STOP>' % (i,))

tests/test_ctrl_chars.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pexpect/spawnbase.py:354: in expect
    return self.expect_list(compiled_pattern_list,
pexpect/spawnbase.py:383: in expect_list
    return exp.expect_loop(timeout)
pexpect/expect.py:181: in expect_loop
    return self.timeout(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pexpect.expect.Expecter object at 0x7ea240a68670>
err = TIMEOUT('Timeout exceeded.')

    def timeout(self, err=None):
        spawn = self.spawn

        spawn.before = spawn._before.getvalue()
        spawn.after = TIMEOUT
        index = self.searcher.timeout_index
        if index >= 0:
            spawn.match = TIMEOUT
            spawn.match_index = index
            return index
        else:
            spawn.match = None
            spawn.match_index = None
            msg = str(spawn)
            msg += '\nsearcher: %s' % self.searcher
            if err is not None:
                msg = str(err) + '\n' + msg

            exc = TIMEOUT(msg)
            exc.__cause__ = None    # in Python 3.x we can use "raise exc from None"
>           raise exc
E           pexpect.exceptions.TIMEOUT: Timeout exceeded.
E           <pexpect.pty_spawn.spawn object at 0x7ea240a68730>
E           command: /testbed/.venv/bin/python3
E           args: ['/testbed/.venv/bin/python3', 'getch.py']
E           buffer (last 100 chars): b'\r\n'
E           before (last 100 chars): b'\r\n'
E           after: <class 'pexpect.exceptions.TIMEOUT'>
E           match: None
E           match_index: None
E           exitstatus: None
E           flag_eof: False
E           pid: 33
E           child_fd: 13
E           closed: False
E           timeout: 5
E           delimiter: <class 'pexpect.exceptions.EOF'>
E           logfile: None
E           logfile_read: None
E           logfile_send: None
E           maxread: 2000
E           ignorecase: False
E           searchwindowsize: None
E           delaybeforesend: 0.05
E           delayafterclose: 0.1
E           delayafterterminate: 0.1
E           searcher: searcher_re:
E               0: re.compile(b'26<STOP>')

pexpect/expect.py:144: TIMEOUT
</pre>
</details>
<h3 id="test_ctrl_charspytestctrlcharstest_sendcontrol">test_ctrl_chars.py::TestCtrlChars::test_sendcontrol</h3>
<details><summary> <pre>test_ctrl_chars.py::TestCtrlChars::test_sendcontrol</pre></summary><pre>
self = <tests.test_ctrl_chars.TestCtrlChars testMethod=test_sendcontrol>

    def test_sendcontrol(self):
        '''This tests that we can send all special control codes by name.
        '''
        child = pexpect.spawn(self.getch_cmd, echo=False, timeout=5)
        child.expect('READY')
        for ctrl in 'abcdefghijklmnopqrstuvwxyz':
            assert child.sendcontrol(ctrl) == 1
            val = ord(ctrl) - ord('a') + 1
>           child.expect_exact(str(val)+'<STOP>')

tests/test_ctrl_chars.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pexpect/spawnbase.py:432: in expect_exact
    return exp.expect_loop(timeout)
pexpect/expect.py:181: in expect_loop
    return self.timeout(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pexpect.expect.Expecter object at 0x7ea2400c0160>
err = TIMEOUT('Timeout exceeded.')

    def timeout(self, err=None):
        spawn = self.spawn

        spawn.before = spawn._before.getvalue()
        spawn.after = TIMEOUT
        index = self.searcher.timeout_index
        if index >= 0:
            spawn.match = TIMEOUT
            spawn.match_index = index
            return index
        else:
            spawn.match = None
            spawn.match_index = None
            msg = str(spawn)
            msg += '\nsearcher: %s' % self.searcher
            if err is not None:
                msg = str(err) + '\n' + msg

            exc = TIMEOUT(msg)
            exc.__cause__ = None    # in Python 3.x we can use "raise exc from None"
>           raise exc
E           pexpect.exceptions.TIMEOUT: Timeout exceeded.
E           <pexpect.pty_spawn.spawn object at 0x7ea2400c2680>
E           command: /testbed/.venv/bin/python3
E           args: ['/testbed/.venv/bin/python3', 'getch.py']
E           buffer (last 100 chars): b'\r\n'
E           before (last 100 chars): b'\r\n'
E           after: <class 'pexpect.exceptions.TIMEOUT'>
E           match: None
E           match_index: None
E           exitstatus: None
E           flag_eof: False
E           pid: 34
E           child_fd: 14
E           closed: False
E           timeout: 5
E           delimiter: <class 'pexpect.exceptions.EOF'>
E           logfile: None
E           logfile_read: None
E           logfile_send: None
E           maxread: 2000
E           ignorecase: False
E           searchwindowsize: None
E           delaybeforesend: 0.05
E           delayafterclose: 0.1
E           delayafterterminate: 0.1
E           searcher: searcher_string:
E               0: b'26<STOP>'

pexpect/expect.py:144: TIMEOUT
</pre>
</details>
<h3 id="test_expectpyexpecttestcasetest_expect">test_expect.py::ExpectTestCase::test_expect</h3>
<details><summary> <pre>test_expect.py::ExpectTestCase::test_expect</pre></summary><pre>
self = <tests.test_expect.ExpectTestCase testMethod=test_expect>

    def test_expect (self):
        the_old_way = subprocess.Popen(args=['ls', '-l', '/bin'],
                stdout=subprocess.PIPE).communicate()[0].rstrip()
        p = pexpect.spawn('ls -l /bin')
        the_new_way = b''
        while 1:
            i = p.expect ([b'\n', pexpect.EOF])
            the_new_way = the_new_way + p.before
            if i == 1:
                break
        the_new_way = the_new_way.rstrip()
        the_new_way = the_new_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
        the_old_way = the_old_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
>       assert the_old_way == the_new_way, hex_diff(the_old_way, the_new_way)

tests/test_expect.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_expect.py:53: in hex_diff
    hex_dump(left).splitlines(), hex_dump(right).splitlines())
tests/test_expect.py:46: in hex_dump
    hexa = ' '.join(["%02X"%ord(x) for x in s])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <bytes_iterator object at 0x7ea2400c3220>

>   hexa = ' '.join(["%02X"%ord(x) for x in s])
E   TypeError: ord() expected string of length 1, but int found

tests/test_expect.py:46: TypeError
</pre>
</details>
<h3 id="test_expectpyexpecttestcasetest_expect_eof">test_expect.py::ExpectTestCase::test_expect_eof</h3>
<details><summary> <pre>test_expect.py::ExpectTestCase::test_expect_eof</pre></summary><pre>
self = <tests.test_expect.ExpectTestCase testMethod=test_expect_eof>

    def test_expect_eof (self):
        the_old_way = subprocess.Popen(args=['/bin/ls', '-l', '/bin'],
                stdout=subprocess.PIPE).communicate()[0].rstrip()
        p = pexpect.spawn('/bin/ls -l /bin')
        p.expect(pexpect.EOF) # This basically tells it to read everything. Same as pexpect.run() function.
        the_new_way = p.before
        the_new_way = the_new_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
        the_old_way = the_old_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
>       assert the_old_way == the_new_way, hex_diff(the_old_way, the_new_way)

tests/test_expect.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_expect.py:53: in hex_diff
    hex_dump(left).splitlines(), hex_dump(right).splitlines())
tests/test_expect.py:46: in hex_dump
    hexa = ' '.join(["%02X"%ord(x) for x in s])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <bytes_iterator object at 0x7ea240726980>

>   hexa = ' '.join(["%02X"%ord(x) for x in s])
E   TypeError: ord() expected string of length 1, but int found

tests/test_expect.py:46: TypeError
</pre>
</details>
<h3 id="test_expectpyexpecttestcasetest_expect_exact">test_expect.py::ExpectTestCase::test_expect_exact</h3>
<details><summary> <pre>test_expect.py::ExpectTestCase::test_expect_exact</pre></summary><pre>
self = <tests.test_expect.ExpectTestCase testMethod=test_expect_exact>

    def test_expect_exact (self):
        the_old_way = subprocess.Popen(args=['ls', '-l', '/bin'],
                stdout=subprocess.PIPE).communicate()[0].rstrip()
        p = pexpect.spawn('ls -l /bin')
        the_new_way = b''
        while 1:
            i = p.expect_exact ([b'\n', pexpect.EOF])
            the_new_way = the_new_way + p.before
            if i == 1:
                break
        the_new_way = the_new_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
        the_old_way = the_old_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
>       assert the_old_way == the_new_way, hex_diff(the_old_way, the_new_way)

tests/test_expect.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_expect.py:53: in hex_diff
    hex_dump(left).splitlines(), hex_dump(right).splitlines())
tests/test_expect.py:46: in hex_dump
    hexa = ' '.join(["%02X"%ord(x) for x in s])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <bytes_iterator object at 0x7ea23f5198d0>

>   hexa = ' '.join(["%02X"%ord(x) for x in s])
E   TypeError: ord() expected string of length 1, but int found

tests/test_expect.py:46: TypeError
</pre>
</details>
<h3 id="test_popen_spawnpyexpecttestcasetest_expect">test_popen_spawn.py::ExpectTestCase::test_expect</h3>
<details><summary> <pre>test_popen_spawn.py::ExpectTestCase::test_expect</pre></summary><pre>
self = <tests.test_popen_spawn.ExpectTestCase testMethod=test_expect>

    def test_expect(self):
        the_old_way = subprocess.Popen(args=['ls', '-l', '/bin'],
                                       stdout=subprocess.PIPE).communicate()[0].rstrip()
        p = PopenSpawn('ls -l /bin')
        the_new_way = b''
        while 1:
            i = p.expect([b'\n', pexpect.EOF])
            the_new_way = the_new_way + p.before
            if i == 1:
                break
            the_new_way += b'\n'
        the_new_way = the_new_way.rstrip()
>       assert the_old_way == the_new_way, len(the_old_way) - len(the_new_way)
E       AssertionError: -30
E       assert b'lrwxrwxrwx ...in -> usr/bin' == b'ls: /bin: B...in -> usr/bin'
E         
E         At index 1 diff: b'r' != b's'
E         Use -v to get more diff

tests/test_popen_spawn.py:66: AssertionError
</pre>
</details>
<h3 id="test_popen_spawnpyexpecttestcasetest_expect_eof">test_popen_spawn.py::ExpectTestCase::test_expect_eof</h3>
<details><summary> <pre>test_popen_spawn.py::ExpectTestCase::test_expect_eof</pre></summary><pre>
self = <tests.test_popen_spawn.ExpectTestCase testMethod=test_expect_eof>

    def test_expect_eof(self):
        the_old_way = subprocess.Popen(args=['ls', '-l', '/bin'],
                                       stdout=subprocess.PIPE).communicate()[0].rstrip()
        p = PopenSpawn('ls -l /bin')
        # This basically tells it to read everything. Same as pexpect.run()
        # function.
        p.expect(pexpect.EOF)
        the_new_way = p.before.rstrip()
>       assert the_old_way == the_new_way, len(the_old_way) - len(the_new_way)
E       AssertionError: -30
E       assert b'lrwxrwxrwx ...in -> usr/bin' == b'ls: /bin: B...in -> usr/bin'
E         
E         At index 1 diff: b'r' != b's'
E         Use -v to get more diff

tests/test_popen_spawn.py:95: AssertionError
</pre>
</details>
<h3 id="test_popen_spawnpyexpecttestcasetest_expect_exact">test_popen_spawn.py::ExpectTestCase::test_expect_exact</h3>
<details><summary> <pre>test_popen_spawn.py::ExpectTestCase::test_expect_exact</pre></summary><pre>
self = <tests.test_popen_spawn.ExpectTestCase testMethod=test_expect_exact>

    def test_expect_exact(self):
        the_old_way = subprocess.Popen(args=['ls', '-l', '/bin'],
                                       stdout=subprocess.PIPE).communicate()[0].rstrip()
        p = PopenSpawn('ls -l /bin')
        the_new_way = b''
        while 1:
            i = p.expect_exact([b'\n', pexpect.EOF])
            the_new_way = the_new_way + p.before
            if i == 1:
                break
            the_new_way += b'\n'
        the_new_way = the_new_way.rstrip()

>       assert the_old_way == the_new_way, len(the_old_way) - len(the_new_way)
E       AssertionError: -30
E       assert b'lrwxrwxrwx ...in -> usr/bin' == b'ls: /bin: B...in -> usr/bin'
E         
E         At index 1 diff: b'r' != b's'
E         Use -v to get more diff

tests/test_popen_spawn.py:81: AssertionError
</pre>
</details>
<h3 id="test_replwrappyreplwraptestcasetest_existing_spawn">test_replwrap.py::REPLWrapTestCase::test_existing_spawn</h3>
<details><summary> <pre>test_replwrap.py::REPLWrapTestCase::test_existing_spawn</pre></summary><pre>
self = <tests.test_replwrap.REPLWrapTestCase testMethod=test_existing_spawn>

    def test_existing_spawn(self):
        child = pexpect.spawn("bash", timeout=5, encoding='utf-8')
        repl = replwrap.REPLWrapper(child, re.compile('[$#]'),
                                    "PS1='{0}' PS2='{1}' "
                                    "PROMPT_COMMAND=''")

        print(repl)
        res = repl.run_command("echo $HOME")
        print(res)
>       assert res.startswith('/'), res
E       AssertionError: [?2004l
/root
E         [?2004h
E       assert False
E        +  where False = <built-in method startswith of str object at 0x7ea23f1a1430>('/')
E        +    where <built-in method startswith of str object at 0x7ea23f1a1430> = '\x1b[?2004l\r/root\r\n\x1b[?2004h'.startswith

/testbed/tests/test_replwrap.py:98: AssertionError
</pre>
</details>
<h3 id="test_replwrappyreplwraptestcasetest_pager_as_cat">test_replwrap.py::REPLWrapTestCase::test_pager_as_cat</h3>
<details><summary> <pre>test_replwrap.py::REPLWrapTestCase::test_pager_as_cat</pre></summary><pre>
self = <tests.test_replwrap.REPLWrapTestCase testMethod=test_pager_as_cat>

    def test_pager_as_cat(self):
        " PAGER is set to cat, to prevent timeout in ``man sleep``. "
        bash = replwrap.bash()
        res = bash.run_command('man sleep', timeout=5)
>       assert 'SLEEP' in res.upper(), res
E       AssertionError: This system has been minimized by removing packages and content that are
E         not required on a system that users do not log into.
E         
E         To restore this content, including manpages, you can run the 'unminimize'
E         command. You will still need to ensure the 'man-db' package is installed.
E         
E       assert 'SLEEP' in "THIS SYSTEM HAS BEEN MINIMIZED BY REMOVING PACKAGES AND CONTENT THAT ARE\r\nNOT REQUIRED ON A SYSTEM THAT USERS DO NO...ANPAGES, YOU CAN RUN THE 'UNMINIMIZE'\r\nCOMMAND. YOU WILL STILL NEED TO ENSURE THE 'MAN-DB' PACKAGE IS INSTALLED.\r\n"
E        +  where "THIS SYSTEM HAS BEEN MINIMIZED BY REMOVING PACKAGES AND CONTENT THAT ARE\r\nNOT REQUIRED ON A SYSTEM THAT USERS DO NO...ANPAGES, YOU CAN RUN THE 'UNMINIMIZE'\r\nCOMMAND. YOU WILL STILL NEED TO ENSURE THE 'MAN-DB' PACKAGE IS INSTALLED.\r\n" = <built-in method upper of str object at 0x7ea23f63cea0>()
E        +    where <built-in method upper of str object at 0x7ea23f63cea0> = "This system has been minimized by removing packages and content that are\r\nnot required on a system that users do no...anpages, you can run the 'unminimize'\r\ncommand. You will still need to ensure the 'man-db' package is installed.\r\n".upper

/testbed/tests/test_replwrap.py:42: AssertionError
</pre>
</details>
<h3 id="test_replwrappyreplwraptestcasetest_zsh">test_replwrap.py::REPLWrapTestCase::test_zsh</h3>
<details><summary> <pre>test_replwrap.py::REPLWrapTestCase::test_zsh</pre></summary><pre>
self = <tests.test_replwrap.REPLWrapTestCase testMethod=test_zsh>

    def test_zsh(self):
>       zsh = replwrap.zsh()

/testbed/tests/test_replwrap.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/pexpect/replwrap.py:136: in zsh
    return _repl_sh(command, list(args), non_printable_insert='%(!..)')
/testbed/pexpect/replwrap.py:116: in _repl_sh
    child = pexpect.spawn(command, args, echo=False, encoding='utf-8')
/testbed/pexpect/pty_spawn.py:205: in __init__
    self._spawn(command, args, preexec_fn, dimensions)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pexpect.pty_spawn.spawn object at 0x7ea23f51d900>, command = 'zsh'
args = ['--no-rcs', '-V', '+Z'], preexec_fn = None, dimensions = None

    def _spawn(self, command, args=[], preexec_fn=None, dimensions=None):
        '''This starts the given command in a child process. This does all the
        fork/exec type of stuff for a pty. This is called by __init__. If args
        is empty then command will be parsed (split on spaces) and args will be
        set to parsed arguments. '''

        # The pid and child_fd of this object get set by this method.
        # Note that it is difficult for this method to fail.
        # You cannot detect if the child process cannot start.
        # So the only way you can tell if the child process started
        # or not is to try to read from the file descriptor. If you get
        # EOF immediately then it means that the child is already dead.
        # That may not necessarily be bad because you may have spawned a child
        # that performs some task; creates no stdout output; and then dies.

        # If command is an int type then it may represent a file descriptor.
        if isinstance(command, type(0)):
            raise ExceptionPexpect('Command is an int type. ' +
                    'If this is a file descriptor then maybe you want to ' +
                    'use fdpexpect.fdspawn which takes an existing ' +
                    'file descriptor instead of a command string.')

        if not isinstance(args, type([])):
            raise TypeError('The argument, args, must be a list.')

        if args == []:
            self.args = split_command_line(command)
            self.command = self.args[0]
        else:
            # Make a shallow copy of the args list.
            self.args = args[:]
            self.args.insert(0, command)
            self.command = command

        command_with_path = which(self.command, env=self.env)
        if command_with_path is None:
>           raise ExceptionPexpect('The command was not found or was not ' +
                    'executable: %s.' % self.command)
E           pexpect.exceptions.ExceptionPexpect: The command was not found or was not executable: zsh.

/testbed/pexpect/pty_spawn.py:276: ExceptionPexpect
</pre>
</details>
<h3 id="test_winsizepytestcasewinsizetest_setwinsize">test_winsize.py::TestCaseWinsize::test_setwinsize</h3>
<details><summary> <pre>test_winsize.py::TestCaseWinsize::test_setwinsize</pre></summary><pre>
self = <tests.test_winsize.TestCaseWinsize testMethod=test_setwinsize>

    def test_setwinsize(self):
        """ Ensure method .setwinsize() sends signal caught by child. """
        p = pexpect.spawn('{self.PYTHONBIN} sigwinch_report.py'
                          .format(self=self), timeout=3)
        # Note that we must await the installation of the child process'
        # signal handler,
        p.expect_exact('READY')
        p.setwinsize(19, 84)
>       p.expect_exact('SIGWINCH: (19, 84)')

/testbed/tests/test_winsize.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/pexpect/spawnbase.py:432: in expect_exact
    return exp.expect_loop(timeout)
/testbed/pexpect/expect.py:181: in expect_loop
    return self.timeout(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pexpect.expect.Expecter object at 0x7ea2401e6620>
err = TIMEOUT('Timeout exceeded.')

    def timeout(self, err=None):
        spawn = self.spawn

        spawn.before = spawn._before.getvalue()
        spawn.after = TIMEOUT
        index = self.searcher.timeout_index
        if index >= 0:
            spawn.match = TIMEOUT
            spawn.match_index = index
            return index
        else:
            spawn.match = None
            spawn.match_index = None
            msg = str(spawn)
            msg += '\nsearcher: %s' % self.searcher
            if err is not None:
                msg = str(err) + '\n' + msg

            exc = TIMEOUT(msg)
            exc.__cause__ = None    # in Python 3.x we can use "raise exc from None"
>           raise exc
E           pexpect.exceptions.TIMEOUT: Timeout exceeded.
E           <pexpect.pty_spawn.spawn object at 0x7ea2401e5060>
E           command: /testbed/.venv/bin/python3
E           args: ['/testbed/.venv/bin/python3', 'sigwinch_report.py']
E           buffer (last 100 chars): b'\r\n'
E           before (last 100 chars): b'\r\n'
E           after: <class 'pexpect.exceptions.TIMEOUT'>
E           match: None
E           match_index: None
E           exitstatus: None
E           flag_eof: False
E           pid: 355
E           child_fd: 21
E           closed: False
E           timeout: 3
E           delimiter: <class 'pexpect.exceptions.EOF'>
E           logfile: None
E           logfile_read: None
E           logfile_send: None
E           maxread: 2000
E           ignorecase: False
E           searchwindowsize: None
E           delaybeforesend: 0.05
E           delayafterclose: 0.1
E           delayafterterminate: 0.1
E           searcher: searcher_string:
E               0: b'SIGWINCH: (19, 84)'

/testbed/pexpect/expect.py:144: TIMEOUT
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/pexpect/ANSI.py b/pexpect/ANSI.py</span>
<span class="gh">index df126d4..1cd2e90 100644</span>
<span class="gd">--- a/pexpect/ANSI.py</span>
<span class="gi">+++ b/pexpect/ANSI.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-&quot;&quot;&quot;This implements an ANSI (VT100) terminal emulator as a subclass of screen.</span>
<span class="gi">+&#39;&#39;&#39;This implements an ANSI (VT100) terminal emulator as a subclass of screen.</span>

<span class="w"> </span>PEXPECT LICENSE

<span class="gu">@@ -17,127 +17,335 @@ PEXPECT LICENSE</span>
<span class="w"> </span>    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<span class="w"> </span>    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+# references:</span>
<span class="gi">+#     http://en.wikipedia.org/wiki/ANSI_escape_code</span>
<span class="gi">+#     http://www.retards.org/terminals/vt102.html</span>
<span class="gi">+#     http://vt100.net/docs/vt102-ug/contents.html</span>
<span class="gi">+#     http://vt100.net/docs/vt220-rm/</span>
<span class="gi">+#     http://www.termsys.demon.co.uk/vtansi.htm</span>
<span class="gi">+</span>
<span class="w"> </span>from . import screen
<span class="w"> </span>from . import FSM
<span class="w"> </span>import string

<span class="gi">+#</span>
<span class="gi">+# The &#39;Do.*&#39; functions are helper functions for the ANSI class.</span>
<span class="gi">+#</span>
<span class="gi">+def DoEmit (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.write_ch(fsm.input_symbol)</span>
<span class="gi">+</span>
<span class="gi">+def DoStartNumber (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    fsm.memory.append (fsm.input_symbol)</span>
<span class="gi">+</span>
<span class="gi">+def DoBuildNumber (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    ns = fsm.memory.pop()</span>
<span class="gi">+    ns = ns + fsm.input_symbol</span>
<span class="gi">+    fsm.memory.append (ns)</span>
<span class="gi">+</span>
<span class="gi">+def DoBackOne (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_back ()</span>
<span class="gi">+</span>
<span class="gi">+def DoBack (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    count = int(fsm.memory.pop())</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_back (count)</span>
<span class="gi">+</span>
<span class="gi">+def DoDownOne (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_down ()</span>
<span class="gi">+</span>
<span class="gi">+def DoDown (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    count = int(fsm.memory.pop())</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_down (count)</span>
<span class="gi">+</span>
<span class="gi">+def DoForwardOne (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_forward ()</span>
<span class="gi">+</span>
<span class="gi">+def DoForward (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    count = int(fsm.memory.pop())</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_forward (count)</span>
<span class="gi">+</span>
<span class="gi">+def DoUpReverse (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_up_reverse()</span>
<span class="gi">+</span>
<span class="gi">+def DoUpOne (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_up ()</span>
<span class="gi">+</span>
<span class="gi">+def DoUp (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    count = int(fsm.memory.pop())</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_up (count)</span>
<span class="gi">+</span>
<span class="gi">+def DoHome (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    c = int(fsm.memory.pop())</span>
<span class="gi">+    r = int(fsm.memory.pop())</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_home (r,c)</span>
<span class="gi">+</span>
<span class="gi">+def DoHomeOrigin (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    c = 1</span>
<span class="gi">+    r = 1</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_home (r,c)</span>
<span class="gi">+</span>
<span class="gi">+def DoEraseDown (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.erase_down()</span>
<span class="gi">+</span>
<span class="gi">+def DoErase (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    arg = int(fsm.memory.pop())</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    if arg == 0:</span>
<span class="gi">+        screen.erase_down()</span>
<span class="gi">+    elif arg == 1:</span>
<span class="gi">+        screen.erase_up()</span>
<span class="gi">+    elif arg == 2:</span>
<span class="gi">+        screen.erase_screen()</span>
<span class="gi">+</span>
<span class="gi">+def DoEraseEndOfLine (fsm):</span>

<span class="gd">-class term(screen.screen):</span>
<span class="gd">-    &quot;&quot;&quot;This class is an abstract, generic terminal.</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.erase_end_of_line()</span>
<span class="gi">+</span>
<span class="gi">+def DoEraseLine (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    arg = int(fsm.memory.pop())</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    if arg == 0:</span>
<span class="gi">+        screen.erase_end_of_line()</span>
<span class="gi">+    elif arg == 1:</span>
<span class="gi">+        screen.erase_start_of_line()</span>
<span class="gi">+    elif arg == 2:</span>
<span class="gi">+        screen.erase_line()</span>
<span class="gi">+</span>
<span class="gi">+def DoEnableScroll (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.scroll_screen()</span>
<span class="gi">+</span>
<span class="gi">+def DoCursorSave (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_save_attrs()</span>
<span class="gi">+</span>
<span class="gi">+def DoCursorRestore (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    screen.cursor_restore_attrs()</span>
<span class="gi">+</span>
<span class="gi">+def DoScrollRegion (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    r2 = int(fsm.memory.pop())</span>
<span class="gi">+    r1 = int(fsm.memory.pop())</span>
<span class="gi">+    screen.scroll_screen_rows (r1,r2)</span>
<span class="gi">+</span>
<span class="gi">+def DoMode (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    mode = fsm.memory.pop() # Should be 4</span>
<span class="gi">+    # screen.setReplaceMode ()</span>
<span class="gi">+</span>
<span class="gi">+def DoLog (fsm):</span>
<span class="gi">+</span>
<span class="gi">+    screen = fsm.memory[0]</span>
<span class="gi">+    fsm.memory = [screen]</span>
<span class="gi">+    fout = open (&#39;log&#39;, &#39;a&#39;)</span>
<span class="gi">+    fout.write (fsm.input_symbol + &#39;,&#39; + fsm.current_state + &#39;\n&#39;)</span>
<span class="gi">+    fout.close()</span>
<span class="gi">+</span>
<span class="gi">+class term (screen.screen):</span>
<span class="gi">+</span>
<span class="gi">+    &#39;&#39;&#39;This class is an abstract, generic terminal.</span>
<span class="w"> </span>    This does nothing. This is a placeholder that
<span class="w"> </span>    provides a common base class for other terminals
<span class="gd">-    such as an ANSI terminal. &quot;&quot;&quot;</span>
<span class="gi">+    such as an ANSI terminal. &#39;&#39;&#39;</span>

<span class="gd">-    def __init__(self, r=24, c=80, *args, **kwargs):</span>
<span class="gd">-        screen.screen.__init__(self, r, c, *args, **kwargs)</span>
<span class="gi">+    def __init__ (self, r=24, c=80, *args, **kwargs):</span>

<span class="gi">+        screen.screen.__init__(self, r,c,*args,**kwargs)</span>

<span class="gd">-class ANSI(term):</span>
<span class="gd">-    &quot;&quot;&quot;This class implements an ANSI (VT100) terminal.</span>
<span class="gi">+class ANSI (term):</span>
<span class="gi">+    &#39;&#39;&#39;This class implements an ANSI (VT100) terminal.</span>
<span class="w"> </span>    It is a stream filter that recognizes ANSI terminal
<span class="gd">-    escape sequences and maintains the state of a screen object. &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, r=24, c=80, *args, **kwargs):</span>
<span class="gd">-        term.__init__(self, r, c, *args, **kwargs)</span>
<span class="gd">-        self.state = FSM.FSM(&#39;INIT&#39;, [self])</span>
<span class="gd">-        self.state.set_default_transition(DoLog, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition_any(&#39;INIT&#39;, DoEmit, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;\x1b&#39;, &#39;INIT&#39;, None, &#39;ESC&#39;)</span>
<span class="gd">-        self.state.add_transition_any(&#39;ESC&#39;, DoLog, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;(&#39;, &#39;ESC&#39;, None, &#39;G0SCS&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;)&#39;, &#39;ESC&#39;, None, &#39;G1SCS&#39;)</span>
<span class="gd">-        self.state.add_transition_list(&#39;AB012&#39;, &#39;G0SCS&#39;, None, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition_list(&#39;AB012&#39;, &#39;G1SCS&#39;, None, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;7&#39;, &#39;ESC&#39;, DoCursorSave, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;8&#39;, &#39;ESC&#39;, DoCursorRestore, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;M&#39;, &#39;ESC&#39;, DoUpReverse, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;&gt;&#39;, &#39;ESC&#39;, DoUpReverse, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;&lt;&#39;, &#39;ESC&#39;, DoUpReverse, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;=&#39;, &#39;ESC&#39;, None, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;#&#39;, &#39;ESC&#39;, None, &#39;GRAPHICS_POUND&#39;)</span>
<span class="gd">-        self.state.add_transition_any(&#39;GRAPHICS_POUND&#39;, None, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;[&#39;, &#39;ESC&#39;, None, &#39;ELB&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;H&#39;, &#39;ELB&#39;, DoHomeOrigin, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;D&#39;, &#39;ELB&#39;, DoBackOne, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;B&#39;, &#39;ELB&#39;, DoDownOne, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;C&#39;, &#39;ELB&#39;, DoForwardOne, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;A&#39;, &#39;ELB&#39;, DoUpOne, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;J&#39;, &#39;ELB&#39;, DoEraseDown, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;K&#39;, &#39;ELB&#39;, DoEraseEndOfLine, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;r&#39;, &#39;ELB&#39;, DoEnableScroll, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;m&#39;, &#39;ELB&#39;, self.do_sgr, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;?&#39;, &#39;ELB&#39;, None, &#39;MODECRAP&#39;)</span>
<span class="gd">-        self.state.add_transition_list(string.digits, &#39;ELB&#39;, DoStartNumber,</span>
<span class="gd">-            &#39;NUMBER_1&#39;)</span>
<span class="gd">-        self.state.add_transition_list(string.digits, &#39;NUMBER_1&#39;,</span>
<span class="gd">-            DoBuildNumber, &#39;NUMBER_1&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;D&#39;, &#39;NUMBER_1&#39;, DoBack, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;B&#39;, &#39;NUMBER_1&#39;, DoDown, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;C&#39;, &#39;NUMBER_1&#39;, DoForward, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;A&#39;, &#39;NUMBER_1&#39;, DoUp, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;J&#39;, &#39;NUMBER_1&#39;, DoErase, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;K&#39;, &#39;NUMBER_1&#39;, DoEraseLine, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;l&#39;, &#39;NUMBER_1&#39;, DoMode, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;m&#39;, &#39;NUMBER_1&#39;, self.do_sgr, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;q&#39;, &#39;NUMBER_1&#39;, self.do_decsca, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition_list(string.digits, &#39;MODECRAP&#39;,</span>
<span class="gd">-            DoStartNumber, &#39;MODECRAP_NUM&#39;)</span>
<span class="gd">-        self.state.add_transition_list(string.digits, &#39;MODECRAP_NUM&#39;,</span>
<span class="gd">-            DoBuildNumber, &#39;MODECRAP_NUM&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;l&#39;, &#39;MODECRAP_NUM&#39;, self.do_modecrap, &#39;INIT&#39;</span>
<span class="gd">-            )</span>
<span class="gd">-        self.state.add_transition(&#39;h&#39;, &#39;MODECRAP_NUM&#39;, self.do_modecrap, &#39;INIT&#39;</span>
<span class="gd">-            )</span>
<span class="gd">-        self.state.add_transition(&#39;;&#39;, &#39;NUMBER_1&#39;, None, &#39;SEMICOLON&#39;)</span>
<span class="gd">-        self.state.add_transition_any(&#39;SEMICOLON&#39;, DoLog, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition_list(string.digits, &#39;SEMICOLON&#39;,</span>
<span class="gd">-            DoStartNumber, &#39;NUMBER_2&#39;)</span>
<span class="gd">-        self.state.add_transition_list(string.digits, &#39;NUMBER_2&#39;,</span>
<span class="gd">-            DoBuildNumber, &#39;NUMBER_2&#39;)</span>
<span class="gd">-        self.state.add_transition_any(&#39;NUMBER_2&#39;, DoLog, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;H&#39;, &#39;NUMBER_2&#39;, DoHome, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;f&#39;, &#39;NUMBER_2&#39;, DoHome, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;r&#39;, &#39;NUMBER_2&#39;, DoScrollRegion, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;m&#39;, &#39;NUMBER_2&#39;, self.do_sgr, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;q&#39;, &#39;NUMBER_2&#39;, self.do_decsca, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;;&#39;, &#39;NUMBER_2&#39;, None, &#39;SEMICOLON_X&#39;)</span>
<span class="gd">-        self.state.add_transition_any(&#39;SEMICOLON_X&#39;, DoLog, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition_list(string.digits, &#39;SEMICOLON_X&#39;,</span>
<span class="gd">-            DoStartNumber, &#39;NUMBER_X&#39;)</span>
<span class="gd">-        self.state.add_transition_list(string.digits, &#39;NUMBER_X&#39;,</span>
<span class="gd">-            DoBuildNumber, &#39;NUMBER_X&#39;)</span>
<span class="gd">-        self.state.add_transition_any(&#39;NUMBER_X&#39;, DoLog, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;m&#39;, &#39;NUMBER_X&#39;, self.do_sgr, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;q&#39;, &#39;NUMBER_X&#39;, self.do_decsca, &#39;INIT&#39;)</span>
<span class="gd">-        self.state.add_transition(&#39;;&#39;, &#39;NUMBER_X&#39;, None, &#39;SEMICOLON_X&#39;)</span>
<span class="gd">-</span>
<span class="gd">-    def process(self, c):</span>
<span class="gi">+    escape sequences and maintains the state of a screen object. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__ (self, r=24,c=80,*args,**kwargs):</span>
<span class="gi">+</span>
<span class="gi">+        term.__init__(self,r,c,*args,**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        #self.screen = screen (24,80)</span>
<span class="gi">+        self.state = FSM.FSM (&#39;INIT&#39;,[self])</span>
<span class="gi">+        self.state.set_default_transition (DoLog, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition_any (&#39;INIT&#39;, DoEmit, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;\x1b&#39;, &#39;INIT&#39;, None, &#39;ESC&#39;)</span>
<span class="gi">+        self.state.add_transition_any (&#39;ESC&#39;, DoLog, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;(&#39;, &#39;ESC&#39;, None, &#39;G0SCS&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;)&#39;, &#39;ESC&#39;, None, &#39;G1SCS&#39;)</span>
<span class="gi">+        self.state.add_transition_list (&#39;AB012&#39;, &#39;G0SCS&#39;, None, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition_list (&#39;AB012&#39;, &#39;G1SCS&#39;, None, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;7&#39;, &#39;ESC&#39;, DoCursorSave, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;8&#39;, &#39;ESC&#39;, DoCursorRestore, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;M&#39;, &#39;ESC&#39;, DoUpReverse, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;&gt;&#39;, &#39;ESC&#39;, DoUpReverse, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;&lt;&#39;, &#39;ESC&#39;, DoUpReverse, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;=&#39;, &#39;ESC&#39;, None, &#39;INIT&#39;) # Selects application keypad.</span>
<span class="gi">+        self.state.add_transition (&#39;#&#39;, &#39;ESC&#39;, None, &#39;GRAPHICS_POUND&#39;)</span>
<span class="gi">+        self.state.add_transition_any (&#39;GRAPHICS_POUND&#39;, None, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;[&#39;, &#39;ESC&#39;, None, &#39;ELB&#39;)</span>
<span class="gi">+        # ELB means Escape Left Bracket. That is ^[[</span>
<span class="gi">+        self.state.add_transition (&#39;H&#39;, &#39;ELB&#39;, DoHomeOrigin, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;D&#39;, &#39;ELB&#39;, DoBackOne, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;B&#39;, &#39;ELB&#39;, DoDownOne, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;C&#39;, &#39;ELB&#39;, DoForwardOne, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;A&#39;, &#39;ELB&#39;, DoUpOne, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;J&#39;, &#39;ELB&#39;, DoEraseDown, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;K&#39;, &#39;ELB&#39;, DoEraseEndOfLine, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;r&#39;, &#39;ELB&#39;, DoEnableScroll, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;m&#39;, &#39;ELB&#39;, self.do_sgr, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;?&#39;, &#39;ELB&#39;, None, &#39;MODECRAP&#39;)</span>
<span class="gi">+        self.state.add_transition_list (string.digits, &#39;ELB&#39;, DoStartNumber, &#39;NUMBER_1&#39;)</span>
<span class="gi">+        self.state.add_transition_list (string.digits, &#39;NUMBER_1&#39;, DoBuildNumber, &#39;NUMBER_1&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;D&#39;, &#39;NUMBER_1&#39;, DoBack, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;B&#39;, &#39;NUMBER_1&#39;, DoDown, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;C&#39;, &#39;NUMBER_1&#39;, DoForward, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;A&#39;, &#39;NUMBER_1&#39;, DoUp, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;J&#39;, &#39;NUMBER_1&#39;, DoErase, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;K&#39;, &#39;NUMBER_1&#39;, DoEraseLine, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;l&#39;, &#39;NUMBER_1&#39;, DoMode, &#39;INIT&#39;)</span>
<span class="gi">+        ### It gets worse... the &#39;m&#39; code can have infinite number of</span>
<span class="gi">+        ### number;number;number before it. I&#39;ve never seen more than two,</span>
<span class="gi">+        ### but the specs say it&#39;s allowed. crap!</span>
<span class="gi">+        self.state.add_transition (&#39;m&#39;, &#39;NUMBER_1&#39;, self.do_sgr, &#39;INIT&#39;)</span>
<span class="gi">+        ### LED control. Same implementation problem as &#39;m&#39; code.</span>
<span class="gi">+        self.state.add_transition (&#39;q&#39;, &#39;NUMBER_1&#39;, self.do_decsca, &#39;INIT&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # \E[?47h switch to alternate screen</span>
<span class="gi">+        # \E[?47l restores to normal screen from alternate screen.</span>
<span class="gi">+        self.state.add_transition_list (string.digits, &#39;MODECRAP&#39;, DoStartNumber, &#39;MODECRAP_NUM&#39;)</span>
<span class="gi">+        self.state.add_transition_list (string.digits, &#39;MODECRAP_NUM&#39;, DoBuildNumber, &#39;MODECRAP_NUM&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;l&#39;, &#39;MODECRAP_NUM&#39;, self.do_modecrap, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;h&#39;, &#39;MODECRAP_NUM&#39;, self.do_modecrap, &#39;INIT&#39;)</span>
<span class="gi">+</span>
<span class="gi">+#RM   Reset Mode                Esc [ Ps l                   none</span>
<span class="gi">+        self.state.add_transition (&#39;;&#39;, &#39;NUMBER_1&#39;, None, &#39;SEMICOLON&#39;)</span>
<span class="gi">+        self.state.add_transition_any (&#39;SEMICOLON&#39;, DoLog, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition_list (string.digits, &#39;SEMICOLON&#39;, DoStartNumber, &#39;NUMBER_2&#39;)</span>
<span class="gi">+        self.state.add_transition_list (string.digits, &#39;NUMBER_2&#39;, DoBuildNumber, &#39;NUMBER_2&#39;)</span>
<span class="gi">+        self.state.add_transition_any (&#39;NUMBER_2&#39;, DoLog, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;H&#39;, &#39;NUMBER_2&#39;, DoHome, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;f&#39;, &#39;NUMBER_2&#39;, DoHome, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;r&#39;, &#39;NUMBER_2&#39;, DoScrollRegion, &#39;INIT&#39;)</span>
<span class="gi">+        ### It gets worse... the &#39;m&#39; code can have infinite number of</span>
<span class="gi">+        ### number;number;number before it. I&#39;ve never seen more than two,</span>
<span class="gi">+        ### but the specs say it&#39;s allowed. crap!</span>
<span class="gi">+        self.state.add_transition (&#39;m&#39;, &#39;NUMBER_2&#39;, self.do_sgr, &#39;INIT&#39;)</span>
<span class="gi">+        ### LED control. Same problem as &#39;m&#39; code.</span>
<span class="gi">+        self.state.add_transition (&#39;q&#39;, &#39;NUMBER_2&#39;, self.do_decsca, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;;&#39;, &#39;NUMBER_2&#39;, None, &#39;SEMICOLON_X&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Create a state for &#39;q&#39; and &#39;m&#39; which allows an infinite number of ignored numbers</span>
<span class="gi">+        self.state.add_transition_any (&#39;SEMICOLON_X&#39;, DoLog, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition_list (string.digits, &#39;SEMICOLON_X&#39;, DoStartNumber, &#39;NUMBER_X&#39;)</span>
<span class="gi">+        self.state.add_transition_list (string.digits, &#39;NUMBER_X&#39;, DoBuildNumber, &#39;NUMBER_X&#39;)</span>
<span class="gi">+        self.state.add_transition_any (&#39;NUMBER_X&#39;, DoLog, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;m&#39;, &#39;NUMBER_X&#39;, self.do_sgr, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;q&#39;, &#39;NUMBER_X&#39;, self.do_decsca, &#39;INIT&#39;)</span>
<span class="gi">+        self.state.add_transition (&#39;;&#39;, &#39;NUMBER_X&#39;, None, &#39;SEMICOLON_X&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def process (self, c):</span>
<span class="w"> </span>        &quot;&quot;&quot;Process a single character. Called by :meth:`write`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(c, bytes):</span>
<span class="gi">+            c = self._decode(c)</span>
<span class="gi">+        self.state.process(c)</span>
<span class="gi">+</span>
<span class="gi">+    def process_list (self, l):</span>
<span class="gi">+</span>
<span class="gi">+        self.write(l)</span>

<span class="gd">-    def write(self, s):</span>
<span class="gi">+    def write (self, s):</span>
<span class="w"> </span>        &quot;&quot;&quot;Process text, writing it to the virtual screen while handling
<span class="w"> </span>        ANSI escape codes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        if isinstance(s, bytes):</span>
<span class="gi">+            s = self._decode(s)</span>
<span class="gi">+        for c in s:</span>
<span class="gi">+            self.process(c)</span>
<span class="gi">+</span>
<span class="gi">+    def flush (self):</span>
<span class="w"> </span>        pass

<span class="gd">-    def write_ch(self, ch):</span>
<span class="gd">-        &quot;&quot;&quot;This puts a character at the current cursor position. The cursor</span>
<span class="gi">+    def write_ch (self, ch):</span>
<span class="gi">+        &#39;&#39;&#39;This puts a character at the current cursor position. The cursor</span>
<span class="w"> </span>        position is moved forward with wrap-around, but no scrolling is done if
<span class="gd">-        the cursor hits the lower-right corner of the screen. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        the cursor hits the lower-right corner of the screen. &#39;&#39;&#39;</span>

<span class="gd">-    def do_sgr(self, fsm):</span>
<span class="gd">-        &quot;&quot;&quot;Select Graphic Rendition, e.g. color. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(ch, bytes):</span>
<span class="gi">+            ch = self._decode(ch)</span>

<span class="gd">-    def do_decsca(self, fsm):</span>
<span class="gd">-        &quot;&quot;&quot;Select character protection attribute. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        #\r and \n both produce a call to cr() and lf(), respectively.</span>
<span class="gi">+        ch = ch[0]</span>

<span class="gd">-    def do_modecrap(self, fsm):</span>
<span class="gd">-        &quot;&quot;&quot;Handler for [?&lt;number&gt;h and [?&lt;number&gt;l. If anyone</span>
<span class="gi">+        if ch == u&#39;\r&#39;:</span>
<span class="gi">+            self.cr()</span>
<span class="gi">+            return</span>
<span class="gi">+        if ch == u&#39;\n&#39;:</span>
<span class="gi">+            self.crlf()</span>
<span class="gi">+            return</span>
<span class="gi">+        if ch == chr(screen.BS):</span>
<span class="gi">+            self.cursor_back()</span>
<span class="gi">+            return</span>
<span class="gi">+        self.put_abs(self.cur_r, self.cur_c, ch)</span>
<span class="gi">+        old_r = self.cur_r</span>
<span class="gi">+        old_c = self.cur_c</span>
<span class="gi">+        self.cursor_forward()</span>
<span class="gi">+        if old_c == self.cur_c:</span>
<span class="gi">+            self.cursor_down()</span>
<span class="gi">+            if old_r != self.cur_r:</span>
<span class="gi">+                self.cursor_home (self.cur_r, 1)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.scroll_up ()</span>
<span class="gi">+                self.cursor_home (self.cur_r, 1)</span>
<span class="gi">+                self.erase_line()</span>
<span class="gi">+</span>
<span class="gi">+    def do_sgr (self, fsm):</span>
<span class="gi">+        &#39;&#39;&#39;Select Graphic Rendition, e.g. color. &#39;&#39;&#39;</span>
<span class="gi">+        screen = fsm.memory[0]</span>
<span class="gi">+        fsm.memory = [screen]</span>
<span class="gi">+</span>
<span class="gi">+    def do_decsca (self, fsm):</span>
<span class="gi">+        &#39;&#39;&#39;Select character protection attribute. &#39;&#39;&#39;</span>
<span class="gi">+        screen = fsm.memory[0]</span>
<span class="gi">+        fsm.memory = [screen]</span>
<span class="gi">+</span>
<span class="gi">+    def do_modecrap (self, fsm):</span>
<span class="gi">+        &#39;&#39;&#39;Handler for \x1b[?&lt;number&gt;h and \x1b[?&lt;number&gt;l. If anyone</span>
<span class="w"> </span>        wanted to actually use these, they&#39;d need to add more states to the
<span class="gd">-        FSM rather than just improve or override this method. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        FSM rather than just improve or override this method. &#39;&#39;&#39;</span>
<span class="gi">+        screen = fsm.memory[0]</span>
<span class="gi">+        fsm.memory = [screen]</span>
<span class="gh">diff --git a/pexpect/FSM.py b/pexpect/FSM.py</span>
<span class="gh">index 5fc4095..46b392e 100644</span>
<span class="gd">--- a/pexpect/FSM.py</span>
<span class="gi">+++ b/pexpect/FSM.py</span>
<span class="gu">@@ -1,4 +1,6 @@</span>
<span class="gd">-&quot;&quot;&quot;This module implements a Finite State Machine (FSM). In addition to state</span>
<span class="gi">+#!/usr/bin/env python</span>
<span class="gi">+</span>
<span class="gi">+&#39;&#39;&#39;This module implements a Finite State Machine (FSM). In addition to state</span>
<span class="w"> </span>this FSM also maintains a user defined &quot;memory&quot;. So this FSM can be used as a
<span class="w"> </span>Push-down Automata (PDA) since a PDA is a FSM + memory.

<span class="gu">@@ -80,11 +82,11 @@ PEXPECT LICENSE</span>
<span class="w"> </span>    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<span class="w"> </span>    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gi">+&#39;&#39;&#39;</span>

<span class="w"> </span>class ExceptionFSM(Exception):
<span class="gd">-    &quot;&quot;&quot;This is the FSM Exception class.&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    &#39;&#39;&#39;This is the FSM Exception class.&#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, value):
<span class="w"> </span>        self.value = value
<span class="gu">@@ -92,19 +94,24 @@ class ExceptionFSM(Exception):</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return &#39;ExceptionFSM: &#39; + str(self.value)

<span class="gd">-</span>
<span class="w"> </span>class FSM:
<span class="gd">-    &quot;&quot;&quot;This is a Finite State Machine (FSM).</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    &#39;&#39;&#39;This is a Finite State Machine (FSM).</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, initial_state, memory=None):
<span class="gd">-        &quot;&quot;&quot;This creates the FSM. You set the initial state here. The &quot;memory&quot;</span>
<span class="gi">+</span>
<span class="gi">+        &#39;&#39;&#39;This creates the FSM. You set the initial state here. The &quot;memory&quot;</span>
<span class="w"> </span>        attribute is any object that you want to pass along to the action
<span class="w"> </span>        functions. It is not used by the FSM. For parsing you would typically
<span class="gd">-        pass a list to be used as a stack. &quot;&quot;&quot;</span>
<span class="gi">+        pass a list to be used as a stack. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Map (input_symbol, current_state) --&gt; (action, next_state).</span>
<span class="w"> </span>        self.state_transitions = {}
<span class="gi">+        # Map (current_state) --&gt; (action, next_state).</span>
<span class="w"> </span>        self.state_transitions_any = {}
<span class="w"> </span>        self.default_transition = None
<span class="gi">+</span>
<span class="w"> </span>        self.input_symbol = None
<span class="w"> </span>        self.initial_state = initial_state
<span class="w"> </span>        self.current_state = self.initial_state
<span class="gu">@@ -112,15 +119,18 @@ class FSM:</span>
<span class="w"> </span>        self.action = None
<span class="w"> </span>        self.memory = memory

<span class="gd">-    def reset(self):</span>
<span class="gd">-        &quot;&quot;&quot;This sets the current_state to the initial_state and sets</span>
<span class="gi">+    def reset (self):</span>
<span class="gi">+</span>
<span class="gi">+        &#39;&#39;&#39;This sets the current_state to the initial_state and sets</span>
<span class="w"> </span>        input_symbol to None. The initial state was set by the constructor
<span class="gd">-        __init__(). &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        __init__(). &#39;&#39;&#39;</span>

<span class="gd">-    def add_transition(self, input_symbol, state, action=None, next_state=None</span>
<span class="gd">-        ):</span>
<span class="gd">-        &quot;&quot;&quot;This adds a transition that associates:</span>
<span class="gi">+        self.current_state = self.initial_state</span>
<span class="gi">+        self.input_symbol = None</span>
<span class="gi">+</span>
<span class="gi">+    def add_transition (self, input_symbol, state, action=None, next_state=None):</span>
<span class="gi">+</span>
<span class="gi">+        &#39;&#39;&#39;This adds a transition that associates:</span>

<span class="w"> </span>                (input_symbol, current_state) --&gt; (action, next_state)

<span class="gu">@@ -129,23 +139,31 @@ class FSM:</span>
<span class="w"> </span>        set to None in which case the current state will be unchanged.

<span class="w"> </span>        You can also set transitions for a list of symbols by using
<span class="gd">-        add_transition_list(). &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        add_transition_list(). &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if next_state is None:</span>
<span class="gi">+            next_state = state</span>
<span class="gi">+        self.state_transitions[(input_symbol, state)] = (action, next_state)</span>

<span class="gd">-    def add_transition_list(self, list_input_symbols, state, action=None,</span>
<span class="gd">-        next_state=None):</span>
<span class="gd">-        &quot;&quot;&quot;This adds the same transition for a list of input symbols.</span>
<span class="gi">+    def add_transition_list (self, list_input_symbols, state, action=None, next_state=None):</span>
<span class="gi">+</span>
<span class="gi">+        &#39;&#39;&#39;This adds the same transition for a list of input symbols.</span>
<span class="w"> </span>        You can pass a list or a string. Note that it is handy to use
<span class="w"> </span>        string.digits, string.whitespace, string.letters, etc. to add
<span class="w"> </span>        transitions that match character classes.

<span class="w"> </span>        The action may be set to None in which case the process() method will
<span class="w"> </span>        ignore the action and only set the next_state. The next_state may be
<span class="gd">-        set to None in which case the current state will be unchanged. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        set to None in which case the current state will be unchanged. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if next_state is None:</span>
<span class="gi">+            next_state = state</span>
<span class="gi">+        for input_symbol in list_input_symbols:</span>
<span class="gi">+            self.add_transition (input_symbol, state, action, next_state)</span>

<span class="gd">-    def add_transition_any(self, state, action=None, next_state=None):</span>
<span class="gd">-        &quot;&quot;&quot;This adds a transition that associates:</span>
<span class="gi">+    def add_transition_any (self, state, action=None, next_state=None):</span>
<span class="gi">+</span>
<span class="gi">+        &#39;&#39;&#39;This adds a transition that associates:</span>

<span class="w"> </span>                (current_state) --&gt; (action, next_state)

<span class="gu">@@ -155,22 +173,28 @@ class FSM:</span>

<span class="w"> </span>        The action may be set to None in which case the process() method will
<span class="w"> </span>        ignore the action and only set the next_state. The next_state may be
<span class="gd">-        set to None in which case the current state will be unchanged. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        set to None in which case the current state will be unchanged. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if next_state is None:</span>
<span class="gi">+            next_state = state</span>
<span class="gi">+        self.state_transitions_any [state] = (action, next_state)</span>

<span class="gd">-    def set_default_transition(self, action, next_state):</span>
<span class="gd">-        &quot;&quot;&quot;This sets the default transition. This defines an action and</span>
<span class="gi">+    def set_default_transition (self, action, next_state):</span>
<span class="gi">+</span>
<span class="gi">+        &#39;&#39;&#39;This sets the default transition. This defines an action and</span>
<span class="w"> </span>        next_state if the FSM cannot find the input symbol and the current
<span class="w"> </span>        state in the transition list and if the FSM cannot find the
<span class="w"> </span>        current_state in the transition_any list. This is useful as a final
<span class="w"> </span>        fall-through state for catching errors and undefined states.

<span class="w"> </span>        The default transition can be removed by setting the attribute
<span class="gd">-        default_transition to None. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        default_transition to None. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.default_transition = (action, next_state)</span>
<span class="gi">+</span>
<span class="gi">+    def get_transition (self, input_symbol, state):</span>

<span class="gd">-    def get_transition(self, input_symbol, state):</span>
<span class="gd">-        &quot;&quot;&quot;This returns (action, next state) given an input_symbol and state.</span>
<span class="gi">+        &#39;&#39;&#39;This returns (action, next state) given an input_symbol and state.</span>
<span class="w"> </span>        This does not modify the FSM state, so calling this method has no side
<span class="w"> </span>        effects. Normally you do not call this method directly. It is called by
<span class="w"> </span>        process().
<span class="gu">@@ -189,35 +213,121 @@ class FSM:</span>
<span class="w"> </span>            This is a handler for errors, undefined states, or defaults.

<span class="w"> </span>        4. No transition was defined. If we get here then raise an exception.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if (input_symbol, state) in self.state_transitions:</span>
<span class="gi">+            return self.state_transitions[(input_symbol, state)]</span>
<span class="gi">+        elif state in self.state_transitions_any:</span>
<span class="gi">+            return self.state_transitions_any[state]</span>
<span class="gi">+        elif self.default_transition is not None:</span>
<span class="gi">+            return self.default_transition</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ExceptionFSM (&#39;Transition is undefined: (%s, %s).&#39; %</span>
<span class="gi">+                (str(input_symbol), str(state)) )</span>
<span class="gi">+</span>
<span class="gi">+    def process (self, input_symbol):</span>

<span class="gd">-    def process(self, input_symbol):</span>
<span class="gd">-        &quot;&quot;&quot;This is the main method that you call to process input. This may</span>
<span class="gi">+        &#39;&#39;&#39;This is the main method that you call to process input. This may</span>
<span class="w"> </span>        cause the FSM to change state and call an action. This method calls
<span class="w"> </span>        get_transition() to find the action and next_state associated with the
<span class="w"> </span>        input_symbol and current_state. If the action is None then the action
<span class="w"> </span>        is not called and only the current state is changed. This method
<span class="w"> </span>        processes one complete input symbol. You can process a list of symbols
<span class="gd">-        (or a string) by calling process_list(). &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        (or a string) by calling process_list(). &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.input_symbol = input_symbol</span>
<span class="gi">+        (self.action, self.next_state) = self.get_transition (self.input_symbol, self.current_state)</span>
<span class="gi">+        if self.action is not None:</span>
<span class="gi">+            self.action (self)</span>
<span class="gi">+        self.current_state = self.next_state</span>
<span class="gi">+        self.next_state = None</span>
<span class="gi">+</span>
<span class="gi">+    def process_list (self, input_symbols):</span>
<span class="gi">+</span>
<span class="gi">+        &#39;&#39;&#39;This takes a list and sends each element to process(). The list may</span>
<span class="gi">+        be a string or any iterable object. &#39;&#39;&#39;</span>

<span class="gd">-    def process_list(self, input_symbols):</span>
<span class="gd">-        &quot;&quot;&quot;This takes a list and sends each element to process(). The list may</span>
<span class="gd">-        be a string or any iterable object. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        for s in input_symbols:</span>
<span class="gi">+            self.process (s)</span>

<span class="gi">+##############################################################################</span>
<span class="gi">+# The following is an example that demonstrates the use of the FSM class to</span>
<span class="gi">+# process an RPN expression. Run this module from the command line. You will</span>
<span class="gi">+# get a prompt &gt; for input. Enter an RPN Expression. Numbers may be integers.</span>
<span class="gi">+# Operators are * / + - Use the = sign to evaluate and print the expression.</span>
<span class="gi">+# For example:</span>
<span class="gi">+#</span>
<span class="gi">+#    167 3 2 2 * * * 1 - =</span>
<span class="gi">+#</span>
<span class="gi">+# will print:</span>
<span class="gi">+#</span>
<span class="gi">+#    2003</span>
<span class="gi">+##############################################################################</span>

<span class="w"> </span>import sys
<span class="w"> </span>import string
<span class="gd">-PY3 = sys.version_info[0] &gt;= 3</span>

<span class="gi">+PY3 = (sys.version_info[0] &gt;= 3)</span>
<span class="gi">+</span>
<span class="gi">+#</span>
<span class="gi">+# These define the actions.</span>
<span class="gi">+# Note that &quot;memory&quot; is a list being used as a stack.</span>
<span class="gi">+#</span>
<span class="gi">+</span>
<span class="gi">+def BeginBuildNumber (fsm):</span>
<span class="gi">+    fsm.memory.append (fsm.input_symbol)</span>
<span class="gi">+</span>
<span class="gi">+def BuildNumber (fsm):</span>
<span class="gi">+    s = fsm.memory.pop ()</span>
<span class="gi">+    s = s + fsm.input_symbol</span>
<span class="gi">+    fsm.memory.append (s)</span>
<span class="gi">+</span>
<span class="gi">+def EndBuildNumber (fsm):</span>
<span class="gi">+    s = fsm.memory.pop ()</span>
<span class="gi">+    fsm.memory.append (int(s))</span>
<span class="gi">+</span>
<span class="gi">+def DoOperator (fsm):</span>
<span class="gi">+    ar = fsm.memory.pop()</span>
<span class="gi">+    al = fsm.memory.pop()</span>
<span class="gi">+    if fsm.input_symbol == &#39;+&#39;:</span>
<span class="gi">+        fsm.memory.append (al + ar)</span>
<span class="gi">+    elif fsm.input_symbol == &#39;-&#39;:</span>
<span class="gi">+        fsm.memory.append (al - ar)</span>
<span class="gi">+    elif fsm.input_symbol == &#39;*&#39;:</span>
<span class="gi">+        fsm.memory.append (al * ar)</span>
<span class="gi">+    elif fsm.input_symbol == &#39;/&#39;:</span>
<span class="gi">+        fsm.memory.append (al / ar)</span>
<span class="gi">+</span>
<span class="gi">+def DoEqual (fsm):</span>
<span class="gi">+    print(str(fsm.memory.pop()))</span>
<span class="gi">+</span>
<span class="gi">+def Error (fsm):</span>
<span class="gi">+    print(&#39;That does not compute.&#39;)</span>
<span class="gi">+    print(str(fsm.input_symbol))</span>

<span class="w"> </span>def main():
<span class="gd">-    &quot;&quot;&quot;This is where the example starts and the FSM state transitions are</span>
<span class="gi">+</span>
<span class="gi">+    &#39;&#39;&#39;This is where the example starts and the FSM state transitions are</span>
<span class="w"> </span>    defined. Note that states are strings (such as &#39;INIT&#39;). This is not
<span class="gd">-    necessary, but it makes the example easier to read. &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    necessary, but it makes the example easier to read. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    f = FSM (&#39;INIT&#39;, [])</span>
<span class="gi">+    f.set_default_transition (Error, &#39;INIT&#39;)</span>
<span class="gi">+    f.add_transition_any  (&#39;INIT&#39;, None, &#39;INIT&#39;)</span>
<span class="gi">+    f.add_transition      (&#39;=&#39;,               &#39;INIT&#39;,            DoEqual,          &#39;INIT&#39;)</span>
<span class="gi">+    f.add_transition_list (string.digits,     &#39;INIT&#39;,            BeginBuildNumber, &#39;BUILDING_NUMBER&#39;)</span>
<span class="gi">+    f.add_transition_list (string.digits,     &#39;BUILDING_NUMBER&#39;, BuildNumber,      &#39;BUILDING_NUMBER&#39;)</span>
<span class="gi">+    f.add_transition_list (string.whitespace, &#39;BUILDING_NUMBER&#39;, EndBuildNumber,   &#39;INIT&#39;)</span>
<span class="gi">+    f.add_transition_list (&#39;+-*/&#39;,            &#39;INIT&#39;,            DoOperator,       &#39;INIT&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    print()</span>
<span class="gi">+    print(&#39;Enter an RPN Expression.&#39;)</span>
<span class="gi">+    print(&#39;Numbers may be integers. Operators are * / + -&#39;)</span>
<span class="gi">+    print(&#39;Use the = sign to evaluate and print the expression.&#39;)</span>
<span class="gi">+    print(&#39;For example: &#39;)</span>
<span class="gi">+    print(&#39;    167 3 2 2 * * * 1 - =&#39;)</span>
<span class="gi">+    inputstr = (input if PY3 else raw_input)(&#39;&gt; &#39;)  # analysis:ignore</span>
<span class="gi">+    f.process_list(inputstr)</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/pexpect/_async.py b/pexpect/_async.py</span>
<span class="gh">index 41e86a0..261720c 100644</span>
<span class="gd">--- a/pexpect/_async.py</span>
<span class="gi">+++ b/pexpect/_async.py</span>
<span class="gu">@@ -9,8 +9,20 @@ For Python versions later than 3.6, coroutines and objects that are defined via</span>

<span class="w"> </span>Here the code is just imported, to provide the same interface to older code.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+# pylint: disable=unused-import</span>
<span class="gi">+# flake8: noqa: F401</span>
<span class="w"> </span>from sys import version_info as py_version_info
<span class="gi">+</span>
<span class="gi">+# this assumes async def/await are more stable</span>
<span class="w"> </span>if py_version_info &gt;= (3, 6):
<span class="gd">-    from pexpect._async_w_await import PatternWaiter, expect_async, repl_run_command_async</span>
<span class="gi">+    from pexpect._async_w_await import (</span>
<span class="gi">+        PatternWaiter,</span>
<span class="gi">+        expect_async,</span>
<span class="gi">+        repl_run_command_async,</span>
<span class="gi">+    )</span>
<span class="w"> </span>else:
<span class="gd">-    from pexpect._async_pre_await import PatternWaiter, expect_async, repl_run_command_async</span>
<span class="gi">+    from pexpect._async_pre_await import (</span>
<span class="gi">+        PatternWaiter,</span>
<span class="gi">+        expect_async,</span>
<span class="gi">+        repl_run_command_async,</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pexpect/_async_pre_await.py b/pexpect/_async_pre_await.py</span>
<span class="gh">index 17921cf..81ece1b 100644</span>
<span class="gd">--- a/pexpect/_async_pre_await.py</span>
<span class="gi">+++ b/pexpect/_async_pre_await.py</span>
<span class="gu">@@ -5,8 +5,107 @@</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import errno
<span class="w"> </span>import signal
<span class="gi">+</span>
<span class="w"> </span>from pexpect import EOF


<span class="gi">+@asyncio.coroutine</span>
<span class="gi">+def expect_async(expecter, timeout=None):</span>
<span class="gi">+    # First process data that was previously read - if it maches, we don&#39;t need</span>
<span class="gi">+    # async stuff.</span>
<span class="gi">+    idx = expecter.existing_data()</span>
<span class="gi">+    if idx is not None:</span>
<span class="gi">+        return idx</span>
<span class="gi">+    if not expecter.spawn.async_pw_transport:</span>
<span class="gi">+        pw = PatternWaiter()</span>
<span class="gi">+        pw.set_expecter(expecter)</span>
<span class="gi">+        transport, pw = yield from asyncio.get_event_loop().connect_read_pipe(</span>
<span class="gi">+            lambda: pw, expecter.spawn</span>
<span class="gi">+        )</span>
<span class="gi">+        expecter.spawn.async_pw_transport = pw, transport</span>
<span class="gi">+    else:</span>
<span class="gi">+        pw, transport = expecter.spawn.async_pw_transport</span>
<span class="gi">+        pw.set_expecter(expecter)</span>
<span class="gi">+        transport.resume_reading()</span>
<span class="gi">+    try:</span>
<span class="gi">+        return (yield from asyncio.wait_for(pw.fut, timeout))</span>
<span class="gi">+    except asyncio.TimeoutError as e:</span>
<span class="gi">+        transport.pause_reading()</span>
<span class="gi">+        return expecter.timeout(e)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@asyncio.coroutine</span>
<span class="gi">+def repl_run_command_async(repl, cmdlines, timeout=-1):</span>
<span class="gi">+    res = []</span>
<span class="gi">+    repl.child.sendline(cmdlines[0])</span>
<span class="gi">+    for line in cmdlines[1:]:</span>
<span class="gi">+        yield from repl._expect_prompt(timeout=timeout, async_=True)</span>
<span class="gi">+        res.append(repl.child.before)</span>
<span class="gi">+        repl.child.sendline(line)</span>
<span class="gi">+</span>
<span class="gi">+    # Command was fully submitted, now wait for the next prompt</span>
<span class="gi">+    prompt_idx = yield from repl._expect_prompt(timeout=timeout, async_=True)</span>
<span class="gi">+    if prompt_idx == 1:</span>
<span class="gi">+        # We got the continuation prompt - command was incomplete</span>
<span class="gi">+        repl.child.kill(signal.SIGINT)</span>
<span class="gi">+        yield from repl._expect_prompt(timeout=1, async_=True)</span>
<span class="gi">+        raise ValueError(&quot;Continuation prompt found - input was incomplete:&quot;)</span>
<span class="gi">+    return &quot;&quot;.join(res + [repl.child.before])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class PatternWaiter(asyncio.Protocol):
<span class="w"> </span>    transport = None
<span class="gi">+</span>
<span class="gi">+    def set_expecter(self, expecter):</span>
<span class="gi">+        self.expecter = expecter</span>
<span class="gi">+        self.fut = asyncio.Future()</span>
<span class="gi">+</span>
<span class="gi">+    def found(self, result):</span>
<span class="gi">+        if not self.fut.done():</span>
<span class="gi">+            self.fut.set_result(result)</span>
<span class="gi">+            self.transport.pause_reading()</span>
<span class="gi">+</span>
<span class="gi">+    def error(self, exc):</span>
<span class="gi">+        if not self.fut.done():</span>
<span class="gi">+            self.fut.set_exception(exc)</span>
<span class="gi">+            self.transport.pause_reading()</span>
<span class="gi">+</span>
<span class="gi">+    def connection_made(self, transport):</span>
<span class="gi">+        self.transport = transport</span>
<span class="gi">+</span>
<span class="gi">+    def data_received(self, data):</span>
<span class="gi">+        spawn = self.expecter.spawn</span>
<span class="gi">+        s = spawn._decoder.decode(data)</span>
<span class="gi">+        spawn._log(s, &quot;read&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.fut.done():</span>
<span class="gi">+            spawn._before.write(s)</span>
<span class="gi">+            spawn._buffer.write(s)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            index = self.expecter.new_data(s)</span>
<span class="gi">+            if index is not None:</span>
<span class="gi">+                # Found a match</span>
<span class="gi">+                self.found(index)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            self.expecter.errored()</span>
<span class="gi">+            self.error(e)</span>
<span class="gi">+</span>
<span class="gi">+    def eof_received(self):</span>
<span class="gi">+        # N.B. If this gets called, async will close the pipe (the spawn object)</span>
<span class="gi">+        # for us</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.expecter.spawn.flag_eof = True</span>
<span class="gi">+            index = self.expecter.eof()</span>
<span class="gi">+        except EOF as e:</span>
<span class="gi">+            self.error(e)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.found(index)</span>
<span class="gi">+</span>
<span class="gi">+    def connection_lost(self, exc):</span>
<span class="gi">+        if isinstance(exc, OSError) and exc.errno == errno.EIO:</span>
<span class="gi">+            # We may get here without eof_received being called, e.g on Linux</span>
<span class="gi">+            self.eof_received()</span>
<span class="gi">+        elif exc is not None:</span>
<span class="gi">+            self.error(exc)</span>
<span class="gh">diff --git a/pexpect/_async_w_await.py b/pexpect/_async_w_await.py</span>
<span class="gh">index fda878f..59cb1ef 100644</span>
<span class="gd">--- a/pexpect/_async_w_await.py</span>
<span class="gi">+++ b/pexpect/_async_w_await.py</span>
<span class="gu">@@ -7,12 +7,112 @@ import asyncio</span>
<span class="w"> </span>import errno
<span class="w"> </span>import signal
<span class="w"> </span>from sys import version_info as py_version_info
<span class="gi">+</span>
<span class="w"> </span>from pexpect import EOF
<span class="gi">+</span>
<span class="w"> </span>if py_version_info &gt;= (3, 7):
<span class="gi">+    # get_running_loop, new in 3.7, is preferred to get_event_loop</span>
<span class="w"> </span>    _loop_getter = asyncio.get_running_loop
<span class="w"> </span>else:
<span class="gi">+    # Deprecation warning since 3.10</span>
<span class="w"> </span>    _loop_getter = asyncio.get_event_loop


<span class="gi">+async def expect_async(expecter, timeout=None):</span>
<span class="gi">+    # First process data that was previously read - if it maches, we don&#39;t need</span>
<span class="gi">+    # async stuff.</span>
<span class="gi">+    idx = expecter.existing_data()</span>
<span class="gi">+    if idx is not None:</span>
<span class="gi">+        return idx</span>
<span class="gi">+    if not expecter.spawn.async_pw_transport:</span>
<span class="gi">+        pattern_waiter = PatternWaiter()</span>
<span class="gi">+        pattern_waiter.set_expecter(expecter)</span>
<span class="gi">+        transport, pattern_waiter = await _loop_getter().connect_read_pipe(</span>
<span class="gi">+            lambda: pattern_waiter, expecter.spawn</span>
<span class="gi">+        )</span>
<span class="gi">+        expecter.spawn.async_pw_transport = pattern_waiter, transport</span>
<span class="gi">+    else:</span>
<span class="gi">+        pattern_waiter, transport = expecter.spawn.async_pw_transport</span>
<span class="gi">+        pattern_waiter.set_expecter(expecter)</span>
<span class="gi">+        transport.resume_reading()</span>
<span class="gi">+    try:</span>
<span class="gi">+        return await asyncio.wait_for(pattern_waiter.fut, timeout)</span>
<span class="gi">+    except asyncio.TimeoutError as exc:</span>
<span class="gi">+        transport.pause_reading()</span>
<span class="gi">+        return expecter.timeout(exc)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def repl_run_command_async(repl, cmdlines, timeout=-1):</span>
<span class="gi">+    res = []</span>
<span class="gi">+    repl.child.sendline(cmdlines[0])</span>
<span class="gi">+    for line in cmdlines[1:]:</span>
<span class="gi">+        await repl._expect_prompt(timeout=timeout, async_=True)</span>
<span class="gi">+        res.append(repl.child.before)</span>
<span class="gi">+        repl.child.sendline(line)</span>
<span class="gi">+</span>
<span class="gi">+    # Command was fully submitted, now wait for the next prompt</span>
<span class="gi">+    prompt_idx = await repl._expect_prompt(timeout=timeout, async_=True)</span>
<span class="gi">+    if prompt_idx == 1:</span>
<span class="gi">+        # We got the continuation prompt - command was incomplete</span>
<span class="gi">+        repl.child.kill(signal.SIGINT)</span>
<span class="gi">+        await repl._expect_prompt(timeout=1, async_=True)</span>
<span class="gi">+        raise ValueError(&quot;Continuation prompt found - input was incomplete:&quot;)</span>
<span class="gi">+    return &quot;&quot;.join(res + [repl.child.before])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class PatternWaiter(asyncio.Protocol):
<span class="w"> </span>    transport = None
<span class="gi">+</span>
<span class="gi">+    def set_expecter(self, expecter):</span>
<span class="gi">+        self.expecter = expecter</span>
<span class="gi">+        self.fut = asyncio.Future()</span>
<span class="gi">+</span>
<span class="gi">+    def found(self, result):</span>
<span class="gi">+        if not self.fut.done():</span>
<span class="gi">+            self.fut.set_result(result)</span>
<span class="gi">+            self.transport.pause_reading()</span>
<span class="gi">+</span>
<span class="gi">+    def error(self, exc):</span>
<span class="gi">+        if not self.fut.done():</span>
<span class="gi">+            self.fut.set_exception(exc)</span>
<span class="gi">+            self.transport.pause_reading()</span>
<span class="gi">+</span>
<span class="gi">+    def connection_made(self, transport):</span>
<span class="gi">+        self.transport = transport</span>
<span class="gi">+</span>
<span class="gi">+    def data_received(self, data):</span>
<span class="gi">+        spawn = self.expecter.spawn</span>
<span class="gi">+        s = spawn._decoder.decode(data)</span>
<span class="gi">+        spawn._log(s, &quot;read&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.fut.done():</span>
<span class="gi">+            spawn._before.write(s)</span>
<span class="gi">+            spawn._buffer.write(s)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            index = self.expecter.new_data(s)</span>
<span class="gi">+            if index is not None:</span>
<span class="gi">+                # Found a match</span>
<span class="gi">+                self.found(index)</span>
<span class="gi">+        except Exception as exc:</span>
<span class="gi">+            self.expecter.errored()</span>
<span class="gi">+            self.error(exc)</span>
<span class="gi">+</span>
<span class="gi">+    def eof_received(self):</span>
<span class="gi">+        # N.B. If this gets called, async will close the pipe (the spawn object)</span>
<span class="gi">+        # for us</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.expecter.spawn.flag_eof = True</span>
<span class="gi">+            index = self.expecter.eof()</span>
<span class="gi">+        except EOF as exc:</span>
<span class="gi">+            self.error(exc)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.found(index)</span>
<span class="gi">+</span>
<span class="gi">+    def connection_lost(self, exc):</span>
<span class="gi">+        if isinstance(exc, OSError) and exc.errno == errno.EIO:</span>
<span class="gi">+            # We may get here without eof_received being called, e.g on Linux</span>
<span class="gi">+            self.eof_received()</span>
<span class="gi">+        elif exc is not None:</span>
<span class="gi">+            self.error(exc)</span>
<span class="gh">diff --git a/pexpect/exceptions.py b/pexpect/exceptions.py</span>
<span class="gh">index c66fe77..cb360f0 100644</span>
<span class="gd">--- a/pexpect/exceptions.py</span>
<span class="gi">+++ b/pexpect/exceptions.py</span>
<span class="gu">@@ -1,11 +1,11 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Exception classes used by Pexpect&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import traceback
<span class="w"> </span>import sys

<span class="gd">-</span>
<span class="w"> </span>class ExceptionPexpect(Exception):
<span class="gd">-    &quot;&quot;&quot;Base class for all exceptions raised by this module.</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Base class for all exceptions raised by this module.</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, value):
<span class="w"> </span>        super(ExceptionPexpect, self).__init__(value)
<span class="gu">@@ -15,16 +15,21 @@ class ExceptionPexpect(Exception):</span>
<span class="w"> </span>        return str(self.value)

<span class="w"> </span>    def get_trace(self):
<span class="gd">-        &quot;&quot;&quot;This returns an abbreviated stack trace with lines that only concern</span>
<span class="gi">+        &#39;&#39;&#39;This returns an abbreviated stack trace with lines that only concern</span>
<span class="w"> </span>        the caller. In other words, the stack trace inside the Pexpect module
<span class="gd">-        is not included. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        is not included. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        tblist = traceback.extract_tb(sys.exc_info()[2])</span>
<span class="gi">+        tblist = [item for item in tblist if (&#39;pexpect/__init__&#39; not in item[0])</span>
<span class="gi">+                                           and (&#39;pexpect/expect&#39; not in item[0])]</span>
<span class="gi">+        tblist = traceback.format_list(tblist)</span>
<span class="gi">+        return &#39;&#39;.join(tblist)</span>


<span class="w"> </span>class EOF(ExceptionPexpect):
<span class="gd">-    &quot;&quot;&quot;Raised when EOF is read from a child.</span>
<span class="gd">-    This usually means the child has exited.&quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Raised when EOF is read from a child.</span>
<span class="gi">+    This usually means the child has exited.&#39;&#39;&#39;</span>


<span class="w"> </span>class TIMEOUT(ExceptionPexpect):
<span class="gd">-    &quot;&quot;&quot;Raised when a read time exceeds the timeout. &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;Raised when a read time exceeds the timeout. &#39;&#39;&#39;</span>
<span class="gh">diff --git a/pexpect/expect.py b/pexpect/expect.py</span>
<span class="gh">index dabbe22..d3409db 100644</span>
<span class="gd">--- a/pexpect/expect.py</span>
<span class="gi">+++ b/pexpect/expect.py</span>
<span class="gu">@@ -1,12 +1,13 @@</span>
<span class="w"> </span>import time
<span class="gd">-from .exceptions import EOF, TIMEOUT</span>

<span class="gi">+from .exceptions import EOF, TIMEOUT</span>

<span class="w"> </span>class Expecter(object):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, spawn, searcher, searchwindowsize=-1):
<span class="w"> </span>        self.spawn = spawn
<span class="w"> </span>        self.searcher = searcher
<span class="gi">+        # A value of -1 means to use the figure from spawn, which should</span>
<span class="gi">+        # be None or a positive number.</span>
<span class="w"> </span>        if searchwindowsize == -1:
<span class="w"> </span>            searchwindowsize = spawn.searchwindowsize
<span class="w"> </span>        self.searchwindowsize = searchwindowsize
<span class="gu">@@ -14,13 +15,177 @@ class Expecter(object):</span>
<span class="w"> </span>        if hasattr(searcher, &#39;longest_string&#39;):
<span class="w"> </span>            self.lookback = searcher.longest_string

<span class="gi">+    def do_search(self, window, freshlen):</span>
<span class="gi">+        spawn = self.spawn</span>
<span class="gi">+        searcher = self.searcher</span>
<span class="gi">+        if freshlen &gt; len(window):</span>
<span class="gi">+            freshlen = len(window)</span>
<span class="gi">+        index = searcher.search(window, freshlen, self.searchwindowsize)</span>
<span class="gi">+        if index &gt;= 0:</span>
<span class="gi">+            spawn._buffer = spawn.buffer_type()</span>
<span class="gi">+            spawn._buffer.write(window[searcher.end:])</span>
<span class="gi">+            spawn.before = spawn._before.getvalue()[</span>
<span class="gi">+                0:-(len(window) - searcher.start)]</span>
<span class="gi">+            spawn._before = spawn.buffer_type()</span>
<span class="gi">+            spawn._before.write(window[searcher.end:])</span>
<span class="gi">+            spawn.after = window[searcher.start:searcher.end]</span>
<span class="gi">+            spawn.match = searcher.match</span>
<span class="gi">+            spawn.match_index = index</span>
<span class="gi">+            # Found a match</span>
<span class="gi">+            return index</span>
<span class="gi">+        elif self.searchwindowsize or self.lookback:</span>
<span class="gi">+            maintain = self.searchwindowsize or self.lookback</span>
<span class="gi">+            if spawn._buffer.tell() &gt; maintain:</span>
<span class="gi">+                spawn._buffer = spawn.buffer_type()</span>
<span class="gi">+                spawn._buffer.write(window[-maintain:])</span>
<span class="gi">+</span>
<span class="gi">+    def existing_data(self):</span>
<span class="gi">+        # First call from a new call to expect_loop or expect_async.</span>
<span class="gi">+        # self.searchwindowsize may have changed.</span>
<span class="gi">+        # Treat all data as fresh.</span>
<span class="gi">+        spawn = self.spawn</span>
<span class="gi">+        before_len = spawn._before.tell()</span>
<span class="gi">+        buf_len = spawn._buffer.tell()</span>
<span class="gi">+        freshlen = before_len</span>
<span class="gi">+        if before_len &gt; buf_len:</span>
<span class="gi">+            if not self.searchwindowsize:</span>
<span class="gi">+                spawn._buffer = spawn.buffer_type()</span>
<span class="gi">+                window = spawn._before.getvalue()</span>
<span class="gi">+                spawn._buffer.write(window)</span>
<span class="gi">+            elif buf_len &lt; self.searchwindowsize:</span>
<span class="gi">+                spawn._buffer = spawn.buffer_type()</span>
<span class="gi">+                spawn._before.seek(</span>
<span class="gi">+                    max(0, before_len - self.searchwindowsize))</span>
<span class="gi">+                window = spawn._before.read()</span>
<span class="gi">+                spawn._buffer.write(window)</span>
<span class="gi">+            else:</span>
<span class="gi">+                spawn._buffer.seek(max(0, buf_len - self.searchwindowsize))</span>
<span class="gi">+                window = spawn._buffer.read()</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.searchwindowsize:</span>
<span class="gi">+                spawn._buffer.seek(max(0, buf_len - self.searchwindowsize))</span>
<span class="gi">+                window = spawn._buffer.read()</span>
<span class="gi">+            else:</span>
<span class="gi">+                window = spawn._buffer.getvalue()</span>
<span class="gi">+        return self.do_search(window, freshlen)</span>
<span class="gi">+</span>
<span class="gi">+    def new_data(self, data):</span>
<span class="gi">+        # A subsequent call, after a call to existing_data.</span>
<span class="gi">+        spawn = self.spawn</span>
<span class="gi">+        freshlen = len(data)</span>
<span class="gi">+        spawn._before.write(data)</span>
<span class="gi">+        if not self.searchwindowsize:</span>
<span class="gi">+            if self.lookback:</span>
<span class="gi">+                # search lookback + new data.</span>
<span class="gi">+                old_len = spawn._buffer.tell()</span>
<span class="gi">+                spawn._buffer.write(data)</span>
<span class="gi">+                spawn._buffer.seek(max(0, old_len - self.lookback))</span>
<span class="gi">+                window = spawn._buffer.read()</span>
<span class="gi">+            else:</span>
<span class="gi">+                # copy the whole buffer (really slow for large datasets).</span>
<span class="gi">+                spawn._buffer.write(data)</span>
<span class="gi">+                window = spawn.buffer</span>
<span class="gi">+        else:</span>
<span class="gi">+            if len(data) &gt;= self.searchwindowsize or not spawn._buffer.tell():</span>
<span class="gi">+                window = data[-self.searchwindowsize:]</span>
<span class="gi">+                spawn._buffer = spawn.buffer_type()</span>
<span class="gi">+                spawn._buffer.write(window[-self.searchwindowsize:])</span>
<span class="gi">+            else:</span>
<span class="gi">+                spawn._buffer.write(data)</span>
<span class="gi">+                new_len = spawn._buffer.tell()</span>
<span class="gi">+                spawn._buffer.seek(max(0, new_len - self.searchwindowsize))</span>
<span class="gi">+                window = spawn._buffer.read()</span>
<span class="gi">+        return self.do_search(window, freshlen)</span>
<span class="gi">+</span>
<span class="gi">+    def eof(self, err=None):</span>
<span class="gi">+        spawn = self.spawn</span>
<span class="gi">+</span>
<span class="gi">+        spawn.before = spawn._before.getvalue()</span>
<span class="gi">+        spawn._buffer = spawn.buffer_type()</span>
<span class="gi">+        spawn._before = spawn.buffer_type()</span>
<span class="gi">+        spawn.after = EOF</span>
<span class="gi">+        index = self.searcher.eof_index</span>
<span class="gi">+        if index &gt;= 0:</span>
<span class="gi">+            spawn.match = EOF</span>
<span class="gi">+            spawn.match_index = index</span>
<span class="gi">+            return index</span>
<span class="gi">+        else:</span>
<span class="gi">+            spawn.match = None</span>
<span class="gi">+            spawn.match_index = None</span>
<span class="gi">+            msg = str(spawn)</span>
<span class="gi">+            msg += &#39;\nsearcher: %s&#39; % self.searcher</span>
<span class="gi">+            if err is not None:</span>
<span class="gi">+                msg = str(err) + &#39;\n&#39; + msg</span>
<span class="gi">+</span>
<span class="gi">+            exc = EOF(msg)</span>
<span class="gi">+            exc.__cause__ = None # in Python 3.x we can use &quot;raise exc from None&quot;</span>
<span class="gi">+            raise exc</span>
<span class="gi">+</span>
<span class="gi">+    def timeout(self, err=None):</span>
<span class="gi">+        spawn = self.spawn</span>
<span class="gi">+</span>
<span class="gi">+        spawn.before = spawn._before.getvalue()</span>
<span class="gi">+        spawn.after = TIMEOUT</span>
<span class="gi">+        index = self.searcher.timeout_index</span>
<span class="gi">+        if index &gt;= 0:</span>
<span class="gi">+            spawn.match = TIMEOUT</span>
<span class="gi">+            spawn.match_index = index</span>
<span class="gi">+            return index</span>
<span class="gi">+        else:</span>
<span class="gi">+            spawn.match = None</span>
<span class="gi">+            spawn.match_index = None</span>
<span class="gi">+            msg = str(spawn)</span>
<span class="gi">+            msg += &#39;\nsearcher: %s&#39; % self.searcher</span>
<span class="gi">+            if err is not None:</span>
<span class="gi">+                msg = str(err) + &#39;\n&#39; + msg</span>
<span class="gi">+</span>
<span class="gi">+            exc = TIMEOUT(msg)</span>
<span class="gi">+            exc.__cause__ = None    # in Python 3.x we can use &quot;raise exc from None&quot;</span>
<span class="gi">+            raise exc</span>
<span class="gi">+</span>
<span class="gi">+    def errored(self):</span>
<span class="gi">+        spawn = self.spawn</span>
<span class="gi">+        spawn.before = spawn._before.getvalue()</span>
<span class="gi">+        spawn.after = None</span>
<span class="gi">+        spawn.match = None</span>
<span class="gi">+        spawn.match_index = None</span>
<span class="gi">+</span>
<span class="w"> </span>    def expect_loop(self, timeout=-1):
<span class="w"> </span>        &quot;&quot;&quot;Blocking expect&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        spawn = self.spawn</span>
<span class="gi">+</span>
<span class="gi">+        if timeout is not None:</span>
<span class="gi">+            end_time = time.time() + timeout</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            idx = self.existing_data()</span>
<span class="gi">+            if idx is not None:</span>
<span class="gi">+                return idx</span>
<span class="gi">+            while True:</span>
<span class="gi">+                # No match at this point</span>
<span class="gi">+                if (timeout is not None) and (timeout &lt; 0):</span>
<span class="gi">+                    return self.timeout()</span>
<span class="gi">+                # Still have time left, so read more data</span>
<span class="gi">+                incoming = spawn.read_nonblocking(spawn.maxread, timeout)</span>
<span class="gi">+                if self.spawn.delayafterread is not None:</span>
<span class="gi">+                    time.sleep(self.spawn.delayafterread)</span>
<span class="gi">+                idx = self.new_data(incoming)</span>
<span class="gi">+                # Keep reading until exception or return.</span>
<span class="gi">+                if idx is not None:</span>
<span class="gi">+                    return idx</span>
<span class="gi">+                if timeout is not None:</span>
<span class="gi">+                    timeout = end_time - time.time()</span>
<span class="gi">+        except EOF as e:</span>
<span class="gi">+            return self.eof(e)</span>
<span class="gi">+        except TIMEOUT as e:</span>
<span class="gi">+            return self.timeout(e)</span>
<span class="gi">+        except:</span>
<span class="gi">+            self.errored()</span>
<span class="gi">+            raise</span>


<span class="w"> </span>class searcher_string(object):
<span class="gd">-    &quot;&quot;&quot;This is a plain string search helper for the spawn.expect_any() method.</span>
<span class="gi">+    &#39;&#39;&#39;This is a plain string search helper for the spawn.expect_any() method.</span>
<span class="w"> </span>    This helper class is for speed. For more powerful regex patterns
<span class="w"> </span>    see the helper class, searcher_re.

<span class="gu">@@ -36,11 +201,12 @@ class searcher_string(object):</span>
<span class="w"> </span>        end   - index into the buffer, first byte after match
<span class="w"> </span>        match - the matching string itself

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, strings):
<span class="gd">-        &quot;&quot;&quot;This creates an instance of searcher_string. This argument &#39;strings&#39;</span>
<span class="gd">-        may be a list; a sequence of strings; or the EOF or TIMEOUT types. &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;This creates an instance of searcher_string. This argument &#39;strings&#39;</span>
<span class="gi">+        may be a list; a sequence of strings; or the EOF or TIMEOUT types. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>        self.eof_index = -1
<span class="w"> </span>        self.timeout_index = -1
<span class="w"> </span>        self._strings = []
<span class="gu">@@ -57,21 +223,22 @@ class searcher_string(object):</span>
<span class="w"> </span>                self.longest_string = len(s)

<span class="w"> </span>    def __str__(self):
<span class="gd">-        &quot;&quot;&quot;This returns a human-readable string that represents the state of</span>
<span class="gd">-        the object.&quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;This returns a human-readable string that represents the state of</span>
<span class="gi">+        the object.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>        ss = [(ns[0], &#39;    %d: %r&#39; % ns) for ns in self._strings]
<span class="w"> </span>        ss.append((-1, &#39;searcher_string:&#39;))
<span class="w"> </span>        if self.eof_index &gt;= 0:
<span class="w"> </span>            ss.append((self.eof_index, &#39;    %d: EOF&#39; % self.eof_index))
<span class="w"> </span>        if self.timeout_index &gt;= 0:
<span class="gd">-            ss.append((self.timeout_index, &#39;    %d: TIMEOUT&#39; % self.</span>
<span class="gd">-                timeout_index))</span>
<span class="gi">+            ss.append((self.timeout_index,</span>
<span class="gi">+                &#39;    %d: TIMEOUT&#39; % self.timeout_index))</span>
<span class="w"> </span>        ss.sort()
<span class="w"> </span>        ss = list(zip(*ss))[1]
<span class="w"> </span>        return &#39;\n&#39;.join(ss)

<span class="w"> </span>    def search(self, buffer, freshlen, searchwindowsize=None):
<span class="gd">-        &quot;&quot;&quot;This searches &#39;buffer&#39; for the first occurrence of one of the search</span>
<span class="gi">+        &#39;&#39;&#39;This searches &#39;buffer&#39; for the first occurrence of one of the search</span>
<span class="w"> </span>        strings.  &#39;freshlen&#39; must indicate the number of bytes at the end of
<span class="w"> </span>        &#39;buffer&#39; which have not been searched before. It helps to avoid
<span class="w"> </span>        searching the same, possibly big, buffer over and over again.
<span class="gu">@@ -79,12 +246,44 @@ class searcher_string(object):</span>
<span class="w"> </span>        See class spawn for the &#39;searchwindowsize&#39; argument.

<span class="w"> </span>        If there is a match this returns the index of that string, and sets
<span class="gd">-        &#39;start&#39;, &#39;end&#39; and &#39;match&#39;. Otherwise, this returns -1. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;start&#39;, &#39;end&#39; and &#39;match&#39;. Otherwise, this returns -1. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        first_match = None</span>
<span class="gi">+</span>
<span class="gi">+        # &#39;freshlen&#39; helps a lot here. Further optimizations could</span>
<span class="gi">+        # possibly include:</span>
<span class="gi">+        #</span>
<span class="gi">+        # using something like the Boyer-Moore Fast String Searching</span>
<span class="gi">+        # Algorithm; pre-compiling the search through a list of</span>
<span class="gi">+        # strings into something that can scan the input once to</span>
<span class="gi">+        # search for all N strings; realize that if we search for</span>
<span class="gi">+        # [&#39;bar&#39;, &#39;baz&#39;] and the input is &#39;...foo&#39; we need not bother</span>
<span class="gi">+        # rescanning until we&#39;ve read three more bytes.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Sadly, I don&#39;t know enough about this interesting topic. /grahn</span>
<span class="gi">+</span>
<span class="gi">+        for index, s in self._strings:</span>
<span class="gi">+            if searchwindowsize is None:</span>
<span class="gi">+                # the match, if any, can only be in the fresh data,</span>
<span class="gi">+                # or at the very end of the old data</span>
<span class="gi">+                offset = -(freshlen + len(s))</span>
<span class="gi">+            else:</span>
<span class="gi">+                # better obey searchwindowsize</span>
<span class="gi">+                offset = -searchwindowsize</span>
<span class="gi">+            n = buffer.find(s, offset)</span>
<span class="gi">+            if n &gt;= 0 and (first_match is None or n &lt; first_match):</span>
<span class="gi">+                first_match = n</span>
<span class="gi">+                best_index, best_match = index, s</span>
<span class="gi">+        if first_match is None:</span>
<span class="gi">+            return -1</span>
<span class="gi">+        self.match = best_match</span>
<span class="gi">+        self.start = first_match</span>
<span class="gi">+        self.end = self.start + len(self.match)</span>
<span class="gi">+        return best_index</span>


<span class="w"> </span>class searcher_re(object):
<span class="gd">-    &quot;&quot;&quot;This is regular expression string search helper for the</span>
<span class="gi">+    &#39;&#39;&#39;This is regular expression string search helper for the</span>
<span class="w"> </span>    spawn.expect_any() method. This helper class is for powerful
<span class="w"> </span>    pattern matching. For speed, see the helper class, searcher_string.

<span class="gu">@@ -100,12 +299,13 @@ class searcher_re(object):</span>
<span class="w"> </span>        end   - index into the buffer, first byte after match
<span class="w"> </span>        match - the re.match object returned by a successful re.search

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="w"> </span>    def __init__(self, patterns):
<span class="gd">-        &quot;&quot;&quot;This creates an instance that searches for &#39;patterns&#39; Where</span>
<span class="gi">+        &#39;&#39;&#39;This creates an instance that searches for &#39;patterns&#39; Where</span>
<span class="w"> </span>        &#39;patterns&#39; may be a list or other sequence of compiled regular
<span class="gd">-        expressions, or the EOF or TIMEOUT types.&quot;&quot;&quot;</span>
<span class="gi">+        expressions, or the EOF or TIMEOUT types.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>        self.eof_index = -1
<span class="w"> </span>        self.timeout_index = -1
<span class="w"> </span>        self._searches = []
<span class="gu">@@ -119,8 +319,11 @@ class searcher_re(object):</span>
<span class="w"> </span>            self._searches.append((n, s))

<span class="w"> </span>    def __str__(self):
<span class="gd">-        &quot;&quot;&quot;This returns a human-readable string that represents the state of</span>
<span class="gd">-        the object.&quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;This returns a human-readable string that represents the state of</span>
<span class="gi">+        the object.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        #ss = [(n, &#39;    %d: re.compile(&quot;%s&quot;)&#39; %</span>
<span class="gi">+        #    (n, repr(s.pattern))) for n, s in self._searches]</span>
<span class="w"> </span>        ss = list()
<span class="w"> </span>        for n, s in self._searches:
<span class="w"> </span>            ss.append((n, &#39;    %d: re.compile(%r)&#39; % (n, s.pattern)))
<span class="gu">@@ -128,19 +331,41 @@ class searcher_re(object):</span>
<span class="w"> </span>        if self.eof_index &gt;= 0:
<span class="w"> </span>            ss.append((self.eof_index, &#39;    %d: EOF&#39; % self.eof_index))
<span class="w"> </span>        if self.timeout_index &gt;= 0:
<span class="gd">-            ss.append((self.timeout_index, &#39;    %d: TIMEOUT&#39; % self.</span>
<span class="gd">-                timeout_index))</span>
<span class="gi">+            ss.append((self.timeout_index, &#39;    %d: TIMEOUT&#39; %</span>
<span class="gi">+                self.timeout_index))</span>
<span class="w"> </span>        ss.sort()
<span class="w"> </span>        ss = list(zip(*ss))[1]
<span class="w"> </span>        return &#39;\n&#39;.join(ss)

<span class="w"> </span>    def search(self, buffer, freshlen, searchwindowsize=None):
<span class="gd">-        &quot;&quot;&quot;This searches &#39;buffer&#39; for the first occurrence of one of the regular</span>
<span class="gi">+        &#39;&#39;&#39;This searches &#39;buffer&#39; for the first occurrence of one of the regular</span>
<span class="w"> </span>        expressions. &#39;freshlen&#39; must indicate the number of bytes at the end of
<span class="w"> </span>        &#39;buffer&#39; which have not been searched before.

<span class="w"> </span>        See class spawn for the &#39;searchwindowsize&#39; argument.

<span class="w"> </span>        If there is a match this returns the index of that string, and sets
<span class="gd">-        &#39;start&#39;, &#39;end&#39; and &#39;match&#39;. Otherwise, returns -1.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;start&#39;, &#39;end&#39; and &#39;match&#39;. Otherwise, returns -1.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        first_match = None</span>
<span class="gi">+        # &#39;freshlen&#39; doesn&#39;t help here -- we cannot predict the</span>
<span class="gi">+        # length of a match, and the re module provides no help.</span>
<span class="gi">+        if searchwindowsize is None:</span>
<span class="gi">+            searchstart = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            searchstart = max(0, len(buffer) - searchwindowsize)</span>
<span class="gi">+        for index, s in self._searches:</span>
<span class="gi">+            match = s.search(buffer, searchstart)</span>
<span class="gi">+            if match is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            n = match.start()</span>
<span class="gi">+            if first_match is None or n &lt; first_match:</span>
<span class="gi">+                first_match = n</span>
<span class="gi">+                the_match = match</span>
<span class="gi">+                best_index = index</span>
<span class="gi">+        if first_match is None:</span>
<span class="gi">+            return -1</span>
<span class="gi">+        self.start = first_match</span>
<span class="gi">+        self.match = the_match</span>
<span class="gi">+        self.end = self.match.end()</span>
<span class="gi">+        return best_index</span>
<span class="gh">diff --git a/pexpect/fdpexpect.py b/pexpect/fdpexpect.py</span>
<span class="gh">index 4f4c4d9..140bdfe 100644</span>
<span class="gd">--- a/pexpect/fdpexpect.py</span>
<span class="gi">+++ b/pexpect/fdpexpect.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-&quot;&quot;&quot;This is like :mod:`pexpect`, but it will work with any file descriptor that you</span>
<span class="gi">+&#39;&#39;&#39;This is like :mod:`pexpect`, but it will work with any file descriptor that you</span>
<span class="w"> </span>pass it. You are responsible for opening and close the file descriptor.
<span class="w"> </span>This allows you to use Pexpect with sockets and named pipes (FIFOs).

<span class="gu">@@ -23,78 +23,101 @@ PEXPECT LICENSE</span>
<span class="w"> </span>    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<span class="w"> </span>    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>from .spawnbase import SpawnBase
<span class="w"> </span>from .exceptions import ExceptionPexpect, TIMEOUT
<span class="w"> </span>from .utils import select_ignore_interrupts, poll_ignore_interrupts
<span class="w"> </span>import os
<span class="gd">-__all__ = [&#39;fdspawn&#39;]</span>

<span class="gi">+__all__ = [&#39;fdspawn&#39;]</span>

<span class="w"> </span>class fdspawn(SpawnBase):
<span class="gd">-    &quot;&quot;&quot;This is like pexpect.spawn but allows you to supply your own open file</span>
<span class="gi">+    &#39;&#39;&#39;This is like pexpect.spawn but allows you to supply your own open file</span>
<span class="w"> </span>    descriptor. For example, you could use it to read through a file looking
<span class="gd">-    for patterns, or to control a modem or serial device. &quot;&quot;&quot;</span>
<span class="gi">+    for patterns, or to control a modem or serial device. &#39;&#39;&#39;</span>

<span class="gd">-    def __init__(self, fd, args=None, timeout=30, maxread=2000,</span>
<span class="gd">-        searchwindowsize=None, logfile=None, encoding=None, codec_errors=</span>
<span class="gd">-        &#39;strict&#39;, use_poll=False):</span>
<span class="gd">-        &quot;&quot;&quot;This takes a file descriptor (an int) or an object that support the</span>
<span class="gi">+    def __init__ (self, fd, args=None, timeout=30, maxread=2000, searchwindowsize=None,</span>
<span class="gi">+                  logfile=None, encoding=None, codec_errors=&#39;strict&#39;, use_poll=False):</span>
<span class="gi">+        &#39;&#39;&#39;This takes a file descriptor (an int) or an object that support the</span>
<span class="w"> </span>        fileno() method (returning an int). All Python file-like objects
<span class="gd">-        support fileno(). &quot;&quot;&quot;</span>
<span class="gi">+        support fileno(). &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>        if type(fd) != type(0) and hasattr(fd, &#39;fileno&#39;):
<span class="w"> </span>            fd = fd.fileno()
<span class="gi">+</span>
<span class="w"> </span>        if type(fd) != type(0):
<span class="gd">-            raise ExceptionPexpect(</span>
<span class="gd">-                &#39;The fd argument is not an int. If this is a command string then maybe you want to use pexpect.spawn.&#39;</span>
<span class="gd">-                )</span>
<span class="gd">-        try:</span>
<span class="gi">+            raise ExceptionPexpect(&#39;The fd argument is not an int. If this is a command string then maybe you want to use pexpect.spawn.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try: # make sure fd is a valid file descriptor</span>
<span class="w"> </span>            os.fstat(fd)
<span class="w"> </span>        except OSError:
<span class="gd">-            raise ExceptionPexpect(</span>
<span class="gd">-                &#39;The fd argument is not a valid file descriptor.&#39;)</span>
<span class="gi">+            raise ExceptionPexpect(&#39;The fd argument is not a valid file descriptor.&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.args = None
<span class="w"> </span>        self.command = None
<span class="gd">-        SpawnBase.__init__(self, timeout, maxread, searchwindowsize,</span>
<span class="gd">-            logfile, encoding=encoding, codec_errors=codec_errors)</span>
<span class="gi">+        SpawnBase.__init__(self, timeout, maxread, searchwindowsize, logfile,</span>
<span class="gi">+                           encoding=encoding, codec_errors=codec_errors)</span>
<span class="w"> </span>        self.child_fd = fd
<span class="w"> </span>        self.own_fd = False
<span class="w"> </span>        self.closed = False
<span class="w"> </span>        self.name = &#39;&lt;file descriptor %d&gt;&#39; % fd
<span class="w"> </span>        self.use_poll = use_poll

<span class="gd">-    def close(self):</span>
<span class="gi">+    def close (self):</span>
<span class="w"> </span>        &quot;&quot;&quot;Close the file descriptor.

<span class="w"> </span>        Calling this method a second time does nothing, but if the file
<span class="w"> </span>        descriptor was closed elsewhere, :class:`OSError` will be raised.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.child_fd == -1:</span>
<span class="gi">+            return</span>

<span class="gd">-    def isalive(self):</span>
<span class="gd">-        &quot;&quot;&quot;This checks if the file descriptor is still valid. If :func:`os.fstat`</span>
<span class="gd">-        does not raise an exception then we assume it is alive. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+        os.close(self.child_fd)</span>
<span class="gi">+        self.child_fd = -1</span>
<span class="gi">+        self.closed = True</span>

<span class="gd">-    def terminate(self, force=False):</span>
<span class="gd">-        &quot;&quot;&quot;Deprecated and invalid. Just raises an exception.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def isalive (self):</span>
<span class="gi">+        &#39;&#39;&#39;This checks if the file descriptor is still valid. If :func:`os.fstat`</span>
<span class="gi">+        does not raise an exception then we assume it is alive. &#39;&#39;&#39;</span>

<span class="gi">+        if self.child_fd == -1:</span>
<span class="gi">+            return False</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.fstat(self.child_fd)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    def terminate (self, force=False):  # pragma: no cover</span>
<span class="gi">+        &#39;&#39;&#39;Deprecated and invalid. Just raises an exception.&#39;&#39;&#39;</span>
<span class="gi">+        raise ExceptionPexpect(&#39;This method is not valid for file descriptors.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # These four methods are left around for backwards compatibility, but not</span>
<span class="gi">+    # documented as part of fdpexpect. You&#39;re encouraged to use os.write</span>
<span class="gi">+    # directly.</span>
<span class="w"> </span>    def send(self, s):
<span class="gd">-        &quot;&quot;&quot;Write to fd, return number of bytes written&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;Write to fd, return number of bytes written&quot;</span>
<span class="gi">+        s = self._coerce_send_string(s)</span>
<span class="gi">+        self._log(s, &#39;send&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        b = self._encoder.encode(s, final=False)</span>
<span class="gi">+        return os.write(self.child_fd, b)</span>

<span class="w"> </span>    def sendline(self, s):
<span class="gd">-        &quot;&quot;&quot;Write to fd with trailing newline, return number of bytes written&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;Write to fd with trailing newline, return number of bytes written&quot;</span>
<span class="gi">+        s = self._coerce_send_string(s)</span>
<span class="gi">+        return self.send(s + self.linesep)</span>

<span class="w"> </span>    def write(self, s):
<span class="gd">-        &quot;&quot;&quot;Write to fd, return None&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;Write to fd, return None&quot;</span>
<span class="gi">+        self.send(s)</span>

<span class="w"> </span>    def writelines(self, sequence):
<span class="gd">-        &quot;&quot;&quot;Call self.write() for each item in sequence&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;Call self.write() for each item in sequence&quot;</span>
<span class="gi">+        for s in sequence:</span>
<span class="gi">+            self.write(s)</span>

<span class="w"> </span>    def read_nonblocking(self, size=1, timeout=-1):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -112,4 +135,18 @@ class fdspawn(SpawnBase):</span>
<span class="w"> </span>            ready to read. When -1 (default), use self.timeout. When 0, poll.
<span class="w"> </span>        :return: String containing the bytes read
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if os.name == &#39;posix&#39;:</span>
<span class="gi">+            if timeout == -1:</span>
<span class="gi">+                timeout = self.timeout</span>
<span class="gi">+            rlist = [self.child_fd]</span>
<span class="gi">+            wlist = []</span>
<span class="gi">+            xlist = []</span>
<span class="gi">+            if self.use_poll:</span>
<span class="gi">+                rlist = poll_ignore_interrupts(rlist, timeout)</span>
<span class="gi">+            else:</span>
<span class="gi">+                rlist, wlist, xlist = select_ignore_interrupts(</span>
<span class="gi">+                    rlist, wlist, xlist, timeout</span>
<span class="gi">+                )</span>
<span class="gi">+            if self.child_fd not in rlist:</span>
<span class="gi">+                raise TIMEOUT(&#39;Timeout exceeded.&#39;)</span>
<span class="gi">+        return super(fdspawn, self).read_nonblocking(size)</span>
<span class="gh">diff --git a/pexpect/popen_spawn.py b/pexpect/popen_spawn.py</span>
<span class="gh">index 5f7d56a..e6bdf07 100644</span>
<span class="gd">--- a/pexpect/popen_spawn.py</span>
<span class="gi">+++ b/pexpect/popen_spawn.py</span>
<span class="gu">@@ -7,91 +7,182 @@ import sys</span>
<span class="w"> </span>import time
<span class="w"> </span>import signal
<span class="w"> </span>import shlex
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    from queue import Queue, Empty</span>
<span class="gi">+    from queue import Queue, Empty  # Python 3</span>
<span class="w"> </span>except ImportError:
<span class="gd">-    from Queue import Queue, Empty</span>
<span class="gi">+    from Queue import Queue, Empty  # Python 2</span>
<span class="gi">+</span>
<span class="w"> </span>from .spawnbase import SpawnBase, PY3
<span class="w"> </span>from .exceptions import EOF
<span class="w"> </span>from .utils import string_types

<span class="gd">-</span>
<span class="w"> </span>class PopenSpawn(SpawnBase):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, cmd, timeout=30, maxread=2000, searchwindowsize=None,
<span class="gd">-        logfile=None, cwd=None, env=None, encoding=None, codec_errors=</span>
<span class="gd">-        &#39;strict&#39;, preexec_fn=None):</span>
<span class="gi">+                 logfile=None, cwd=None, env=None, encoding=None,</span>
<span class="gi">+                 codec_errors=&#39;strict&#39;, preexec_fn=None):</span>
<span class="w"> </span>        super(PopenSpawn, self).__init__(timeout=timeout, maxread=maxread,
<span class="gd">-            searchwindowsize=searchwindowsize, logfile=logfile, encoding=</span>
<span class="gd">-            encoding, codec_errors=codec_errors)</span>
<span class="gi">+                searchwindowsize=searchwindowsize, logfile=logfile,</span>
<span class="gi">+                encoding=encoding, codec_errors=codec_errors)</span>
<span class="gi">+</span>
<span class="gi">+        # Note that `SpawnBase` initializes `self.crlf` to `\r\n`</span>
<span class="gi">+        # because the default behaviour for a PTY is to convert</span>
<span class="gi">+        # incoming LF to `\r\n` (see the `onlcr` flag and</span>
<span class="gi">+        # https://stackoverflow.com/a/35887657/5397009). Here we set</span>
<span class="gi">+        # it to `os.linesep` because that is what the spawned</span>
<span class="gi">+        # application outputs by default and `popen` doesn&#39;t translate</span>
<span class="gi">+        # anything.</span>
<span class="w"> </span>        if encoding is None:
<span class="gd">-            self.crlf = os.linesep.encode(&#39;ascii&#39;)</span>
<span class="gi">+            self.crlf = os.linesep.encode (&quot;ascii&quot;)</span>
<span class="w"> </span>        else:
<span class="gd">-            self.crlf = self.string_type(os.linesep)</span>
<span class="gd">-        kwargs = dict(bufsize=0, stdin=subprocess.PIPE, stderr=subprocess.</span>
<span class="gd">-            STDOUT, stdout=subprocess.PIPE, cwd=cwd, preexec_fn=preexec_fn,</span>
<span class="gd">-            env=env)</span>
<span class="gi">+            self.crlf = self.string_type (os.linesep)</span>
<span class="gi">+</span>
<span class="gi">+        kwargs = dict(bufsize=0, stdin=subprocess.PIPE,</span>
<span class="gi">+                      stderr=subprocess.STDOUT, stdout=subprocess.PIPE,</span>
<span class="gi">+                      cwd=cwd, preexec_fn=preexec_fn, env=env)</span>
<span class="gi">+</span>
<span class="w"> </span>        if sys.platform == &#39;win32&#39;:
<span class="w"> </span>            startupinfo = subprocess.STARTUPINFO()
<span class="w"> </span>            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
<span class="w"> </span>            kwargs[&#39;startupinfo&#39;] = startupinfo
<span class="w"> </span>            kwargs[&#39;creationflags&#39;] = subprocess.CREATE_NEW_PROCESS_GROUP
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(cmd, string_types) and sys.platform != &#39;win32&#39;:
<span class="w"> </span>            cmd = shlex.split(cmd, posix=os.name == &#39;posix&#39;)
<span class="gi">+</span>
<span class="w"> </span>        self.proc = subprocess.Popen(cmd, **kwargs)
<span class="w"> </span>        self.pid = self.proc.pid
<span class="w"> </span>        self.closed = False
<span class="w"> </span>        self._buf = self.string_type()
<span class="gi">+</span>
<span class="w"> </span>        self._read_queue = Queue()
<span class="w"> </span>        self._read_thread = threading.Thread(target=self._read_incoming)
<span class="w"> </span>        self._read_thread.daemon = True
<span class="w"> </span>        self._read_thread.start()
<span class="gi">+</span>
<span class="w"> </span>    _read_reached_eof = False

<span class="gi">+    def read_nonblocking(self, size, timeout):</span>
<span class="gi">+        buf = self._buf</span>
<span class="gi">+        if self._read_reached_eof:</span>
<span class="gi">+            # We have already finished reading. Use up any buffered data,</span>
<span class="gi">+            # then raise EOF</span>
<span class="gi">+            if buf:</span>
<span class="gi">+                self._buf = buf[size:]</span>
<span class="gi">+                return buf[:size]</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.flag_eof = True</span>
<span class="gi">+                raise EOF(&#39;End Of File (EOF).&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if timeout == -1:</span>
<span class="gi">+            timeout = self.timeout</span>
<span class="gi">+        elif timeout is None:</span>
<span class="gi">+            timeout = 1e6</span>
<span class="gi">+</span>
<span class="gi">+        t0 = time.time()</span>
<span class="gi">+        while (time.time() - t0) &lt; timeout and size and len(buf) &lt; size:</span>
<span class="gi">+            try:</span>
<span class="gi">+                incoming = self._read_queue.get_nowait()</span>
<span class="gi">+            except Empty:</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                if incoming is None:</span>
<span class="gi">+                    self._read_reached_eof = True</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+                buf += self._decoder.decode(incoming, final=False)</span>
<span class="gi">+</span>
<span class="gi">+        r, self._buf = buf[:size], buf[size:]</span>
<span class="gi">+</span>
<span class="gi">+        self._log(r, &#39;read&#39;)</span>
<span class="gi">+        return r</span>
<span class="gi">+</span>
<span class="w"> </span>    def _read_incoming(self):
<span class="w"> </span>        &quot;&quot;&quot;Run in a thread to move output from a pipe to a queue.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fileno = self.proc.stdout.fileno()</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            buf = b&#39;&#39;</span>
<span class="gi">+            try:</span>
<span class="gi">+                buf = os.read(fileno, 1024)</span>
<span class="gi">+            except OSError as e:</span>
<span class="gi">+                self._log(e, &#39;read&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if not buf:</span>
<span class="gi">+                # This indicates we have reached EOF</span>
<span class="gi">+                self._read_queue.put(None)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            self._read_queue.put(buf)</span>

<span class="w"> </span>    def write(self, s):
<span class="gd">-        &quot;&quot;&quot;This is similar to send() except that there is no return value.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;This is similar to send() except that there is no return value.</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        self.send(s)</span>

<span class="w"> </span>    def writelines(self, sequence):
<span class="gd">-        &quot;&quot;&quot;This calls write() for each element in the sequence.</span>
<span class="gi">+        &#39;&#39;&#39;This calls write() for each element in the sequence.</span>

<span class="w"> </span>        The sequence can be any iterable object producing strings, typically a
<span class="w"> </span>        list of strings. This does not add line separators. There is no return
<span class="w"> </span>        value.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        for s in sequence:</span>
<span class="gi">+            self.send(s)</span>

<span class="w"> </span>    def send(self, s):
<span class="gd">-        &quot;&quot;&quot;Send data to the subprocess&#39; stdin.</span>
<span class="gi">+        &#39;&#39;&#39;Send data to the subprocess&#39; stdin.</span>

<span class="w"> </span>        Returns the number of bytes written.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        s = self._coerce_send_string(s)</span>
<span class="gi">+        self._log(s, &#39;send&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        b = self._encoder.encode(s, final=False)</span>
<span class="gi">+        if PY3:</span>
<span class="gi">+            return self.proc.stdin.write(b)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # On Python 2, .write() returns None, so we return the length of</span>
<span class="gi">+            # bytes written ourselves. This assumes they all got written.</span>
<span class="gi">+            self.proc.stdin.write(b)</span>
<span class="gi">+            return len(b)</span>

<span class="w"> </span>    def sendline(self, s=&#39;&#39;):
<span class="gd">-        &quot;&quot;&quot;Wraps send(), sending string ``s`` to child process, with os.linesep</span>
<span class="gd">-        automatically appended. Returns number of bytes written. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;Wraps send(), sending string ``s`` to child process, with os.linesep</span>
<span class="gi">+        automatically appended. Returns number of bytes written. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        n = self.send(s)</span>
<span class="gi">+        return n + self.send(self.linesep)</span>

<span class="w"> </span>    def wait(self):
<span class="gd">-        &quot;&quot;&quot;Wait for the subprocess to finish.</span>
<span class="gi">+        &#39;&#39;&#39;Wait for the subprocess to finish.</span>

<span class="w"> </span>        Returns the exit code.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        status = self.proc.wait()</span>
<span class="gi">+        if status &gt;= 0:</span>
<span class="gi">+            self.exitstatus = status</span>
<span class="gi">+            self.signalstatus = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.exitstatus = None</span>
<span class="gi">+            self.signalstatus = -status</span>
<span class="gi">+        self.terminated = True</span>
<span class="gi">+        return status</span>

<span class="w"> </span>    def kill(self, sig):
<span class="gd">-        &quot;&quot;&quot;Sends a Unix signal to the subprocess.</span>
<span class="gi">+        &#39;&#39;&#39;Sends a Unix signal to the subprocess.</span>

<span class="w"> </span>        Use constants from the :mod:`signal` module to specify which signal.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+            if sig in [signal.SIGINT, signal.CTRL_C_EVENT]:</span>
<span class="gi">+                sig = signal.CTRL_C_EVENT</span>
<span class="gi">+            elif sig in [signal.SIGBREAK, signal.CTRL_BREAK_EVENT]:</span>
<span class="gi">+                sig = signal.CTRL_BREAK_EVENT</span>
<span class="gi">+            else:</span>
<span class="gi">+                sig = signal.SIGTERM</span>
<span class="gi">+</span>
<span class="gi">+        os.kill(self.proc.pid, sig)</span>

<span class="w"> </span>    def sendeof(self):
<span class="gd">-        &quot;&quot;&quot;Closes the stdin pipe from the writing end.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;Closes the stdin pipe from the writing end.&#39;&#39;&#39;</span>
<span class="gi">+        self.proc.stdin.close()</span>
<span class="gh">diff --git a/pexpect/pty_spawn.py b/pexpect/pty_spawn.py</span>
<span class="gh">index 4fc030b..8e28ca7 100644</span>
<span class="gd">--- a/pexpect/pty_spawn.py</span>
<span class="gi">+++ b/pexpect/pty_spawn.py</span>
<span class="gu">@@ -6,32 +6,39 @@ import tty</span>
<span class="w"> </span>import errno
<span class="w"> </span>import signal
<span class="w"> </span>from contextlib import contextmanager
<span class="gi">+</span>
<span class="w"> </span>import ptyprocess
<span class="w"> </span>from ptyprocess.ptyprocess import use_native_pty_fork
<span class="gi">+</span>
<span class="w"> </span>from .exceptions import ExceptionPexpect, EOF, TIMEOUT
<span class="w"> </span>from .spawnbase import SpawnBase
<span class="gd">-from .utils import which, split_command_line, select_ignore_interrupts, poll_ignore_interrupts</span>
<span class="gd">-</span>
<span class="gi">+from .utils import (</span>
<span class="gi">+    which, split_command_line, select_ignore_interrupts, poll_ignore_interrupts</span>
<span class="gi">+)</span>

<span class="w"> </span>@contextmanager
<span class="w"> </span>def _wrap_ptyprocess_err():
<span class="w"> </span>    &quot;&quot;&quot;Turn ptyprocess errors into our own ExceptionPexpect errors&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-PY3 = sys.version_info[0] &gt;= 3</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    except ptyprocess.PtyProcessError as e:</span>
<span class="gi">+        raise ExceptionPexpect(*e.args)</span>

<span class="gi">+PY3 = (sys.version_info[0] &gt;= 3)</span>

<span class="w"> </span>class spawn(SpawnBase):
<span class="gd">-    &quot;&quot;&quot;This is the main class interface for Pexpect. Use this class to start</span>
<span class="gd">-    and control child applications. &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;This is the main class interface for Pexpect. Use this class to start</span>
<span class="gi">+    and control child applications. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # This is purely informational now - changing it has no effect</span>
<span class="w"> </span>    use_native_pty_fork = use_native_pty_fork

<span class="w"> </span>    def __init__(self, command, args=[], timeout=30, maxread=2000,
<span class="gd">-        searchwindowsize=None, logfile=None, cwd=None, env=None,</span>
<span class="gd">-        ignore_sighup=False, echo=True, preexec_fn=None, encoding=None,</span>
<span class="gd">-        codec_errors=&#39;strict&#39;, dimensions=None, use_poll=False):</span>
<span class="gd">-        &quot;&quot;&quot;This is the constructor. The command parameter may be a string that</span>
<span class="gi">+                 searchwindowsize=None, logfile=None, cwd=None, env=None,</span>
<span class="gi">+                 ignore_sighup=False, echo=True, preexec_fn=None,</span>
<span class="gi">+                 encoding=None, codec_errors=&#39;strict&#39;, dimensions=None,</span>
<span class="gi">+                 use_poll=False):</span>
<span class="gi">+        &#39;&#39;&#39;This is the constructor. The command parameter may be a string that</span>
<span class="w"> </span>        includes a command and any arguments to the command. For example::

<span class="w"> </span>            child = pexpect.spawn(&#39;/usr/bin/ftp&#39;)
<span class="gu">@@ -178,10 +185,9 @@ class spawn(SpawnBase):</span>

<span class="w"> </span>        The use_poll attribute enables using select.poll() over select.select()
<span class="w"> </span>        for socket handling. This is handy if your system could have &gt; 1024 fds
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        super(spawn, self).__init__(timeout=timeout, maxread=maxread,</span>
<span class="gd">-            searchwindowsize=searchwindowsize, logfile=logfile, encoding=</span>
<span class="gd">-            encoding, codec_errors=codec_errors)</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        super(spawn, self).__init__(timeout=timeout, maxread=maxread, searchwindowsize=searchwindowsize,</span>
<span class="gi">+                                    logfile=logfile, encoding=encoding, codec_errors=codec_errors)</span>
<span class="w"> </span>        self.STDIN_FILENO = pty.STDIN_FILENO
<span class="w"> </span>        self.STDOUT_FILENO = pty.STDOUT_FILENO
<span class="w"> </span>        self.STDERR_FILENO = pty.STDERR_FILENO
<span class="gu">@@ -200,16 +206,15 @@ class spawn(SpawnBase):</span>
<span class="w"> </span>        self.use_poll = use_poll

<span class="w"> </span>    def __str__(self):
<span class="gd">-        &quot;&quot;&quot;This returns a human-readable string that represents the state of</span>
<span class="gd">-        the object. &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;This returns a human-readable string that represents the state of</span>
<span class="gi">+        the object. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>        s = []
<span class="w"> </span>        s.append(repr(self))
<span class="w"> </span>        s.append(&#39;command: &#39; + str(self.command))
<span class="w"> </span>        s.append(&#39;args: %r&#39; % (self.args,))
<span class="gd">-        s.append(&#39;buffer (last %s chars): %r&#39; % (self.str_last_chars, self.</span>
<span class="gd">-            buffer[-self.str_last_chars:]))</span>
<span class="gd">-        s.append(&#39;before (last %s chars): %r&#39; % (self.str_last_chars, self.</span>
<span class="gd">-            before[-self.str_last_chars:] if self.before else &#39;&#39;))</span>
<span class="gi">+        s.append(&#39;buffer (last %s chars): %r&#39; % (self.str_last_chars,self.buffer[-self.str_last_chars:]))</span>
<span class="gi">+        s.append(&#39;before (last %s chars): %r&#39; % (self.str_last_chars,self.before[-self.str_last_chars:] if self.before else &#39;&#39;))</span>
<span class="w"> </span>        s.append(&#39;after: %r&#39; % (self.after,))
<span class="w"> </span>        s.append(&#39;match: %r&#39; % (self.match,))
<span class="w"> </span>        s.append(&#39;match_index: &#39; + str(self.match_index))
<span class="gu">@@ -233,36 +238,111 @@ class spawn(SpawnBase):</span>
<span class="w"> </span>        return &#39;\n&#39;.join(s)

<span class="w"> </span>    def _spawn(self, command, args=[], preexec_fn=None, dimensions=None):
<span class="gd">-        &quot;&quot;&quot;This starts the given command in a child process. This does all the</span>
<span class="gi">+        &#39;&#39;&#39;This starts the given command in a child process. This does all the</span>
<span class="w"> </span>        fork/exec type of stuff for a pty. This is called by __init__. If args
<span class="w"> </span>        is empty then command will be parsed (split on spaces) and args will be
<span class="gd">-        set to parsed arguments. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        set to parsed arguments. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # The pid and child_fd of this object get set by this method.</span>
<span class="gi">+        # Note that it is difficult for this method to fail.</span>
<span class="gi">+        # You cannot detect if the child process cannot start.</span>
<span class="gi">+        # So the only way you can tell if the child process started</span>
<span class="gi">+        # or not is to try to read from the file descriptor. If you get</span>
<span class="gi">+        # EOF immediately then it means that the child is already dead.</span>
<span class="gi">+        # That may not necessarily be bad because you may have spawned a child</span>
<span class="gi">+        # that performs some task; creates no stdout output; and then dies.</span>
<span class="gi">+</span>
<span class="gi">+        # If command is an int type then it may represent a file descriptor.</span>
<span class="gi">+        if isinstance(command, type(0)):</span>
<span class="gi">+            raise ExceptionPexpect(&#39;Command is an int type. &#39; +</span>
<span class="gi">+                    &#39;If this is a file descriptor then maybe you want to &#39; +</span>
<span class="gi">+                    &#39;use fdpexpect.fdspawn which takes an existing &#39; +</span>
<span class="gi">+                    &#39;file descriptor instead of a command string.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(args, type([])):</span>
<span class="gi">+            raise TypeError(&#39;The argument, args, must be a list.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if args == []:</span>
<span class="gi">+            self.args = split_command_line(command)</span>
<span class="gi">+            self.command = self.args[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Make a shallow copy of the args list.</span>
<span class="gi">+            self.args = args[:]</span>
<span class="gi">+            self.args.insert(0, command)</span>
<span class="gi">+            self.command = command</span>
<span class="gi">+</span>
<span class="gi">+        command_with_path = which(self.command, env=self.env)</span>
<span class="gi">+        if command_with_path is None:</span>
<span class="gi">+            raise ExceptionPexpect(&#39;The command was not found or was not &#39; +</span>
<span class="gi">+                    &#39;executable: %s.&#39; % self.command)</span>
<span class="gi">+        self.command = command_with_path</span>
<span class="gi">+        self.args[0] = self.command</span>
<span class="gi">+</span>
<span class="gi">+        self.name = &#39;&lt;&#39; + &#39; &#39;.join(self.args) + &#39;&gt;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        assert self.pid is None, &#39;The pid member must be None.&#39;</span>
<span class="gi">+        assert self.command is not None, &#39;The command member must not be None.&#39;</span>
<span class="gi">+</span>
<span class="gi">+        kwargs = {&#39;echo&#39;: self.echo, &#39;preexec_fn&#39;: preexec_fn}</span>
<span class="gi">+        if self.ignore_sighup:</span>
<span class="gi">+            def preexec_wrapper():</span>
<span class="gi">+                &quot;Set SIGHUP to be ignored, then call the real preexec_fn&quot;</span>
<span class="gi">+                signal.signal(signal.SIGHUP, signal.SIG_IGN)</span>
<span class="gi">+                if preexec_fn is not None:</span>
<span class="gi">+                    preexec_fn()</span>
<span class="gi">+            kwargs[&#39;preexec_fn&#39;] = preexec_wrapper</span>
<span class="gi">+</span>
<span class="gi">+        if dimensions is not None:</span>
<span class="gi">+            kwargs[&#39;dimensions&#39;] = dimensions</span>
<span class="gi">+</span>
<span class="gi">+        if self.encoding is not None:</span>
<span class="gi">+            # Encode command line using the specified encoding</span>
<span class="gi">+            self.args = [a if isinstance(a, bytes) else a.encode(self.encoding)</span>
<span class="gi">+                         for a in self.args]</span>
<span class="gi">+</span>
<span class="gi">+        self.ptyproc = self._spawnpty(self.args, env=self.env,</span>
<span class="gi">+                                     cwd=self.cwd, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        self.pid = self.ptyproc.pid</span>
<span class="gi">+        self.child_fd = self.ptyproc.fd</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+        self.terminated = False</span>
<span class="gi">+        self.closed = False</span>

<span class="w"> </span>    def _spawnpty(self, args, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Spawn a pty and return an instance of PtyProcess.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;Spawn a pty and return an instance of PtyProcess.&#39;&#39;&#39;</span>
<span class="gi">+        return ptyprocess.PtyProcess.spawn(args, **kwargs)</span>

<span class="w"> </span>    def close(self, force=True):
<span class="gd">-        &quot;&quot;&quot;This closes the connection with the child application. Note that</span>
<span class="gi">+        &#39;&#39;&#39;This closes the connection with the child application. Note that</span>
<span class="w"> </span>        calling close() more than once is valid. This emulates standard Python
<span class="w"> </span>        behavior with files. Set force to True if you want to make sure that
<span class="w"> </span>        the child is terminated (SIGKILL is sent if the child ignores SIGHUP
<span class="gd">-        and SIGINT). &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        and SIGINT). &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+        with _wrap_ptyprocess_err():</span>
<span class="gi">+            # PtyProcessError may be raised if it is not possible to terminate</span>
<span class="gi">+            # the child.</span>
<span class="gi">+            self.ptyproc.close(force=force)</span>
<span class="gi">+        self.isalive()  # Update exit status from ptyproc</span>
<span class="gi">+        self.child_fd = -1</span>
<span class="gi">+        self.closed = True</span>

<span class="w"> </span>    def isatty(self):
<span class="gd">-        &quot;&quot;&quot;This returns True if the file descriptor is open and connected to a</span>
<span class="gi">+        &#39;&#39;&#39;This returns True if the file descriptor is open and connected to a</span>
<span class="w"> </span>        tty(-like) device, else False.

<span class="w"> </span>        On SVR4-style platforms implementing streams, such as SunOS and HP-UX,
<span class="w"> </span>        the child pty may not appear as a terminal device.  This means
<span class="w"> </span>        methods such as setecho(), setwinsize(), getwinsize() may raise an
<span class="gd">-        IOError. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        IOError. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return os.isatty(self.child_fd)</span>

<span class="w"> </span>    def waitnoecho(self, timeout=-1):
<span class="gd">-        &quot;&quot;&quot;This waits until the terminal ECHO flag is set False. This returns</span>
<span class="gi">+        &#39;&#39;&#39;This waits until the terminal ECHO flag is set False. This returns</span>
<span class="w"> </span>        True if the echo mode is off. This returns False if the ECHO flag was
<span class="w"> </span>        not set False before the timeout. This can be used to detect when the
<span class="w"> </span>        child is waiting for a password. Usually a child application will turn
<span class="gu">@@ -276,19 +356,31 @@ class spawn(SpawnBase):</span>

<span class="w"> </span>        If timeout==-1 then this method will use the value in self.timeout.
<span class="w"> </span>        If timeout==None then this method to block until ECHO flag is False.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if timeout == -1:</span>
<span class="gi">+            timeout = self.timeout</span>
<span class="gi">+        if timeout is not None:</span>
<span class="gi">+            end_time = time.time() + timeout</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if not self.getecho():</span>
<span class="gi">+                return True</span>
<span class="gi">+            if timeout &lt; 0 and timeout is not None:</span>
<span class="gi">+                return False</span>
<span class="gi">+            if timeout is not None:</span>
<span class="gi">+                timeout = end_time - time.time()</span>
<span class="gi">+            time.sleep(0.1)</span>

<span class="w"> </span>    def getecho(self):
<span class="gd">-        &quot;&quot;&quot;This returns the terminal echo mode. This returns True if echo is</span>
<span class="gi">+        &#39;&#39;&#39;This returns the terminal echo mode. This returns True if echo is</span>
<span class="w"> </span>        on or False if echo is off. Child applications that are expecting you
<span class="w"> </span>        to enter a password often set ECHO False. See waitnoecho().

<span class="gd">-        Not supported on platforms where ``isatty()`` returns False.  &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        Not supported on platforms where ``isatty()`` returns False.  &#39;&#39;&#39;</span>
<span class="gi">+        return self.ptyproc.getecho()</span>

<span class="w"> </span>    def setecho(self, state):
<span class="gd">-        &quot;&quot;&quot;This sets the terminal echo mode on or off. Note that anything the</span>
<span class="gi">+        &#39;&#39;&#39;This sets the terminal echo mode on or off. Note that anything the</span>
<span class="w"> </span>        child sent before the echo will be lost, so you should be sure that
<span class="w"> </span>        your input buffer is empty before you call setecho(). For example, the
<span class="w"> </span>        following will work as expected::
<span class="gu">@@ -318,11 +410,11 @@ class spawn(SpawnBase):</span>


<span class="w"> </span>        Not supported on platforms where ``isatty()`` returns False.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        return self.ptyproc.setecho(state)</span>

<span class="w"> </span>    def read_nonblocking(self, size=1, timeout=-1):
<span class="gd">-        &quot;&quot;&quot;This reads at most size characters from the child application. It</span>
<span class="gi">+        &#39;&#39;&#39;This reads at most size characters from the child application. It</span>
<span class="w"> </span>        includes a timeout. If the read does not complete within the timeout
<span class="w"> </span>        period then a TIMEOUT exception is raised. If the end of file is read
<span class="w"> </span>        then an EOF exception will be raised.  If a logfile is specified, a
<span class="gu">@@ -345,23 +437,95 @@ class spawn(SpawnBase):</span>
<span class="w"> </span>        to read, the buffer will be filled, regardless of timeout.

<span class="w"> </span>        This is a wrapper around os.read(). It uses select.select() or
<span class="gd">-        select.poll() to implement the timeout. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        select.poll() to implement the timeout. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if self.closed:</span>
<span class="gi">+            raise ValueError(&#39;I/O operation on closed file.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.use_poll:</span>
<span class="gi">+            def select(timeout):</span>
<span class="gi">+                return poll_ignore_interrupts([self.child_fd], timeout)</span>
<span class="gi">+        else:</span>
<span class="gi">+            def select(timeout):</span>
<span class="gi">+                return select_ignore_interrupts([self.child_fd], [], [], timeout)[0]</span>
<span class="gi">+</span>
<span class="gi">+        # If there is data available to read right now, read as much as</span>
<span class="gi">+        # we can. We do this to increase performance if there are a lot</span>
<span class="gi">+        # of bytes to be read. This also avoids calling isalive() too</span>
<span class="gi">+        # often. See also:</span>
<span class="gi">+        # * https://github.com/pexpect/pexpect/pull/304</span>
<span class="gi">+        # * http://trac.sagemath.org/ticket/10295</span>
<span class="gi">+        if select(0):</span>
<span class="gi">+            try:</span>
<span class="gi">+                incoming = super(spawn, self).read_nonblocking(size)</span>
<span class="gi">+            except EOF:</span>
<span class="gi">+                # Maybe the child is dead: update some attributes in that case</span>
<span class="gi">+                self.isalive()</span>
<span class="gi">+                raise</span>
<span class="gi">+            while len(incoming) &lt; size and select(0):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    incoming += super(spawn, self).read_nonblocking(size - len(incoming))</span>
<span class="gi">+                except EOF:</span>
<span class="gi">+                    # Maybe the child is dead: update some attributes in that case</span>
<span class="gi">+                    self.isalive()</span>
<span class="gi">+                    # Don&#39;t raise EOF, just return what we read so far.</span>
<span class="gi">+                    return incoming</span>
<span class="gi">+            return incoming</span>
<span class="gi">+</span>
<span class="gi">+        if timeout == -1:</span>
<span class="gi">+            timeout = self.timeout</span>
<span class="gi">+</span>
<span class="gi">+        if not self.isalive():</span>
<span class="gi">+            # The process is dead, but there may or may not be data</span>
<span class="gi">+            # available to read. Note that some systems such as Solaris</span>
<span class="gi">+            # do not give an EOF when the child dies. In fact, you can</span>
<span class="gi">+            # still try to read from the child_fd -- it will block</span>
<span class="gi">+            # forever or until TIMEOUT. For that reason, it&#39;s important</span>
<span class="gi">+            # to do this check before calling select() with timeout.</span>
<span class="gi">+            if select(0):</span>
<span class="gi">+                return super(spawn, self).read_nonblocking(size)</span>
<span class="gi">+            self.flag_eof = True</span>
<span class="gi">+            raise EOF(&#39;End Of File (EOF). Braindead platform.&#39;)</span>
<span class="gi">+        elif self.__irix_hack:</span>
<span class="gi">+            # Irix takes a long time before it realizes a child was terminated.</span>
<span class="gi">+            # Make sure that the timeout is at least 2 seconds.</span>
<span class="gi">+            # FIXME So does this mean Irix systems are forced to always have</span>
<span class="gi">+            # FIXME a 2 second delay when calling read_nonblocking? That sucks.</span>
<span class="gi">+            if timeout is not None and timeout &lt; 2:</span>
<span class="gi">+                timeout = 2</span>
<span class="gi">+</span>
<span class="gi">+        # Because of the select(0) check above, we know that no data</span>
<span class="gi">+        # is available right now. But if a non-zero timeout is given</span>
<span class="gi">+        # (possibly timeout=None), we call select() with a timeout.</span>
<span class="gi">+        if (timeout != 0) and select(timeout):</span>
<span class="gi">+            return super(spawn, self).read_nonblocking(size)</span>
<span class="gi">+</span>
<span class="gi">+        if not self.isalive():</span>
<span class="gi">+            # Some platforms, such as Irix, will claim that their</span>
<span class="gi">+            # processes are alive; timeout on the select; and</span>
<span class="gi">+            # then finally admit that they are not alive.</span>
<span class="gi">+            self.flag_eof = True</span>
<span class="gi">+            raise EOF(&#39;End of File (EOF). Very slow platform.&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TIMEOUT(&#39;Timeout exceeded.&#39;)</span>

<span class="w"> </span>    def write(self, s):
<span class="gd">-        &quot;&quot;&quot;This is similar to send() except that there is no return value.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;This is similar to send() except that there is no return value.</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.send(s)</span>

<span class="w"> </span>    def writelines(self, sequence):
<span class="gd">-        &quot;&quot;&quot;This calls write() for each element in the sequence. The sequence</span>
<span class="gi">+        &#39;&#39;&#39;This calls write() for each element in the sequence. The sequence</span>
<span class="w"> </span>        can be any iterable object producing strings, typically a list of
<span class="w"> </span>        strings. This does not add line separators. There is no return value.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        for s in sequence:</span>
<span class="gi">+            self.write(s)</span>

<span class="w"> </span>    def send(self, s):
<span class="gd">-        &quot;&quot;&quot;Sends string ``s`` to the child process, returning the number of</span>
<span class="gi">+        &#39;&#39;&#39;Sends string ``s`` to the child process, returning the number of</span>
<span class="w"> </span>        bytes written. If a logfile is specified, a copy is written to that
<span class="w"> </span>        log.

<span class="gu">@@ -381,7 +545,7 @@ class spawn(SpawnBase):</span>
<span class="w"> </span>            256

<span class="w"> </span>        On such a system, only 256 bytes may be received per line. Any
<span class="gd">-        subsequent bytes received will be discarded. BEL (``&#39;&#39;``) is then</span>
<span class="gi">+        subsequent bytes received will be discarded. BEL (``&#39;\a&#39;``) is then</span>
<span class="w"> </span>        sent to output if IMAXBEL (termios.h) is set by the tty driver.
<span class="w"> </span>        This is usually enabled by default.  Linux does not honor this as
<span class="w"> </span>        an option -- it behaves as though it is always set on.
<span class="gu">@@ -393,62 +557,120 @@ class spawn(SpawnBase):</span>
<span class="w"> </span>            &gt;&gt;&gt; bash.sendline(&#39;stty -icanon&#39;)
<span class="w"> </span>            &gt;&gt;&gt; bash.sendline(&#39;base64&#39;)
<span class="w"> </span>            &gt;&gt;&gt; bash.sendline(&#39;x&#39; * 5000)
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if self.delaybeforesend is not None:</span>
<span class="gi">+            time.sleep(self.delaybeforesend)</span>
<span class="gi">+</span>
<span class="gi">+        s = self._coerce_send_string(s)</span>
<span class="gi">+        self._log(s, &#39;send&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        b = self._encoder.encode(s, final=False)</span>
<span class="gi">+        return os.write(self.child_fd, b)</span>

<span class="w"> </span>    def sendline(self, s=&#39;&#39;):
<span class="gd">-        &quot;&quot;&quot;Wraps send(), sending string ``s`` to child process, with</span>
<span class="gi">+        &#39;&#39;&#39;Wraps send(), sending string ``s`` to child process, with</span>
<span class="w"> </span>        ``os.linesep`` automatically appended. Returns number of bytes
<span class="w"> </span>        written.  Only a limited number of bytes may be sent for each
<span class="w"> </span>        line in the default terminal mode, see docstring of :meth:`send`.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        s = self._coerce_send_string(s)</span>
<span class="gi">+        return self.send(s + self.linesep)</span>

<span class="w"> </span>    def _log_control(self, s):
<span class="w"> </span>        &quot;&quot;&quot;Write control characters to the appropriate log files&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.encoding is not None:</span>
<span class="gi">+            s = s.decode(self.encoding, &#39;replace&#39;)</span>
<span class="gi">+        self._log(s, &#39;send&#39;)</span>

<span class="w"> </span>    def sendcontrol(self, char):
<span class="gd">-        &quot;&quot;&quot;Helper method that wraps send() with mnemonic access for sending control</span>
<span class="gi">+        &#39;&#39;&#39;Helper method that wraps send() with mnemonic access for sending control</span>
<span class="w"> </span>        character to the child (such as Ctrl-C or Ctrl-D).  For example, to send
<span class="gd">-        Ctrl-G (ASCII 7, bell, &#39;&#39;)::</span>
<span class="gi">+        Ctrl-G (ASCII 7, bell, &#39;\a&#39;)::</span>

<span class="w"> </span>            child.sendcontrol(&#39;g&#39;)

<span class="w"> </span>        See also, sendintr() and sendeof().
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        n, byte = self.ptyproc.sendcontrol(char)</span>
<span class="gi">+        self._log_control(byte)</span>
<span class="gi">+        return n</span>

<span class="w"> </span>    def sendeof(self):
<span class="gd">-        &quot;&quot;&quot;This sends an EOF to the child. This sends a character which causes</span>
<span class="gi">+        &#39;&#39;&#39;This sends an EOF to the child. This sends a character which causes</span>
<span class="w"> </span>        the pending parent output buffer to be sent to the waiting child
<span class="w"> </span>        program without waiting for end-of-line. If it is the first character
<span class="w"> </span>        of the line, the read() in the user program returns 0, which signifies
<span class="w"> </span>        end-of-file. This means to work as expected a sendeof() has to be
<span class="w"> </span>        called at the beginning of a line. This method does not send a newline.
<span class="w"> </span>        It is the responsibility of the caller to ensure the eof is sent at the
<span class="gd">-        beginning of a line. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        beginning of a line. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        n, byte = self.ptyproc.sendeof()</span>
<span class="gi">+        self._log_control(byte)</span>

<span class="w"> </span>    def sendintr(self):
<span class="gd">-        &quot;&quot;&quot;This sends a SIGINT to the child. It does not require</span>
<span class="gd">-        the SIGINT to be the first character on a line. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;This sends a SIGINT to the child. It does not require</span>
<span class="gi">+        the SIGINT to be the first character on a line. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        n, byte = self.ptyproc.sendintr()</span>
<span class="gi">+        self._log_control(byte)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def flag_eof(self):</span>
<span class="gi">+        return self.ptyproc.flag_eof</span>
<span class="gi">+</span>
<span class="gi">+    @flag_eof.setter</span>
<span class="gi">+    def flag_eof(self, value):</span>
<span class="gi">+        self.ptyproc.flag_eof = value</span>

<span class="w"> </span>    def eof(self):
<span class="gd">-        &quot;&quot;&quot;This returns True if the EOF exception was ever raised.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;This returns True if the EOF exception was ever raised.</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        return self.flag_eof</span>

<span class="w"> </span>    def terminate(self, force=False):
<span class="gd">-        &quot;&quot;&quot;This forces a child process to terminate. It starts nicely with</span>
<span class="gi">+        &#39;&#39;&#39;This forces a child process to terminate. It starts nicely with</span>
<span class="w"> </span>        SIGHUP and SIGINT. If &quot;force&quot; is True then moves onto SIGKILL. This
<span class="w"> </span>        returns True if the child was terminated. This returns False if the
<span class="gd">-        child could not be terminated. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        child could not be terminated. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if not self.isalive():</span>
<span class="gi">+            return True</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.kill(signal.SIGHUP)</span>
<span class="gi">+            time.sleep(self.delayafterterminate)</span>
<span class="gi">+            if not self.isalive():</span>
<span class="gi">+                return True</span>
<span class="gi">+            self.kill(signal.SIGCONT)</span>
<span class="gi">+            time.sleep(self.delayafterterminate)</span>
<span class="gi">+            if not self.isalive():</span>
<span class="gi">+                return True</span>
<span class="gi">+            self.kill(signal.SIGINT)</span>
<span class="gi">+            time.sleep(self.delayafterterminate)</span>
<span class="gi">+            if not self.isalive():</span>
<span class="gi">+                return True</span>
<span class="gi">+            if force:</span>
<span class="gi">+                self.kill(signal.SIGKILL)</span>
<span class="gi">+                time.sleep(self.delayafterterminate)</span>
<span class="gi">+                if not self.isalive():</span>
<span class="gi">+                    return True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return False</span>
<span class="gi">+            return False</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            # I think there are kernel timing issues that sometimes cause</span>
<span class="gi">+            # this to happen. I think isalive() reports True, but the</span>
<span class="gi">+            # process is dead to the kernel.</span>
<span class="gi">+            # Make one last attempt to see if the kernel is up to date.</span>
<span class="gi">+            time.sleep(self.delayafterterminate)</span>
<span class="gi">+            if not self.isalive():</span>
<span class="gi">+                return True</span>
<span class="gi">+            else:</span>
<span class="gi">+                return False</span>

<span class="w"> </span>    def wait(self):
<span class="gd">-        &quot;&quot;&quot;This waits until the child exits. This is a blocking call. This will</span>
<span class="gi">+        &#39;&#39;&#39;This waits until the child exits. This is a blocking call. This will</span>
<span class="w"> </span>        not read any data from the child, so this will block forever if the
<span class="w"> </span>        child has unread output and has terminated. In other words, the child
<span class="w"> </span>        may have printed output then called exit(), but, the child is
<span class="gu">@@ -457,39 +679,67 @@ class spawn(SpawnBase):</span>
<span class="w"> </span>        This method is non-blocking if :meth:`wait` has already been called
<span class="w"> </span>        previously or :meth:`isalive` method returns False.  It simply returns
<span class="w"> </span>        the previously determined exit status.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        ptyproc = self.ptyproc</span>
<span class="gi">+        with _wrap_ptyprocess_err():</span>
<span class="gi">+            # exception may occur if &quot;Is some other process attempting</span>
<span class="gi">+            # &quot;job control with our child pid?&quot;</span>
<span class="gi">+            exitstatus = ptyproc.wait()</span>
<span class="gi">+        self.status = ptyproc.status</span>
<span class="gi">+        self.exitstatus = ptyproc.exitstatus</span>
<span class="gi">+        self.signalstatus = ptyproc.signalstatus</span>
<span class="gi">+        self.terminated = True</span>
<span class="gi">+</span>
<span class="gi">+        return exitstatus</span>

<span class="w"> </span>    def isalive(self):
<span class="gd">-        &quot;&quot;&quot;This tests if the child process is running or not. This is</span>
<span class="gi">+        &#39;&#39;&#39;This tests if the child process is running or not. This is</span>
<span class="w"> </span>        non-blocking. If the child was terminated then this will read the
<span class="w"> </span>        exitstatus or signalstatus of the child. This returns True if the child
<span class="w"> </span>        process appears to be running or False if not. It can take literally
<span class="gd">-        SECONDS for Solaris to return the right status. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        SECONDS for Solaris to return the right status. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        ptyproc = self.ptyproc</span>
<span class="gi">+        with _wrap_ptyprocess_err():</span>
<span class="gi">+            alive = ptyproc.isalive()</span>
<span class="gi">+</span>
<span class="gi">+        if not alive:</span>
<span class="gi">+            self.status = ptyproc.status</span>
<span class="gi">+            self.exitstatus = ptyproc.exitstatus</span>
<span class="gi">+            self.signalstatus = ptyproc.signalstatus</span>
<span class="gi">+            self.terminated = True</span>
<span class="gi">+</span>
<span class="gi">+        return alive</span>

<span class="w"> </span>    def kill(self, sig):
<span class="gd">-        &quot;&quot;&quot;This sends the given signal to the child application. In keeping</span>
<span class="gi">+</span>
<span class="gi">+        &#39;&#39;&#39;This sends the given signal to the child application. In keeping</span>
<span class="w"> </span>        with UNIX tradition it has a misleading name. It does not necessarily
<span class="gd">-        kill the child unless you send the right signal. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        kill the child unless you send the right signal. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Same as os.kill, but the pid is given for you.</span>
<span class="gi">+        if self.isalive():</span>
<span class="gi">+            os.kill(self.pid, sig)</span>

<span class="w"> </span>    def getwinsize(self):
<span class="gd">-        &quot;&quot;&quot;This returns the terminal window size of the child tty. The return</span>
<span class="gd">-        value is a tuple of (rows, cols). &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;This returns the terminal window size of the child tty. The return</span>
<span class="gi">+        value is a tuple of (rows, cols). &#39;&#39;&#39;</span>
<span class="gi">+        return self.ptyproc.getwinsize()</span>

<span class="w"> </span>    def setwinsize(self, rows, cols):
<span class="gd">-        &quot;&quot;&quot;This sets the terminal window size of the child tty. This will cause</span>
<span class="gi">+        &#39;&#39;&#39;This sets the terminal window size of the child tty. This will cause</span>
<span class="w"> </span>        a SIGWINCH signal to be sent to the child. This does not change the
<span class="w"> </span>        physical window size. It changes the size reported to TTY-aware
<span class="w"> </span>        applications like vi or curses -- applications that respond to the
<span class="gd">-        SIGWINCH signal. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        SIGWINCH signal. &#39;&#39;&#39;</span>
<span class="gi">+        return self.ptyproc.setwinsize(rows, cols)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+    def interact(self, escape_character=chr(29),</span>
<span class="gi">+            input_filter=None, output_filter=None):</span>

<span class="gd">-    def interact(self, escape_character=chr(29), input_filter=None,</span>
<span class="gd">-        output_filter=None):</span>
<span class="gd">-        &quot;&quot;&quot;This gives control of the child process to the interactive user (the</span>
<span class="gi">+        &#39;&#39;&#39;This gives control of the child process to the interactive user (the</span>
<span class="w"> </span>        human at the keyboard). Keystrokes are sent to the child process, and
<span class="w"> </span>        the stdout and stderr output of the child process is printed. This
<span class="w"> </span>        simply echos the child stdout and child stderr to the real stdout and
<span class="gu">@@ -529,26 +779,82 @@ class spawn(SpawnBase):</span>
<span class="w"> </span>            p = pexpect.spawn(&#39;/bin/bash&#39;)
<span class="w"> </span>            signal.signal(signal.SIGWINCH, sigwinch_passthrough)
<span class="w"> </span>            p.interact()
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Flush the buffer.</span>
<span class="gi">+        self.write_to_stdout(self.buffer)</span>
<span class="gi">+        self.stdout.flush()</span>
<span class="gi">+        self._buffer = self.buffer_type()</span>
<span class="gi">+        mode = tty.tcgetattr(self.STDIN_FILENO)</span>
<span class="gi">+        tty.setraw(self.STDIN_FILENO)</span>
<span class="gi">+        if escape_character is not None and PY3:</span>
<span class="gi">+            escape_character = escape_character.encode(&#39;latin-1&#39;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.__interact_copy(escape_character, input_filter, output_filter)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            tty.tcsetattr(self.STDIN_FILENO, tty.TCSAFLUSH, mode)</span>

<span class="w"> </span>    def __interact_writen(self, fd, data):
<span class="gd">-        &quot;&quot;&quot;This is used by the interact() method.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;This is used by the interact() method.</span>
<span class="gi">+        &#39;&#39;&#39;</span>

<span class="gd">-    def __interact_read(self, fd):</span>
<span class="gd">-        &quot;&quot;&quot;This is used by the interact() method.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        while data != b&#39;&#39; and self.isalive():</span>
<span class="gi">+            n = os.write(fd, data)</span>
<span class="gi">+            data = data[n:]</span>

<span class="gd">-    def __interact_copy(self, escape_character=None, input_filter=None,</span>
<span class="gd">-        output_filter=None):</span>
<span class="gd">-        &quot;&quot;&quot;This is used by the interact() method.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def __interact_read(self, fd):</span>
<span class="gi">+        &#39;&#39;&#39;This is used by the interact() method.</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return os.read(fd, 1000)</span>
<span class="gi">+</span>
<span class="gi">+    def __interact_copy(</span>
<span class="gi">+        self, escape_character=None, input_filter=None, output_filter=None</span>
<span class="gi">+    ):</span>
<span class="gi">+</span>
<span class="gi">+        &#39;&#39;&#39;This is used by the interact() method.</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        while self.isalive():</span>
<span class="gi">+            if self.use_poll:</span>
<span class="gi">+                r = poll_ignore_interrupts([self.child_fd, self.STDIN_FILENO])</span>
<span class="gi">+            else:</span>
<span class="gi">+                r, w, e = select_ignore_interrupts(</span>
<span class="gi">+                    [self.child_fd, self.STDIN_FILENO], [], []</span>
<span class="gi">+                )</span>
<span class="gi">+            if self.child_fd in r:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    data = self.__interact_read(self.child_fd)</span>
<span class="gi">+                except OSError as err:</span>
<span class="gi">+                    if err.args[0] == errno.EIO:</span>
<span class="gi">+                        # Linux-style EOF</span>
<span class="gi">+                        break</span>
<span class="gi">+                    raise</span>
<span class="gi">+                if data == b&#39;&#39;:</span>
<span class="gi">+                    # BSD-style EOF</span>
<span class="gi">+                    break</span>
<span class="gi">+                if output_filter:</span>
<span class="gi">+                    data = output_filter(data)</span>
<span class="gi">+                self._log(data, &#39;read&#39;)</span>
<span class="gi">+                os.write(self.STDOUT_FILENO, data)</span>
<span class="gi">+            if self.STDIN_FILENO in r:</span>
<span class="gi">+                data = self.__interact_read(self.STDIN_FILENO)</span>
<span class="gi">+                if input_filter:</span>
<span class="gi">+                    data = input_filter(data)</span>
<span class="gi">+                i = -1</span>
<span class="gi">+                if escape_character is not None:</span>
<span class="gi">+                    i = data.rfind(escape_character)</span>
<span class="gi">+                if i != -1:</span>
<span class="gi">+                    data = data[:i]</span>
<span class="gi">+                    if data:</span>
<span class="gi">+                        self._log(data, &#39;send&#39;)</span>
<span class="gi">+                    self.__interact_writen(self.child_fd, data)</span>
<span class="gi">+                    break</span>
<span class="gi">+                self._log(data, &#39;send&#39;)</span>
<span class="gi">+                self.__interact_writen(self.child_fd, data)</span>


<span class="w"> </span>def spawnu(*args, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;Deprecated: pass encoding to spawn() instead.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kwargs.setdefault(&#39;encoding&#39;, &#39;utf-8&#39;)</span>
<span class="gi">+    return spawn(*args, **kwargs)</span>
<span class="gh">diff --git a/pexpect/pxssh.py b/pexpect/pxssh.py</span>
<span class="gh">index b1c2a86..742f59e 100644</span>
<span class="gd">--- a/pexpect/pxssh.py</span>
<span class="gi">+++ b/pexpect/pxssh.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-&quot;&quot;&quot;This class extends pexpect.spawn to specialize setting up SSH connections.</span>
<span class="gi">+&#39;&#39;&#39;This class extends pexpect.spawn to specialize setting up SSH connections.</span>
<span class="w"> </span>This adds methods for login, logout, and expecting the shell prompt.

<span class="w"> </span>PEXPECT LICENSE
<span class="gu">@@ -18,32 +18,39 @@ PEXPECT LICENSE</span>
<span class="w"> </span>    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<span class="w"> </span>    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>from pexpect import ExceptionPexpect, TIMEOUT, EOF, spawn
<span class="w"> </span>import time
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>import re
<span class="gd">-__all__ = [&#39;ExceptionPxssh&#39;, &#39;pxssh&#39;]</span>

<span class="gi">+__all__ = [&#39;ExceptionPxssh&#39;, &#39;pxssh&#39;]</span>

<span class="gi">+# Exception classes used by this module.</span>
<span class="w"> </span>class ExceptionPxssh(ExceptionPexpect):
<span class="gd">-    &quot;&quot;&quot;Raised for pxssh exceptions.</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gi">+    &#39;&#39;&#39;Raised for pxssh exceptions.</span>
<span class="gi">+    &#39;&#39;&#39;</span>

<span class="w"> </span>if sys.version_info &gt; (3, 0):
<span class="w"> </span>    from shlex import quote
<span class="w"> </span>else:
<span class="gd">-    _find_unsafe = re.compile(&#39;[^\\w@%+=:,./-]&#39;).search</span>
<span class="gi">+    _find_unsafe = re.compile(r&#39;[^\w@%+=:,./-]&#39;).search</span>

<span class="w"> </span>    def quote(s):
<span class="w"> </span>        &quot;&quot;&quot;Return a shell-escaped version of the string *s*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not s:</span>
<span class="gi">+            return &quot;&#39;&#39;&quot;</span>
<span class="gi">+        if _find_unsafe(s) is None:</span>
<span class="gi">+            return s</span>

<span class="gi">+        # use single quotes, and put single quotes into double quotes</span>
<span class="gi">+        # the string $&#39;b is then quoted as &#39;$&#39;&quot;&#39;&quot;&#39;b&#39;</span>
<span class="gi">+        return &quot;&#39;&quot; + s.replace(&quot;&#39;&quot;, &quot;&#39;\&quot;&#39;\&quot;&#39;&quot;) + &quot;&#39;&quot;</span>

<span class="gd">-class pxssh(spawn):</span>
<span class="gd">-    &quot;&quot;&quot;This class extends pexpect.spawn to specialize setting up SSH</span>
<span class="gi">+class pxssh (spawn):</span>
<span class="gi">+    &#39;&#39;&#39;This class extends pexpect.spawn to specialize setting up SSH</span>
<span class="w"> </span>    connections. This adds methods for login, logout, and expecting the shell
<span class="w"> </span>    prompt. It does various tricky things to handle many situations in the SSH
<span class="w"> </span>    login process. For example, if the session is your first login, then pxssh
<span class="gu">@@ -106,59 +113,154 @@ class pxssh(spawn):</span>
<span class="w"> </span>    `debug_command_string` is only for the test suite to confirm that the string
<span class="w"> </span>    generated for SSH is correct, using this will not allow you to do
<span class="w"> </span>    anything other than get a string back from `pxssh.pxssh.login()`.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__ (self, timeout=30, maxread=2000, searchwindowsize=None,</span>
<span class="gi">+                    logfile=None, cwd=None, env=None, ignore_sighup=True, echo=True,</span>
<span class="gi">+                    options={}, encoding=None, codec_errors=&#39;strict&#39;,</span>
<span class="gi">+                    debug_command_string=False, use_poll=False):</span>

<span class="gd">-    def __init__(self, timeout=30, maxread=2000, searchwindowsize=None,</span>
<span class="gd">-        logfile=None, cwd=None, env=None, ignore_sighup=True, echo=True,</span>
<span class="gd">-        options={}, encoding=None, codec_errors=&#39;strict&#39;,</span>
<span class="gd">-        debug_command_string=False, use_poll=False):</span>
<span class="w"> </span>        spawn.__init__(self, None, timeout=timeout, maxread=maxread,
<span class="gd">-            searchwindowsize=searchwindowsize, logfile=logfile, cwd=cwd,</span>
<span class="gd">-            env=env, ignore_sighup=ignore_sighup, echo=echo, encoding=</span>
<span class="gd">-            encoding, codec_errors=codec_errors, use_poll=use_poll)</span>
<span class="gi">+                       searchwindowsize=searchwindowsize, logfile=logfile,</span>
<span class="gi">+                       cwd=cwd, env=env, ignore_sighup=ignore_sighup, echo=echo,</span>
<span class="gi">+                       encoding=encoding, codec_errors=codec_errors, use_poll=use_poll)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.name = &#39;&lt;pxssh&gt;&#39;
<span class="gd">-        self.UNIQUE_PROMPT = &#39;\\[PEXPECT\\][\\$\\#] &#39;</span>
<span class="gi">+</span>
<span class="gi">+        #SUBTLE HACK ALERT! Note that the command that SETS the prompt uses a</span>
<span class="gi">+        #slightly different string than the regular expression to match it. This</span>
<span class="gi">+        #is because when you set the prompt the command will echo back, but we</span>
<span class="gi">+        #don&#39;t want to match the echoed command. So if we make the set command</span>
<span class="gi">+        #slightly different than the regex we eliminate the problem. To make the</span>
<span class="gi">+        #set command different we add a backslash in front of $. The $ doesn&#39;t</span>
<span class="gi">+        #need to be escaped, but it doesn&#39;t hurt and serves to make the set</span>
<span class="gi">+        #prompt command different than the regex.</span>
<span class="gi">+</span>
<span class="gi">+        # used to match the command-line prompt</span>
<span class="gi">+        self.UNIQUE_PROMPT = r&quot;\[PEXPECT\][\$\#] &quot;</span>
<span class="w"> </span>        self.PROMPT = self.UNIQUE_PROMPT
<span class="gd">-        self.PROMPT_SET_SH = &quot;PS1=&#39;[PEXPECT]\\$ &#39;&quot;</span>
<span class="gd">-        self.PROMPT_SET_CSH = &quot;set prompt=&#39;[PEXPECT]\\$ &#39;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # used to set shell command-line prompt to UNIQUE_PROMPT.</span>
<span class="gi">+        self.PROMPT_SET_SH = r&quot;PS1=&#39;[PEXPECT]\$ &#39;&quot;</span>
<span class="gi">+        self.PROMPT_SET_CSH = r&quot;set prompt=&#39;[PEXPECT]\$ &#39;&quot;</span>
<span class="w"> </span>        self.PROMPT_SET_ZSH = &quot;prompt restore;\nPS1=&#39;[PEXPECT]%(!.#.$) &#39;&quot;
<span class="gd">-        self.SSH_OPTS = &quot; -o &#39;PubkeyAuthentication=no&#39;&quot;</span>
<span class="gi">+        self.SSH_OPTS = (&quot; -o &#39;PubkeyAuthentication=no&#39;&quot;)</span>
<span class="gi">+# Disabling host key checking, makes you vulnerable to MITM attacks.</span>
<span class="gi">+#                + &quot; -o &#39;StrictHostKeyChecking=no&#39;&quot;</span>
<span class="gi">+#                + &quot; -o &#39;UserKnownHostsFile /dev/null&#39; &quot;)</span>
<span class="gi">+        # Disabling X11 forwarding gets rid of the annoying SSH_ASKPASS from</span>
<span class="gi">+        # displaying a GUI password dialog. I have not figured out how to</span>
<span class="gi">+        # disable only SSH_ASKPASS without also disabling X11 forwarding.</span>
<span class="gi">+        # Unsetting SSH_ASKPASS on the remote side doesn&#39;t disable it! Annoying!</span>
<span class="gi">+        #self.SSH_OPTS = &quot;-x -o &#39;PubkeyAuthentication=no&#39;&quot;</span>
<span class="w"> </span>        self.force_password = False
<span class="gi">+</span>
<span class="w"> </span>        self.debug_command_string = debug_command_string
<span class="gi">+</span>
<span class="gi">+        # User defined SSH options, eg,</span>
<span class="gi">+        # ssh.otions = dict(StrictHostKeyChecking=&quot;no&quot;,UserKnownHostsFile=&quot;/dev/null&quot;)</span>
<span class="w"> </span>        self.options = options

<span class="w"> </span>    def levenshtein_distance(self, a, b):
<span class="gd">-        &quot;&quot;&quot;This calculates the Levenshtein distance between a and b.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;This calculates the Levenshtein distance between a and b.</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        n, m = len(a), len(b)</span>
<span class="gi">+        if n &gt; m:</span>
<span class="gi">+            a,b = b,a</span>
<span class="gi">+            n,m = m,n</span>
<span class="gi">+        current = range(n+1)</span>
<span class="gi">+        for i in range(1,m+1):</span>
<span class="gi">+            previous, current = current, [i]+[0]*n</span>
<span class="gi">+            for j in range(1,n+1):</span>
<span class="gi">+                add, delete = previous[j]+1, current[j-1]+1</span>
<span class="gi">+                change = previous[j-1]</span>
<span class="gi">+                if a[j-1] != b[i-1]:</span>
<span class="gi">+                    change = change + 1</span>
<span class="gi">+                current[j] = min(add, delete, change)</span>
<span class="gi">+        return current[n]</span>

<span class="w"> </span>    def try_read_prompt(self, timeout_multiplier):
<span class="gd">-        &quot;&quot;&quot;This facilitates using communication timeouts to perform</span>
<span class="gi">+        &#39;&#39;&#39;This facilitates using communication timeouts to perform</span>
<span class="w"> </span>        synchronization as quickly as possible, while supporting high latency
<span class="w"> </span>        connections with a tunable worst case performance. Fast connections
<span class="w"> </span>        should be read almost immediately. Worst case performance for this
<span class="w"> </span>        method is timeout_multiplier * 3 seconds.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # maximum time allowed to read the first response</span>
<span class="gi">+        first_char_timeout = timeout_multiplier * 0.5</span>

<span class="gd">-    def sync_original_prompt(self, sync_multiplier=1.0):</span>
<span class="gd">-        &quot;&quot;&quot;This attempts to find the prompt. Basically, press enter and record</span>
<span class="gi">+        # maximum time allowed between subsequent characters</span>
<span class="gi">+        inter_char_timeout = timeout_multiplier * 0.1</span>
<span class="gi">+</span>
<span class="gi">+        # maximum time for reading the entire prompt</span>
<span class="gi">+        total_timeout = timeout_multiplier * 3.0</span>
<span class="gi">+</span>
<span class="gi">+        prompt = self.string_type()</span>
<span class="gi">+        begin = time.time()</span>
<span class="gi">+        expired = 0.0</span>
<span class="gi">+        timeout = first_char_timeout</span>
<span class="gi">+</span>
<span class="gi">+        while expired &lt; total_timeout:</span>
<span class="gi">+            try:</span>
<span class="gi">+                prompt += self.read_nonblocking(size=1, timeout=timeout)</span>
<span class="gi">+                expired = time.time() - begin # updated total time expired</span>
<span class="gi">+                timeout = inter_char_timeout</span>
<span class="gi">+            except TIMEOUT:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        return prompt</span>
<span class="gi">+</span>
<span class="gi">+    def sync_original_prompt (self, sync_multiplier=1.0):</span>
<span class="gi">+        &#39;&#39;&#39;This attempts to find the prompt. Basically, press enter and record</span>
<span class="w"> </span>        the response; press enter again and record the response; if the two
<span class="w"> </span>        responses are similar then assume we are at the original prompt.
<span class="w"> </span>        This can be a slow function. Worst case with the default sync_multiplier
<span class="w"> </span>        can take 12 seconds. Low latency connections are more likely to fail
<span class="w"> </span>        with a low sync_multiplier. Best case sync time gets worse with a
<span class="gd">-        high sync multiplier (500 ms with default). &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def login(self, server, username=None, password=&#39;&#39;, terminal_type=</span>
<span class="gd">-        &#39;ansi&#39;, original_prompt=&#39;[#$]&#39;, login_timeout=10, port=None,</span>
<span class="gd">-        auto_prompt_reset=True, ssh_key=None, quiet=True, sync_multiplier=1,</span>
<span class="gd">-        check_local_ip=True, password_regex=</span>
<span class="gd">-        &#39;(?i)(?:password:)|(?:passphrase for key)&#39;, ssh_tunnels={},</span>
<span class="gd">-        spawn_local_ssh=True, sync_original_prompt=True, ssh_config=None,</span>
<span class="gd">-        cmd=&#39;ssh&#39;):</span>
<span class="gd">-        &quot;&quot;&quot;This logs the user into the given server.</span>
<span class="gi">+        high sync multiplier (500 ms with default). &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # All of these timing pace values are magic.</span>
<span class="gi">+        # I came up with these based on what seemed reliable for</span>
<span class="gi">+        # connecting to a heavily loaded machine I have.</span>
<span class="gi">+        self.sendline()</span>
<span class="gi">+        time.sleep(0.1)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Clear the buffer before getting the prompt.</span>
<span class="gi">+            self.try_read_prompt(sync_multiplier)</span>
<span class="gi">+        except TIMEOUT:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        self.sendline()</span>
<span class="gi">+        x = self.try_read_prompt(sync_multiplier)</span>
<span class="gi">+</span>
<span class="gi">+        self.sendline()</span>
<span class="gi">+        a = self.try_read_prompt(sync_multiplier)</span>
<span class="gi">+</span>
<span class="gi">+        self.sendline()</span>
<span class="gi">+        b = self.try_read_prompt(sync_multiplier)</span>
<span class="gi">+</span>
<span class="gi">+        ld = self.levenshtein_distance(a,b)</span>
<span class="gi">+        len_a = len(a)</span>
<span class="gi">+        if len_a == 0:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if float(ld)/len_a &lt; 0.4:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    ### TODO: This is getting messy and I&#39;m pretty sure this isn&#39;t perfect.</span>
<span class="gi">+    ### TODO: I need to draw a flow chart for this.</span>
<span class="gi">+    ### TODO: Unit tests for SSH tunnels, remote SSH command exec, disabling original prompt sync</span>
<span class="gi">+    def login (self, server, username=None, password=&#39;&#39;, terminal_type=&#39;ansi&#39;,</span>
<span class="gi">+                original_prompt=r&quot;[#$]&quot;, login_timeout=10, port=None,</span>
<span class="gi">+                auto_prompt_reset=True, ssh_key=None, quiet=True,</span>
<span class="gi">+                sync_multiplier=1, check_local_ip=True,</span>
<span class="gi">+                password_regex=r&#39;(?i)(?:password:)|(?:passphrase for key)&#39;,</span>
<span class="gi">+                ssh_tunnels={}, spawn_local_ssh=True,</span>
<span class="gi">+                sync_original_prompt=True, ssh_config=None, cmd=&#39;ssh&#39;):</span>
<span class="gi">+        &#39;&#39;&#39;This logs the user into the given server.</span>

<span class="w"> </span>        It uses &#39;original_prompt&#39; to try to find the prompt right after login.
<span class="w"> </span>        When it finds the prompt it immediately tries to reset the prompt to
<span class="gu">@@ -204,18 +306,186 @@ class pxssh(spawn):</span>
<span class="w"> </span>        Alter the ``cmd`` to change the ssh client used, or to prepend it with network
<span class="w"> </span>        namespaces. For example ```cmd=&quot;ip netns exec vlan2 ssh&quot;``` to execute the ssh in
<span class="w"> </span>        network namespace named ```vlan```.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def logout(self):</span>
<span class="gd">-        &quot;&quot;&quot;Sends exit to the remote shell.</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        session_regex_array = [&quot;(?i)are you sure you want to continue connecting&quot;, original_prompt, password_regex, &quot;(?i)permission denied&quot;, &quot;(?i)terminal type&quot;, TIMEOUT]</span>
<span class="gi">+        session_init_regex_array = []</span>
<span class="gi">+        session_init_regex_array.extend(session_regex_array)</span>
<span class="gi">+        session_init_regex_array.extend([&quot;(?i)connection closed by remote host&quot;, EOF])</span>
<span class="gi">+</span>
<span class="gi">+        ssh_options = &#39;&#39;.join([&quot; -o &#39;%s=%s&#39;&quot; % (o, v) for (o, v) in self.options.items()])</span>
<span class="gi">+        if quiet:</span>
<span class="gi">+            ssh_options = ssh_options + &#39; -q&#39;</span>
<span class="gi">+        if not check_local_ip:</span>
<span class="gi">+            ssh_options = ssh_options + &quot; -o&#39;NoHostAuthenticationForLocalhost=yes&#39;&quot;</span>
<span class="gi">+        if self.force_password:</span>
<span class="gi">+            ssh_options = ssh_options + &#39; &#39; + self.SSH_OPTS</span>
<span class="gi">+        if ssh_config is not None:</span>
<span class="gi">+            if spawn_local_ssh and not os.path.isfile(ssh_config):</span>
<span class="gi">+                raise ExceptionPxssh(&#39;SSH config does not exist or is not a file.&#39;)</span>
<span class="gi">+            ssh_options = ssh_options + &#39; -F &#39; + ssh_config</span>
<span class="gi">+        if port is not None:</span>
<span class="gi">+            ssh_options = ssh_options + &#39; -p %s&#39;%(str(port))</span>
<span class="gi">+        if ssh_key is not None:</span>
<span class="gi">+            # Allow forwarding our SSH key to the current session</span>
<span class="gi">+            if ssh_key==True:</span>
<span class="gi">+                ssh_options = ssh_options + &#39; -A&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                if spawn_local_ssh and not os.path.isfile(ssh_key):</span>
<span class="gi">+                    raise ExceptionPxssh(&#39;private ssh key does not exist or is not a file.&#39;)</span>
<span class="gi">+                ssh_options = ssh_options + &#39; -i %s&#39; % (ssh_key)</span>
<span class="gi">+</span>
<span class="gi">+        # SSH tunnels, make sure you know what you&#39;re putting into the lists</span>
<span class="gi">+        # under each heading. Do not expect these to open 100% of the time,</span>
<span class="gi">+        # The port you&#39;re requesting might be bound.</span>
<span class="gi">+        #</span>
<span class="gi">+        # The structure should be like this:</span>
<span class="gi">+        # { &#39;local&#39;: [&#39;2424:localhost:22&#39;],  # Local SSH tunnels</span>
<span class="gi">+        # &#39;remote&#39;: [&#39;2525:localhost:22&#39;],   # Remote SSH tunnels</span>
<span class="gi">+        # &#39;dynamic&#39;: [8888] } # Dynamic/SOCKS tunnels</span>
<span class="gi">+        if ssh_tunnels!={} and isinstance({},type(ssh_tunnels)):</span>
<span class="gi">+            tunnel_types = {</span>
<span class="gi">+                &#39;local&#39;:&#39;L&#39;,</span>
<span class="gi">+                &#39;remote&#39;:&#39;R&#39;,</span>
<span class="gi">+                &#39;dynamic&#39;:&#39;D&#39;</span>
<span class="gi">+            }</span>
<span class="gi">+            for tunnel_type in tunnel_types:</span>
<span class="gi">+                cmd_type = tunnel_types[tunnel_type]</span>
<span class="gi">+                if tunnel_type in ssh_tunnels:</span>
<span class="gi">+                    tunnels = ssh_tunnels[tunnel_type]</span>
<span class="gi">+                    for tunnel in tunnels:</span>
<span class="gi">+                        if spawn_local_ssh==False:</span>
<span class="gi">+                            tunnel = quote(str(tunnel))</span>
<span class="gi">+                        ssh_options = ssh_options + &#39; -&#39; + cmd_type + &#39; &#39; + str(tunnel)</span>
<span class="gi">+</span>
<span class="gi">+        if username is not None:</span>
<span class="gi">+            ssh_options = ssh_options + &#39; -l &#39; + username</span>
<span class="gi">+        elif ssh_config is None:</span>
<span class="gi">+            raise TypeError(&#39;login() needs either a username or an ssh_config&#39;)</span>
<span class="gi">+        else:  # make sure ssh_config has an entry for the server with a username</span>
<span class="gi">+            with open(ssh_config, &#39;rt&#39;) as f:</span>
<span class="gi">+                lines = [l.strip() for l in f.readlines()]</span>
<span class="gi">+</span>
<span class="gi">+            server_regex = r&#39;^Host\s+%s\s*$&#39; % server</span>
<span class="gi">+            user_regex = r&#39;^User\s+\w+\s*$&#39;</span>
<span class="gi">+            config_has_server = False</span>
<span class="gi">+            server_has_username = False</span>
<span class="gi">+            for line in lines:</span>
<span class="gi">+                if not config_has_server and re.match(server_regex, line, re.IGNORECASE):</span>
<span class="gi">+                    config_has_server = True</span>
<span class="gi">+                elif config_has_server and &#39;hostname&#39; in line.lower():</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif config_has_server and &#39;host&#39; in line.lower():</span>
<span class="gi">+                    server_has_username = False  # insurance</span>
<span class="gi">+                    break  # we have left the relevant section</span>
<span class="gi">+                elif config_has_server and re.match(user_regex, line, re.IGNORECASE):</span>
<span class="gi">+                    server_has_username = True</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            if lines:</span>
<span class="gi">+                del line</span>
<span class="gi">+</span>
<span class="gi">+            del lines</span>
<span class="gi">+</span>
<span class="gi">+            if not config_has_server:</span>
<span class="gi">+                raise TypeError(&#39;login() ssh_config has no Host entry for %s&#39; % server)</span>
<span class="gi">+            elif not server_has_username:</span>
<span class="gi">+                raise TypeError(&#39;login() ssh_config has no user entry for %s&#39; % server)</span>
<span class="gi">+</span>
<span class="gi">+        cmd += &quot; %s %s&quot; % (ssh_options, server)</span>
<span class="gi">+        if self.debug_command_string:</span>
<span class="gi">+            return(cmd)</span>
<span class="gi">+</span>
<span class="gi">+        # Are we asking for a local ssh command or to spawn one in another session?</span>
<span class="gi">+        if spawn_local_ssh:</span>
<span class="gi">+            spawn._spawn(self, cmd)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.sendline(cmd)</span>
<span class="gi">+</span>
<span class="gi">+        # This does not distinguish between a remote server &#39;password&#39; prompt</span>
<span class="gi">+        # and a local ssh &#39;passphrase&#39; prompt (for unlocking a private key).</span>
<span class="gi">+        i = self.expect(session_init_regex_array, timeout=login_timeout)</span>
<span class="gi">+</span>
<span class="gi">+        # First phase</span>
<span class="gi">+        if i==0:</span>
<span class="gi">+            # New certificate -- always accept it.</span>
<span class="gi">+            # This is what you get if SSH does not have the remote host&#39;s</span>
<span class="gi">+            # public key stored in the &#39;known_hosts&#39; cache.</span>
<span class="gi">+            self.sendline(&quot;yes&quot;)</span>
<span class="gi">+            i = self.expect(session_regex_array)</span>
<span class="gi">+        if i==2: # password or passphrase</span>
<span class="gi">+            self.sendline(password)</span>
<span class="gi">+            i = self.expect(session_regex_array)</span>
<span class="gi">+        if i==4:</span>
<span class="gi">+            self.sendline(terminal_type)</span>
<span class="gi">+            i = self.expect(session_regex_array)</span>
<span class="gi">+        if i==7:</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            raise ExceptionPxssh(&#39;Could not establish connection to host&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Second phase</span>
<span class="gi">+        if i==0:</span>
<span class="gi">+            # This is weird. This should not happen twice in a row.</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            raise ExceptionPxssh(&#39;Weird error. Got &quot;are you sure&quot; prompt twice.&#39;)</span>
<span class="gi">+        elif i==1: # can occur if you have a public key pair set to authenticate.</span>
<span class="gi">+            ### TODO: May NOT be OK if expect() got tricked and matched a false prompt.</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif i==2: # password prompt again</span>
<span class="gi">+            # For incorrect passwords, some ssh servers will</span>
<span class="gi">+            # ask for the password again, others return &#39;denied&#39; right away.</span>
<span class="gi">+            # If we get the password prompt again then this means</span>
<span class="gi">+            # we didn&#39;t get the password right the first time.</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            raise ExceptionPxssh(&#39;password refused&#39;)</span>
<span class="gi">+        elif i==3: # permission denied -- password was bad.</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            raise ExceptionPxssh(&#39;permission denied&#39;)</span>
<span class="gi">+        elif i==4: # terminal type again? WTF?</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            raise ExceptionPxssh(&#39;Weird error. Got &quot;terminal type&quot; prompt twice.&#39;)</span>
<span class="gi">+        elif i==5: # Timeout</span>
<span class="gi">+            #This is tricky... I presume that we are at the command-line prompt.</span>
<span class="gi">+            #It may be that the shell prompt was so weird that we couldn&#39;t match</span>
<span class="gi">+            #it. Or it may be that we couldn&#39;t log in for some other reason. I</span>
<span class="gi">+            #can&#39;t be sure, but it&#39;s safe to guess that we did login because if</span>
<span class="gi">+            #I presume wrong and we are not logged in then this should be caught</span>
<span class="gi">+            #later when I try to set the shell prompt.</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif i==6: # Connection closed by remote host</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            raise ExceptionPxssh(&#39;connection closed&#39;)</span>
<span class="gi">+        else: # Unexpected</span>
<span class="gi">+            self.close()</span>
<span class="gi">+            raise ExceptionPxssh(&#39;unexpected login response&#39;)</span>
<span class="gi">+        if sync_original_prompt:</span>
<span class="gi">+            if not self.sync_original_prompt(sync_multiplier):</span>
<span class="gi">+                self.close()</span>
<span class="gi">+                raise ExceptionPxssh(&#39;could not synchronize with original prompt&#39;)</span>
<span class="gi">+        # We appear to be in.</span>
<span class="gi">+        # set shell prompt to something unique.</span>
<span class="gi">+        if auto_prompt_reset:</span>
<span class="gi">+            if not self.set_unique_prompt():</span>
<span class="gi">+                self.close()</span>
<span class="gi">+                raise ExceptionPxssh(&#39;could not set shell prompt &#39;</span>
<span class="gi">+                                     &#39;(received: %r, expected: %r).&#39; % (</span>
<span class="gi">+                                         self.before, self.PROMPT,))</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def logout (self):</span>
<span class="gi">+        &#39;&#39;&#39;Sends exit to the remote shell.</span>

<span class="w"> </span>        If there are stopped jobs then this automatically sends exit twice.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        self.sendline(&quot;exit&quot;)</span>
<span class="gi">+        index = self.expect([EOF, &quot;(?i)there are stopped jobs&quot;])</span>
<span class="gi">+        if index==1:</span>
<span class="gi">+            self.sendline(&quot;exit&quot;)</span>
<span class="gi">+            self.expect(EOF)</span>
<span class="gi">+        self.close()</span>

<span class="w"> </span>    def prompt(self, timeout=-1):
<span class="gd">-        &quot;&quot;&quot;Match the next shell prompt.</span>
<span class="gi">+        &#39;&#39;&#39;Match the next shell prompt.</span>

<span class="w"> </span>        This is little more than a short-cut to the :meth:`~pexpect.spawn.expect`
<span class="w"> </span>        method. Note that if you called :meth:`login` with
<span class="gu">@@ -229,11 +499,17 @@ class pxssh(spawn):</span>

<span class="w"> </span>        :return: True if the shell prompt was matched, False if the timeout was
<span class="w"> </span>                 reached.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if timeout == -1:</span>
<span class="gi">+            timeout = self.timeout</span>
<span class="gi">+        i = self.expect([self.PROMPT, TIMEOUT], timeout=timeout)</span>
<span class="gi">+        if i==1:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def set_unique_prompt(self):
<span class="gd">-        &quot;&quot;&quot;This sets the remote prompt to something more unique than ``#`` or ``$``.</span>
<span class="gi">+        &#39;&#39;&#39;This sets the remote prompt to something more unique than ``#`` or ``$``.</span>
<span class="w"> </span>        This makes it easier for the :meth:`prompt` method to match the shell prompt
<span class="w"> </span>        unambiguously. This method is called automatically by the :meth:`login`
<span class="w"> </span>        method, but you may want to call it manually if you somehow reset the
<span class="gu">@@ -246,5 +522,19 @@ class pxssh(spawn):</span>
<span class="w"> </span>        should call :meth:`login` with ``auto_prompt_reset=False``; then set the
<span class="w"> </span>        :attr:`PROMPT` attribute to a regular expression. After that, the
<span class="w"> </span>        :meth:`prompt` method will try to match your prompt pattern.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.sendline(&quot;unset PROMPT_COMMAND&quot;)</span>
<span class="gi">+        self.sendline(self.PROMPT_SET_SH) # sh-style</span>
<span class="gi">+        i = self.expect ([TIMEOUT, self.PROMPT], timeout=10)</span>
<span class="gi">+        if i == 0: # csh-style</span>
<span class="gi">+            self.sendline(self.PROMPT_SET_CSH)</span>
<span class="gi">+            i = self.expect([TIMEOUT, self.PROMPT], timeout=10)</span>
<span class="gi">+            if i == 0: # zsh-style</span>
<span class="gi">+                self.sendline(self.PROMPT_SET_ZSH)</span>
<span class="gi">+                i = self.expect([TIMEOUT, self.PROMPT], timeout=10)</span>
<span class="gi">+                if i == 0:</span>
<span class="gi">+                    return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+# vi:ts=4:sw=4:expandtab:ft=python:</span>
<span class="gh">diff --git a/pexpect/replwrap.py b/pexpect/replwrap.py</span>
<span class="gh">index 07a3d64..08dbd5e 100644</span>
<span class="gd">--- a/pexpect/replwrap.py</span>
<span class="gi">+++ b/pexpect/replwrap.py</span>
<span class="gu">@@ -3,14 +3,17 @@</span>
<span class="w"> </span>import os.path
<span class="w"> </span>import signal
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>import pexpect
<span class="gd">-PY3 = sys.version_info[0] &gt;= 3</span>
<span class="gi">+</span>
<span class="gi">+PY3 = (sys.version_info[0] &gt;= 3)</span>
<span class="gi">+</span>
<span class="w"> </span>if PY3:
<span class="w"> </span>    basestring = str
<span class="gi">+</span>
<span class="w"> </span>PEXPECT_PROMPT = u&#39;[PEXPECT_PROMPT&gt;&#39;
<span class="w"> </span>PEXPECT_CONTINUATION_PROMPT = u&#39;[PEXPECT_PROMPT+&#39;

<span class="gd">-</span>
<span class="w"> </span>class REPLWrapper(object):
<span class="w"> </span>    &quot;&quot;&quot;Wrapper for a REPL.

<span class="gu">@@ -27,29 +30,41 @@ class REPLWrapper(object):</span>
<span class="w"> </span>    :param str extra_init_cmd: Commands to do extra initialisation, such as
<span class="w"> </span>      disabling pagers.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-</span>
<span class="gd">-    def __init__(self, cmd_or_spawn, orig_prompt, prompt_change, new_prompt</span>
<span class="gd">-        =PEXPECT_PROMPT, continuation_prompt=PEXPECT_CONTINUATION_PROMPT,</span>
<span class="gd">-        extra_init_cmd=None):</span>
<span class="gi">+    def __init__(self, cmd_or_spawn, orig_prompt, prompt_change,</span>
<span class="gi">+                 new_prompt=PEXPECT_PROMPT,</span>
<span class="gi">+                 continuation_prompt=PEXPECT_CONTINUATION_PROMPT,</span>
<span class="gi">+                 extra_init_cmd=None):</span>
<span class="w"> </span>        if isinstance(cmd_or_spawn, basestring):
<span class="gd">-            self.child = pexpect.spawn(cmd_or_spawn, echo=False, encoding=</span>
<span class="gd">-                &#39;utf-8&#39;)</span>
<span class="gi">+            self.child = pexpect.spawn(cmd_or_spawn, echo=False, encoding=&#39;utf-8&#39;)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.child = cmd_or_spawn
<span class="w"> </span>        if self.child.echo:
<span class="gi">+            # Existing spawn instance has echo enabled, disable it</span>
<span class="gi">+            # to prevent our input from being repeated to output.</span>
<span class="w"> </span>            self.child.setecho(False)
<span class="w"> </span>            self.child.waitnoecho()
<span class="gi">+</span>
<span class="w"> </span>        if prompt_change is None:
<span class="w"> </span>            self.prompt = orig_prompt
<span class="w"> </span>        else:
<span class="gd">-            self.set_prompt(orig_prompt, prompt_change.format(new_prompt,</span>
<span class="gd">-                continuation_prompt))</span>
<span class="gi">+            self.set_prompt(orig_prompt,</span>
<span class="gi">+                        prompt_change.format(new_prompt, continuation_prompt))</span>
<span class="w"> </span>            self.prompt = new_prompt
<span class="w"> </span>        self.continuation_prompt = continuation_prompt
<span class="gi">+</span>
<span class="w"> </span>        self._expect_prompt()
<span class="gi">+</span>
<span class="w"> </span>        if extra_init_cmd is not None:
<span class="w"> </span>            self.run_command(extra_init_cmd)

<span class="gi">+    def set_prompt(self, orig_prompt, prompt_change):</span>
<span class="gi">+        self.child.expect(orig_prompt)</span>
<span class="gi">+        self.child.sendline(prompt_change)</span>
<span class="gi">+</span>
<span class="gi">+    def _expect_prompt(self, timeout=-1, async_=False):</span>
<span class="gi">+        return self.child.expect_exact([self.prompt, self.continuation_prompt],</span>
<span class="gi">+                                       timeout=timeout, async_=async_)</span>
<span class="gi">+</span>
<span class="w"> </span>    def run_command(self, command, timeout=-1, async_=False):
<span class="w"> </span>        &quot;&quot;&quot;Send a command to the REPL, wait for and return output.

<span class="gu">@@ -65,19 +80,57 @@ class REPLWrapper(object):</span>
<span class="w"> </span>          :mod:`asyncio` Future, which you can yield from to get the same
<span class="w"> </span>          result that this method would normally give directly.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Split up multiline commands and feed them in bit-by-bit</span>
<span class="gi">+        cmdlines = command.splitlines()</span>
<span class="gi">+        # splitlines ignores trailing newlines - add it back in manually</span>
<span class="gi">+        if command.endswith(&#39;\n&#39;):</span>
<span class="gi">+            cmdlines.append(&#39;&#39;)</span>
<span class="gi">+        if not cmdlines:</span>
<span class="gi">+            raise ValueError(&quot;No command was given&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if async_:</span>
<span class="gi">+            from ._async import repl_run_command_async</span>
<span class="gi">+            return repl_run_command_async(self, cmdlines, timeout)</span>

<span class="gi">+        res = []</span>
<span class="gi">+        self.child.sendline(cmdlines[0])</span>
<span class="gi">+        for line in cmdlines[1:]:</span>
<span class="gi">+            self._expect_prompt(timeout=timeout)</span>
<span class="gi">+            res.append(self.child.before)</span>
<span class="gi">+            self.child.sendline(line)</span>
<span class="gi">+</span>
<span class="gi">+        # Command was fully submitted, now wait for the next prompt</span>
<span class="gi">+        if self._expect_prompt(timeout=timeout) == 1:</span>
<span class="gi">+            # We got the continuation prompt - command was incomplete</span>
<span class="gi">+            self.child.kill(signal.SIGINT)</span>
<span class="gi">+            self._expect_prompt(timeout=1)</span>
<span class="gi">+            raise ValueError(&quot;Continuation prompt found - input was incomplete:\n&quot;</span>
<span class="gi">+                             + command)</span>
<span class="gi">+        return u&#39;&#39;.join(res + [self.child.before])</span>

<span class="w"> </span>def python(command=sys.executable):
<span class="w"> </span>    &quot;&quot;&quot;Start a Python shell and return a :class:`REPLWrapper` object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return REPLWrapper(command, u&quot;&gt;&gt;&gt; &quot;, u&quot;import sys; sys.ps1={0!r}; sys.ps2={1!r}&quot;)</span>

<span class="gi">+def _repl_sh(command, args, non_printable_insert):</span>
<span class="gi">+    child = pexpect.spawn(command, args, echo=False, encoding=&#39;utf-8&#39;)</span>

<span class="gd">-def bash(command=&#39;bash&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Start a bash shell and return a :class:`REPLWrapper` object.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    # If the user runs &#39;env&#39;, the value of PS1 will be in the output. To avoid</span>
<span class="gi">+    # replwrap seeing that as the next prompt, we&#39;ll embed the marker characters</span>
<span class="gi">+    # for invisible characters in the prompt; these show up when inspecting the</span>
<span class="gi">+    # environment variable, but not when bash displays the prompt.</span>
<span class="gi">+    ps1 = PEXPECT_PROMPT[:5] + non_printable_insert + PEXPECT_PROMPT[5:]</span>
<span class="gi">+    ps2 = PEXPECT_CONTINUATION_PROMPT[:5] + non_printable_insert + PEXPECT_CONTINUATION_PROMPT[5:]</span>
<span class="gi">+    prompt_change = u&quot;PS1=&#39;{0}&#39; PS2=&#39;{1}&#39; PROMPT_COMMAND=&#39;&#39;&quot;.format(ps1, ps2)</span>

<span class="gi">+    return REPLWrapper(child, u&#39;\\$&#39;, prompt_change,</span>
<span class="gi">+                       extra_init_cmd=&quot;export PAGER=cat&quot;)</span>
<span class="gi">+</span>
<span class="gi">+def bash(command=&quot;bash&quot;):</span>
<span class="gi">+    &quot;&quot;&quot;Start a bash shell and return a :class:`REPLWrapper` object.&quot;&quot;&quot;</span>
<span class="gi">+    bashrc = os.path.join(os.path.dirname(__file__), &#39;bashrc.sh&#39;)</span>
<span class="gi">+    return _repl_sh(command, [&#39;--rcfile&#39;, bashrc], non_printable_insert=&#39;\\[\\]&#39;)</span>

<span class="gd">-def zsh(command=&#39;zsh&#39;, args=(&#39;--no-rcs&#39;, &#39;-V&#39;, &#39;+Z&#39;)):</span>
<span class="gi">+def zsh(command=&quot;zsh&quot;, args=(&quot;--no-rcs&quot;, &quot;-V&quot;, &quot;+Z&quot;)):</span>
<span class="w"> </span>    &quot;&quot;&quot;Start a zsh shell and return a :class:`REPLWrapper` object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _repl_sh(command, list(args), non_printable_insert=&#39;%(!..)&#39;)</span>
<span class="gh">diff --git a/pexpect/run.py b/pexpect/run.py</span>
<span class="gh">index 8710741..5695ab7 100644</span>
<span class="gd">--- a/pexpect/run.py</span>
<span class="gi">+++ b/pexpect/run.py</span>
<span class="gu">@@ -1,12 +1,13 @@</span>
<span class="w"> </span>import sys
<span class="w"> </span>import types
<span class="gi">+</span>
<span class="w"> </span>from .exceptions import EOF, TIMEOUT
<span class="w"> </span>from .pty_spawn import spawn

<span class="gi">+def run(command, timeout=30, withexitstatus=False, events=None,</span>
<span class="gi">+        extra_args=None, logfile=None, cwd=None, env=None, **kwargs):</span>

<span class="gd">-def run(command, timeout=30, withexitstatus=False, events=None, extra_args=</span>
<span class="gd">-    None, logfile=None, cwd=None, env=None, **kwargs):</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    This function runs the given command; waits for it to finish; then
<span class="w"> </span>    returns all output as a string. STDERR is included in output. If the full
<span class="w"> </span>    path to the command is not given then the path is searched.
<span class="gu">@@ -90,12 +91,67 @@ def run(command, timeout=30, withexitstatus=False, events=None, extra_args=</span>
<span class="w"> </span>    Like :class:`spawn`, passing *encoding* will make it work with unicode
<span class="w"> </span>    instead of bytes. You can pass *codec_errors* to control how errors in
<span class="w"> </span>    encoding and decoding are handled.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def runu(command, timeout=30, withexitstatus=False, events=None, extra_args</span>
<span class="gd">-    =None, logfile=None, cwd=None, env=None, **kwargs):</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+    if timeout == -1:</span>
<span class="gi">+        child = spawn(command, maxread=2000, logfile=logfile, cwd=cwd, env=env,</span>
<span class="gi">+                        **kwargs)</span>
<span class="gi">+    else:</span>
<span class="gi">+        child = spawn(command, timeout=timeout, maxread=2000, logfile=logfile,</span>
<span class="gi">+                cwd=cwd, env=env, **kwargs)</span>
<span class="gi">+    if isinstance(events, list):</span>
<span class="gi">+        patterns= [x for x,y in events]</span>
<span class="gi">+        responses = [y for x,y in events]</span>
<span class="gi">+    elif isinstance(events, dict):</span>
<span class="gi">+        patterns = list(events.keys())</span>
<span class="gi">+        responses = list(events.values())</span>
<span class="gi">+    else:</span>
<span class="gi">+        # This assumes EOF or TIMEOUT will eventually cause run to terminate.</span>
<span class="gi">+        patterns = None</span>
<span class="gi">+        responses = None</span>
<span class="gi">+    child_result_list = []</span>
<span class="gi">+    event_count = 0</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            index = child.expect(patterns)</span>
<span class="gi">+            if isinstance(child.after, child.allowed_string_types):</span>
<span class="gi">+                child_result_list.append(child.before + child.after)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # child.after may have been a TIMEOUT or EOF,</span>
<span class="gi">+                # which we don&#39;t want appended to the list.</span>
<span class="gi">+                child_result_list.append(child.before)</span>
<span class="gi">+            if isinstance(responses[index], child.allowed_string_types):</span>
<span class="gi">+                child.send(responses[index])</span>
<span class="gi">+            elif (isinstance(responses[index], types.FunctionType) or</span>
<span class="gi">+                  isinstance(responses[index], types.MethodType)):</span>
<span class="gi">+                callback_result = responses[index](locals())</span>
<span class="gi">+                sys.stdout.flush()</span>
<span class="gi">+                if isinstance(callback_result, child.allowed_string_types):</span>
<span class="gi">+                    child.send(callback_result)</span>
<span class="gi">+                elif callback_result:</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(&quot;parameter `event&#39; at index {index} must be &quot;</span>
<span class="gi">+                                &quot;a string, method, or function: {value!r}&quot;</span>
<span class="gi">+                                .format(index=index, value=responses[index]))</span>
<span class="gi">+            event_count = event_count + 1</span>
<span class="gi">+        except TIMEOUT:</span>
<span class="gi">+            child_result_list.append(child.before)</span>
<span class="gi">+            break</span>
<span class="gi">+        except EOF:</span>
<span class="gi">+            child_result_list.append(child.before)</span>
<span class="gi">+            break</span>
<span class="gi">+    child_result = child.string_type().join(child_result_list)</span>
<span class="gi">+    if withexitstatus:</span>
<span class="gi">+        child.close()</span>
<span class="gi">+        return (child_result, child.exitstatus)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return child_result</span>
<span class="gi">+</span>
<span class="gi">+def runu(command, timeout=30, withexitstatus=False, events=None,</span>
<span class="gi">+        extra_args=None, logfile=None, cwd=None, env=None, **kwargs):</span>
<span class="w"> </span>    &quot;&quot;&quot;Deprecated: pass encoding to run() instead.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kwargs.setdefault(&#39;encoding&#39;, &#39;utf-8&#39;)</span>
<span class="gi">+    return run(command, timeout=timeout, withexitstatus=withexitstatus,</span>
<span class="gi">+                events=events, extra_args=extra_args, logfile=logfile, cwd=cwd,</span>
<span class="gi">+                env=env, **kwargs)</span>
<span class="gh">diff --git a/pexpect/screen.py b/pexpect/screen.py</span>
<span class="gh">index c1cb2a3..79f95c4 100644</span>
<span class="gd">--- a/pexpect/screen.py</span>
<span class="gi">+++ b/pexpect/screen.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-&quot;&quot;&quot;This implements a virtual screen. This is used to support ANSI terminal</span>
<span class="gi">+&#39;&#39;&#39;This implements a virtual screen. This is used to support ANSI terminal</span>
<span class="w"> </span>emulation. The screen representation and state is implemented in this class.
<span class="w"> </span>Most of the methods are inspired by ANSI screen control codes. The
<span class="w"> </span>:class:`~pexpect.ANSI.ANSI` class extends this class to add parsing of ANSI
<span class="gu">@@ -21,44 +21,54 @@ PEXPECT LICENSE</span>
<span class="w"> </span>    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<span class="w"> </span>    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>import codecs
<span class="w"> </span>import copy
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>import warnings
<span class="gd">-warnings.warn(</span>
<span class="gd">-    &#39;pexpect.screen and pexpect.ANSI are deprecated. We recommend using pyte to emulate a terminal screen: https://pypi.python.org/pypi/pyte&#39;</span>
<span class="gd">-    , stacklevel=2)</span>
<span class="gd">-NUL = 0</span>
<span class="gd">-ENQ = 5</span>
<span class="gd">-BEL = 7</span>
<span class="gd">-BS = 8</span>
<span class="gd">-HT = 9</span>
<span class="gd">-LF = 10</span>
<span class="gd">-VT = 11</span>
<span class="gd">-FF = 12</span>
<span class="gd">-CR = 13</span>
<span class="gd">-SO = 14</span>
<span class="gd">-SI = 15</span>
<span class="gd">-XON = 17</span>
<span class="gd">-XOFF = 19</span>
<span class="gd">-CAN = 24</span>
<span class="gd">-SUB = 26</span>
<span class="gd">-ESC = 27</span>
<span class="gd">-DEL = 127</span>
<span class="gd">-SPACE = u&#39; &#39;</span>
<span class="gd">-PY3 = sys.version_info[0] &gt;= 3</span>
<span class="gi">+</span>
<span class="gi">+warnings.warn((&quot;pexpect.screen and pexpect.ANSI are deprecated. &quot;</span>
<span class="gi">+               &quot;We recommend using pyte to emulate a terminal screen: &quot;</span>
<span class="gi">+               &quot;https://pypi.python.org/pypi/pyte&quot;),</span>
<span class="gi">+               stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+NUL = 0    # Fill character; ignored on input.</span>
<span class="gi">+ENQ = 5    # Transmit answerback message.</span>
<span class="gi">+BEL = 7    # Ring the bell.</span>
<span class="gi">+BS  = 8    # Move cursor left.</span>
<span class="gi">+HT  = 9    # Move cursor to next tab stop.</span>
<span class="gi">+LF = 10    # Line feed.</span>
<span class="gi">+VT = 11    # Same as LF.</span>
<span class="gi">+FF = 12    # Same as LF.</span>
<span class="gi">+CR = 13    # Move cursor to left margin or newline.</span>
<span class="gi">+SO = 14    # Invoke G1 character set.</span>
<span class="gi">+SI = 15    # Invoke G0 character set.</span>
<span class="gi">+XON = 17   # Resume transmission.</span>
<span class="gi">+XOFF = 19  # Halt transmission.</span>
<span class="gi">+CAN = 24   # Cancel escape sequence.</span>
<span class="gi">+SUB = 26   # Same as CAN.</span>
<span class="gi">+ESC = 27   # Introduce a control sequence.</span>
<span class="gi">+DEL = 127  # Fill character; ignored on input.</span>
<span class="gi">+SPACE = u&#39; &#39; # Space or blank character.</span>
<span class="gi">+</span>
<span class="gi">+PY3 = (sys.version_info[0] &gt;= 3)</span>
<span class="w"> </span>if PY3:
<span class="w"> </span>    unicode = str

<span class="gi">+def constrain (n, min, max):</span>

<span class="gd">-def constrain(n, min, max):</span>
<span class="gd">-    &quot;&quot;&quot;This returns a number, n constrained to the min and max bounds. &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &#39;&#39;&#39;This returns a number, n constrained to the min and max bounds. &#39;&#39;&#39;</span>

<span class="gi">+    if n &lt; min:</span>
<span class="gi">+        return min</span>
<span class="gi">+    if n &gt; max:</span>
<span class="gi">+        return max</span>
<span class="gi">+    return n</span>

<span class="w"> </span>class screen:
<span class="gd">-    &quot;&quot;&quot;This object maintains the state of a virtual text screen as a</span>
<span class="gi">+    &#39;&#39;&#39;This object maintains the state of a virtual text screen as a</span>
<span class="w"> </span>    rectangular array. This maintains a virtual cursor position and handles
<span class="w"> </span>    scrolling as characters are added. This supports most of the methods needed
<span class="w"> </span>    by an ANSI text screen. Row and column indexes are 1-based (not zero-based,
<span class="gu">@@ -71,18 +81,16 @@ class screen:</span>
<span class="w"> </span>    unicode strings, with the exception of __str__() under Python 2. Passing
<span class="w"> </span>    ``encoding=None`` limits the API to only accept unicode input, so passing
<span class="w"> </span>    bytes in will raise :exc:`TypeError`.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+    def __init__(self, r=24, c=80, encoding=&#39;latin-1&#39;, encoding_errors=&#39;replace&#39;):</span>
<span class="gi">+        &#39;&#39;&#39;This initializes a blank screen of the given dimensions.&#39;&#39;&#39;</span>

<span class="gd">-    def __init__(self, r=24, c=80, encoding=&#39;latin-1&#39;, encoding_errors=</span>
<span class="gd">-        &#39;replace&#39;):</span>
<span class="gd">-        &quot;&quot;&quot;This initializes a blank screen of the given dimensions.&quot;&quot;&quot;</span>
<span class="w"> </span>        self.rows = r
<span class="w"> </span>        self.cols = c
<span class="w"> </span>        self.encoding = encoding
<span class="w"> </span>        self.encoding_errors = encoding_errors
<span class="w"> </span>        if encoding is not None:
<span class="gd">-            self.decoder = codecs.getincrementaldecoder(encoding)(</span>
<span class="gd">-                encoding_errors)</span>
<span class="gi">+            self.decoder = codecs.getincrementaldecoder(encoding)(encoding_errors)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.decoder = None
<span class="w"> </span>        self.cur_r = 1
<span class="gu">@@ -91,164 +99,333 @@ class screen:</span>
<span class="w"> </span>        self.cur_saved_c = 1
<span class="w"> </span>        self.scroll_row_start = 1
<span class="w"> </span>        self.scroll_row_end = self.rows
<span class="gd">-        self.w = [([SPACE] * self.cols) for _ in range(self.rows)]</span>
<span class="gi">+        self.w = [ [SPACE] * self.cols for _ in range(self.rows)]</span>

<span class="w"> </span>    def _decode(self, s):
<span class="gd">-        &quot;&quot;&quot;This converts from the external coding system (as passed to</span>
<span class="gd">-        the constructor) to the internal one (unicode). &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;This converts from the external coding system (as passed to</span>
<span class="gi">+        the constructor) to the internal one (unicode). &#39;&#39;&#39;</span>
<span class="gi">+        if self.decoder is not None:</span>
<span class="gi">+            return self.decoder.decode(s)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(&quot;This screen was constructed with encoding=None, &quot;</span>
<span class="gi">+                            &quot;so it does not handle bytes.&quot;)</span>

<span class="w"> </span>    def _unicode(self):
<span class="gd">-        &quot;&quot;&quot;This returns a printable representation of the screen as a unicode</span>
<span class="gi">+        &#39;&#39;&#39;This returns a printable representation of the screen as a unicode</span>
<span class="w"> </span>        string (which, under Python 3.x, is the same as &#39;str&#39;). The end of each
<span class="gd">-        screen line is terminated by a newline.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        screen line is terminated by a newline.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return u&#39;\n&#39;.join ([ u&#39;&#39;.join(c) for c in self.w ])</span>
<span class="gi">+</span>
<span class="w"> </span>    if PY3:
<span class="w"> </span>        __str__ = _unicode
<span class="w"> </span>    else:
<span class="w"> </span>        __unicode__ = _unicode

<span class="w"> </span>        def __str__(self):
<span class="gd">-            &quot;&quot;&quot;This returns a printable representation of the screen. The end of</span>
<span class="gd">-            each screen line is terminated by a newline. &quot;&quot;&quot;</span>
<span class="gi">+            &#39;&#39;&#39;This returns a printable representation of the screen. The end of</span>
<span class="gi">+            each screen line is terminated by a newline. &#39;&#39;&#39;</span>
<span class="w"> </span>            encoding = self.encoding or &#39;ascii&#39;
<span class="w"> </span>            return self._unicode().encode(encoding, &#39;replace&#39;)

<span class="gd">-    def dump(self):</span>
<span class="gd">-        &quot;&quot;&quot;This returns a copy of the screen as a unicode string. This is similar to</span>
<span class="gi">+    def dump (self):</span>
<span class="gi">+        &#39;&#39;&#39;This returns a copy of the screen as a unicode string. This is similar to</span>
<span class="w"> </span>        __str__/__unicode__ except that lines are not terminated with line
<span class="gd">-        feeds.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        feeds.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return u&#39;&#39;.join ([ u&#39;&#39;.join(c) for c in self.w ])</span>

<span class="gd">-    def pretty(self):</span>
<span class="gd">-        &quot;&quot;&quot;This returns a copy of the screen as a unicode string with an ASCII</span>
<span class="gi">+    def pretty (self):</span>
<span class="gi">+        &#39;&#39;&#39;This returns a copy of the screen as a unicode string with an ASCII</span>
<span class="w"> </span>        text box around the screen border. This is similar to
<span class="gd">-        __str__/__unicode__ except that it adds a box.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        __str__/__unicode__ except that it adds a box.&#39;&#39;&#39;</span>

<span class="gd">-    def cr(self):</span>
<span class="gd">-        &quot;&quot;&quot;This moves the cursor to the beginning (col 1) of the current row.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        top_bot = u&#39;+&#39; + u&#39;-&#39;*self.cols + u&#39;+\n&#39;</span>
<span class="gi">+        return top_bot + u&#39;\n&#39;.join([u&#39;|&#39;+line+u&#39;|&#39; for line in unicode(self).split(u&#39;\n&#39;)]) + u&#39;\n&#39; + top_bot</span>

<span class="gd">-    def lf(self):</span>
<span class="gd">-        &quot;&quot;&quot;This moves the cursor down with scrolling.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def fill (self, ch=SPACE):</span>

<span class="gd">-    def crlf(self):</span>
<span class="gd">-        &quot;&quot;&quot;This advances the cursor with CRLF properties.</span>
<span class="gi">+        if isinstance(ch, bytes):</span>
<span class="gi">+            ch = self._decode(ch)</span>
<span class="gi">+</span>
<span class="gi">+        self.fill_region (1,1,self.rows,self.cols, ch)</span>
<span class="gi">+</span>
<span class="gi">+    def fill_region (self, rs,cs, re,ce, ch=SPACE):</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(ch, bytes):</span>
<span class="gi">+            ch = self._decode(ch)</span>
<span class="gi">+</span>
<span class="gi">+        rs = constrain (rs, 1, self.rows)</span>
<span class="gi">+        re = constrain (re, 1, self.rows)</span>
<span class="gi">+        cs = constrain (cs, 1, self.cols)</span>
<span class="gi">+        ce = constrain (ce, 1, self.cols)</span>
<span class="gi">+        if rs &gt; re:</span>
<span class="gi">+            rs, re = re, rs</span>
<span class="gi">+        if cs &gt; ce:</span>
<span class="gi">+            cs, ce = ce, cs</span>
<span class="gi">+        for r in range (rs, re+1):</span>
<span class="gi">+            for c in range (cs, ce + 1):</span>
<span class="gi">+                self.put_abs (r,c,ch)</span>
<span class="gi">+</span>
<span class="gi">+    def cr (self):</span>
<span class="gi">+        &#39;&#39;&#39;This moves the cursor to the beginning (col 1) of the current row.</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.cursor_home (self.cur_r, 1)</span>
<span class="gi">+</span>
<span class="gi">+    def lf (self):</span>
<span class="gi">+        &#39;&#39;&#39;This moves the cursor down with scrolling.</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        old_r = self.cur_r</span>
<span class="gi">+        self.cursor_down()</span>
<span class="gi">+        if old_r == self.cur_r:</span>
<span class="gi">+            self.scroll_up ()</span>
<span class="gi">+            self.erase_line()</span>
<span class="gi">+</span>
<span class="gi">+    def crlf (self):</span>
<span class="gi">+        &#39;&#39;&#39;This advances the cursor with CRLF properties.</span>
<span class="w"> </span>        The cursor will line wrap and the screen may scroll.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>

<span class="gd">-    def newline(self):</span>
<span class="gd">-        &quot;&quot;&quot;This is an alias for crlf().</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        self.cr ()</span>
<span class="gi">+        self.lf ()</span>

<span class="gd">-    def put_abs(self, r, c, ch):</span>
<span class="gd">-        &quot;&quot;&quot;Screen array starts at 1 index.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def newline (self):</span>
<span class="gi">+        &#39;&#39;&#39;This is an alias for crlf().</span>
<span class="gi">+        &#39;&#39;&#39;</span>

<span class="gd">-    def put(self, ch):</span>
<span class="gd">-        &quot;&quot;&quot;This puts a characters at the current cursor position.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        self.crlf()</span>
<span class="gi">+</span>
<span class="gi">+    def put_abs (self, r, c, ch):</span>
<span class="gi">+        &#39;&#39;&#39;Screen array starts at 1 index.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        r = constrain (r, 1, self.rows)</span>
<span class="gi">+        c = constrain (c, 1, self.cols)</span>
<span class="gi">+        if isinstance(ch, bytes):</span>
<span class="gi">+            ch = self._decode(ch)[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            ch = ch[0]</span>
<span class="gi">+        self.w[r-1][c-1] = ch</span>
<span class="gi">+</span>
<span class="gi">+    def put (self, ch):</span>
<span class="gi">+        &#39;&#39;&#39;This puts a characters at the current cursor position.</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(ch, bytes):</span>
<span class="gi">+            ch = self._decode(ch)</span>

<span class="gd">-    def insert_abs(self, r, c, ch):</span>
<span class="gd">-        &quot;&quot;&quot;This inserts a character at (r,c). Everything under</span>
<span class="gi">+        self.put_abs (self.cur_r, self.cur_c, ch)</span>
<span class="gi">+</span>
<span class="gi">+    def insert_abs (self, r, c, ch):</span>
<span class="gi">+        &#39;&#39;&#39;This inserts a character at (r,c). Everything under</span>
<span class="w"> </span>        and to the right is shifted right one character.
<span class="w"> </span>        The last character of the line is lost.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>

<span class="gd">-    def get_region(self, rs, cs, re, ce):</span>
<span class="gd">-        &quot;&quot;&quot;This returns a list of lines representing the region.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(ch, bytes):</span>
<span class="gi">+            ch = self._decode(ch)</span>

<span class="gd">-    def cursor_constrain(self):</span>
<span class="gd">-        &quot;&quot;&quot;This keeps the cursor within the screen area.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        r = constrain (r, 1, self.rows)</span>
<span class="gi">+        c = constrain (c, 1, self.cols)</span>
<span class="gi">+        for ci in range (self.cols, c, -1):</span>
<span class="gi">+            self.put_abs (r,ci, self.get_abs(r,ci-1))</span>
<span class="gi">+        self.put_abs (r,c,ch)</span>

<span class="gd">-    def cursor_force_position(self, r, c):</span>
<span class="gd">-        &quot;&quot;&quot;Identical to Cursor Home.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def insert (self, ch):</span>

<span class="gd">-    def cursor_save(self):</span>
<span class="gd">-        &quot;&quot;&quot;Save current cursor position.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(ch, bytes):</span>
<span class="gi">+            ch = self._decode(ch)</span>

<span class="gd">-    def cursor_unsave(self):</span>
<span class="gd">-        &quot;&quot;&quot;Restores cursor position after a Save Cursor.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        self.insert_abs (self.cur_r, self.cur_c, ch)</span>

<span class="gd">-    def cursor_save_attrs(self):</span>
<span class="gd">-        &quot;&quot;&quot;Save current cursor position.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def get_abs (self, r, c):</span>

<span class="gd">-    def cursor_restore_attrs(self):</span>
<span class="gd">-        &quot;&quot;&quot;Restores cursor position after a Save Cursor.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        r = constrain (r, 1, self.rows)</span>
<span class="gi">+        c = constrain (c, 1, self.cols)</span>
<span class="gi">+        return self.w[r-1][c-1]</span>

<span class="gd">-    def scroll_constrain(self):</span>
<span class="gd">-        &quot;&quot;&quot;This keeps the scroll region within the screen region.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def get (self):</span>

<span class="gd">-    def scroll_screen(self):</span>
<span class="gd">-        &quot;&quot;&quot;Enable scrolling for entire display.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        self.get_abs (self.cur_r, self.cur_c)</span>

<span class="gd">-    def scroll_screen_rows(self, rs, re):</span>
<span class="gd">-        &quot;&quot;&quot;Enable scrolling from row {start} to row {end}.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def get_region (self, rs,cs, re,ce):</span>
<span class="gi">+        &#39;&#39;&#39;This returns a list of lines representing the region.</span>
<span class="gi">+        &#39;&#39;&#39;</span>

<span class="gd">-    def scroll_down(self):</span>
<span class="gd">-        &quot;&quot;&quot;Scroll display down one line.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        rs = constrain (rs, 1, self.rows)</span>
<span class="gi">+        re = constrain (re, 1, self.rows)</span>
<span class="gi">+        cs = constrain (cs, 1, self.cols)</span>
<span class="gi">+        ce = constrain (ce, 1, self.cols)</span>
<span class="gi">+        if rs &gt; re:</span>
<span class="gi">+            rs, re = re, rs</span>
<span class="gi">+        if cs &gt; ce:</span>
<span class="gi">+            cs, ce = ce, cs</span>
<span class="gi">+        sc = []</span>
<span class="gi">+        for r in range (rs, re+1):</span>
<span class="gi">+            line = u&#39;&#39;</span>
<span class="gi">+            for c in range (cs, ce + 1):</span>
<span class="gi">+                ch = self.get_abs (r,c)</span>
<span class="gi">+                line = line + ch</span>
<span class="gi">+            sc.append (line)</span>
<span class="gi">+        return sc</span>

<span class="gd">-    def scroll_up(self):</span>
<span class="gd">-        &quot;&quot;&quot;Scroll display up one line.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cursor_constrain (self):</span>
<span class="gi">+        &#39;&#39;&#39;This keeps the cursor within the screen area.</span>
<span class="gi">+        &#39;&#39;&#39;</span>

<span class="gd">-    def erase_end_of_line(self):</span>
<span class="gd">-        &quot;&quot;&quot;Erases from the current cursor position to the end of the current</span>
<span class="gd">-        line.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        self.cur_r = constrain (self.cur_r, 1, self.rows)</span>
<span class="gi">+        self.cur_c = constrain (self.cur_c, 1, self.cols)</span>

<span class="gd">-    def erase_start_of_line(self):</span>
<span class="gd">-        &quot;&quot;&quot;Erases from the current cursor position to the start of the current</span>
<span class="gd">-        line.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cursor_home (self, r=1, c=1): # &lt;ESC&gt;[{ROW};{COLUMN}H</span>

<span class="gd">-    def erase_line(self):</span>
<span class="gd">-        &quot;&quot;&quot;Erases the entire current line.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        self.cur_r = r</span>
<span class="gi">+        self.cur_c = c</span>
<span class="gi">+        self.cursor_constrain ()</span>

<span class="gd">-    def erase_down(self):</span>
<span class="gd">-        &quot;&quot;&quot;Erases the screen from the current line down to the bottom of the</span>
<span class="gd">-        screen.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cursor_back (self,count=1): # &lt;ESC&gt;[{COUNT}D (not confused with down)</span>

<span class="gd">-    def erase_up(self):</span>
<span class="gd">-        &quot;&quot;&quot;Erases the screen from the current line up to the top of the</span>
<span class="gd">-        screen.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        self.cur_c = self.cur_c - count</span>
<span class="gi">+        self.cursor_constrain ()</span>

<span class="gd">-    def erase_screen(self):</span>
<span class="gd">-        &quot;&quot;&quot;Erases the screen with the background color.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def cursor_down (self,count=1): # &lt;ESC&gt;[{COUNT}B (not confused with back)</span>
<span class="gi">+</span>
<span class="gi">+        self.cur_r = self.cur_r + count</span>
<span class="gi">+        self.cursor_constrain ()</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_forward (self,count=1): # &lt;ESC&gt;[{COUNT}C</span>
<span class="gi">+</span>
<span class="gi">+        self.cur_c = self.cur_c + count</span>
<span class="gi">+        self.cursor_constrain ()</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_up (self,count=1): # &lt;ESC&gt;[{COUNT}A</span>
<span class="gi">+</span>
<span class="gi">+        self.cur_r = self.cur_r - count</span>
<span class="gi">+        self.cursor_constrain ()</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_up_reverse (self): # &lt;ESC&gt; M   (called RI -- Reverse Index)</span>
<span class="gi">+</span>
<span class="gi">+        old_r = self.cur_r</span>
<span class="gi">+        self.cursor_up()</span>
<span class="gi">+        if old_r == self.cur_r:</span>
<span class="gi">+            self.scroll_up()</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_force_position (self, r, c): # &lt;ESC&gt;[{ROW};{COLUMN}f</span>
<span class="gi">+        &#39;&#39;&#39;Identical to Cursor Home.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.cursor_home (r, c)</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_save (self): # &lt;ESC&gt;[s</span>
<span class="gi">+        &#39;&#39;&#39;Save current cursor position.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.cursor_save_attrs()</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_unsave (self): # &lt;ESC&gt;[u</span>
<span class="gi">+        &#39;&#39;&#39;Restores cursor position after a Save Cursor.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.cursor_restore_attrs()</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_save_attrs (self): # &lt;ESC&gt;7</span>
<span class="gi">+        &#39;&#39;&#39;Save current cursor position.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.cur_saved_r = self.cur_r</span>
<span class="gi">+        self.cur_saved_c = self.cur_c</span>
<span class="gi">+</span>
<span class="gi">+    def cursor_restore_attrs (self): # &lt;ESC&gt;8</span>
<span class="gi">+        &#39;&#39;&#39;Restores cursor position after a Save Cursor.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.cursor_home (self.cur_saved_r, self.cur_saved_c)</span>
<span class="gi">+</span>
<span class="gi">+    def scroll_constrain (self):</span>
<span class="gi">+        &#39;&#39;&#39;This keeps the scroll region within the screen region.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if self.scroll_row_start &lt;= 0:</span>
<span class="gi">+            self.scroll_row_start = 1</span>
<span class="gi">+        if self.scroll_row_end &gt; self.rows:</span>
<span class="gi">+            self.scroll_row_end = self.rows</span>
<span class="gi">+</span>
<span class="gi">+    def scroll_screen (self): # &lt;ESC&gt;[r</span>
<span class="gi">+        &#39;&#39;&#39;Enable scrolling for entire display.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.scroll_row_start = 1</span>
<span class="gi">+        self.scroll_row_end = self.rows</span>
<span class="gi">+</span>
<span class="gi">+    def scroll_screen_rows (self, rs, re): # &lt;ESC&gt;[{start};{end}r</span>
<span class="gi">+        &#39;&#39;&#39;Enable scrolling from row {start} to row {end}.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.scroll_row_start = rs</span>
<span class="gi">+        self.scroll_row_end = re</span>
<span class="gi">+        self.scroll_constrain()</span>
<span class="gi">+</span>
<span class="gi">+    def scroll_down (self): # &lt;ESC&gt;D</span>
<span class="gi">+        &#39;&#39;&#39;Scroll display down one line.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Screen is indexed from 1, but arrays are indexed from 0.</span>
<span class="gi">+        s = self.scroll_row_start - 1</span>
<span class="gi">+        e = self.scroll_row_end - 1</span>
<span class="gi">+        self.w[s+1:e+1] = copy.deepcopy(self.w[s:e])</span>
<span class="gi">+</span>
<span class="gi">+    def scroll_up (self): # &lt;ESC&gt;M</span>
<span class="gi">+        &#39;&#39;&#39;Scroll display up one line.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Screen is indexed from 1, but arrays are indexed from 0.</span>
<span class="gi">+        s = self.scroll_row_start - 1</span>
<span class="gi">+        e = self.scroll_row_end - 1</span>
<span class="gi">+        self.w[s:e] = copy.deepcopy(self.w[s+1:e+1])</span>
<span class="gi">+</span>
<span class="gi">+    def erase_end_of_line (self): # &lt;ESC&gt;[0K -or- &lt;ESC&gt;[K</span>
<span class="gi">+        &#39;&#39;&#39;Erases from the current cursor position to the end of the current</span>
<span class="gi">+        line.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.fill_region (self.cur_r, self.cur_c, self.cur_r, self.cols)</span>
<span class="gi">+</span>
<span class="gi">+    def erase_start_of_line (self): # &lt;ESC&gt;[1K</span>
<span class="gi">+        &#39;&#39;&#39;Erases from the current cursor position to the start of the current</span>
<span class="gi">+        line.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.fill_region (self.cur_r, 1, self.cur_r, self.cur_c)</span>
<span class="gi">+</span>
<span class="gi">+    def erase_line (self): # &lt;ESC&gt;[2K</span>
<span class="gi">+        &#39;&#39;&#39;Erases the entire current line.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.fill_region (self.cur_r, 1, self.cur_r, self.cols)</span>
<span class="gi">+</span>
<span class="gi">+    def erase_down (self): # &lt;ESC&gt;[0J -or- &lt;ESC&gt;[J</span>
<span class="gi">+        &#39;&#39;&#39;Erases the screen from the current line down to the bottom of the</span>
<span class="gi">+        screen.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.erase_end_of_line ()</span>
<span class="gi">+        self.fill_region (self.cur_r + 1, 1, self.rows, self.cols)</span>
<span class="gi">+</span>
<span class="gi">+    def erase_up (self): # &lt;ESC&gt;[1J</span>
<span class="gi">+        &#39;&#39;&#39;Erases the screen from the current line up to the top of the</span>
<span class="gi">+        screen.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.erase_start_of_line ()</span>
<span class="gi">+        self.fill_region (self.cur_r-1, 1, 1, self.cols)</span>
<span class="gi">+</span>
<span class="gi">+    def erase_screen (self): # &lt;ESC&gt;[2J</span>
<span class="gi">+        &#39;&#39;&#39;Erases the screen with the background color.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.fill ()</span>
<span class="gi">+</span>
<span class="gi">+    def set_tab (self): # &lt;ESC&gt;H</span>
<span class="gi">+        &#39;&#39;&#39;Sets a tab at the current position.&#39;&#39;&#39;</span>

<span class="gd">-    def set_tab(self):</span>
<span class="gd">-        &quot;&quot;&quot;Sets a tab at the current position.&quot;&quot;&quot;</span>
<span class="w"> </span>        pass

<span class="gd">-    def clear_tab(self):</span>
<span class="gd">-        &quot;&quot;&quot;Clears tab at the current position.&quot;&quot;&quot;</span>
<span class="gi">+    def clear_tab (self): # &lt;ESC&gt;[g</span>
<span class="gi">+        &#39;&#39;&#39;Clears tab at the current position.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>        pass

<span class="gd">-    def clear_all_tabs(self):</span>
<span class="gd">-        &quot;&quot;&quot;Clears all tabs.&quot;&quot;&quot;</span>
<span class="gi">+    def clear_all_tabs (self): # &lt;ESC&gt;[3g</span>
<span class="gi">+        &#39;&#39;&#39;Clears all tabs.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>        pass
<span class="gi">+</span>
<span class="gi">+#        Insert line             Esc [ Pn L</span>
<span class="gi">+#        Delete line             Esc [ Pn M</span>
<span class="gi">+#        Delete character        Esc [ Pn P</span>
<span class="gi">+#        Scrolling region        Esc [ Pn(top);Pn(bot) r</span>
<span class="gi">+</span>
<span class="gh">diff --git a/pexpect/socket_pexpect.py b/pexpect/socket_pexpect.py</span>
<span class="gh">index 5d7ca43..cb11ac2 100644</span>
<span class="gd">--- a/pexpect/socket_pexpect.py</span>
<span class="gi">+++ b/pexpect/socket_pexpect.py</span>
<span class="gu">@@ -19,11 +19,14 @@ PEXPECT LICENSE</span>
<span class="w"> </span>    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import socket
<span class="w"> </span>from contextlib import contextmanager
<span class="gi">+</span>
<span class="w"> </span>from .exceptions import TIMEOUT, EOF
<span class="w"> </span>from .spawnbase import SpawnBase
<span class="gd">-__all__ = [&#39;SocketSpawn&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;SocketSpawn&quot;]</span>


<span class="w"> </span>class SocketSpawn(SpawnBase):
<span class="gu">@@ -31,18 +34,35 @@ class SocketSpawn(SpawnBase):</span>
<span class="w"> </span>    rather than the unix-specific file descriptor api. Thus, it works with
<span class="w"> </span>    remote connections on both unix and windows.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, socket: socket.socket, args=None, timeout=30,</span>
<span class="gd">-        maxread=2000, searchwindowsize=None, logfile=None, encoding=None,</span>
<span class="gd">-        codec_errors=&#39;strict&#39;, use_poll=False):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        socket: socket.socket,</span>
<span class="gi">+        args=None,</span>
<span class="gi">+        timeout=30,</span>
<span class="gi">+        maxread=2000,</span>
<span class="gi">+        searchwindowsize=None,</span>
<span class="gi">+        logfile=None,</span>
<span class="gi">+        encoding=None,</span>
<span class="gi">+        codec_errors=&quot;strict&quot;,</span>
<span class="gi">+        use_poll=False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;This takes an open socket.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.args = None
<span class="w"> </span>        self.command = None
<span class="gd">-        SpawnBase.__init__(self, timeout, maxread, searchwindowsize,</span>
<span class="gd">-            logfile, encoding=encoding, codec_errors=codec_errors)</span>
<span class="gi">+        SpawnBase.__init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            timeout,</span>
<span class="gi">+            maxread,</span>
<span class="gi">+            searchwindowsize,</span>
<span class="gi">+            logfile,</span>
<span class="gi">+            encoding=encoding,</span>
<span class="gi">+            codec_errors=codec_errors,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.socket = socket
<span class="w"> </span>        self.child_fd = socket.fileno()
<span class="w"> </span>        self.closed = False
<span class="gd">-        self.name = &#39;&lt;socket %s&gt;&#39; % socket</span>
<span class="gi">+        self.name = &quot;&lt;socket %s&gt;&quot; % socket</span>
<span class="w"> </span>        self.use_poll = use_poll

<span class="w"> </span>    def close(self):
<span class="gu">@@ -51,27 +71,50 @@ class SocketSpawn(SpawnBase):</span>
<span class="w"> </span>        Calling this method a second time does nothing, but if the file
<span class="w"> </span>        descriptor was closed elsewhere, :class:`OSError` will be raised.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.child_fd == -1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+        self.socket.shutdown(socket.SHUT_RDWR)</span>
<span class="gi">+        self.socket.close()</span>
<span class="gi">+        self.child_fd = -1</span>
<span class="gi">+        self.closed = True</span>

<span class="w"> </span>    def isalive(self):
<span class="w"> </span>        &quot;&quot;&quot; Alive if the fileno is valid &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.socket.fileno() &gt;= 0</span>

<span class="gd">-    def send(self, s) -&gt;int:</span>
<span class="gi">+    def send(self, s) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write to socket, return number of bytes written&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        s = self._coerce_send_string(s)</span>
<span class="gi">+        self._log(s, &quot;send&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        b = self._encoder.encode(s, final=False)</span>
<span class="gi">+        self.socket.sendall(b)</span>
<span class="gi">+        return len(b)</span>

<span class="gd">-    def sendline(self, s) -&gt;int:</span>
<span class="gi">+    def sendline(self, s) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write to socket with trailing newline, return number of bytes written&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        s = self._coerce_send_string(s)</span>
<span class="gi">+        return self.send(s + self.linesep)</span>

<span class="w"> </span>    def write(self, s):
<span class="w"> </span>        &quot;&quot;&quot;Write to socket, return None&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.send(s)</span>

<span class="w"> </span>    def writelines(self, sequence):
<span class="gd">-        &quot;&quot;&quot;Call self.write() for each item in sequence&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;Call self.write() for each item in sequence&quot;</span>
<span class="gi">+        for s in sequence:</span>
<span class="gi">+            self.write(s)</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def _timeout(self, timeout):</span>
<span class="gi">+        saved_timeout = self.socket.gettimeout()</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.socket.settimeout(timeout)</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.socket.settimeout(saved_timeout)</span>

<span class="w"> </span>    def read_nonblocking(self, size=1, timeout=-1):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -89,4 +132,14 @@ class SocketSpawn(SpawnBase):</span>
<span class="w"> </span>            ready to read. When -1 (default), use self.timeout. When 0, poll.
<span class="w"> </span>        :return: String containing the bytes read
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if timeout == -1:</span>
<span class="gi">+            timeout = self.timeout</span>
<span class="gi">+        try:</span>
<span class="gi">+            with self._timeout(timeout):</span>
<span class="gi">+                s = self.socket.recv(size)</span>
<span class="gi">+                if s == b&#39;&#39;:</span>
<span class="gi">+                    self.flag_eof = True</span>
<span class="gi">+                    raise EOF(&quot;Socket closed&quot;)</span>
<span class="gi">+                return s</span>
<span class="gi">+        except socket.timeout:</span>
<span class="gi">+            raise TIMEOUT(&quot;Timeout exceeded.&quot;)</span>
<span class="gh">diff --git a/pexpect/spawnbase.py b/pexpect/spawnbase.py</span>
<span class="gh">index abe78e6..abf8071 100644</span>
<span class="gd">--- a/pexpect/spawnbase.py</span>
<span class="gi">+++ b/pexpect/spawnbase.py</span>
<span class="gu">@@ -6,13 +6,19 @@ import re</span>
<span class="w"> </span>import errno
<span class="w"> </span>from .exceptions import ExceptionPexpect, EOF, TIMEOUT
<span class="w"> </span>from .expect import Expecter, searcher_string, searcher_re
<span class="gd">-PY3 = sys.version_info[0] &gt;= 3</span>
<span class="gd">-text_type = str if PY3 else unicode</span>

<span class="gi">+PY3 = (sys.version_info[0] &gt;= 3)</span>
<span class="gi">+text_type = str if PY3 else unicode</span>

<span class="w"> </span>class _NullCoder(object):
<span class="w"> </span>    &quot;&quot;&quot;Pass bytes through unchanged.&quot;&quot;&quot;
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def encode(b, final=False):</span>
<span class="gi">+        return b</span>

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def decode(b, final=False):</span>
<span class="gi">+        return b</span>

<span class="w"> </span>class SpawnBase(object):
<span class="w"> </span>    &quot;&quot;&quot;A base class providing the backwards-compatible spawn API for Pexpect.
<span class="gu">@@ -25,10 +31,11 @@ class SpawnBase(object):</span>
<span class="w"> </span>    flag_eof = False

<span class="w"> </span>    def __init__(self, timeout=30, maxread=2000, searchwindowsize=None,
<span class="gd">-        logfile=None, encoding=None, codec_errors=&#39;strict&#39;):</span>
<span class="gi">+                 logfile=None, encoding=None, codec_errors=&#39;strict&#39;):</span>
<span class="w"> </span>        self.stdin = sys.stdin
<span class="w"> </span>        self.stdout = sys.stdout
<span class="w"> </span>        self.stderr = sys.stderr
<span class="gi">+</span>
<span class="w"> </span>        self.searcher = None
<span class="w"> </span>        self.ignorecase = False
<span class="w"> </span>        self.before = None
<span class="gu">@@ -38,60 +45,126 @@ class SpawnBase(object):</span>
<span class="w"> </span>        self.terminated = True
<span class="w"> </span>        self.exitstatus = None
<span class="w"> </span>        self.signalstatus = None
<span class="gi">+        # status returned by os.waitpid</span>
<span class="w"> </span>        self.status = None
<span class="gi">+        # the child file descriptor is initially closed</span>
<span class="w"> </span>        self.child_fd = -1
<span class="w"> </span>        self.timeout = timeout
<span class="w"> </span>        self.delimiter = EOF
<span class="w"> </span>        self.logfile = logfile
<span class="gi">+        # input from child (read_nonblocking)</span>
<span class="w"> </span>        self.logfile_read = None
<span class="gi">+        # output to send (send, sendline)</span>
<span class="w"> </span>        self.logfile_send = None
<span class="gi">+        # max bytes to read at one time into buffer</span>
<span class="w"> </span>        self.maxread = maxread
<span class="gi">+        # Data before searchwindowsize point is preserved, but not searched.</span>
<span class="w"> </span>        self.searchwindowsize = searchwindowsize
<span class="gi">+        # Delay used before sending data to child. Time in seconds.</span>
<span class="gi">+        # Set this to None to skip the time.sleep() call completely.</span>
<span class="w"> </span>        self.delaybeforesend = 0.05
<span class="gi">+        # Used by close() to give kernel time to update process status.</span>
<span class="gi">+        # Time in seconds.</span>
<span class="w"> </span>        self.delayafterclose = 0.1
<span class="gi">+        # Used by terminate() to give kernel time to update process status.</span>
<span class="gi">+        # Time in seconds.</span>
<span class="w"> </span>        self.delayafterterminate = 0.1
<span class="gi">+        # Delay in seconds to sleep after each call to read_nonblocking().</span>
<span class="gi">+        # Set this to None to skip the time.sleep() call completely: that</span>
<span class="gi">+        # would restore the behavior from pexpect-2.0 (for performance</span>
<span class="gi">+        # reasons or because you don&#39;t want to release Python&#39;s global</span>
<span class="gi">+        # interpreter lock).</span>
<span class="w"> </span>        self.delayafterread = 0.0001
<span class="w"> </span>        self.softspace = False
<span class="w"> </span>        self.name = &#39;&lt;&#39; + repr(self) + &#39;&gt;&#39;
<span class="w"> </span>        self.closed = True
<span class="gi">+</span>
<span class="gi">+        # Unicode interface</span>
<span class="w"> </span>        self.encoding = encoding
<span class="w"> </span>        self.codec_errors = codec_errors
<span class="w"> </span>        if encoding is None:
<span class="gi">+            # bytes mode (accepts some unicode for backwards compatibility)</span>
<span class="w"> </span>            self._encoder = self._decoder = _NullCoder()
<span class="w"> </span>            self.string_type = bytes
<span class="w"> </span>            self.buffer_type = BytesIO
<span class="w"> </span>            self.crlf = b&#39;\r\n&#39;
<span class="w"> </span>            if PY3:
<span class="gd">-                self.allowed_string_types = bytes, str</span>
<span class="gi">+                self.allowed_string_types = (bytes, str)</span>
<span class="w"> </span>                self.linesep = os.linesep.encode(&#39;ascii&#39;)
<span class="gd">-</span>
<span class="w"> </span>                def write_to_stdout(b):
<span class="w"> </span>                    try:
<span class="w"> </span>                        return sys.stdout.buffer.write(b)
<span class="w"> </span>                    except AttributeError:
<span class="gi">+                        # If stdout has been replaced, it may not have .buffer</span>
<span class="w"> </span>                        return sys.stdout.write(b.decode(&#39;ascii&#39;, &#39;replace&#39;))
<span class="w"> </span>                self.write_to_stdout = write_to_stdout
<span class="w"> </span>            else:
<span class="gd">-                self.allowed_string_types = basestring,</span>
<span class="gi">+                self.allowed_string_types = (basestring,)  # analysis:ignore</span>
<span class="w"> </span>                self.linesep = os.linesep
<span class="w"> </span>                self.write_to_stdout = sys.stdout.write
<span class="w"> </span>        else:
<span class="gd">-            self._encoder = codecs.getincrementalencoder(encoding)(codec_errors</span>
<span class="gd">-                )</span>
<span class="gd">-            self._decoder = codecs.getincrementaldecoder(encoding)(codec_errors</span>
<span class="gd">-                )</span>
<span class="gi">+            # unicode mode</span>
<span class="gi">+            self._encoder = codecs.getincrementalencoder(encoding)(codec_errors)</span>
<span class="gi">+            self._decoder = codecs.getincrementaldecoder(encoding)(codec_errors)</span>
<span class="w"> </span>            self.string_type = text_type
<span class="w"> </span>            self.buffer_type = StringIO
<span class="w"> </span>            self.crlf = u&#39;\r\n&#39;
<span class="gd">-            self.allowed_string_types = text_type,</span>
<span class="gi">+            self.allowed_string_types = (text_type, )</span>
<span class="w"> </span>            if PY3:
<span class="w"> </span>                self.linesep = os.linesep
<span class="w"> </span>            else:
<span class="w"> </span>                self.linesep = os.linesep.decode(&#39;ascii&#39;)
<span class="gi">+            # This can handle unicode in both Python 2 and 3</span>
<span class="w"> </span>            self.write_to_stdout = sys.stdout.write
<span class="gi">+        # storage for async transport</span>
<span class="w"> </span>        self.async_pw_transport = None
<span class="gi">+        # This is the read buffer. See maxread.</span>
<span class="w"> </span>        self._buffer = self.buffer_type()
<span class="gi">+        # The buffer may be trimmed for efficiency reasons.  This is the</span>
<span class="gi">+        # untrimmed buffer, used to create the before attribute.</span>
<span class="w"> </span>        self._before = self.buffer_type()
<span class="gi">+</span>
<span class="gi">+    def _log(self, s, direction):</span>
<span class="gi">+        if self.logfile is not None:</span>
<span class="gi">+            self.logfile.write(s)</span>
<span class="gi">+            self.logfile.flush()</span>
<span class="gi">+        second_log = self.logfile_send if (direction==&#39;send&#39;) else self.logfile_read</span>
<span class="gi">+        if second_log is not None:</span>
<span class="gi">+            second_log.write(s)</span>
<span class="gi">+            second_log.flush()</span>
<span class="gi">+</span>
<span class="gi">+    # For backwards compatibility, in bytes mode (when encoding is None)</span>
<span class="gi">+    # unicode is accepted for send and expect. Unicode mode is strictly unicode</span>
<span class="gi">+    # only.</span>
<span class="gi">+    def _coerce_expect_string(self, s):</span>
<span class="gi">+        if self.encoding is None and not isinstance(s, bytes):</span>
<span class="gi">+            return s.encode(&#39;ascii&#39;)</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    # In bytes mode, regex patterns should also be of bytes type</span>
<span class="gi">+    def _coerce_expect_re(self, r):</span>
<span class="gi">+        p = r.pattern</span>
<span class="gi">+        if self.encoding is None and not isinstance(p, bytes):</span>
<span class="gi">+            return re.compile(p.encode(&#39;utf-8&#39;))</span>
<span class="gi">+        # And vice-versa</span>
<span class="gi">+        elif self.encoding is not None and isinstance(p, bytes):</span>
<span class="gi">+            return re.compile(p.decode(&#39;utf-8&#39;))</span>
<span class="gi">+        return r</span>
<span class="gi">+</span>
<span class="gi">+    def _coerce_send_string(self, s):</span>
<span class="gi">+        if self.encoding is None and not isinstance(s, bytes):</span>
<span class="gi">+            return s.encode(&#39;utf-8&#39;)</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def _get_buffer(self):</span>
<span class="gi">+        return self._buffer.getvalue()</span>
<span class="gi">+</span>
<span class="gi">+    def _set_buffer(self, value):</span>
<span class="gi">+        self._buffer = self.buffer_type()</span>
<span class="gi">+        self._buffer.write(value)</span>
<span class="gi">+</span>
<span class="gi">+    # This property is provided for backwards compatibility (self.buffer used</span>
<span class="gi">+    # to be a string/bytes object)</span>
<span class="w"> </span>    buffer = property(_get_buffer, _set_buffer)

<span class="w"> </span>    def read_nonblocking(self, size=1, timeout=None):
<span class="gu">@@ -101,10 +174,36 @@ class SpawnBase(object):</span>

<span class="w"> </span>        The timeout parameter is ignored.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            s = os.read(self.child_fd, size)</span>
<span class="gi">+        except OSError as err:</span>
<span class="gi">+            if err.args[0] == errno.EIO:</span>
<span class="gi">+                # Linux-style EOF</span>
<span class="gi">+                self.flag_eof = True</span>
<span class="gi">+                raise EOF(&#39;End Of File (EOF). Exception style platform.&#39;)</span>
<span class="gi">+            raise</span>
<span class="gi">+        if s == b&#39;&#39;:</span>
<span class="gi">+            # BSD-style EOF</span>
<span class="gi">+            self.flag_eof = True</span>
<span class="gi">+            raise EOF(&#39;End Of File (EOF). Empty string style platform.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        s = self._decoder.decode(s, final=False)</span>
<span class="gi">+        self._log(s, &#39;read&#39;)</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def _pattern_type_err(self, pattern):</span>
<span class="gi">+        raise TypeError(&#39;got {badtype} ({badobj!r}) as pattern, must be one&#39;</span>
<span class="gi">+                        &#39; of: {goodtypes}, pexpect.EOF, pexpect.TIMEOUT&#39;\</span>
<span class="gi">+                        .format(badtype=type(pattern),</span>
<span class="gi">+                                badobj=pattern,</span>
<span class="gi">+                                goodtypes=&#39;, &#39;.join([str(ast)\</span>
<span class="gi">+                                    for ast in self.allowed_string_types])</span>
<span class="gi">+                                )</span>
<span class="gi">+                        )</span>

<span class="w"> </span>    def compile_pattern_list(self, patterns):
<span class="gd">-        &quot;&quot;&quot;This compiles a pattern-string or a list of pattern-strings.</span>
<span class="gi">+        &#39;&#39;&#39;This compiles a pattern-string or a list of pattern-strings.</span>
<span class="w"> </span>        Patterns must be a StringType, EOF, TIMEOUT, SRE_Pattern, or a list of
<span class="w"> </span>        those. Patterns may also be None which results in an empty list (you
<span class="w"> </span>        might do this if waiting for an EOF or TIMEOUT condition without
<span class="gu">@@ -125,12 +224,35 @@ class SpawnBase(object):</span>
<span class="w"> </span>                ...
<span class="w"> </span>                i = self.expect_list(cpl, timeout)
<span class="w"> </span>                ...
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if patterns is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+        if not isinstance(patterns, list):</span>
<span class="gi">+            patterns = [patterns]</span>
<span class="gi">+</span>
<span class="gi">+        # Allow dot to match \n</span>
<span class="gi">+        compile_flags = re.DOTALL</span>
<span class="gi">+        if self.ignorecase:</span>
<span class="gi">+            compile_flags = compile_flags | re.IGNORECASE</span>
<span class="gi">+        compiled_pattern_list = []</span>
<span class="gi">+        for idx, p in enumerate(patterns):</span>
<span class="gi">+            if isinstance(p, self.allowed_string_types):</span>
<span class="gi">+                p = self._coerce_expect_string(p)</span>
<span class="gi">+                compiled_pattern_list.append(re.compile(p, compile_flags))</span>
<span class="gi">+            elif p is EOF:</span>
<span class="gi">+                compiled_pattern_list.append(EOF)</span>
<span class="gi">+            elif p is TIMEOUT:</span>
<span class="gi">+                compiled_pattern_list.append(TIMEOUT)</span>
<span class="gi">+            elif isinstance(p, type(re.compile(&#39;&#39;))):</span>
<span class="gi">+                p = self._coerce_expect_re(p)</span>
<span class="gi">+                compiled_pattern_list.append(p)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._pattern_type_err(p)</span>
<span class="gi">+        return compiled_pattern_list</span>

<span class="gd">-    def expect(self, pattern, timeout=-1, searchwindowsize=-1, async_=False,</span>
<span class="gd">-        **kw):</span>
<span class="gd">-        &quot;&quot;&quot;This seeks through the stream until a pattern is matched. The</span>
<span class="gi">+    def expect(self, pattern, timeout=-1, searchwindowsize=-1, async_=False, **kw):</span>
<span class="gi">+        &#39;&#39;&#39;This seeks through the stream until a pattern is matched. The</span>
<span class="w"> </span>        pattern is overloaded and may take several types. The pattern can be a
<span class="w"> </span>        StringType, EOF, a compiled re, or a list of any of those types.
<span class="w"> </span>        Strings will be compiled to re types. This returns the index into the
<span class="gu">@@ -222,12 +344,19 @@ class SpawnBase(object):</span>
<span class="w"> </span>        With this non-blocking form::

<span class="w"> </span>            index = yield from p.expect(patterns, async_=True)
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        if &#39;async&#39; in kw:</span>
<span class="gi">+            async_ = kw.pop(&#39;async&#39;)</span>
<span class="gi">+        if kw:</span>
<span class="gi">+            raise TypeError(&quot;Unknown keyword arguments: {}&quot;.format(kw))</span>
<span class="gi">+</span>
<span class="gi">+        compiled_pattern_list = self.compile_pattern_list(pattern)</span>
<span class="gi">+        return self.expect_list(compiled_pattern_list,</span>
<span class="gi">+                timeout, searchwindowsize, async_)</span>

<span class="w"> </span>    def expect_list(self, pattern_list, timeout=-1, searchwindowsize=-1,
<span class="gd">-        async_=False, **kw):</span>
<span class="gd">-        &quot;&quot;&quot;This takes a list of compiled regular expressions and returns the</span>
<span class="gi">+                    async_=False, **kw):</span>
<span class="gi">+        &#39;&#39;&#39;This takes a list of compiled regular expressions and returns the</span>
<span class="w"> </span>        index into the pattern_list that matched the child output. The list may
<span class="w"> </span>        also contain EOF or TIMEOUT(which are not compiled regular
<span class="w"> </span>        expressions). This method is similar to the expect() method except that
<span class="gu">@@ -238,12 +367,25 @@ class SpawnBase(object):</span>

<span class="w"> </span>        Like :meth:`expect`, passing ``async_=True`` will make this return an
<span class="w"> </span>        asyncio coroutine.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        if timeout == -1:</span>
<span class="gi">+            timeout = self.timeout</span>
<span class="gi">+        if &#39;async&#39; in kw:</span>
<span class="gi">+            async_ = kw.pop(&#39;async&#39;)</span>
<span class="gi">+        if kw:</span>
<span class="gi">+            raise TypeError(&quot;Unknown keyword arguments: {}&quot;.format(kw))</span>
<span class="gi">+</span>
<span class="gi">+        exp = Expecter(self, searcher_re(pattern_list), searchwindowsize)</span>
<span class="gi">+        if async_:</span>
<span class="gi">+            from ._async import expect_async</span>
<span class="gi">+            return expect_async(exp, timeout)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return exp.expect_loop(timeout)</span>

<span class="w"> </span>    def expect_exact(self, pattern_list, timeout=-1, searchwindowsize=-1,
<span class="gd">-        async_=False, **kw):</span>
<span class="gd">-        &quot;&quot;&quot;This is similar to expect(), but uses plain string matching instead</span>
<span class="gi">+                     async_=False, **kw):</span>
<span class="gi">+</span>
<span class="gi">+        &#39;&#39;&#39;This is similar to expect(), but uses plain string matching instead</span>
<span class="w"> </span>        of compiled regular expressions in &#39;pattern_list&#39;. The &#39;pattern_list&#39;
<span class="w"> </span>        may be a string; a list or other sequence of strings; or TIMEOUT and
<span class="w"> </span>        EOF.
<span class="gu">@@ -257,27 +399,79 @@ class SpawnBase(object):</span>

<span class="w"> </span>        Like :meth:`expect`, passing ``async_=True`` will make this return an
<span class="w"> </span>        asyncio coroutine.
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        if timeout == -1:</span>
<span class="gi">+            timeout = self.timeout</span>
<span class="gi">+        if &#39;async&#39; in kw:</span>
<span class="gi">+            async_ = kw.pop(&#39;async&#39;)</span>
<span class="gi">+        if kw:</span>
<span class="gi">+            raise TypeError(&quot;Unknown keyword arguments: {}&quot;.format(kw))</span>
<span class="gi">+</span>
<span class="gi">+        if (isinstance(pattern_list, self.allowed_string_types) or</span>
<span class="gi">+                pattern_list in (TIMEOUT, EOF)):</span>
<span class="gi">+            pattern_list = [pattern_list]</span>
<span class="gi">+</span>
<span class="gi">+        def prepare_pattern(pattern):</span>
<span class="gi">+            if pattern in (TIMEOUT, EOF):</span>
<span class="gi">+                return pattern</span>
<span class="gi">+            if isinstance(pattern, self.allowed_string_types):</span>
<span class="gi">+                return self._coerce_expect_string(pattern)</span>
<span class="gi">+            self._pattern_type_err(pattern)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            pattern_list = iter(pattern_list)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            self._pattern_type_err(pattern_list)</span>
<span class="gi">+        pattern_list = [prepare_pattern(p) for p in pattern_list]</span>
<span class="gi">+</span>
<span class="gi">+        exp = Expecter(self, searcher_string(pattern_list), searchwindowsize)</span>
<span class="gi">+        if async_:</span>
<span class="gi">+            from ._async import expect_async</span>
<span class="gi">+            return expect_async(exp, timeout)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return exp.expect_loop(timeout)</span>

<span class="w"> </span>    def expect_loop(self, searcher, timeout=-1, searchwindowsize=-1):
<span class="gd">-        &quot;&quot;&quot;This is the common loop used inside expect. The &#39;searcher&#39; should be</span>
<span class="gi">+        &#39;&#39;&#39;This is the common loop used inside expect. The &#39;searcher&#39; should be</span>
<span class="w"> </span>        an instance of searcher_re or searcher_string, which describes how and
<span class="w"> </span>        what to search for in the input.

<span class="gd">-        See expect() for other arguments, return value and exceptions. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        See expect() for other arguments, return value and exceptions. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        exp = Expecter(self, searcher, searchwindowsize)</span>
<span class="gi">+        return exp.expect_loop(timeout)</span>

<span class="w"> </span>    def read(self, size=-1):
<span class="gd">-        &quot;&quot;&quot;This reads at most &quot;size&quot; bytes from the file (less if the read hits</span>
<span class="gi">+        &#39;&#39;&#39;This reads at most &quot;size&quot; bytes from the file (less if the read hits</span>
<span class="w"> </span>        EOF before obtaining size bytes). If the size argument is negative or
<span class="w"> </span>        omitted, read all data until EOF is reached. The bytes are returned as
<span class="w"> </span>        a string object. An empty string is returned when EOF is encountered
<span class="gd">-        immediately. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        immediately. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if size == 0:</span>
<span class="gi">+            return self.string_type()</span>
<span class="gi">+        if size &lt; 0:</span>
<span class="gi">+            # delimiter default is EOF</span>
<span class="gi">+            self.expect(self.delimiter)</span>
<span class="gi">+            return self.before</span>
<span class="gi">+</span>
<span class="gi">+        # I could have done this more directly by not using expect(), but</span>
<span class="gi">+        # I deliberately decided to couple read() to expect() so that</span>
<span class="gi">+        # I would catch any bugs early and ensure consistent behavior.</span>
<span class="gi">+        # It&#39;s a little less efficient, but there is less for me to</span>
<span class="gi">+        # worry about if I have to later modify read() or expect().</span>
<span class="gi">+        # Note, it&#39;s OK if size==-1 in the regex. That just means it</span>
<span class="gi">+        # will never match anything in which case we stop only on EOF.</span>
<span class="gi">+        cre = re.compile(self._coerce_expect_string(&#39;.{%d}&#39; % size), re.DOTALL)</span>
<span class="gi">+        # delimiter default is EOF</span>
<span class="gi">+        index = self.expect([cre, self.delimiter])</span>
<span class="gi">+        if index == 0:</span>
<span class="gi">+            ### FIXME self.before should be &#39;&#39;. Should I assert this?</span>
<span class="gi">+            return self.after</span>
<span class="gi">+        return self.before</span>

<span class="w"> </span>    def readline(self, size=-1):
<span class="gd">-        &quot;&quot;&quot;This reads and returns one entire line. The newline at the end of</span>
<span class="gi">+        &#39;&#39;&#39;This reads and returns one entire line. The newline at the end of</span>
<span class="w"> </span>        line is returned as part of the string, unless the file ends without a
<span class="w"> </span>        newline. An empty string is returned if EOF is encountered immediately.
<span class="w"> </span>        This looks for a newline as a CR/LF pair (\\r\\n) even on UNIX because
<span class="gu">@@ -286,39 +480,57 @@ class SpawnBase(object):</span>

<span class="w"> </span>        If the size argument is 0 then an empty string is returned. In all
<span class="w"> </span>        other cases the size argument is ignored, which is not standard
<span class="gd">-        behavior for a file-like object. &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        behavior for a file-like object. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if size == 0:</span>
<span class="gi">+            return self.string_type()</span>
<span class="gi">+        # delimiter default is EOF</span>
<span class="gi">+        index = self.expect([self.crlf, self.delimiter])</span>
<span class="gi">+        if index == 0:</span>
<span class="gi">+            return self.before + self.crlf</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.before</span>

<span class="w"> </span>    def __iter__(self):
<span class="gd">-        &quot;&quot;&quot;This is to support iterators over a file-like object.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;This is to support iterators over a file-like object.</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        return iter(self.readline, self.string_type())

<span class="w"> </span>    def readlines(self, sizehint=-1):
<span class="gd">-        &quot;&quot;&quot;This reads until EOF using readline() and returns a list containing</span>
<span class="gi">+        &#39;&#39;&#39;This reads until EOF using readline() and returns a list containing</span>
<span class="w"> </span>        the lines thus read. The optional &#39;sizehint&#39; argument is ignored.
<span class="w"> </span>        Remember, because this reads until EOF that means the child
<span class="w"> </span>        process should have closed its stdout. If you run this method on
<span class="w"> </span>        a child that is still running with its stdout open then this
<span class="gd">-        method will block until it timesout.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        method will block until it timesout.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            line = self.readline()</span>
<span class="gi">+            if not line:</span>
<span class="gi">+                break</span>
<span class="gi">+            lines.append(line)</span>
<span class="gi">+        return lines</span>

<span class="w"> </span>    def fileno(self):
<span class="gd">-        &quot;&quot;&quot;Expose file descriptor for a file-like interface</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;Expose file descriptor for a file-like interface</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        return self.child_fd</span>

<span class="w"> </span>    def flush(self):
<span class="gd">-        &quot;&quot;&quot;This does nothing. It is here to support the interface for a</span>
<span class="gd">-        File-like object. &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;This does nothing. It is here to support the interface for a</span>
<span class="gi">+        File-like object. &#39;&#39;&#39;</span>
<span class="w"> </span>        pass

<span class="w"> </span>    def isatty(self):
<span class="w"> </span>        &quot;&quot;&quot;Overridden in subclass using tty&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="gi">+    # For &#39;with spawn(...) as child:&#39;</span>
<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self

<span class="w"> </span>    def __exit__(self, etype, evalue, tb):
<span class="gi">+        # We rely on subclasses to implement close(). If they don&#39;t, it&#39;s not</span>
<span class="gi">+        # clear what a context manager should do.</span>
<span class="w"> </span>        self.close()
<span class="gh">diff --git a/pexpect/utils.py b/pexpect/utils.py</span>
<span class="gh">index 960e622..f774519 100644</span>
<span class="gd">--- a/pexpect/utils.py</span>
<span class="gi">+++ b/pexpect/utils.py</span>
<span class="gu">@@ -4,14 +4,17 @@ import stat</span>
<span class="w"> </span>import select
<span class="w"> </span>import time
<span class="w"> </span>import errno
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    InterruptedError
<span class="w"> </span>except NameError:
<span class="gi">+    # Alias Python2 exception to Python3</span>
<span class="w"> </span>    InterruptedError = select.error
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info[0] &gt;= 3:
<span class="gd">-    string_types = str,</span>
<span class="gi">+    string_types = (str,)</span>
<span class="w"> </span>else:
<span class="gd">-    string_types = unicode, str</span>
<span class="gi">+    string_types = (unicode, str)</span>


<span class="w"> </span>def is_executable_file(path):
<span class="gu">@@ -19,33 +22,166 @@ def is_executable_file(path):</span>

<span class="w"> </span>    This is roughly ``os.path isfile(path) and os.access(path, os.X_OK)``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # follow symlinks,</span>
<span class="gi">+    fpath = os.path.realpath(path)</span>
<span class="gi">+</span>
<span class="gi">+    if not os.path.isfile(fpath):</span>
<span class="gi">+        # non-files (directories, fifo, etc.)</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    mode = os.stat(fpath).st_mode</span>
<span class="gi">+</span>
<span class="gi">+    if (sys.platform.startswith(&#39;sunos&#39;)</span>
<span class="gi">+            and os.getuid() == 0):</span>
<span class="gi">+        # When root on Solaris, os.X_OK is True for *all* files, irregardless</span>
<span class="gi">+        # of their executability -- instead, any permission bit of any user,</span>
<span class="gi">+        # group, or other is fine enough.</span>
<span class="gi">+        #</span>
<span class="gi">+        # (This may be true for other &quot;Unix98&quot; OS&#39;s such as HP-UX and AIX)</span>
<span class="gi">+        return bool(mode &amp; (stat.S_IXUSR |</span>
<span class="gi">+                            stat.S_IXGRP |</span>
<span class="gi">+                            stat.S_IXOTH))</span>
<span class="gi">+</span>
<span class="gi">+    return os.access(fpath, os.X_OK)</span>


<span class="w"> </span>def which(filename, env=None):
<span class="gd">-    &quot;&quot;&quot;This takes a given filename; tries to find it in the environment path;</span>
<span class="gi">+    &#39;&#39;&#39;This takes a given filename; tries to find it in the environment path;</span>
<span class="w"> </span>    then checks if it is executable. This returns the full path to the filename
<span class="gd">-    if found and executable. Otherwise this returns None.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    if found and executable. Otherwise this returns None.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Special case where filename contains an explicit path.</span>
<span class="gi">+    if os.path.dirname(filename) != &#39;&#39; and is_executable_file(filename):</span>
<span class="gi">+        return filename</span>
<span class="gi">+    if env is None:</span>
<span class="gi">+        env = os.environ</span>
<span class="gi">+    p = env.get(&#39;PATH&#39;)</span>
<span class="gi">+    if not p:</span>
<span class="gi">+        p = os.defpath</span>
<span class="gi">+    pathlist = p.split(os.pathsep)</span>
<span class="gi">+    for path in pathlist:</span>
<span class="gi">+        ff = os.path.join(path, filename)</span>
<span class="gi">+        if is_executable_file(ff):</span>
<span class="gi">+            return ff</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def split_command_line(command_line):
<span class="gd">-    &quot;&quot;&quot;This splits a command line into a list of arguments. It splits arguments</span>
<span class="gi">+</span>
<span class="gi">+    &#39;&#39;&#39;This splits a command line into a list of arguments. It splits arguments</span>
<span class="w"> </span>    on spaces, but handles embedded quotes, doublequotes, and escaped
<span class="w"> </span>    characters. It&#39;s impossible to do this with a regular expression, so I
<span class="gd">-    wrote a little state machine to parse the command line. &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    wrote a little state machine to parse the command line. &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    arg_list = []</span>
<span class="gi">+    arg = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Constants to name the states we can be in.</span>
<span class="gi">+    state_basic = 0</span>
<span class="gi">+    state_esc = 1</span>
<span class="gi">+    state_singlequote = 2</span>
<span class="gi">+    state_doublequote = 3</span>
<span class="gi">+    # The state when consuming whitespace between commands.</span>
<span class="gi">+    state_whitespace = 4</span>
<span class="gi">+    state = state_basic</span>
<span class="gi">+</span>
<span class="gi">+    for c in command_line:</span>
<span class="gi">+        if state == state_basic or state == state_whitespace:</span>
<span class="gi">+            if c == &#39;\\&#39;:</span>
<span class="gi">+                # Escape the next character</span>
<span class="gi">+                state = state_esc</span>
<span class="gi">+            elif c == r&quot;&#39;&quot;:</span>
<span class="gi">+                # Handle single quote</span>
<span class="gi">+                state = state_singlequote</span>
<span class="gi">+            elif c == r&#39;&quot;&#39;:</span>
<span class="gi">+                # Handle double quote</span>
<span class="gi">+                state = state_doublequote</span>
<span class="gi">+            elif c.isspace():</span>
<span class="gi">+                # Add arg to arg_list if we aren&#39;t in the middle of whitespace.</span>
<span class="gi">+                if state == state_whitespace:</span>
<span class="gi">+                    # Do nothing.</span>
<span class="gi">+                    None</span>
<span class="gi">+                else:</span>
<span class="gi">+                    arg_list.append(arg)</span>
<span class="gi">+                    arg = &#39;&#39;</span>
<span class="gi">+                    state = state_whitespace</span>
<span class="gi">+            else:</span>
<span class="gi">+                arg = arg + c</span>
<span class="gi">+                state = state_basic</span>
<span class="gi">+        elif state == state_esc:</span>
<span class="gi">+            arg = arg + c</span>
<span class="gi">+            state = state_basic</span>
<span class="gi">+        elif state == state_singlequote:</span>
<span class="gi">+            if c == r&quot;&#39;&quot;:</span>
<span class="gi">+                state = state_basic</span>
<span class="gi">+            else:</span>
<span class="gi">+                arg = arg + c</span>
<span class="gi">+        elif state == state_doublequote:</span>
<span class="gi">+            if c == r&#39;&quot;&#39;:</span>
<span class="gi">+                state = state_basic</span>
<span class="gi">+            else:</span>
<span class="gi">+                arg = arg + c</span>
<span class="gi">+</span>
<span class="gi">+    if arg != &#39;&#39;:</span>
<span class="gi">+        arg_list.append(arg)</span>
<span class="gi">+    return arg_list</span>


<span class="w"> </span>def select_ignore_interrupts(iwtd, owtd, ewtd, timeout=None):
<span class="gd">-    &quot;&quot;&quot;This is a wrapper around select.select() that ignores signals. If</span>
<span class="gi">+</span>
<span class="gi">+    &#39;&#39;&#39;This is a wrapper around select.select() that ignores signals. If</span>
<span class="w"> </span>    select.select raises a select.error exception and errno is an EINTR
<span class="w"> </span>    error then it is ignored. Mainly this is used to ignore sigwinch
<span class="gd">-    (terminal resize). &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    (terminal resize). &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # if select() is interrupted by a signal (errno==EINTR) then</span>
<span class="gi">+    # we loop back and enter the select() again.</span>
<span class="gi">+    if timeout is not None:</span>
<span class="gi">+        end_time = time.time() + timeout</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return select.select(iwtd, owtd, ewtd, timeout)</span>
<span class="gi">+        except InterruptedError:</span>
<span class="gi">+            err = sys.exc_info()[1]</span>
<span class="gi">+            if err.args[0] == errno.EINTR:</span>
<span class="gi">+                # if we loop back we have to subtract the</span>
<span class="gi">+                # amount of time we already waited.</span>
<span class="gi">+                if timeout is not None:</span>
<span class="gi">+                    timeout = end_time - time.time()</span>
<span class="gi">+                    if timeout &lt; 0:</span>
<span class="gi">+                        return([], [], [])</span>
<span class="gi">+            else:</span>
<span class="gi">+                # something else caused the select.error, so</span>
<span class="gi">+                # this actually is an exception.</span>
<span class="gi">+                raise</span>


<span class="w"> </span>def poll_ignore_interrupts(fds, timeout=None):
<span class="gd">-    &quot;&quot;&quot;Simple wrapper around poll to register file descriptors and</span>
<span class="gd">-    ignore signals.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &#39;&#39;&#39;Simple wrapper around poll to register file descriptors and</span>
<span class="gi">+    ignore signals.&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if timeout is not None:</span>
<span class="gi">+        end_time = time.time() + timeout</span>
<span class="gi">+</span>
<span class="gi">+    poller = select.poll()</span>
<span class="gi">+    for fd in fds:</span>
<span class="gi">+        poller.register(fd, select.POLLIN | select.POLLPRI | select.POLLHUP | select.POLLERR)</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            timeout_ms = None if timeout is None else timeout * 1000</span>
<span class="gi">+            results = poller.poll(timeout_ms)</span>
<span class="gi">+            return [afd for afd, _ in results]</span>
<span class="gi">+        except InterruptedError:</span>
<span class="gi">+            err = sys.exc_info()[1]</span>
<span class="gi">+            if err.args[0] == errno.EINTR:</span>
<span class="gi">+                # if we loop back we have to subtract the</span>
<span class="gi">+                # amount of time we already waited.</span>
<span class="gi">+                if timeout is not None:</span>
<span class="gi">+                    timeout = end_time - time.time()</span>
<span class="gi">+                    if timeout &lt; 0:</span>
<span class="gi">+                        return []</span>
<span class="gi">+            else:</span>
<span class="gi">+                # something else caused the select.error, so</span>
<span class="gi">+                # this actually is an exception.</span>
<span class="gi">+                raise</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>