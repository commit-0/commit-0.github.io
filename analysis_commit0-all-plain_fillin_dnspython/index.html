
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin dnspython - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-dnspython" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin dnspython
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_addresspyipv4teststest_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_address.py::IPv4Tests::test_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_addresspyipv6teststest_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_address.py::IPv6Tests::test_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_addresspyipv6teststest_valid" class="md-nav__link">
    <span class="md-ellipsis">
      test_address.py::IPv6Tests::test_valid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_entropypyentropytestcasetest_functions" class="md-nav__link">
    <span class="md-ellipsis">
      test_entropy.py::EntropyTestCase::test_functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_entropypyentropytestcasetest_pool" class="md-nav__link">
    <span class="md-ellipsis">
      test_entropy.py::EntropyTestCase::test_pool
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_entropypyentropytestcasetest_pool_random" class="md-nav__link">
    <span class="md-ellipsis">
      test_entropy.py::EntropyTestCase::test_pool_random
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_entropypyentropytestcasetest_pool_random_between" class="md-nav__link">
    <span class="md-ellipsis">
      test_entropy.py::EntropyTestCase::test_pool_random_between
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_entropypyentropyforcepooltestcasetest_functions" class="md-nav__link">
    <span class="md-ellipsis">
      test_entropy.py::EntropyForcePoolTestCase::test_functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspyexceptiontestcasetest_formatted_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::ExceptionTestCase::test_formatted_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspyexceptiontestcasetest_kwargs_only" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::ExceptionTestCase::test_kwargs_only
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptionspyexceptiontestcasetest_kwargs_unsupported" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions.py::ExceptionTestCase::test_kwargs_unsupported
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_flagspyflagstestcasetest_rcode4" class="md-nav__link">
    <span class="md-ellipsis">
      test_flags.py::FlagsTestCase::test_rcode4
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_flagspyflagstestcasetest_rcode6" class="md-nav__link">
    <span class="md-ellipsis">
      test_flags.py::FlagsTestCase::test_rcode6
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_flagspyflagstestcasetest_rcode_badsig" class="md-nav__link">
    <span class="md-ellipsis">
      test_flags.py::FlagsTestCase::test_rcode_badsig
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_flagspyflagstestcasetest_unknown_rcode" class="md-nav__link">
    <span class="md-ellipsis">
      test_flags.py::FlagsTestCase::test_unknown_rcode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_aton3" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_aton3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_aton8" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_aton8
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_bad_aton4" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_bad_aton4
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_bad_ntoa3" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_bad_ntoa3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_bad_v4_aton" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_bad_v4_aton
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_inet_canonicalize" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_inet_canonicalize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ipv4_canonicalize" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ipv4_canonicalize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ipv6_canonicalize" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ipv6_canonicalize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_is_mapped" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_is_mapped
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_low_level_address_tuple" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_low_level_address_tuple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_multiple_scopes_bad" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_multiple_scopes_bad
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa1" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa10" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa10
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa11" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa11
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa12" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa12
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa13" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa13
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa14" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa14
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa15" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa15
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa2" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa3" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa5" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa5
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa6" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa6
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa7" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa7
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa8" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa8
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ntoa9" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa9
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_ptontop" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_ptontop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ntoaatonpyntoaatontestcasetest_rfc5952_section_4_2_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_ntoaaton.py::NtoAAtoNTestCase::test_rfc5952_section_4_2_2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rdtypeandclasspyrdtypeandclasstestcasetest_class_bytext_bounds1" class="md-nav__link">
    <span class="md-ellipsis">
      test_rdtypeandclass.py::RdTypeAndClassTestCase::test_class_bytext_bounds1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rdtypeandclasspyrdtypeandclasstestcasetest_class_bytext_bounds2" class="md-nav__link">
    <span class="md-ellipsis">
      test_rdtypeandclass.py::RdTypeAndClassTestCase::test_class_bytext_bounds2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rdtypeandclasspyrdtypeandclasstestcasetest_type_bytext_bounds1" class="md-nav__link">
    <span class="md-ellipsis">
      test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_bytext_bounds1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rdtypeandclasspyrdtypeandclasstestcasetest_type_bytext_bounds2" class="md-nav__link">
    <span class="md-ellipsis">
      test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_bytext_bounds2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rdtypeandclasspyrdtypeandclasstestcasetest_type_totext1" class="md-nav__link">
    <span class="md-ellipsis">
      test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_totext1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_rdtypeandclasspyrdtypeandclasstestcasetest_type_totext2" class="md-nav__link">
    <span class="md-ellipsis">
      test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_totext2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestbaddisjoint" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testBadDisjoint
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestbadsubsetsuperset" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testBadSubsetSuperset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestbadupdates" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testBadUpdates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestdisjoint1" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testDisjoint1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestdisjoint2" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testDisjoint2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestdisjoint3" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testDisjoint3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestremovenonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testRemoveNonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestselfupdates" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testSelfUpdates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestsymmetricdifference3" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testSymmetricDifference3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestsymmetricdifference4" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testSymmetricDifference4
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestsymmetricdifference5" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testSymmetricDifference5
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_setpysettestcasetestsymmetricdifference6" class="md-nav__link">
    <span class="md-ellipsis">
      test_set.py::SetTestCase::testSymmetricDifference6
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ttlpyttltestcasetest_bind_style_no_unit" class="md-nav__link">
    <span class="md-ellipsis">
      test_ttl.py::TTLTestCase::test_bind_style_no_unit
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-dnspython"><strong>Claude Sonnet 3.5 - Fill-in</strong>: dnspython</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">61</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">118</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">179</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">179</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_addresspyipv4teststest_invalid">test_address.py::IPv4Tests::test_invalid</h3>
<details><summary> <pre>test_address.py::IPv4Tests::test_invalid</pre></summary><pre>
self = <tests.test_address.IPv4Tests testMethod=test_invalid>

    def test_invalid(self):
        invalid = (
            "",
            ".",
            "..",
            "400.2.3.4",
            "260.2.3.4",
            "256.2.3.4",
            "1.256.3.4",
            "1.2.256.4",
            "1.2.3.256",
            "300.2.3.4",
            "1.300.3.4",
            "1.2.300.4",
            "1.2.3.300",
            "900.2.3.4",
            "1.900.3.4",
            "1.2.900.4",
            "1.2.3.900",
            "300.300.300.300",
            "3000.30.30.30",
            "255Z255X255Y255",
            "192x168.1.26",
            "2.3.4",
            "257.1.2.3",
            "00.00.00.00",
            "000.000.000.000",
            "256.256.256.256",
            "255255.255.255",
            "255.255255.255",
            "255.255.255255",
            "1...",
            "1.2..",
            "1.2.3.",
            ".2..",
            ".2.3.",
            ".2.3.4",
            "..3.",
            "..3.4",
            "...4",
            ".1.2.3.4",
            "1.2.3.4.",
            " 1.2.3.4",
            "1.2.3.4 ",
            " 1.2.3.4 ",
            "::",
        )
        for s in invalid:
>           with self.assertRaises(
                dns.exception.SyntaxError, msg=f'invalid IPv4 address: "{s}"'
            ):
E           AssertionError: SyntaxError not raised : invalid IPv4 address: "00.00.00.00"

tests/test_address.py:77: AssertionError
</pre>
</details>
<h3 id="test_addresspyipv6teststest_invalid">test_address.py::IPv6Tests::test_invalid</h3>
<details><summary> <pre>test_address.py::IPv6Tests::test_invalid</pre></summary><pre>
self = <tests.test_address.IPv6Tests testMethod=test_invalid>

    def test_invalid(self):
        invalid = (
            "",
            ":",
            ":::",
            "2001:DB8:0:0:8:800:200C:417A:221",
            "FF01::101::2",
            "02001:0000:1234:0000:0000:C1C0:ABCD:0876",
            "2001:0000:1234:0000:00001:C1C0:ABCD:0876",
            " 2001:0000:1234:0000:0000:C1C0:ABCD:0876",
            "2001:0000:1234:0000:0000:C1C0:ABCD:0876 ",
            " 2001:0000:1234:0000:0000:C1C0:ABCD:0876  ",
            "2001:0000:1234:0000:0000:C1C0:ABCD:0876  0",
            "2001:0000:1234: 0000:0000:C1C0:ABCD:0876",
            "3ffe:0b00:0000:0001:0000:0000:000a",
            "FF02:0000:0000:0000:0000:0000:0000:0000:0001",
            "3ffe:b00::1::a",
            "::1111:2222:3333:4444:5555:6666::",
            "1:2:3::4:5::7:8",
            "12345::6:7:8",
            "1::5:400.2.3.4",
            "1::5:260.2.3.4",
            "1::5:256.2.3.4",
            "1::5:1.256.3.4",
            "1::5:1.2.256.4",
            "1::5:1.2.3.256",
            "1::5:300.2.3.4",
            "1::5:1.300.3.4",
            "1::5:1.2.300.4",
            "1::5:1.2.3.300",
            "1::5:900.2.3.4",
            "1::5:1.900.3.4",
            "1::5:1.2.900.4",
            "1::5:1.2.3.900",
            "1::5:300.300.300.300",
            "1::5:3000.30.30.30",
            "1::400.2.3.4",
            "1::260.2.3.4",
            "1::256.2.3.4",
            "1::1.256.3.4",
            "1::1.2.256.4",
            "1::1.2.3.256",
            "1::300.2.3.4",
            "1::1.300.3.4",
            "1::1.2.300.4",
            "1::1.2.3.300",
            "1::900.2.3.4",
            "1::1.900.3.4",
            "1::1.2.900.4",
            "1::1.2.3.900",
            "1::300.300.300.300",
            "1::3000.30.30.30",
            "::400.2.3.4",
            "::260.2.3.4",
            "::256.2.3.4",
            "::1.256.3.4",
            "::1.2.256.4",
            "::1.2.3.256",
            "::300.2.3.4",
            "::1.300.3.4",
            "::1.2.300.4",
            "::1.2.3.300",
            "::900.2.3.4",
            "::1.900.3.4",
            "::1.2.900.4",
            "::1.2.3.900",
            "::300.300.300.300",
            "::3000.30.30.30",
            "::1.2.3.4.",
            "2001:1:1:1:1:1:255Z255X255Y255",
            "::ffff:192x168.1.26",
            "::ffff:2.3.4",
            "::ffff:257.1.2.3",
            "1.2.3.4",
            "1.2.3.4:1111:2222:3333:4444::5555",
            "1.2.3.4:1111:2222:3333::5555",
            "1.2.3.4:1111:2222::5555",
            "1.2.3.4:1111::5555",
            "1.2.3.4::5555",
            "1.2.3.4::",
            "fe80:0000:0000:0000:0204:61ff:254.157.241.086",
            "XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:1.2.3.4",
            "1111:2222:3333:4444:5555:6666:00.00.00.00",
            "1111:2222:3333:4444:5555:6666:000.000.000.000",
            "1111:2222:3333:4444:5555:6666:256.256.256.256",
            "1111:2222:3333:4444::5555:",
            "1111:2222:3333::5555:",
            "1111:2222::5555:",
            "1111::5555:",
            "::5555:",
            "1111:",
            ":1111:2222:3333:4444::5555",
            ":1111:2222:3333::5555",
            ":1111:2222::5555",
            ":1111::5555",
            ":::5555",
            "123",
            "ldkfj",
            "2001::FFD3::57ab",
            "2001:db8:85a3::8a2e:37023:7334",
            "2001:db8:85a3::8a2e:370k:7334",
            "1:2:3:4:5:6:7:8:9",
            "1::2::3",
            "1:::3:4:5",
            "1:2:3::4:5:6:7:8:9",
            "XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX",
            "1111:2222:3333:4444:5555:6666:7777:8888:9999",
            "1111:2222:3333:4444:5555:6666:7777:8888::",
            "::2222:3333:4444:5555:6666:7777:8888:9999",
            "1111:2222:3333:4444:5555:6666:7777",
            "1111:2222:3333:4444:5555:6666",
            "1111:2222:3333:4444:5555",
            "1111:2222:3333:4444",
            "1111:2222:3333",
            "1111:2222",
            "1111",
            "11112222:3333:4444:5555:6666:7777:8888",
            "1111:22223333:4444:5555:6666:7777:8888",
            "1111:2222:33334444:5555:6666:7777:8888",
            "1111:2222:3333:44445555:6666:7777:8888",
            "1111:2222:3333:4444:55556666:7777:8888",
            "1111:2222:3333:4444:5555:66667777:8888",
            "1111:2222:3333:4444:5555:6666:77778888",
            "1111:2222:3333:4444:5555:6666:7777:8888:",
            "1111:2222:3333:4444:5555:6666:7777:",
            "1111:2222:3333:4444:5555:6666:",
            "1111:2222:3333:4444:5555:",
            "1111:2222:3333:4444:",
            "1111:2222:3333:",
            "1111:2222:",
            ":8888",
            ":7777:8888",
            ":6666:7777:8888",
            ":5555:6666:7777:8888",
            ":4444:5555:6666:7777:8888",
            ":3333:4444:5555:6666:7777:8888",
            ":2222:3333:4444:5555:6666:7777:8888",
            ":1111:2222:3333:4444:5555:6666:7777:8888",
            ":::2222:3333:4444:5555:6666:7777:8888",
            "1111:::3333:4444:5555:6666:7777:8888",
            "1111:2222:::4444:5555:6666:7777:8888",
            "1111:2222:3333:::5555:6666:7777:8888",
            "1111:2222:3333:4444:::6666:7777:8888",
            "1111:2222:3333:4444:5555:::7777:8888",
            "1111:2222:3333:4444:5555:6666:::8888",
            "::2222::4444:5555:6666:7777:8888",
            "::2222:3333::5555:6666:7777:8888",
            "::2222:3333:4444::6666:7777:8888",
            "::2222:3333:4444:5555::7777:8888",
            "::2222:3333:4444:5555:7777::8888",
            "::2222:3333:4444:5555:7777:8888::",
            "1111::3333::5555:6666:7777:8888",
            "1111::3333:4444::6666:7777:8888",
            "1111::3333:4444:5555::7777:8888",
            "1111::3333:4444:5555:6666::8888",
            "1111::3333:4444:5555:6666:7777::",
            "1111:2222::4444::6666:7777:8888",
            "1111:2222::4444:5555::7777:8888",
            "1111:2222::4444:5555:6666::8888",
            "1111:2222::4444:5555:6666:7777::",
            "1111:2222:3333::5555::7777:8888",
            "1111:2222:3333::5555:6666::8888",
            "1111:2222:3333::5555:6666:7777::",
            "1111:2222:3333:4444::6666::8888",
            "1111:2222:3333:4444::6666:7777::",
            "1111:2222:3333:4444:5555::7777::",
            "1111:2222:3333:4444:5555:6666:7777:8888:1.2.3.4",
            "1111:2222:3333:4444:5555:6666:7777:1.2.3.4",
            "1111:2222:3333:4444:5555:6666::1.2.3.4",
            "::2222:3333:4444:5555:6666:7777:1.2.3.4",
            "1111:2222:3333:4444:5555:6666:1.2.3.4.5",
            "1111:2222:3333:4444:5555:1.2.3.4",
            "1111:2222:3333:4444:1.2.3.4",
            "1111:2222:3333:1.2.3.4",
            "1111:2222:1.2.3.4",
            "1111:1.2.3.4",
            "11112222:3333:4444:5555:6666:1.2.3.4",
            "1111:22223333:4444:5555:6666:1.2.3.4",
            "1111:2222:33334444:5555:6666:1.2.3.4",
            "1111:2222:3333:44445555:6666:1.2.3.4",
            "1111:2222:3333:4444:55556666:1.2.3.4",
            "1111:2222:3333:4444:5555:66661.2.3.4",
            "1111:2222:3333:4444:5555:6666:255255.255.255",
            "1111:2222:3333:4444:5555:6666:255.255255.255",
            "1111:2222:3333:4444:5555:6666:255.255.255255",
            ":1.2.3.4",
            ":6666:1.2.3.4",
            ":5555:6666:1.2.3.4",
            ":4444:5555:6666:1.2.3.4",
            ":3333:4444:5555:6666:1.2.3.4",
            ":2222:3333:4444:5555:6666:1.2.3.4",
            ":1111:2222:3333:4444:5555:6666:1.2.3.4",
            ":::2222:3333:4444:5555:6666:1.2.3.4",
            "1111:::3333:4444:5555:6666:1.2.3.4",
            "1111:2222:::4444:5555:6666:1.2.3.4",
            "1111:2222:3333:::5555:6666:1.2.3.4",
            "1111:2222:3333:4444:::6666:1.2.3.4",
            "1111:2222:3333:4444:5555:::1.2.3.4",
            "::2222::4444:5555:6666:1.2.3.4",
            "::2222:3333::5555:6666:1.2.3.4",
            "::2222:3333:4444::6666:1.2.3.4",
            "::2222:3333:4444:5555::1.2.3.4",
            "1111::3333::5555:6666:1.2.3.4",
            "1111::3333:4444::6666:1.2.3.4",
            "1111::3333:4444:5555::1.2.3.4",
            "1111:2222::4444::6666:1.2.3.4",
            "1111:2222::4444:5555::1.2.3.4",
            "1111:2222:3333::5555::1.2.3.4",
            "::.",
            "::..",
            "::...",
            "::1...",
            "::1.2..",
            "::1.2.3.",
            "::.2..",
            "::.2.3.",
            "::.2.3.4",
            "::..3.",
            "::..3.4",
            "::...4",
            ":1111:2222:3333:4444:5555:6666:7777::",
            ":1111:2222:3333:4444:5555:6666::",
            ":1111:2222:3333:4444:5555::",
            ":1111:2222:3333:4444::",
            ":1111:2222:3333::",
            ":1111:2222::",
            ":1111::",
            ":1111:2222:3333:4444:5555:6666::8888",
            ":1111:2222:3333:4444:5555::8888",
            ":1111:2222:3333:4444::8888",
            ":1111:2222:3333::8888",
            ":1111:2222::8888",
            ":1111::8888",
            ":::8888",
            ":1111:2222:3333:4444:5555::7777:8888",
            ":1111:2222:3333:4444::7777:8888",
            ":1111:2222:3333::7777:8888",
            ":1111:2222::7777:8888",
            ":1111::7777:8888",
            ":::7777:8888",
            ":1111:2222:3333:4444::6666:7777:8888",
            ":1111:2222:3333::6666:7777:8888",
            ":1111:2222::6666:7777:8888",
            ":1111::6666:7777:8888",
            ":::6666:7777:8888",
            ":1111:2222:3333::5555:6666:7777:8888",
            ":1111:2222::5555:6666:7777:8888",
            ":1111::5555:6666:7777:8888",
            ":::5555:6666:7777:8888",
            ":1111:2222::4444:5555:6666:7777:8888",
            ":1111::4444:5555:6666:7777:8888",
            ":::4444:5555:6666:7777:8888",
            ":1111::3333:4444:5555:6666:7777:8888",
            ":::3333:4444:5555:6666:7777:8888",
            ":1111:2222:3333:4444:5555::1.2.3.4",
            ":1111:2222:3333:4444::1.2.3.4",
            ":1111:2222:3333::1.2.3.4",
            ":1111:2222::1.2.3.4",
            ":1111::1.2.3.4",
            ":::1.2.3.4",
            ":1111:2222:3333:4444::6666:1.2.3.4",
            ":1111:2222:3333::6666:1.2.3.4",
            ":1111:2222::6666:1.2.3.4",
            ":1111::6666:1.2.3.4",
            ":::6666:1.2.3.4",
            ":1111:2222:3333::5555:6666:1.2.3.4",
            ":1111:2222::5555:6666:1.2.3.4",
            ":1111::5555:6666:1.2.3.4",
            ":::5555:6666:1.2.3.4",
            ":1111:2222::4444:5555:6666:1.2.3.4",
            ":1111::4444:5555:6666:1.2.3.4",
            ":::4444:5555:6666:1.2.3.4",
            ":1111::3333:4444:5555:6666:1.2.3.4",
            "1111:2222:3333:4444:5555:6666:7777:::",
            "1111:2222:3333:4444:5555:6666:::",
            "1111:2222:3333:4444:5555:::",
            "1111:2222:3333:4444:::",
            "1111:2222:3333:::",
            "1111:2222:::",
            "1111:::",
            "1111:2222:3333:4444:5555:6666::8888:",
            "1111:2222:3333:4444:5555::8888:",
            "1111:2222:3333:4444::8888:",
            "1111:2222:3333::8888:",
            "1111:2222::8888:",
            "1111::8888:",
            "::8888:",
            "1111:2222:3333:4444:5555::7777:8888:",
            "1111:2222:3333:4444::7777:8888:",
            "1111:2222:3333::7777:8888:",
            "1111:2222::7777:8888:",
            "1111::7777:8888:",
            "::7777:8888:",
            "1111:2222:3333:4444::6666:7777:8888:",
            "1111:2222:3333::6666:7777:8888:",
            "1111:2222::6666:7777:8888:",
            "1111::6666:7777:8888:",
            "::6666:7777:8888:",
            "1111:2222:3333::5555:6666:7777:8888:",
            "1111:2222::5555:6666:7777:8888:",
            "1111::5555:6666:7777:8888:",
            "::5555:6666:7777:8888:",
            "1111:2222::4444:5555:6666:7777:8888:",
            "1111::4444:5555:6666:7777:8888:",
            "::4444:5555:6666:7777:8888:",
            "1111::3333:4444:5555:6666:7777:8888:",
            "::3333:4444:5555:6666:7777:8888:",
            "::2222:3333:4444:5555:6666:7777:8888:",
            "':10.0.0.1",
        )
        for s in invalid:
>           with self.assertRaises(
                dns.exception.SyntaxError, msg=f'invalid IPv6 address: "{s}"'
            ):
E           AssertionError: SyntaxError not raised : invalid IPv6 address: "02001:0000:1234:0000:0000:C1C0:ABCD:0876"

tests/test_address.py:582: AssertionError
</pre>
</details>
<h3 id="test_addresspyipv6teststest_valid">test_address.py::IPv6Tests::test_valid</h3>
<details><summary> <pre>test_address.py::IPv6Tests::test_valid</pre></summary><pre>
self = <tests.test_address.IPv6Tests testMethod=test_valid>

    def test_valid(self):
        valid = (
            "::1",
            "::",
            "0:0:0:0:0:0:0:1",
            "0:0:0:0:0:0:0:0",
            "2001:DB8:0:0:8:800:200C:417A",
            "FF01:0:0:0:0:0:0:101",
            "2001:DB8::8:800:200C:417A",
            "FF01::101",
            "fe80::217:f2ff:fe07:ed62",
            "2001:0000:1234:0000:0000:C1C0:ABCD:0876",
            "3ffe:0b00:0000:0000:0001:0000:0000:000a",
            "FF02:0000:0000:0000:0000:0000:0000:0001",
            "0000:0000:0000:0000:0000:0000:0000:0001",
            "0000:0000:0000:0000:0000:0000:0000:0000",
            "2::10",
            "ff02::1",
            "fe80::",
            "2002::",
            "2001:db8::",
            "2001:0db8:1234::",
            "::ffff:0:0",
            "1:2:3:4:5:6:7:8",
            "1:2:3:4:5:6::8",
            "1:2:3:4:5::8",
            "1:2:3:4::8",
            "1:2:3::8",
            "1:2::8",
            "1::8",
            "1::2:3:4:5:6:7",
            "1::2:3:4:5:6",
            "1::2:3:4:5",
            "1::2:3:4",
            "1::2:3",
            "::2:3:4:5:6:7:8",
            "::2:3:4:5:6:7",
            "::2:3:4:5:6",
            "::2:3:4:5",
            "::2:3:4",
            "::2:3",
            "::8",
            "1:2:3:4:5:6::",
            "1:2:3:4:5::",
            "1:2:3:4::",
            "1:2:3::",
            "1:2::",
            "1::",
            "1:2:3:4:5::7:8",
            "1:2:3:4::7:8",
            "1:2:3::7:8",
            "1:2::7:8",
            "1::7:8",
            "1:2:3:4:5:6:1.2.3.4",
            "1:2:3:4:5::1.2.3.4",
            "1:2:3:4::1.2.3.4",
            "1:2:3::1.2.3.4",
            "1:2::1.2.3.4",
            "1::1.2.3.4",
            "1:2:3:4::5:1.2.3.4",
            "1:2:3::5:1.2.3.4",
            "1:2:3::5:1.2.3.4",
            "1:2::5:1.2.3.4",
            "1::5:1.2.3.4",
            "1::5:11.22.33.44",
            "fe80::217:f2ff:254.7.237.98",
            "::ffff:192.168.1.26",
            "::ffff:192.168.1.1",
            "0:0:0:0:0:0:13.1.68.3",
            "0:0:0:0:0:FFFF:129.144.52.38",
            "::13.1.68.3",
            "::FFFF:129.144.52.38",
            "fe80:0:0:0:204:61ff:254.157.241.86",
            "fe80::204:61ff:254.157.241.86",
            "::ffff:12.34.56.78",
            "::ffff:192.0.2.128",
            "fe80:0000:0000:0000:0204:61ff:fe9d:f156",
            "fe80:0:0:0:204:61ff:fe9d:f156",
            "fe80::204:61ff:fe9d:f156",
            "fe80::1",
            "::ffff:c000:280",
            "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
            "2001:db8:85a3:0:0:8a2e:370:7334",
            "2001:db8:85a3::8a2e:370:7334",
            "2001:0db8:0000:0000:0000:0000:1428:57ab",
            "2001:0db8:0000:0000:0000::1428:57ab",
            "2001:0db8:0:0:0:0:1428:57ab",
            "2001:0db8:0:0::1428:57ab",
            "2001:0db8::1428:57ab",
            "2001:db8::1428:57ab",
            "::ffff:0c22:384e",
            "2001:0db8:1234:0000:0000:0000:0000:0000",
            "2001:0db8:1234:ffff:ffff:ffff:ffff:ffff",
            "2001:db8:a::123",
            "1111:2222:3333:4444:5555:6666:7777:8888",
            "1111:2222:3333:4444:5555:6666:7777::",
            "1111:2222:3333:4444:5555:6666::",
            "1111:2222:3333:4444:5555::",
            "1111:2222:3333:4444::",
            "1111:2222:3333::",
            "1111:2222::",
            "1111::",
            "1111:2222:3333:4444:5555:6666::8888",
            "1111:2222:3333:4444:5555::8888",
            "1111:2222:3333:4444::8888",
            "1111:2222:3333::8888",
            "1111:2222::8888",
            "1111::8888",
            "::8888",
            "1111:2222:3333:4444:5555::7777:8888",
            "1111:2222:3333:4444::7777:8888",
            "1111:2222:3333::7777:8888",
            "1111:2222::7777:8888",
            "1111::7777:8888",
            "::7777:8888",
            "1111:2222:3333:4444::6666:7777:8888",
            "1111:2222:3333::6666:7777:8888",
            "1111:2222::6666:7777:8888",
            "1111::6666:7777:8888",
            "::6666:7777:8888",
            "1111:2222:3333::5555:6666:7777:8888",
            "1111:2222::5555:6666:7777:8888",
            "1111::5555:6666:7777:8888",
            "::5555:6666:7777:8888",
            "1111:2222::4444:5555:6666:7777:8888",
            "1111::4444:5555:6666:7777:8888",
            "::4444:5555:6666:7777:8888",
            "1111::3333:4444:5555:6666:7777:8888",
            "::3333:4444:5555:6666:7777:8888",
            "::2222:3333:4444:5555:6666:7777:8888",
            "1111:2222:3333:4444:5555:6666:123.123.123.123",
            "1111:2222:3333:4444:5555::123.123.123.123",
            "1111:2222:3333:4444::123.123.123.123",
            "1111:2222:3333::123.123.123.123",
            "1111:2222::123.123.123.123",
            "1111::123.123.123.123",
            "::123.123.123.123",
            "1111:2222:3333:4444::6666:123.123.123.123",
            "1111:2222:3333::6666:123.123.123.123",
            "1111:2222::6666:123.123.123.123",
            "1111::6666:123.123.123.123",
            "::6666:123.123.123.123",
            "1111:2222:3333::5555:6666:123.123.123.123",
            "1111:2222::5555:6666:123.123.123.123",
            "1111::5555:6666:123.123.123.123",
            "::5555:6666:123.123.123.123",
            "1111:2222::4444:5555:6666:123.123.123.123",
            "1111::4444:5555:6666:123.123.123.123",
            "::4444:5555:6666:123.123.123.123",
            "1111::3333:4444:5555:6666:123.123.123.123",
            "::2222:3333:4444:5555:6666:123.123.123.123",
            "::0:0:0:0:0:0:0",
            "::0:0:0:0:0:0",
            "::0:0:0:0:0",
            "::0:0:0:0",
            "::0:0:0",
            "::0:0",
            "::0",
            "0:0:0:0:0:0:0::",
            "0:0:0:0:0:0::",
            "0:0:0:0:0::",
            "0:0:0:0::",
            "0:0:0::",
            "0:0::",
            "0::",
            "0:a:b:c:d:e:f::",
            "::0:a:b:c:d:e:f",
            "a:b:c:d:e:f:0::",
        )

        win32_invalid = {
            "::2:3:4:5:6:7:8",
            "::2222:3333:4444:5555:6666:7777:8888",
            "::2222:3333:4444:5555:6666:123.123.123.123",
            "::0:0:0:0:0:0:0",
            "::0:a:b:c:d:e:f",
        }

        for s in valid:
            if sys.platform == "win32" and s in win32_invalid:
                # socket.inet_pton() on win32 rejects some valid (as
                # far as we can tell) IPv6 addresses.  Skip them.
                continue
            self.assertEqual(
>               dns.ipv6.inet_aton(s), socket.inet_pton(socket.AF_INET6, s)
            )

tests/test_address.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = '1:2:3:4:5:6:1.2.3.4', ignore_scope = False

    def inet_aton(text: Union[str, bytes], ignore_scope: bool=False) ->bytes:
        """Convert an IPv6 address in text form to binary form.

        *text*, a ``str`` or ``bytes``, the IPv6 address in textual form.

        *ignore_scope*, a ``bool``.  If ``True``, a scope will be ignored.
        If ``False``, the default, it is an error for a scope to be present.

        Returns a ``bytes``.
        """
        if isinstance(text, bytes):
            text = text.decode()

        if '%' in text:
            if ignore_scope:
                text = text.split('%')[0]
            else:
                raise dns.exception.SyntaxError("IPv6 address with a scope")

        if '::' in text:
            left, right = text.split('::', 1)
            left_parts = left.split(':') if left else []
            right_parts = right.split(':') if right else []
            missing = 8 - (len(left_parts) + len(right_parts))
            parts = left_parts + ['0'] * missing + right_parts
        else:
            parts = text.split(':')

        if len(parts) != 8:
>           raise dns.exception.SyntaxError("Invalid IPv6 address")
E           dns.exception.SyntaxError: Invalid IPv6 address

dns/ipv6.py:85: SyntaxError
</pre>
</details>
<h3 id="test_entropypyentropytestcasetest_functions">test_entropy.py::EntropyTestCase::test_functions</h3>
<details><summary> <pre>test_entropy.py::EntropyTestCase::test_functions</pre></summary><pre>
self = <tests.test_entropy.EntropyTestCase testMethod=test_functions>

    def test_functions(self):
>       v = dns.entropy.random_16()
E       AttributeError: module 'dns.entropy' has no attribute 'random_16'. Did you mean: 'random'?

tests/test_entropy.py:41: AttributeError
</pre>
</details>
<h3 id="test_entropypyentropytestcasetest_pool">test_entropy.py::EntropyTestCase::test_pool</h3>
<details><summary> <pre>test_entropy.py::EntropyTestCase::test_pool</pre></summary><pre>
self = <tests.test_entropy.EntropyTestCase testMethod=test_pool>

    def test_pool(self):
>       pool = dns.entropy.EntropyPool(b"seed-value")

tests/test_entropy.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <dns.entropy.EntropyPool object at 0x7ff67f6aa660>, seed = b'seed-value'

    def __init__(self, seed: Optional[bytes]=None):
        self.pool_index = 0
        self.digest: Optional[bytearray] = None
        self.next_byte = 0
        self.lock = threading.Lock()
        self.hash = hashlib.sha1()
        self.hash_len = 20
        self.pool = bytearray(b'\x00' * self.hash_len)
        if seed is not None:
>           self._stir(seed)
E           AttributeError: 'EntropyPool' object has no attribute '_stir'

dns/entropy.py:20: AttributeError
</pre>
</details>
<h3 id="test_entropypyentropytestcasetest_pool_random">test_entropy.py::EntropyTestCase::test_pool_random</h3>
<details><summary> <pre>test_entropy.py::EntropyTestCase::test_pool_random</pre></summary><pre>
self = <tests.test_entropy.EntropyTestCase testMethod=test_pool_random>

    def test_pool_random(self):
        pool = dns.entropy.EntropyPool()
>       values = {pool.random_32() for n in range(12)}
E       AttributeError: 'EntropyPool' object has no attribute 'random_32'

tests/test_entropy.py:22: AttributeError
</pre>
</details>
<h3 id="test_entropypyentropytestcasetest_pool_random_between">test_entropy.py::EntropyTestCase::test_pool_random_between</h3>
<details><summary> <pre>test_entropy.py::EntropyTestCase::test_pool_random_between</pre></summary><pre>
self = <tests.test_entropy.EntropyTestCase testMethod=test_pool_random_between>

    def test_pool_random_between(self):
        pool = dns.entropy.EntropyPool()

        def bad():
            pool.random_between(0, 4294967296)

>       self.assertRaises(ValueError, bad)

tests/test_entropy.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def bad():
>       pool.random_between(0, 4294967296)
E       AttributeError: 'EntropyPool' object has no attribute 'random_between'

tests/test_entropy.py:30: AttributeError
</pre>
</details>
<h3 id="test_entropypyentropyforcepooltestcasetest_functions">test_entropy.py::EntropyForcePoolTestCase::test_functions</h3>
<details><summary> <pre>test_entropy.py::EntropyForcePoolTestCase::test_functions</pre></summary><pre>
self = <tests.test_entropy.EntropyForcePoolTestCase testMethod=test_functions>

    def test_functions(self):
>       v = dns.entropy.random_16()
E       AttributeError: module 'dns.entropy' has no attribute 'random_16'. Did you mean: 'random'?

tests/test_entropy.py:56: AttributeError
</pre>
</details>
<h3 id="test_exceptionspyexceptiontestcasetest_formatted_error">test_exceptions.py::ExceptionTestCase::test_formatted_error</h3>
<details><summary> <pre>test_exceptions.py::ExceptionTestCase::test_formatted_error</pre></summary><pre>
self = <tests.test_exceptions.ExceptionTestCase testMethod=test_formatted_error>

    def test_formatted_error(self):
        """Exceptions with explicit format has to respect it."""
        params = {"parameter": "value"}
        try:
>           raise FormatedError(**params)

tests/test_exceptions.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = FormatedError(), args = (), kwargs = {'parameter': 'value'}

    def __init__(self, *args, **kwargs):
        self._check_params(*args, **kwargs)
        if kwargs:
>           self.kwargs = self._check_kwargs(**kwargs)
E           AttributeError: 'FormatedError' object has no attribute '_check_kwargs'. Did you mean: '_check_params'?

dns/exception.py:38: AttributeError
</pre>
</details>
<h3 id="test_exceptionspyexceptiontestcasetest_kwargs_only">test_exceptions.py::ExceptionTestCase::test_kwargs_only</h3>
<details><summary> <pre>test_exceptions.py::ExceptionTestCase::test_kwargs_only</pre></summary><pre>
self = <tests.test_exceptions.ExceptionTestCase testMethod=test_kwargs_only>

    def test_kwargs_only(self):
        """Kwargs cannot be combined with args."""
        with self.assertRaises(AssertionError):
>           raise FormatedError(1, a=2)

tests/test_exceptions.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dns/exception.py:36: in __init__
    self._check_params(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _check_params(self, *args, **kwargs):
        """Old exceptions supported only args and not kwargs.

        For sanity we do not allow to mix old and new behavior."""
        if args and kwargs:
>           raise ValueError("Cannot mix args and kwargs in exception initialization")
E           ValueError: Cannot mix args and kwargs in exception initialization

dns/exception.py:54: ValueError
</pre>
</details>
<h3 id="test_exceptionspyexceptiontestcasetest_kwargs_unsupported">test_exceptions.py::ExceptionTestCase::test_kwargs_unsupported</h3>
<details><summary> <pre>test_exceptions.py::ExceptionTestCase::test_kwargs_unsupported</pre></summary><pre>
self = <tests.test_exceptions.ExceptionTestCase testMethod=test_kwargs_unsupported>

    def test_kwargs_unsupported(self):
        """Only supported kwargs are accepted."""
        with self.assertRaises(AssertionError):
>           raise FormatedError(unsupported=2)

tests/test_exceptions.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dns/exception.py:36: in __init__
    self._check_params(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _check_params(self, *args, **kwargs):
        """Old exceptions supported only args and not kwargs.

        For sanity we do not allow to mix old and new behavior."""
        if args and kwargs:
            raise ValueError("Cannot mix args and kwargs in exception initialization")
        if kwargs and not set(kwargs.keys()).issubset(self.supp_kwargs):
>           raise ValueError(f"Unsupported kwargs: {set(kwargs.keys()) - self.supp_kwargs}")
E           ValueError: Unsupported kwargs: {'unsupported'}

dns/exception.py:56: ValueError
</pre>
</details>
<h3 id="test_flagspyflagstestcasetest_rcode4">test_flags.py::FlagsTestCase::test_rcode4</h3>
<details><summary> <pre>test_flags.py::FlagsTestCase::test_rcode4</pre></summary><pre>
self = <tests.test_flags.FlagsTestCase testMethod=test_rcode4>

    def test_rcode4(self):
>       self.assertEqual(dns.rcode.to_flags(dns.rcode.BADVERS), (0, 0x01000000))
E       AssertionError: Tuples differ: (0, 256) != (0, 16777216)
E       
E       First differing element 1:
E       256
E       16777216
E       
E       - (0, 256)
E       + (0, 16777216)

tests/test_flags.py:36: AssertionError
</pre>
</details>
<h3 id="test_flagspyflagstestcasetest_rcode6">test_flags.py::FlagsTestCase::test_rcode6</h3>
<details><summary> <pre>test_flags.py::FlagsTestCase::test_rcode6</pre></summary><pre>
self = <tests.test_flags.FlagsTestCase testMethod=test_rcode6>

    def test_rcode6(self):
>       self.assertEqual(dns.rcode.from_flags(0, 0x01000000), dns.rcode.BADVERS)
E       AssertionError: <Rcode.NOERROR: 0> != <Rcode.BADVERS: 16>

tests/test_flags.py:39: AssertionError
</pre>
</details>
<h3 id="test_flagspyflagstestcasetest_rcode_badsig">test_flags.py::FlagsTestCase::test_rcode_badsig</h3>
<details><summary> <pre>test_flags.py::FlagsTestCase::test_rcode_badsig</pre></summary><pre>
self = <tests.test_flags.FlagsTestCase testMethod=test_rcode_badsig>

    def test_rcode_badsig(self):
        rcode = dns.rcode.BADSIG
        self.assertEqual(rcode.value, 16)
        # Yes, we mean BADVERS on the next line.  BADSIG and BADVERS have
        # the same code.
        self.assertEqual(rcode.name, "BADVERS")
        self.assertEqual(dns.rcode.to_text(rcode), "BADVERS")
        # In TSIG text mode, it should be BADSIG
>       self.assertEqual(dns.rcode.to_text(rcode, True), "BADSIG")
E       AssertionError: 'BADVERS' != 'BADSIG'
E       - BADVERS
E       + BADSIG

tests/test_flags.py:74: AssertionError
</pre>
</details>
<h3 id="test_flagspyflagstestcasetest_unknown_rcode">test_flags.py::FlagsTestCase::test_unknown_rcode</h3>
<details><summary> <pre>test_flags.py::FlagsTestCase::test_unknown_rcode</pre></summary><pre>
@classmethod
    def make(cls: Type[TIntEnum], value: Union[int, str]) ->TIntEnum:
        """Convert text or a value into an enumerated type, if possible.

        *value*, the ``int`` or ``str`` to convert.

        Raises a class-specific exception if a ``str`` is provided that
        cannot be converted.

        Raises ``ValueError`` if the value is out of range.

        Returns an enumeration from the calling class corresponding to the
        value, if one is defined, or an ``int`` otherwise.
        """
        if isinstance(value, str):
            try:
>               return cls[value.upper()]

dns/enum.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'Rcode'>, name = 'BOGUS'

    def __getitem__(cls, name):
        """
        Return the member matching `name`.
        """
>       return cls._member_map_[name]
E       KeyError: 'BOGUS'

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/enum.py:814: KeyError

During handling of the above exception, another exception occurred:

self = <tests.test_flags.FlagsTestCase testMethod=test_unknown_rcode>

    def test_unknown_rcode(self):
        with self.assertRaises(dns.rcode.UnknownRcode):
>           dns.rcode.Rcode.make("BOGUS")

tests/test_flags.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @classmethod
    def make(cls: Type[TIntEnum], value: Union[int, str]) ->TIntEnum:
        """Convert text or a value into an enumerated type, if possible.

        *value*, the ``int`` or ``str`` to convert.

        Raises a class-specific exception if a ``str`` is provided that
        cannot be converted.

        Raises ``ValueError`` if the value is out of range.

        Returns an enumeration from the calling class corresponding to the
        value, if one is defined, or an ``int`` otherwise.
        """
        if isinstance(value, str):
            try:
                return cls[value.upper()]
            except KeyError:
>               raise cls.UnknownValue(f"Unknown {cls.__name__}: {value}")
E               AttributeError: type object 'Rcode' has no attribute 'UnknownValue'

dns/enum.py:26: AttributeError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_aton3">test_ntoaaton.py::NtoAAtoNTestCase::test_aton3</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_aton3</pre></summary><pre>
text = '::10.0.0.1', ignore_scope = False

    def inet_aton(text: Union[str, bytes], ignore_scope: bool=False) ->bytes:
        """Convert an IPv6 address in text form to binary form.

        *text*, a ``str`` or ``bytes``, the IPv6 address in textual form.

        *ignore_scope*, a ``bool``.  If ``True``, a scope will be ignored.
        If ``False``, the default, it is an error for a scope to be present.

        Returns a ``bytes``.
        """
        if isinstance(text, bytes):
            text = text.decode()

        if '%' in text:
            if ignore_scope:
                text = text.split('%')[0]
            else:
                raise dns.exception.SyntaxError("IPv6 address with a scope")

        if '::' in text:
            left, right = text.split('::', 1)
            left_parts = left.split(':') if left else []
            right_parts = right.split(':') if right else []
            missing = 8 - (len(left_parts) + len(right_parts))
            parts = left_parts + ['0'] * missing + right_parts
        else:
            parts = text.split(':')

        if len(parts) != 8:
            raise dns.exception.SyntaxError("Invalid IPv6 address")

        try:
>           return b''.join(int(part, 16).to_bytes(2, 'big') for part in parts)

dns/ipv6.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <list_iterator object at 0x7ff67eefe0e0>

>   return b''.join(int(part, 16).to_bytes(2, 'big') for part in parts)
E   ValueError: invalid literal for int() with base 16: '10.0.0.1'

dns/ipv6.py:88: ValueError

During handling of the above exception, another exception occurred:

self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_aton3>

    def test_aton3(self):
>       a = aton6("::10.0.0.1")

tests/test_ntoaaton.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = '::10.0.0.1', ignore_scope = False

    def inet_aton(text: Union[str, bytes], ignore_scope: bool=False) ->bytes:
        """Convert an IPv6 address in text form to binary form.

        *text*, a ``str`` or ``bytes``, the IPv6 address in textual form.

        *ignore_scope*, a ``bool``.  If ``True``, a scope will be ignored.
        If ``False``, the default, it is an error for a scope to be present.

        Returns a ``bytes``.
        """
        if isinstance(text, bytes):
            text = text.decode()

        if '%' in text:
            if ignore_scope:
                text = text.split('%')[0]
            else:
                raise dns.exception.SyntaxError("IPv6 address with a scope")

        if '::' in text:
            left, right = text.split('::', 1)
            left_parts = left.split(':') if left else []
            right_parts = right.split(':') if right else []
            missing = 8 - (len(left_parts) + len(right_parts))
            parts = left_parts + ['0'] * missing + right_parts
        else:
            parts = text.split(':')

        if len(parts) != 8:
            raise dns.exception.SyntaxError("Invalid IPv6 address")

        try:
            return b''.join(int(part, 16).to_bytes(2, 'big') for part in parts)
        except ValueError:
>           raise dns.exception.SyntaxError("Invalid hexadecimal in IPv6 address")
E           dns.exception.SyntaxError: Invalid hexadecimal in IPv6 address

dns/ipv6.py:90: SyntaxError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_aton8">test_ntoaaton.py::NtoAAtoNTestCase::test_aton8</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_aton8</pre></summary><pre>
text = '::10.0.0.1', ignore_scope = False

    def inet_aton(text: Union[str, bytes], ignore_scope: bool=False) ->bytes:
        """Convert an IPv6 address in text form to binary form.

        *text*, a ``str`` or ``bytes``, the IPv6 address in textual form.

        *ignore_scope*, a ``bool``.  If ``True``, a scope will be ignored.
        If ``False``, the default, it is an error for a scope to be present.

        Returns a ``bytes``.
        """
        if isinstance(text, bytes):
            text = text.decode()

        if '%' in text:
            if ignore_scope:
                text = text.split('%')[0]
            else:
                raise dns.exception.SyntaxError("IPv6 address with a scope")

        if '::' in text:
            left, right = text.split('::', 1)
            left_parts = left.split(':') if left else []
            right_parts = right.split(':') if right else []
            missing = 8 - (len(left_parts) + len(right_parts))
            parts = left_parts + ['0'] * missing + right_parts
        else:
            parts = text.split(':')

        if len(parts) != 8:
            raise dns.exception.SyntaxError("Invalid IPv6 address")

        try:
>           return b''.join(int(part, 16).to_bytes(2, 'big') for part in parts)

dns/ipv6.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <list_iterator object at 0x7ff67ee4cf70>

>   return b''.join(int(part, 16).to_bytes(2, 'big') for part in parts)
E   ValueError: invalid literal for int() with base 16: '10.0.0.1'

dns/ipv6.py:88: ValueError

During handling of the above exception, another exception occurred:

self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_aton8>

    def test_aton8(self):
>       a = aton6("::10.0.0.1")

tests/test_ntoaaton.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = '::10.0.0.1', ignore_scope = False

    def inet_aton(text: Union[str, bytes], ignore_scope: bool=False) ->bytes:
        """Convert an IPv6 address in text form to binary form.

        *text*, a ``str`` or ``bytes``, the IPv6 address in textual form.

        *ignore_scope*, a ``bool``.  If ``True``, a scope will be ignored.
        If ``False``, the default, it is an error for a scope to be present.

        Returns a ``bytes``.
        """
        if isinstance(text, bytes):
            text = text.decode()

        if '%' in text:
            if ignore_scope:
                text = text.split('%')[0]
            else:
                raise dns.exception.SyntaxError("IPv6 address with a scope")

        if '::' in text:
            left, right = text.split('::', 1)
            left_parts = left.split(':') if left else []
            right_parts = right.split(':') if right else []
            missing = 8 - (len(left_parts) + len(right_parts))
            parts = left_parts + ['0'] * missing + right_parts
        else:
            parts = text.split(':')

        if len(parts) != 8:
            raise dns.exception.SyntaxError("Invalid IPv6 address")

        try:
            return b''.join(int(part, 16).to_bytes(2, 'big') for part in parts)
        except ValueError:
>           raise dns.exception.SyntaxError("Invalid hexadecimal in IPv6 address")
E           dns.exception.SyntaxError: Invalid hexadecimal in IPv6 address

dns/ipv6.py:90: SyntaxError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_bad_aton4">test_ntoaaton.py::NtoAAtoNTestCase::test_bad_aton4</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_bad_aton4</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_bad_aton4>

    def test_bad_aton4(self):
        def bad():
            aton4("001.002.003.004")

>       self.assertRaises(dns.exception.SyntaxError, bad)
E       AssertionError: SyntaxError not raised by bad

tests/test_ntoaaton.py:110: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_bad_ntoa3">test_ntoaaton.py::NtoAAtoNTestCase::test_bad_ntoa3</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_bad_ntoa3</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_bad_ntoa3>

    def test_bad_ntoa3(self):
        def bad():
            ntoa4(b"\x00" * 5)

        # Ideally we'd have been consistent and raised ValueError as
        # we do for IPv6, but oh well!
>       self.assertRaises(dns.exception.SyntaxError, bad)
E       AssertionError: SyntaxError not raised by bad

tests/test_ntoaaton.py:222: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_bad_v4_aton">test_ntoaaton.py::NtoAAtoNTestCase::test_bad_v4_aton</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_bad_v4_aton</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_bad_v4_aton>

    def test_bad_v4_aton(self):
        def make_bad(a):
            def bad():
                return aton4(a)

            return bad

        for addr in v4_bad_addrs:
>           self.assertRaises(dns.exception.SyntaxError, make_bad(addr))
E           AssertionError: SyntaxError not raised by bad

tests/test_ntoaaton.py:244: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_inet_canonicalize">test_ntoaaton.py::NtoAAtoNTestCase::test_inet_canonicalize</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_inet_canonicalize</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_inet_canonicalize>

    def test_inet_canonicalize(self):
        for address, expected in itertools.chain(
            v4_canonicalize_addrs, v6_canonicalize_addrs
        ):
>           self.assertEqual(dns.inet.canonicalize(address), expected)
E           AssertionError: '2001:0503:83eb::0030' != '2001:503:83eb::30'
E           - 2001:0503:83eb::0030
E           ?      -          --
E           + 2001:503:83eb::30

tests/test_ntoaaton.py:395: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ipv4_canonicalize">test_ntoaaton.py::NtoAAtoNTestCase::test_ipv4_canonicalize</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ipv4_canonicalize</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ipv4_canonicalize>

    def test_ipv4_canonicalize(self):
        for address, expected in v4_canonicalize_addrs:
            self.assertEqual(dns.ipv4.canonicalize(address), expected)
        for bad_address in bad_canonicalize_addrs:
>           self.assertRaises(
                dns.exception.SyntaxError, lambda: dns.ipv4.canonicalize(bad_address)
            )
E           AssertionError: SyntaxError not raised by <lambda>

tests/test_ntoaaton.py:379: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ipv6_canonicalize">test_ntoaaton.py::NtoAAtoNTestCase::test_ipv6_canonicalize</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ipv6_canonicalize</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ipv6_canonicalize>

    def test_ipv6_canonicalize(self):
        for address, expected in v6_canonicalize_addrs:
>           self.assertEqual(dns.ipv6.canonicalize(address), expected)
E           AssertionError: '2001:0503:83eb::0030' != '2001:503:83eb::30'
E           - 2001:0503:83eb::0030
E           ?      -          --
E           + 2001:503:83eb::30

tests/test_ntoaaton.py:385: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_is_mapped">test_ntoaaton.py::NtoAAtoNTestCase::test_is_mapped</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_is_mapped</pre></summary><pre>
text = '::ffff:127.0.0.1', ignore_scope = False

    def inet_aton(text: Union[str, bytes], ignore_scope: bool=False) ->bytes:
        """Convert an IPv6 address in text form to binary form.

        *text*, a ``str`` or ``bytes``, the IPv6 address in textual form.

        *ignore_scope*, a ``bool``.  If ``True``, a scope will be ignored.
        If ``False``, the default, it is an error for a scope to be present.

        Returns a ``bytes``.
        """
        if isinstance(text, bytes):
            text = text.decode()

        if '%' in text:
            if ignore_scope:
                text = text.split('%')[0]
            else:
                raise dns.exception.SyntaxError("IPv6 address with a scope")

        if '::' in text:
            left, right = text.split('::', 1)
            left_parts = left.split(':') if left else []
            right_parts = right.split(':') if right else []
            missing = 8 - (len(left_parts) + len(right_parts))
            parts = left_parts + ['0'] * missing + right_parts
        else:
            parts = text.split(':')

        if len(parts) != 8:
            raise dns.exception.SyntaxError("Invalid IPv6 address")

        try:
>           return b''.join(int(part, 16).to_bytes(2, 'big') for part in parts)

dns/ipv6.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <list_iterator object at 0x7ff67f019b10>

>   return b''.join(int(part, 16).to_bytes(2, 'big') for part in parts)
E   ValueError: invalid literal for int() with base 16: '127.0.0.1'

dns/ipv6.py:88: ValueError

During handling of the above exception, another exception occurred:

self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_is_mapped>

    def test_is_mapped(self):
        t1 = "2001:db8:0:1:1:1:1:1"
        t2 = "::ffff:127.0.0.1"
        t3 = "1::ffff:127.0.0.1"
        self.assertFalse(dns.ipv6.is_mapped(aton6(t1)))
>       self.assertTrue(dns.ipv6.is_mapped(aton6(t2)))

tests/test_ntoaaton.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = '::ffff:127.0.0.1', ignore_scope = False

    def inet_aton(text: Union[str, bytes], ignore_scope: bool=False) ->bytes:
        """Convert an IPv6 address in text form to binary form.

        *text*, a ``str`` or ``bytes``, the IPv6 address in textual form.

        *ignore_scope*, a ``bool``.  If ``True``, a scope will be ignored.
        If ``False``, the default, it is an error for a scope to be present.

        Returns a ``bytes``.
        """
        if isinstance(text, bytes):
            text = text.decode()

        if '%' in text:
            if ignore_scope:
                text = text.split('%')[0]
            else:
                raise dns.exception.SyntaxError("IPv6 address with a scope")

        if '::' in text:
            left, right = text.split('::', 1)
            left_parts = left.split(':') if left else []
            right_parts = right.split(':') if right else []
            missing = 8 - (len(left_parts) + len(right_parts))
            parts = left_parts + ['0'] * missing + right_parts
        else:
            parts = text.split(':')

        if len(parts) != 8:
            raise dns.exception.SyntaxError("Invalid IPv6 address")

        try:
            return b''.join(int(part, 16).to_bytes(2, 'big') for part in parts)
        except ValueError:
>           raise dns.exception.SyntaxError("Invalid hexadecimal in IPv6 address")
E           dns.exception.SyntaxError: Invalid hexadecimal in IPv6 address

dns/ipv6.py:90: SyntaxError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_low_level_address_tuple">test_ntoaaton.py::NtoAAtoNTestCase::test_low_level_address_tuple</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_low_level_address_tuple</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_low_level_address_tuple>

    def test_low_level_address_tuple(self):
        t = dns.inet.low_level_address_tuple(("1.2.3.4", 53))
        self.assertEqual(t, ("1.2.3.4", 53))
        t = dns.inet.low_level_address_tuple(("2600::1", 53))
        self.assertEqual(t, ("2600::1", 53, 0, 0))
        t = dns.inet.low_level_address_tuple(("1.2.3.4", 53), socket.AF_INET)
        self.assertEqual(t, ("1.2.3.4", 53))
        t = dns.inet.low_level_address_tuple(("2600::1", 53), socket.AF_INET6)
        self.assertEqual(t, ("2600::1", 53, 0, 0))
        t = dns.inet.low_level_address_tuple(("fd80::1%2", 53), socket.AF_INET6)
>       self.assertEqual(t, ("fd80::1", 53, 0, 2))
E       AssertionError: Tuples differ: ('fd80::1%2', 53, 0, 0) != ('fd80::1', 53, 0, 2)
E       
E       First differing element 0:
E       'fd80::1%2'
E       'fd80::1'
E       
E       - ('fd80::1%2', 53, 0, 0)
E       ?          --          ^
E       
E       + ('fd80::1', 53, 0, 2)
E       ?                    ^

tests/test_ntoaaton.py:341: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_multiple_scopes_bad">test_ntoaaton.py::NtoAAtoNTestCase::test_multiple_scopes_bad</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_multiple_scopes_bad</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_multiple_scopes_bad>

    def test_multiple_scopes_bad(self):
        def bad():
            t1 = "fe80::1%lo0%lo1"
            aton6(t1, True)

>       self.assertRaises(dns.exception.SyntaxError, bad)
E       AssertionError: SyntaxError not raised by bad

tests/test_ntoaaton.py:311: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa1">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa1</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa1</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa1>

    def test_ntoa1(self):
        b = binascii.unhexlify(b"00010002000300040005000600070008")
        t = ntoa6(b)
>       self.assertEqual(t, "1:2:3:4:5:6:7:8")
E       AssertionError: '0001:0002:0003:0004:0005:0006:0007:0008' != '1:2:3:4:5:6:7:8'
E       - 0001:0002:0003:0004:0005:0006:0007:0008
E       + 1:2:3:4:5:6:7:8

tests/test_ntoaaton.py:131: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa10">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa10</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa10</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa10>

    def test_ntoa10(self):
        b = binascii.unhexlify(b"0000000000000000000000010a000001")
        t = ntoa6(b)
>       self.assertEqual(t, "::1:a00:1")
E       AssertionError: '::0001:0a00:0001' != '::1:a00:1'
E       - ::0001:0a00:0001
E       + ::1:a00:1

tests/test_ntoaaton.py:176: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa11">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa11</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa11</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa11>

    def test_ntoa11(self):
        b = binascii.unhexlify(b"00000000000000000000ffff0a000001")
        t = ntoa6(b)
>       self.assertEqual(t, "::ffff:10.0.0.1")
E       AssertionError: '::ffff:0a00:0001' != '::ffff:10.0.0.1'
E       - ::ffff:0a00:0001
E       + ::ffff:10.0.0.1

tests/test_ntoaaton.py:181: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa12">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa12</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa12</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa12>

    def test_ntoa12(self):
        b = binascii.unhexlify(b"000000000000000000000000ffffffff")
        t = ntoa6(b)
>       self.assertEqual(t, "::255.255.255.255")
E       AssertionError: '::ffff:ffff' != '::255.255.255.255'
E       - ::ffff:ffff
E       + ::255.255.255.255

tests/test_ntoaaton.py:186: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa13">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa13</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa13</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa13>

    def test_ntoa13(self):
        b = binascii.unhexlify(b"00000000000000000000ffffffffffff")
        t = ntoa6(b)
>       self.assertEqual(t, "::ffff:255.255.255.255")
E       AssertionError: '::ffff:ffff:ffff' != '::ffff:255.255.255.255'
E       - ::ffff:ffff:ffff
E       + ::ffff:255.255.255.255

tests/test_ntoaaton.py:191: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa14">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa14</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa14</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa14>

    def test_ntoa14(self):
        b = binascii.unhexlify(b"0000000000000000000000000001ffff")
        t = ntoa6(b)
>       self.assertEqual(t, "::0.1.255.255")
E       AssertionError: '::0001:ffff' != '::0.1.255.255'
E       - ::0001:ffff
E       + ::0.1.255.255

tests/test_ntoaaton.py:196: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa15">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa15</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa15</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa15>

    def test_ntoa15(self):
        # This exercises the current_len > best_len branch in the <= case.
        b = binascii.unhexlify(b"0000ffff00000000ffff00000000ffff")
        t = ntoa6(b)
>       self.assertEqual(t, "0:ffff::ffff:0:0:ffff")
E       AssertionError: '0000:ffff::ffff:0000:0000:ffff' != '0:ffff::ffff:0:0:ffff'
E       - 0000:ffff::ffff:0000:0000:ffff
E       ? ---              --- ---
E       + 0:ffff::ffff:0:0:ffff

tests/test_ntoaaton.py:202: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa2">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa2</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa2</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa2>

    def test_ntoa2(self):
        b = b"\x00" * 16
        t = ntoa6(b)
>       self.assertEqual(t, "::")
E       AssertionError: '' != '::'
E       + ::

tests/test_ntoaaton.py:136: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa3">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa3</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa3</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa3>

    def test_ntoa3(self):
        b = b"\x00" * 15 + b"\x01"
        t = ntoa6(b)
>       self.assertEqual(t, "::1")
E       AssertionError: '::0001' != '::1'
E       - ::0001
E       + ::1

tests/test_ntoaaton.py:141: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa5">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa5</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa5</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa5>

    def test_ntoa5(self):
        b = b"\x01\xcd" + b"\x00" * 12 + b"\x03\xef"
        t = ntoa6(b)
>       self.assertEqual(t, "1cd::3ef")
E       AssertionError: '01cd::03ef' != '1cd::3ef'
E       - 01cd::03ef
E       ? -     -
E       + 1cd::3ef

tests/test_ntoaaton.py:151: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa6">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa6</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa6</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa6>

    def test_ntoa6(self):
        b = binascii.unhexlify(b"ffff00000000ffff000000000000ffff")
        t = ntoa6(b)
>       self.assertEqual(t, "ffff:0:0:ffff::ffff")
E       AssertionError: 'ffff:0000:0000:ffff::ffff' != 'ffff:0:0:ffff::ffff'
E       - ffff:0000:0000:ffff::ffff
E       ?       --- ---
E       + ffff:0:0:ffff::ffff

tests/test_ntoaaton.py:156: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa7">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa7</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa7</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa7>

    def test_ntoa7(self):
        b = binascii.unhexlify(b"00000000ffff000000000000ffffffff")
        t = ntoa6(b)
>       self.assertEqual(t, "0:0:ffff::ffff:ffff")
E       AssertionError: '0000:0000:ffff::ffff:ffff' != '0:0:ffff::ffff:ffff'
E       - 0000:0000:ffff::ffff:ffff
E       ? ---  ---
E       + 0:0:ffff::ffff:ffff

tests/test_ntoaaton.py:161: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa8">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa8</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa8</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa8>

    def test_ntoa8(self):
        b = binascii.unhexlify(b"ffff0000ffff00000000ffff00000000")
        t = ntoa6(b)
>       self.assertEqual(t, "ffff:0:ffff::ffff:0:0")
E       AssertionError: 'ffff:0000:ffff::ffff:0000:0000' != 'ffff:0:ffff::ffff:0:0'
E       - ffff:0000:ffff::ffff:0000:0000
E       ?      ---              ---  ---
E       + ffff:0:ffff::ffff:0:0

tests/test_ntoaaton.py:166: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ntoa9">test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa9</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ntoa9</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ntoa9>

    def test_ntoa9(self):
        b = binascii.unhexlify(b"0000000000000000000000000a000001")
        t = ntoa6(b)
>       self.assertEqual(t, "::10.0.0.1")
E       AssertionError: '::0a00:0001' != '::10.0.0.1'
E       - ::0a00:0001
E       + ::10.0.0.1

tests/test_ntoaaton.py:171: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_ptontop">test_ntoaaton.py::NtoAAtoNTestCase::test_ptontop</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_ptontop</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_ptontop>

    def test_ptontop(self):
        for af, a in [
            (socket.AF_INET, "1.2.3.4"),
            (socket.AF_INET6, "2001:db8:0:1:1:1:1:1"),
        ]:
>           self.assertEqual(dns.inet.inet_ntop(af, dns.inet.inet_pton(af, a)), a)
E           AssertionError: '2001:0db8:0000:0001:0001:0001:0001:0001' != '2001:db8:0:1:1:1:1:1'
E           - 2001:0db8:0000:0001:0001:0001:0001:0001
E           + 2001:db8:0:1:1:1:1:1

tests/test_ntoaaton.py:318: AssertionError
</pre>
</details>
<h3 id="test_ntoaatonpyntoaatontestcasetest_rfc5952_section_4_2_2">test_ntoaaton.py::NtoAAtoNTestCase::test_rfc5952_section_4_2_2</h3>
<details><summary> <pre>test_ntoaaton.py::NtoAAtoNTestCase::test_rfc5952_section_4_2_2</pre></summary><pre>
self = <tests.test_ntoaaton.NtoAAtoNTestCase testMethod=test_rfc5952_section_4_2_2>

    def test_rfc5952_section_4_2_2(self):
        addr = "2001:db8:0:1:1:1:1:1"
        b1 = aton6(addr)
        t1 = ntoa6(b1)
>       self.assertEqual(t1, addr)
E       AssertionError: '2001:0db8:0000:0001:0001:0001:0001:0001' != '2001:db8:0:1:1:1:1:1'
E       - 2001:0db8:0000:0001:0001:0001:0001:0001
E       + 2001:db8:0:1:1:1:1:1

tests/test_ntoaaton.py:264: AssertionError
</pre>
</details>
<h3 id="test_rdtypeandclasspyrdtypeandclasstestcasetest_class_bytext_bounds1">test_rdtypeandclass.py::RdTypeAndClassTestCase::test_class_bytext_bounds1</h3>
<details><summary> <pre>test_rdtypeandclass.py::RdTypeAndClassTestCase::test_class_bytext_bounds1</pre></summary><pre>
self = <tests.test_rdtypeandclass.RdTypeAndClassTestCase testMethod=test_class_bytext_bounds1>

    def test_class_bytext_bounds1(self):
        self.assertEqual(dns.rdataclass.from_text("CLASS0"), 0)
>       self.assertEqual(dns.rdataclass.from_text("CLASS65535"), 65535)

tests/test_rdtypeandclass.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = 'CLASS65535'

    def from_text(text: str) ->RdataClass:
        """Convert text into a DNS rdata class value.

        The input text can be a defined DNS RR class mnemonic or
        instance of the DNS generic class syntax.

        For example, "IN" and "CLASS1" will both result in a value of 1.

        Raises ``dns.rdatatype.UnknownRdataclass`` if the class is unknown.

        Raises ``ValueError`` if the rdata class value is not >= 0 and <= 65535.

        Returns a ``dns.rdataclass.RdataClass``.
        """
        text = text.upper()
        try:
            return RdataClass[text]
        except KeyError:
            if text.startswith('CLASS'):
                try:
                    value = int(text[5:])
                    if 0 <= value <= 65535:
                        return RdataClass(value)
                    else:
                        raise ValueError("DNS rdata class must be between 0 and 65535")
                except ValueError:
                    pass
>       raise UnknownRdataclass(f"Unknown DNS class: {text}")
E       dns.rdataclass.UnknownRdataclass: Unknown DNS class: CLASS65535

dns/rdataclass.py:53: UnknownRdataclass
</pre>
</details>
<h3 id="test_rdtypeandclasspyrdtypeandclasstestcasetest_class_bytext_bounds2">test_rdtypeandclass.py::RdTypeAndClassTestCase::test_class_bytext_bounds2</h3>
<details><summary> <pre>test_rdtypeandclass.py::RdTypeAndClassTestCase::test_class_bytext_bounds2</pre></summary><pre>
self = <tests.test_rdtypeandclass.RdTypeAndClassTestCase testMethod=test_class_bytext_bounds2>

    def test_class_bytext_bounds2(self):
        def bad():
            dns.rdataclass.from_text("CLASS65536")

>       self.assertRaises(ValueError, bad)

tests/test_rdtypeandclass.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_rdtypeandclass.py:45: in bad
    dns.rdataclass.from_text("CLASS65536")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def from_text(text: str) ->RdataClass:
        """Convert text into a DNS rdata class value.

        The input text can be a defined DNS RR class mnemonic or
        instance of the DNS generic class syntax.

        For example, "IN" and "CLASS1" will both result in a value of 1.

        Raises ``dns.rdatatype.UnknownRdataclass`` if the class is unknown.

        Raises ``ValueError`` if the rdata class value is not >= 0 and <= 65535.

        Returns a ``dns.rdataclass.RdataClass``.
        """
        text = text.upper()
        try:
            return RdataClass[text]
        except KeyError:
            if text.startswith('CLASS'):
                try:
                    value = int(text[5:])
                    if 0 <= value <= 65535:
                        return RdataClass(value)
                    else:
                        raise ValueError("DNS rdata class must be between 0 and 65535")
                except ValueError:
                    pass
>       raise UnknownRdataclass(f"Unknown DNS class: {text}")
E       dns.rdataclass.UnknownRdataclass: Unknown DNS class: CLASS65536

dns/rdataclass.py:53: UnknownRdataclass
</pre>
</details>
<h3 id="test_rdtypeandclasspyrdtypeandclasstestcasetest_type_bytext_bounds1">test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_bytext_bounds1</h3>
<details><summary> <pre>test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_bytext_bounds1</pre></summary><pre>
text = 'TYPE65535'

    def from_text(text: str) ->RdataType:
        """Convert text into a DNS rdata type value.

        The input text can be a defined DNS RR type mnemonic or
        instance of the DNS generic type syntax.

        For example, "NS" and "TYPE2" will both result in a value of 2.

        Raises ``dns.rdatatype.UnknownRdatatype`` if the type is unknown.

        Raises ``ValueError`` if the rdata type value is not >= 0 and <= 65535.

        Returns a ``dns.rdatatype.RdataType``.
        """
        text = text.upper()
        if text.startswith('TYPE'):
            try:
                value = int(text[4:])
                if 0 <= value <= 65535:
>                   return RdataType(value)

dns/rdatatype.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/enum.py:757: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'RdataType'>, value = 65535

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 65535 is not a valid RdataType

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/enum.py:1171: ValueError

During handling of the above exception, another exception occurred:

self = <tests.test_rdtypeandclass.RdTypeAndClassTestCase testMethod=test_type_bytext_bounds1>

    def test_type_bytext_bounds1(self):
        self.assertEqual(dns.rdatatype.from_text("TYPE0"), 0)
>       self.assertEqual(dns.rdatatype.from_text("TYPE65535"), 65535)

tests/test_rdtypeandclass.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

text = 'TYPE65535'

    def from_text(text: str) ->RdataType:
        """Convert text into a DNS rdata type value.

        The input text can be a defined DNS RR type mnemonic or
        instance of the DNS generic type syntax.

        For example, "NS" and "TYPE2" will both result in a value of 2.

        Raises ``dns.rdatatype.UnknownRdatatype`` if the type is unknown.

        Raises ``ValueError`` if the rdata type value is not >= 0 and <= 65535.

        Returns a ``dns.rdatatype.RdataType``.
        """
        text = text.upper()
        if text.startswith('TYPE'):
            try:
                value = int(text[4:])
                if 0 <= value <= 65535:
                    return RdataType(value)
                else:
                    raise ValueError("Rdata type value must be between 0 and 65535")
            except ValueError:
>               raise UnknownRdatatype(f"Unknown rdatatype: {text}")
E               dns.rdatatype.UnknownRdatatype: Unknown rdatatype: TYPE65535

dns/rdatatype.py:126: UnknownRdatatype
</pre>
</details>
<h3 id="test_rdtypeandclasspyrdtypeandclasstestcasetest_type_bytext_bounds2">test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_bytext_bounds2</h3>
<details><summary> <pre>test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_bytext_bounds2</pre></summary><pre>
def from_text(text: str) ->RdataType:
        """Convert text into a DNS rdata type value.

        The input text can be a defined DNS RR type mnemonic or
        instance of the DNS generic type syntax.

        For example, "NS" and "TYPE2" will both result in a value of 2.

        Raises ``dns.rdatatype.UnknownRdatatype`` if the type is unknown.

        Raises ``ValueError`` if the rdata type value is not >= 0 and <= 65535.

        Returns a ``dns.rdatatype.RdataType``.
        """
        text = text.upper()
        if text.startswith('TYPE'):
            try:
                value = int(text[4:])
                if 0 <= value <= 65535:
                    return RdataType(value)
                else:
>                   raise ValueError("Rdata type value must be between 0 and 65535")
E                   ValueError: Rdata type value must be between 0 and 65535

dns/rdatatype.py:124: ValueError

During handling of the above exception, another exception occurred:

self = <tests.test_rdtypeandclass.RdTypeAndClassTestCase testMethod=test_type_bytext_bounds2>

    def test_type_bytext_bounds2(self):
        def bad():
            dns.rdatatype.from_text("TYPE65536")

>       self.assertRaises(ValueError, bad)

tests/test_rdtypeandclass.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_rdtypeandclass.py:102: in bad
    dns.rdatatype.from_text("TYPE65536")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def from_text(text: str) ->RdataType:
        """Convert text into a DNS rdata type value.

        The input text can be a defined DNS RR type mnemonic or
        instance of the DNS generic type syntax.

        For example, "NS" and "TYPE2" will both result in a value of 2.

        Raises ``dns.rdatatype.UnknownRdatatype`` if the type is unknown.

        Raises ``ValueError`` if the rdata type value is not >= 0 and <= 65535.

        Returns a ``dns.rdatatype.RdataType``.
        """
        text = text.upper()
        if text.startswith('TYPE'):
            try:
                value = int(text[4:])
                if 0 <= value <= 65535:
                    return RdataType(value)
                else:
                    raise ValueError("Rdata type value must be between 0 and 65535")
            except ValueError:
>               raise UnknownRdatatype(f"Unknown rdatatype: {text}")
E               dns.rdatatype.UnknownRdatatype: Unknown rdatatype: TYPE65536

dns/rdatatype.py:126: UnknownRdatatype
</pre>
</details>
<h3 id="test_rdtypeandclasspyrdtypeandclasstestcasetest_type_totext1">test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_totext1</h3>
<details><summary> <pre>test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_totext1</pre></summary><pre>
self = <tests.test_rdtypeandclass.RdTypeAndClassTestCase testMethod=test_type_totext1>

    def test_type_totext1(self):
>       self.assertEqual(dns.rdatatype.to_text(dns.rdatatype.A), "A")
E       AssertionError: 'TYPE1' != 'A'
E       - TYPE1
E       + A

tests/test_rdtypeandclass.py:113: AssertionError
</pre>
</details>
<h3 id="test_rdtypeandclasspyrdtypeandclasstestcasetest_type_totext2">test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_totext2</h3>
<details><summary> <pre>test_rdtypeandclass.py::RdTypeAndClassTestCase::test_type_totext2</pre></summary><pre>
self = <tests.test_rdtypeandclass.RdTypeAndClassTestCase testMethod=test_type_totext2>

    def test_type_totext2(self):
>       self.assertEqual(dns.rdatatype.to_text(999), "TYPE999")

tests/test_rdtypeandclass.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dns/rdatatype.py:145: in to_text
    value = RdataType(value)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/enum.py:757: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'RdataType'>, value = 999

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 999 is not a valid RdataType

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/enum.py:1171: ValueError
</pre>
</details>
<h3 id="test_setpysettestcasetestbaddisjoint">test_set.py::SetTestCase::testBadDisjoint</h3>
<details><summary> <pre>test_set.py::SetTestCase::testBadDisjoint</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testBadDisjoint>

    def testBadDisjoint(self):
        s = S([1, 2, 3])
>       self.assertRaises(ValueError, lambda: s.isdisjoint(123))

tests/test_set.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   self.assertRaises(ValueError, lambda: s.isdisjoint(123))
E   AttributeError: 'Set' object has no attribute 'isdisjoint'

tests/test_set.py:324: AttributeError
</pre>
</details>
<h3 id="test_setpysettestcasetestbadsubsetsuperset">test_set.py::SetTestCase::testBadSubsetSuperset</h3>
<details><summary> <pre>test_set.py::SetTestCase::testBadSubsetSuperset</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testBadSubsetSuperset>

    def testBadSubsetSuperset(self):
        s = S([1, 2, 3])
>       self.assertRaises(ValueError, lambda: s.issubset(123))

tests/test_set.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_set.py:319: in <lambda>
    self.assertRaises(ValueError, lambda: s.issubset(123))
dns/set.py:215: in issubset
    return all(item in other for item in self.items)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return all(item in other for item in self.items)
E   TypeError: argument of type 'int' is not iterable

dns/set.py:215: TypeError
</pre>
</details>
<h3 id="test_setpysettestcasetestbadupdates">test_set.py::SetTestCase::testBadUpdates</h3>
<details><summary> <pre>test_set.py::SetTestCase::testBadUpdates</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testBadUpdates>

    def testBadUpdates(self):
        s = S([1, 2, 3])
>       self.assertRaises(ValueError, lambda: s.union_update(1))

tests/test_set.py:302: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_set.py:302: in <lambda>
    self.assertRaises(ValueError, lambda: s.union_update(1))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def union_update(self, other):
        """Update the set, adding any elements from other which are not
        already in the set.
        """
>       for item in other:
E       TypeError: 'int' object is not iterable

dns/set.py:73: TypeError
</pre>
</details>
<h3 id="test_setpysettestcasetestdisjoint1">test_set.py::SetTestCase::testDisjoint1</h3>
<details><summary> <pre>test_set.py::SetTestCase::testDisjoint1</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testDisjoint1>

    def testDisjoint1(self):
        s1 = S([1, 2, 3])
        s2 = S([4])
>       self.assertTrue(s1.isdisjoint(s2))
E       AttributeError: 'Set' object has no attribute 'isdisjoint'

tests/test_set.py:210: AttributeError
</pre>
</details>
<h3 id="test_setpysettestcasetestdisjoint2">test_set.py::SetTestCase::testDisjoint2</h3>
<details><summary> <pre>test_set.py::SetTestCase::testDisjoint2</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testDisjoint2>

    def testDisjoint2(self):
        s1 = S([1, 2, 3])
        s2 = S([2, 4])
>       self.assertTrue(not s1.isdisjoint(s2))
E       AttributeError: 'Set' object has no attribute 'isdisjoint'

tests/test_set.py:215: AttributeError
</pre>
</details>
<h3 id="test_setpysettestcasetestdisjoint3">test_set.py::SetTestCase::testDisjoint3</h3>
<details><summary> <pre>test_set.py::SetTestCase::testDisjoint3</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testDisjoint3>

    def testDisjoint3(self):
        s1 = S([1, 2, 3])
        s2 = S([])
>       self.assertTrue(s1.isdisjoint(s2))
E       AttributeError: 'Set' object has no attribute 'isdisjoint'

tests/test_set.py:220: AttributeError
</pre>
</details>
<h3 id="test_setpysettestcasetestremovenonexistent">test_set.py::SetTestCase::testRemoveNonexistent</h3>
<details><summary> <pre>test_set.py::SetTestCase::testRemoveNonexistent</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testRemoveNonexistent>

    def testRemoveNonexistent(self):
        s1 = S([1, 2, 3])
        s2 = S([1, 2, 3])
        with self.assertRaises(ValueError):
>           s1.remove(4)

tests/test_set.py:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def remove(self, item):
        """Remove an item from the set."""
>       del self.items[item]
E       KeyError: 4

dns/set.py:33: KeyError
</pre>
</details>
<h3 id="test_setpysettestcasetestselfupdates">test_set.py::SetTestCase::testSelfUpdates</h3>
<details><summary> <pre>test_set.py::SetTestCase::testSelfUpdates</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testSelfUpdates>

    def testSelfUpdates(self):
        expected = S([1, 2, 3])
        s = S([1, 2, 3])
        s.union_update(s)
        self.assertEqual(s, expected)
        s.intersection_update(s)
        self.assertEqual(s, expected)
>       s.difference_update(s)

tests/test_set.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = dns.set.Set([2, 3]), other = dns.set.Set([2, 3])

    def difference_update(self, other):
        """Update the set, removing any elements from other which are in
        the set.
        """
>       for item in other:
E       RuntimeError: dictionary changed size during iteration

dns/set.py:86: RuntimeError
</pre>
</details>
<h3 id="test_setpysettestcasetestsymmetricdifference3">test_set.py::SetTestCase::testSymmetricDifference3</h3>
<details><summary> <pre>test_set.py::SetTestCase::testSymmetricDifference3</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testSymmetricDifference3>

    def testSymmetricDifference3(self):
        s1 = S([1, 2, 3])
        s2 = S([3, 2])
        e = S([1])
>       self.assertEqual(s1 ^ s2, e)
E       AssertionError: dns.set.Set([2, 3, 1]) != dns.set.Set([1])

tests/test_set.py:128: AssertionError
</pre>
</details>
<h3 id="test_setpysettestcasetestsymmetricdifference4">test_set.py::SetTestCase::testSymmetricDifference4</h3>
<details><summary> <pre>test_set.py::SetTestCase::testSymmetricDifference4</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testSymmetricDifference4>

    def testSymmetricDifference4(self):
        s1 = S([1, 2, 3])
        s2 = S([3, 2, 1])
        e = S([])
>       self.assertEqual(s1 ^ s2, e)
E       AssertionError: dns.set.Set([1, 2, 3]) != dns.set.Set([])

tests/test_set.py:134: AssertionError
</pre>
</details>
<h3 id="test_setpysettestcasetestsymmetricdifference5">test_set.py::SetTestCase::testSymmetricDifference5</h3>
<details><summary> <pre>test_set.py::SetTestCase::testSymmetricDifference5</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testSymmetricDifference5>

    def testSymmetricDifference5(self):
        s1 = S([1, 2, 3])
        s2 = S([2, 4])
        s1 ^= s2
        e = S([1, 3, 4])
>       self.assertEqual(s1, e)
E       AssertionError: dns.set.Set([2, 1, 3, 4]) != dns.set.Set([1, 3, 4])

tests/test_set.py:141: AssertionError
</pre>
</details>
<h3 id="test_setpysettestcasetestsymmetricdifference6">test_set.py::SetTestCase::testSymmetricDifference6</h3>
<details><summary> <pre>test_set.py::SetTestCase::testSymmetricDifference6</pre></summary><pre>
self = <tests.test_set.SetTestCase testMethod=testSymmetricDifference6>

    def testSymmetricDifference6(self):
        s1 = S([1, 2, 3])
        s1 ^= s1
        e = S([])
>       self.assertEqual(s1, e)
E       AssertionError: dns.set.Set([1, 2, 3]) != dns.set.Set([])

tests/test_set.py:147: AssertionError
</pre>
</details>
<h3 id="test_ttlpyttltestcasetest_bind_style_no_unit">test_ttl.py::TTLTestCase::test_bind_style_no_unit</h3>
<details><summary> <pre>test_ttl.py::TTLTestCase::test_bind_style_no_unit</pre></summary><pre>
self = <tests.test_ttl.TTLTestCase testMethod=test_bind_style_no_unit>

    def test_bind_style_no_unit(self):
>       with self.assertRaises(dns.ttl.BadTTL):
E       AssertionError: BadTTL not raised

tests/test_ttl.py:23: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/dns/_asyncbackend.py b/dns/_asyncbackend.py</span>
<span class="gh">index eba0ba6..23633ba 100644</span>
<span class="gd">--- a/dns/_asyncbackend.py</span>
<span class="gi">+++ b/dns/_asyncbackend.py</span>
<span class="gu">@@ -30,14 +30,41 @@ class DatagramSocket(Socket):</span>
<span class="w"> </span>    def __init__(self, family: int):
<span class="w"> </span>        self.family = family

<span class="gi">+    async def sendto(self, data: bytes, address: tuple) -&gt; int:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    async def recvfrom(self, size: int) -&gt; tuple:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>

<span class="w"> </span>class StreamSocket(Socket):
<span class="gd">-    pass</span>
<span class="gi">+    async def connect(self, address: tuple) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    async def sendall(self, data: bytes) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    async def recv(self, size: int) -&gt; bytes:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class NullTransport:
<span class="gd">-    pass</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>class Backend:
<span class="gd">-    pass</span>
<span class="gi">+    async def make_socket(self, af: int, socktype: int, proto: int = 0, source: tuple = None) -&gt; Socket:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def datagram_connection_required(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    async def sleep(self, interval: float) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gh">diff --git a/dns/_asyncio_backend.py b/dns/_asyncio_backend.py</span>
<span class="gh">index 6b61355..9b9806d 100644</span>
<span class="gd">--- a/dns/_asyncio_backend.py</span>
<span class="gi">+++ b/dns/_asyncio_backend.py</span>
<span class="gu">@@ -23,6 +23,19 @@ class DatagramSocket(dns._asyncbackend.DatagramSocket):</span>
<span class="w"> </span>        self.transport = transport
<span class="w"> </span>        self.protocol = protocol

<span class="gi">+    async def sendto(self, what, destination, timeout):</span>
<span class="gi">+        self.transport.sendto(what, destination)</span>
<span class="gi">+</span>
<span class="gi">+    async def recvfrom(self, size, timeout):</span>
<span class="gi">+        self.protocol.recvfrom = asyncio.Future()</span>
<span class="gi">+        try:</span>
<span class="gi">+            return await asyncio.wait_for(self.protocol.recvfrom, timeout)</span>
<span class="gi">+        except asyncio.TimeoutError:</span>
<span class="gi">+            raise dns.exception.Timeout</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        self.transport.close()</span>
<span class="gi">+</span>

<span class="w"> </span>class StreamSocket(dns._asyncbackend.StreamSocket):

<span class="gu">@@ -31,6 +44,20 @@ class StreamSocket(dns._asyncbackend.StreamSocket):</span>
<span class="w"> </span>        self.reader = reader
<span class="w"> </span>        self.writer = writer

<span class="gi">+    async def sendall(self, what, timeout):</span>
<span class="gi">+        self.writer.write(what)</span>
<span class="gi">+        await asyncio.wait_for(self.writer.drain(), timeout)</span>
<span class="gi">+</span>
<span class="gi">+    async def recv(self, size, timeout):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return await asyncio.wait_for(self.reader.read(size), timeout)</span>
<span class="gi">+        except asyncio.TimeoutError:</span>
<span class="gi">+            raise dns.exception.Timeout</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        self.writer.close()</span>
<span class="gi">+        await self.writer.wait_closed()</span>
<span class="gi">+</span>

<span class="w"> </span>if dns._features.have(&#39;doh&#39;):
<span class="w"> </span>    import anyio
<span class="gu">@@ -71,4 +98,39 @@ else:</span>


<span class="w"> </span>class Backend(dns._asyncbackend.Backend):
<span class="gd">-    pass</span>
<span class="gi">+    async def make_socket(self, af, socktype, proto=0, source=None, destination=None,</span>
<span class="gi">+                          timeout=None, ssl_context=None, server_hostname=None):</span>
<span class="gi">+        if socktype == socket.SOCK_DGRAM:</span>
<span class="gi">+            transport, protocol = await asyncio.get_event_loop().create_datagram_endpoint(</span>
<span class="gi">+                lambda: _DatagramProtocol(),</span>
<span class="gi">+                local_addr=source,</span>
<span class="gi">+                remote_addr=destination,</span>
<span class="gi">+                family=af,</span>
<span class="gi">+                proto=proto</span>
<span class="gi">+            )</span>
<span class="gi">+            return DatagramSocket(af, transport, protocol)</span>
<span class="gi">+        elif socktype == socket.SOCK_STREAM:</span>
<span class="gi">+            if destination is None:</span>
<span class="gi">+                raise ValueError(&quot;destination required for stream sockets&quot;)</span>
<span class="gi">+            host, port = destination</span>
<span class="gi">+            if timeout is not None:</span>
<span class="gi">+                reader, writer = await asyncio.wait_for(</span>
<span class="gi">+                    asyncio.open_connection(host, port, ssl=ssl_context, </span>
<span class="gi">+                                            server_hostname=server_hostname),</span>
<span class="gi">+                    timeout</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                reader, writer = await asyncio.open_connection(host, port, ssl=ssl_context, </span>
<span class="gi">+                                                               server_hostname=server_hostname)</span>
<span class="gi">+            return StreamSocket(af, reader, writer)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError(f&quot;unsupported socket type {socktype}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    async def sleep(self, interval):</span>
<span class="gi">+        await asyncio.sleep(interval)</span>
<span class="gi">+</span>
<span class="gi">+    def datagram_connection_required(self):</span>
<span class="gi">+        return not _is_win32</span>
<span class="gi">+</span>
<span class="gi">+    def get_transport_class(self):</span>
<span class="gi">+        return _HTTPTransport</span>
<span class="gh">diff --git a/dns/_ddr.py b/dns/_ddr.py</span>
<span class="gh">index f03d10e..30b99af 100644</span>
<span class="gd">--- a/dns/_ddr.py</span>
<span class="gi">+++ b/dns/_ddr.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>import socket
<span class="gi">+import ssl</span>
<span class="w"> </span>import time
<span class="gi">+import asyncio</span>
<span class="w"> </span>from urllib.parse import urlparse
<span class="w"> </span>import dns.asyncbackend
<span class="w"> </span>import dns.inet
<span class="gu">@@ -20,16 +22,96 @@ class _SVCBInfo:</span>

<span class="w"> </span>    def ddr_check_certificate(self, cert):
<span class="w"> </span>        &quot;&quot;&quot;Verify that the _SVCBInfo&#39;s address is in the cert&#39;s subjectAltName (SAN)&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not hasattr(cert, &#39;get_subject_alt_name&#39;):</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        sans = cert.get_subject_alt_name()</span>
<span class="gi">+        if sans is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        for san_type, san_value in sans:</span>
<span class="gi">+            if san_type == &#39;DNS&#39; and san_value == self.hostname:</span>
<span class="gi">+                return True</span>
<span class="gi">+            if san_type == &#39;IP Address&#39; and san_value == self.bootstrap_address:</span>
<span class="gi">+                return True</span>
<span class="gi">+        </span>
<span class="gi">+        return False</span>


<span class="w"> </span>def _get_nameservers_sync(answer, lifetime):
<span class="w"> </span>    &quot;&quot;&quot;Return a list of TLS-validated resolver nameservers extracted from an SVCB
<span class="w"> </span>    answer.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nameservers = []</span>
<span class="gi">+    start_time = time.time()</span>
<span class="gi">+</span>
<span class="gi">+    for rrset in answer.answer:</span>
<span class="gi">+        for rr in rrset:</span>
<span class="gi">+            if isinstance(rr, dns.rdtypes.svcbbase.SVCBBase):</span>
<span class="gi">+                svcb_info = _SVCBInfo(</span>
<span class="gi">+                    bootstrap_address=rr.target.to_text(),</span>
<span class="gi">+                    port=rr.port,</span>
<span class="gi">+                    hostname=rr.target.to_text(),</span>
<span class="gi">+                    nameservers=[]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    context = ssl.create_default_context()</span>
<span class="gi">+                    with socket.create_connection((svcb_info.bootstrap_address, svcb_info.port), timeout=lifetime) as sock:</span>
<span class="gi">+                        with context.wrap_socket(sock, server_hostname=svcb_info.hostname) as secure_sock:</span>
<span class="gi">+                            cert = secure_sock.getpeercert()</span>
<span class="gi">+                            if svcb_info.ddr_check_certificate(cert):</span>
<span class="gi">+                                nameservers.append((svcb_info.bootstrap_address, svcb_info.port))</span>
<span class="gi">+                except (socket.error, ssl.SSLError):</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+            if time.time() - start_time &gt; lifetime:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if time.time() - start_time &gt; lifetime:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    return nameservers</span>


<span class="w"> </span>async def _get_nameservers_async(answer, lifetime):
<span class="w"> </span>    &quot;&quot;&quot;Return a list of TLS-validated resolver nameservers extracted from an SVCB
<span class="w"> </span>    answer.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nameservers = []</span>
<span class="gi">+    start_time = time.time()</span>
<span class="gi">+</span>
<span class="gi">+    for rrset in answer.answer:</span>
<span class="gi">+        for rr in rrset:</span>
<span class="gi">+            if isinstance(rr, dns.rdtypes.svcbbase.SVCBBase):</span>
<span class="gi">+                svcb_info = _SVCBInfo(</span>
<span class="gi">+                    bootstrap_address=rr.target.to_text(),</span>
<span class="gi">+                    port=rr.port,</span>
<span class="gi">+                    hostname=rr.target.to_text(),</span>
<span class="gi">+                    nameservers=[]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    context = ssl.create_default_context()</span>
<span class="gi">+                    reader, writer = await asyncio.wait_for(</span>
<span class="gi">+                        asyncio.open_connection(svcb_info.bootstrap_address, svcb_info.port),</span>
<span class="gi">+                        timeout=lifetime</span>
<span class="gi">+                    )</span>
<span class="gi">+                    transport = writer.transport</span>
<span class="gi">+                    protocol = transport.get_protocol()</span>
<span class="gi">+                    ssl_context = await protocol._make_ssl_transport(</span>
<span class="gi">+                        transport, protocol, context, svcb_info.hostname, server_side=False</span>
<span class="gi">+                    )</span>
<span class="gi">+                    cert = ssl_context.getpeercert()</span>
<span class="gi">+                    if svcb_info.ddr_check_certificate(cert):</span>
<span class="gi">+                        nameservers.append((svcb_info.bootstrap_address, svcb_info.port))</span>
<span class="gi">+                    writer.close()</span>
<span class="gi">+                    await writer.wait_closed()</span>
<span class="gi">+                except (asyncio.TimeoutError, ssl.SSLError):</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+            if time.time() - start_time &gt; lifetime:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if time.time() - start_time &gt; lifetime:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    return nameservers</span>
<span class="gh">diff --git a/dns/_features.py b/dns/_features.py</span>
<span class="gh">index bb537c8..db73539 100644</span>
<span class="gd">--- a/dns/_features.py</span>
<span class="gi">+++ b/dns/_features.py</span>
<span class="gu">@@ -11,7 +11,12 @@ def _version_check(requirement: str) -&gt;bool:</span>

<span class="w"> </span>        package&gt;=version
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    package, version = requirement.split(&#39;&gt;=&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        installed_version = importlib.metadata.version(package)</span>
<span class="gi">+        return installed_version &gt;= version</span>
<span class="gi">+    except importlib.metadata.PackageNotFoundError:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>_cache: Dict[str, bool] = {}
<span class="gu">@@ -27,7 +32,15 @@ def have(feature: str) -&gt;bool:</span>
<span class="w"> </span>    and ``False`` if it is not or if metadata is
<span class="w"> </span>    missing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if feature in _cache:</span>
<span class="gi">+        return _cache[feature]</span>
<span class="gi">+    </span>
<span class="gi">+    if feature not in _requirements:</span>
<span class="gi">+        return False</span>
<span class="gi">+    </span>
<span class="gi">+    result = all(_version_check(req) for req in _requirements[feature])</span>
<span class="gi">+    _cache[feature] = result</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def force(feature: str, enabled: bool) -&gt;None:
<span class="gu">@@ -36,7 +49,7 @@ def force(feature: str, enabled: bool) -&gt;None:</span>
<span class="w"> </span>    This method is provided as a workaround for any cases
<span class="w"> </span>    where importlib.metadata is ineffective, or for testing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _cache[feature] = enabled</span>


<span class="w"> </span>_requirements: Dict[str, List[str]] = {&#39;dnssec&#39;: [&#39;cryptography&gt;=41&#39;],
<span class="gh">diff --git a/dns/_trio_backend.py b/dns/_trio_backend.py</span>
<span class="gh">index 52268ee..73e97f4 100644</span>
<span class="gd">--- a/dns/_trio_backend.py</span>
<span class="gi">+++ b/dns/_trio_backend.py</span>
<span class="gu">@@ -17,6 +17,34 @@ class DatagramSocket(dns._asyncbackend.DatagramSocket):</span>
<span class="w"> </span>        super().__init__(socket.family)
<span class="w"> </span>        self.socket = socket

<span class="gi">+    async def sendto(self, what, destination, timeout):</span>
<span class="gi">+        &quot;&quot;&quot;Send a datagram to the specified destination.&quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            with trio.move_on_after(timeout):</span>
<span class="gi">+                return await self.socket.sendto(what, destination)</span>
<span class="gi">+        except trio.TooSlowError:</span>
<span class="gi">+            raise dns.exception.Timeout(timeout=timeout)</span>
<span class="gi">+</span>
<span class="gi">+    async def recvfrom(self, size, timeout):</span>
<span class="gi">+        &quot;&quot;&quot;Receive a datagram.&quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            with trio.move_on_after(timeout):</span>
<span class="gi">+                return await self.socket.recvfrom(size)</span>
<span class="gi">+        except trio.TooSlowError:</span>
<span class="gi">+            raise dns.exception.Timeout(timeout=timeout)</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        &quot;&quot;&quot;Close the socket.&quot;&quot;&quot;</span>
<span class="gi">+        self.socket.close()</span>
<span class="gi">+</span>
<span class="gi">+    async def getpeername(self):</span>
<span class="gi">+        &quot;&quot;&quot;Get the remote address to which the socket is connected.&quot;&quot;&quot;</span>
<span class="gi">+        return self.socket.getpeername()</span>
<span class="gi">+</span>
<span class="gi">+    async def getsockname(self):</span>
<span class="gi">+        &quot;&quot;&quot;Get the socket&#39;s own address.&quot;&quot;&quot;</span>
<span class="gi">+        return self.socket.getsockname()</span>
<span class="gi">+</span>

<span class="w"> </span>class StreamSocket(dns._asyncbackend.StreamSocket):

<span class="gu">@@ -25,6 +53,34 @@ class StreamSocket(dns._asyncbackend.StreamSocket):</span>
<span class="w"> </span>        self.stream = stream
<span class="w"> </span>        self.tls = tls

<span class="gi">+    async def sendall(self, what, timeout):</span>
<span class="gi">+        &quot;&quot;&quot;Send the entire contents of the datagram.&quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            with trio.move_on_after(timeout):</span>
<span class="gi">+                return await self.stream.send_all(what)</span>
<span class="gi">+        except trio.TooSlowError:</span>
<span class="gi">+            raise dns.exception.Timeout(timeout=timeout)</span>
<span class="gi">+</span>
<span class="gi">+    async def recv(self, size, timeout):</span>
<span class="gi">+        &quot;&quot;&quot;Receive data from the stream.&quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            with trio.move_on_after(timeout):</span>
<span class="gi">+                return await self.stream.receive_some(size)</span>
<span class="gi">+        except trio.TooSlowError:</span>
<span class="gi">+            raise dns.exception.Timeout(timeout=timeout)</span>
<span class="gi">+</span>
<span class="gi">+    async def close(self):</span>
<span class="gi">+        &quot;&quot;&quot;Close the stream.&quot;&quot;&quot;</span>
<span class="gi">+        await self.stream.aclose()</span>
<span class="gi">+</span>
<span class="gi">+    async def getpeername(self):</span>
<span class="gi">+        &quot;&quot;&quot;Get the remote address to which the socket is connected.&quot;&quot;&quot;</span>
<span class="gi">+        return self.stream.socket.getpeername()</span>
<span class="gi">+</span>
<span class="gi">+    async def getsockname(self):</span>
<span class="gi">+        &quot;&quot;&quot;Get the socket&#39;s own address.&quot;&quot;&quot;</span>
<span class="gi">+        return self.stream.socket.getsockname()</span>
<span class="gi">+</span>

<span class="w"> </span>if dns._features.have(&#39;doh&#39;):
<span class="w"> </span>    import httpcore
<span class="gu">@@ -60,4 +116,48 @@ else:</span>


<span class="w"> </span>class Backend(dns._asyncbackend.Backend):
<span class="gd">-    pass</span>
<span class="gi">+    def name(self):</span>
<span class="gi">+        return &#39;trio&#39;</span>
<span class="gi">+</span>
<span class="gi">+    async def make_socket(self, af, socktype, proto=0,</span>
<span class="gi">+                          source=None, destination=None, timeout=None,</span>
<span class="gi">+                          ssl_context=None, server_hostname=None):</span>
<span class="gi">+        &quot;&quot;&quot;Make a socket based on the parameters.&quot;&quot;&quot;</span>
<span class="gi">+        if socktype == socket.SOCK_DGRAM:</span>
<span class="gi">+            s = trio.socket.socket(af, socktype, proto)</span>
<span class="gi">+            if source:</span>
<span class="gi">+                await s.bind(_lltuple(source, af))</span>
<span class="gi">+            return DatagramSocket(s)</span>
<span class="gi">+        elif socktype == socket.SOCK_STREAM:</span>
<span class="gi">+            if destination is None:</span>
<span class="gi">+                raise ValueError(&#39;destination required for stream sockets&#39;)</span>
<span class="gi">+            if timeout is None:</span>
<span class="gi">+                timeout = 5</span>
<span class="gi">+            try:</span>
<span class="gi">+                with trio.move_on_after(timeout):</span>
<span class="gi">+                    s = await trio.open_tcp_stream(*_lltuple(destination, af))</span>
<span class="gi">+                    if ssl_context:</span>
<span class="gi">+                        s = trio.SSLStream(s, ssl_context,</span>
<span class="gi">+                                           server_hostname=server_hostname)</span>
<span class="gi">+                        await s.do_handshake()</span>
<span class="gi">+                    return StreamSocket(af, s, ssl_context is not None)</span>
<span class="gi">+            except trio.TooSlowError:</span>
<span class="gi">+                raise dns.exception.Timeout(timeout=timeout)</span>
<span class="gi">+        raise NotImplementedError(&#39;unsupported socket type&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    async def sleep(self, interval):</span>
<span class="gi">+        &quot;&quot;&quot;Sleep for the specified interval.&quot;&quot;&quot;</span>
<span class="gi">+        await trio.sleep(interval)</span>
<span class="gi">+</span>
<span class="gi">+    def datagram_connection_required(self):</span>
<span class="gi">+        &quot;&quot;&quot;Return True if a connection is required, False otherwise.&quot;&quot;&quot;</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def set_socket_options(self, socket, options):</span>
<span class="gi">+        &quot;&quot;&quot;Set socket options.&quot;&quot;&quot;</span>
<span class="gi">+        for option in options:</span>
<span class="gi">+            socket.setsockopt(*option)</span>
<span class="gi">+</span>
<span class="gi">+    def get_socket_family(self, socket):</span>
<span class="gi">+        &quot;&quot;&quot;Get the socket family.&quot;&quot;&quot;</span>
<span class="gi">+        return socket.family</span>
<span class="gh">diff --git a/dns/asyncbackend.py b/dns/asyncbackend.py</span>
<span class="gh">index 3e2691b..4625cf2 100644</span>
<span class="gd">--- a/dns/asyncbackend.py</span>
<span class="gi">+++ b/dns/asyncbackend.py</span>
<span class="gu">@@ -18,7 +18,16 @@ def get_backend(name: str) -&gt;Backend:</span>

<span class="w"> </span>    Raises NotImplementedError if an unknown backend name is specified.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name not in _backends:</span>
<span class="gi">+        if name == &#39;trio&#39;:</span>
<span class="gi">+            from dns import _trio_backend</span>
<span class="gi">+            _backends[&#39;trio&#39;] = _trio_backend.Backend()</span>
<span class="gi">+        elif name == &#39;asyncio&#39;:</span>
<span class="gi">+            from dns import _asyncio_backend</span>
<span class="gi">+            _backends[&#39;asyncio&#39;] = _asyncio_backend.Backend()</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NotImplementedError(f&quot;Unknown backend &#39;{name}&#39;&quot;)</span>
<span class="gi">+    return _backends[name]</span>


<span class="w"> </span>def sniff() -&gt;str:
<span class="gu">@@ -28,12 +37,33 @@ def sniff() -&gt;str:</span>
<span class="w"> </span>    Returns the name of the library, or raises AsyncLibraryNotFoundError
<span class="w"> </span>    if the library cannot be determined.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _no_sniffio</span>
<span class="gi">+    if _no_sniffio:</span>
<span class="gi">+        raise AsyncLibraryNotFoundError(&quot;sniffio module not available&quot;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        import sniffio</span>
<span class="gi">+        library = sniffio.current_async_library()</span>
<span class="gi">+        if library == &#39;trio&#39;:</span>
<span class="gi">+            return &#39;trio&#39;</span>
<span class="gi">+        elif library == &#39;asyncio&#39;:</span>
<span class="gi">+            return &#39;asyncio&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AsyncLibraryNotFoundError(f&quot;Unsupported async library: {library}&quot;)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        _no_sniffio = True</span>
<span class="gi">+        raise AsyncLibraryNotFoundError(&quot;sniffio module not available&quot;)</span>


<span class="w"> </span>def get_default_backend() -&gt;Backend:
<span class="w"> </span>    &quot;&quot;&quot;Get the default backend, initializing it if necessary.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _default_backend</span>
<span class="gi">+    if _default_backend is None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            name = sniff()</span>
<span class="gi">+        except AsyncLibraryNotFoundError:</span>
<span class="gi">+            name = &#39;asyncio&#39;  # Default to asyncio if sniffio fails</span>
<span class="gi">+        _default_backend = get_backend(name)</span>
<span class="gi">+    return _default_backend</span>


<span class="w"> </span>def set_default_backend(name: str) -&gt;Backend:
<span class="gu">@@ -45,4 +75,6 @@ def set_default_backend(name: str) -&gt;Backend:</span>
<span class="w"> </span>    in testing situations, this function allows the backend to be set
<span class="w"> </span>    explicitly.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _default_backend</span>
<span class="gi">+    _default_backend = get_backend(name)</span>
<span class="gi">+    return _default_backend</span>
<span class="gh">diff --git a/dns/asyncquery.py b/dns/asyncquery.py</span>
<span class="gh">index 5fbfbb5..69d6d0f 100644</span>
<span class="gd">--- a/dns/asyncquery.py</span>
<span class="gi">+++ b/dns/asyncquery.py</span>
<span class="gu">@@ -41,7 +41,11 @@ async def send_udp(sock: dns.asyncbackend.DatagramSocket, what: Union[dns.</span>

<span class="w"> </span>    Returns an ``(int, float)`` tuple of bytes sent and the sent time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(what, dns.message.Message):</span>
<span class="gi">+        what = what.to_wire()</span>
<span class="gi">+    sent_time = time.time()</span>
<span class="gi">+    n = await sock.sendto(what, destination)</span>
<span class="gi">+    return (n, sent_time)</span>


<span class="w"> </span>async def receive_udp(sock: dns.asyncbackend.DatagramSocket, destination:
<span class="gu">@@ -61,7 +65,20 @@ async def receive_udp(sock: dns.asyncbackend.DatagramSocket, destination:</span>
<span class="w"> </span>    Returns a ``(dns.message.Message, float, tuple)`` tuple of the received message, the
<span class="w"> </span>    received time, and the address where the message arrived from.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    wire, from_address = await sock.recvfrom(65535)</span>
<span class="gi">+    received_time = time.time()</span>
<span class="gi">+    r = dns.message.from_wire(wire, keyring=keyring, request_mac=request_mac,</span>
<span class="gi">+                              one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+                              ignore_trailing=ignore_trailing,</span>
<span class="gi">+                              raise_on_truncation=raise_on_truncation,</span>
<span class="gi">+                              ignore_errors=ignore_errors)</span>
<span class="gi">+    if not query:</span>
<span class="gi">+        return (r, received_time, from_address)</span>
<span class="gi">+    if not _matches_destination(query, from_address, destination, ignore_unexpected):</span>
<span class="gi">+        if not ignore_unexpected:</span>
<span class="gi">+            raise dns.exception.FormError(&quot;got a response from the wrong server&quot;)</span>
<span class="gi">+        return (None, received_time, from_address)</span>
<span class="gi">+    return (r, received_time, from_address)</span>


<span class="w"> </span>async def udp(q: dns.message.Message, where: str, timeout: Optional[float]=
<span class="gu">@@ -84,7 +101,28 @@ async def udp(q: dns.message.Message, where: str, timeout: Optional[float]=</span>
<span class="w"> </span>    See :py:func:`dns.query.udp()` for the documentation of the other
<span class="w"> </span>    parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    (begin_time, expiration) = _compute_times(timeout)</span>
<span class="gi">+    af = dns.inet.af_for_address(where)</span>
<span class="gi">+    destination = _lltuple((where, port), af)</span>
<span class="gi">+    if sock:</span>
<span class="gi">+        cm: contextlib.AbstractAsyncContextManager = NullContext(sock)</span>
<span class="gi">+    else:</span>
<span class="gi">+        cm = dns.asyncbackend.make_socket(af, socket.SOCK_DGRAM, 0, backend=backend,</span>
<span class="gi">+                                          source=source, source_port=source_port)</span>
<span class="gi">+    async with cm as s:</span>
<span class="gi">+        await send_udp(s, wire, destination, expiration)</span>
<span class="gi">+        (r, _, _) = await receive_udp(s, destination, expiration,</span>
<span class="gi">+                                      ignore_unexpected=ignore_unexpected,</span>
<span class="gi">+                                      one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+                                      ignore_trailing=ignore_trailing,</span>
<span class="gi">+                                      raise_on_truncation=raise_on_truncation,</span>
<span class="gi">+                                      ignore_errors=ignore_errors,</span>
<span class="gi">+                                      query=q)</span>
<span class="gi">+    r.time = time.time() - begin_time</span>
<span class="gi">+    if not q.is_response(r):</span>
<span class="gi">+        raise BadResponse</span>
<span class="gi">+    return r</span>


<span class="w"> </span>async def udp_with_fallback(q: dns.message.Message, where: str, timeout:
<span class="gu">@@ -114,7 +152,17 @@ async def udp_with_fallback(q: dns.message.Message, where: str, timeout:</span>
<span class="w"> </span>    of the other parameters, exceptions, and return type of this
<span class="w"> </span>    method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        response = await udp(q, where, timeout, port, source, source_port,</span>
<span class="gi">+                             ignore_unexpected, one_rr_per_rrset,</span>
<span class="gi">+                             ignore_trailing, True, udp_sock, backend,</span>
<span class="gi">+                             ignore_errors)</span>
<span class="gi">+        return (response, False)</span>
<span class="gi">+    except dns.message.Truncated:</span>
<span class="gi">+        response = await tcp(q, where, timeout, port, source, source_port,</span>
<span class="gi">+                             one_rr_per_rrset, ignore_trailing, tcp_sock,</span>
<span class="gi">+                             backend)</span>
<span class="gi">+        return (response, True)</span>


<span class="w"> </span>async def send_tcp(sock: dns.asyncbackend.StreamSocket, what: Union[dns.
<span class="gu">@@ -127,14 +175,30 @@ async def send_tcp(sock: dns.asyncbackend.StreamSocket, what: Union[dns.</span>
<span class="w"> </span>    See :py:func:`dns.query.send_tcp()` for the documentation of the other
<span class="w"> </span>    parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(what, dns.message.Message):</span>
<span class="gi">+        wire = what.to_wire()</span>
<span class="gi">+    else:</span>
<span class="gi">+        wire = what</span>
<span class="gi">+    l = len(wire)</span>
<span class="gi">+    # converting to bytes for Python 3 compatibility</span>
<span class="gi">+    tcpmsg = struct.pack(&quot;!H&quot;, l) + wire</span>
<span class="gi">+    sent_time = time.time()</span>
<span class="gi">+    await sock.sendall(tcpmsg, expiration)</span>
<span class="gi">+    return (len(tcpmsg), sent_time)</span>


<span class="w"> </span>async def _read_exactly(sock, count, expiration):
<span class="w"> </span>    &quot;&quot;&quot;Read the specified number of bytes from stream.  Keep trying until we
<span class="w"> </span>    either get the desired amount, or we hit EOF.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    s = b&#39;&#39;</span>
<span class="gi">+    while count &gt; 0:</span>
<span class="gi">+        n = await sock.recv(count, expiration)</span>
<span class="gi">+        if n == b&#39;&#39;:</span>
<span class="gi">+            raise EOFError</span>
<span class="gi">+        count -= len(n)</span>
<span class="gi">+        s += n</span>
<span class="gi">+    return s</span>


<span class="w"> </span>async def receive_tcp(sock: dns.asyncbackend.StreamSocket, expiration:
<span class="gu">@@ -148,7 +212,14 @@ async def receive_tcp(sock: dns.asyncbackend.StreamSocket, expiration:</span>
<span class="w"> </span>    See :py:func:`dns.query.receive_tcp()` for the documentation of the other
<span class="w"> </span>    parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ldata = await _read_exactly(sock, 2, expiration)</span>
<span class="gi">+    (l,) = struct.unpack(&quot;!H&quot;, ldata)</span>
<span class="gi">+    wire = await _read_exactly(sock, l, expiration)</span>
<span class="gi">+    received_time = time.time()</span>
<span class="gi">+    r = dns.message.from_wire(wire, keyring=keyring, request_mac=request_mac,</span>
<span class="gi">+                              one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+                              ignore_trailing=ignore_trailing)</span>
<span class="gi">+    return (r, received_time)</span>


<span class="w"> </span>async def tcp(q: dns.message.Message, where: str, timeout: Optional[float]=
<span class="gu">@@ -169,7 +240,23 @@ async def tcp(q: dns.message.Message, where: str, timeout: Optional[float]=</span>
<span class="w"> </span>    See :py:func:`dns.query.tcp()` for the documentation of the other
<span class="w"> </span>    parameters, exceptions, and return type of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    (begin_time, expiration) = _compute_times(timeout)</span>
<span class="gi">+    af = dns.inet.af_for_address(where)</span>
<span class="gi">+    if sock:</span>
<span class="gi">+        cm: contextlib.AbstractAsyncContextManager = NullContext(sock)</span>
<span class="gi">+    else:</span>
<span class="gi">+        cm = dns.asyncbackend.make_socket(af, socket.SOCK_STREAM, 0, backend=backend,</span>
<span class="gi">+                                          source=source, source_port=source_port)</span>
<span class="gi">+    async with cm as s:</span>
<span class="gi">+        await s.connect((where, port), expiration)</span>
<span class="gi">+        await send_tcp(s, wire, expiration)</span>
<span class="gi">+        (r, received_time) = await receive_tcp(s, expiration, one_rr_per_rrset,</span>
<span class="gi">+                                               q.keyring, q.mac, ignore_trailing)</span>
<span class="gi">+    r.time = received_time - begin_time</span>
<span class="gi">+    if not q.is_response(r):</span>
<span class="gi">+        raise BadResponse</span>
<span class="gi">+    return r</span>


<span class="w"> </span>async def tls(q: dns.message.Message, where: str, timeout: Optional[float]=
<span class="gh">diff --git a/dns/asyncresolver.py b/dns/asyncresolver.py</span>
<span class="gh">index e587e04..fefc57a 100644</span>
<span class="gd">--- a/dns/asyncresolver.py</span>
<span class="gi">+++ b/dns/asyncresolver.py</span>
<span class="gu">@@ -35,7 +35,17 @@ class Resolver(dns.resolver.BaseResolver):</span>
<span class="w"> </span>        documentation of the other parameters, exceptions, and return
<span class="w"> </span>        type of this method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(qname, str):</span>
<span class="gi">+            qname = dns.name.from_text(qname)</span>
<span class="gi">+        if search is None:</span>
<span class="gi">+            search = self.use_search_by_default</span>
<span class="gi">+        if search:</span>
<span class="gi">+            qname = self._ensure_absolute_name(qname)</span>
<span class="gi">+        backend = self._get_backend(backend)</span>
<span class="gi">+        request = dns.message.make_query(qname, rdtype, rdclass)</span>
<span class="gi">+        answer = await self._resolve_with_cache(request, qname, rdtype, rdclass, tcp, source,</span>
<span class="gi">+                                                raise_on_no_answer, source_port, lifetime, backend)</span>
<span class="gi">+        return answer</span>

<span class="w"> </span>    async def resolve_address(self, ipaddr: str, *args: Any, **kwargs: Any
<span class="w"> </span>        ) -&gt;dns.resolver.Answer:
<span class="gu">@@ -53,7 +63,10 @@ class Resolver(dns.resolver.BaseResolver):</span>
<span class="w"> </span>        function.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return await dns.asyncresolver.resolve(dns.reversename.from_address(ipaddr),</span>
<span class="gi">+                                               rdtype=&#39;PTR&#39;,</span>
<span class="gi">+                                               *args,</span>
<span class="gi">+                                               **kwargs)</span>

<span class="w"> </span>    async def resolve_name(self, name: Union[dns.name.Name, str], family:
<span class="w"> </span>        int=socket.AF_UNSPEC, **kwargs: Any) -&gt;dns.resolver.HostAnswers:
<span class="gu">@@ -71,7 +84,26 @@ class Resolver(dns.resolver.BaseResolver):</span>
<span class="w"> </span>        except for rdtype and rdclass are also supported by this
<span class="w"> </span>        function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rdtypes = []</span>
<span class="gi">+        if family == socket.AF_INET6:</span>
<span class="gi">+            rdtypes.append(&#39;AAAA&#39;)</span>
<span class="gi">+        elif family == socket.AF_INET:</span>
<span class="gi">+            rdtypes.append(&#39;A&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            rdtypes.extend([&#39;A&#39;, &#39;AAAA&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        answers = []</span>
<span class="gi">+        for rdtype in rdtypes:</span>
<span class="gi">+            try:</span>
<span class="gi">+                answer = await self.resolve(name, rdtype, **kwargs)</span>
<span class="gi">+                answers.append(answer)</span>
<span class="gi">+            except dns.resolver.NoAnswer:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        if not answers:</span>
<span class="gi">+            raise dns.resolver.NoAnswer</span>
<span class="gi">+</span>
<span class="gi">+        return dns.resolver.HostAnswers(answers)</span>

<span class="w"> </span>    async def canonical_name(self, name: Union[dns.name.Name, str]
<span class="w"> </span>        ) -&gt;dns.name.Name:
<span class="gu">@@ -88,7 +120,12 @@ class Resolver(dns.resolver.BaseResolver):</span>

<span class="w"> </span>        Returns a ``dns.name.Name``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            answer = await self.resolve(name, &#39;CNAME&#39;)</span>
<span class="gi">+            cname = answer.canonical_name</span>
<span class="gi">+        except dns.resolver.NoAnswer:</span>
<span class="gi">+            cname = dns.name.from_text(name) if isinstance(name, str) else name</span>
<span class="gi">+        return cname</span>

<span class="w"> </span>    async def try_ddr(self, lifetime: float=5.0) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Try to update the resolver&#39;s nameservers using Discovery of Designated
<span class="gu">@@ -109,7 +146,13 @@ class Resolver(dns.resolver.BaseResolver):</span>
<span class="w"> </span>        the bootstrap nameserver is in the Subject Alternative Name field of the
<span class="w"> </span>        TLS certficate.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            ddr = dns._ddr.AsyncDDR(self)</span>
<span class="gi">+            nameservers = await ddr.get_nameservers(lifetime)</span>
<span class="gi">+            if nameservers:</span>
<span class="gi">+                self.nameservers = nameservers</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>


<span class="w"> </span>default_resolver = None
<span class="gu">@@ -117,7 +160,10 @@ default_resolver = None</span>

<span class="w"> </span>def get_default_resolver() -&gt;Resolver:
<span class="w"> </span>    &quot;&quot;&quot;Get the default asynchronous resolver, initializing it if necessary.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global default_resolver</span>
<span class="gi">+    if default_resolver is None:</span>
<span class="gi">+        default_resolver = Resolver()</span>
<span class="gi">+    return default_resolver</span>


<span class="w"> </span>def reset_default_resolver() -&gt;None:
<span class="gu">@@ -126,7 +172,8 @@ def reset_default_resolver() -&gt;None:</span>
<span class="w"> </span>    Note that the resolver configuration (i.e. /etc/resolv.conf on UNIX
<span class="w"> </span>    systems) will be re-read immediately.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global default_resolver</span>
<span class="gi">+    default_resolver = None</span>


<span class="w"> </span>async def resolve(qname: Union[dns.name.Name, str], rdtype: Union[dns.
<span class="gu">@@ -143,7 +190,9 @@ async def resolve(qname: Union[dns.name.Name, str], rdtype: Union[dns.</span>
<span class="w"> </span>    See :py:func:`dns.asyncresolver.Resolver.resolve` for more
<span class="w"> </span>    information on the parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return await get_default_resolver().resolve(qname, rdtype, rdclass, tcp, source,</span>
<span class="gi">+                                                raise_on_no_answer, source_port, lifetime,</span>
<span class="gi">+                                                search, backend)</span>


<span class="w"> </span>async def resolve_address(ipaddr: str, *args: Any, **kwargs: Any
<span class="gu">@@ -153,7 +202,7 @@ async def resolve_address(ipaddr: str, *args: Any, **kwargs: Any</span>
<span class="w"> </span>    See :py:func:`dns.asyncresolver.Resolver.resolve_address` for more
<span class="w"> </span>    information on the parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return await get_default_resolver().resolve_address(ipaddr, *args, **kwargs)</span>


<span class="w"> </span>async def resolve_name(name: Union[dns.name.Name, str], family: int=socket.
<span class="gu">@@ -163,7 +212,7 @@ async def resolve_name(name: Union[dns.name.Name, str], family: int=socket.</span>
<span class="w"> </span>    See :py:func:`dns.asyncresolver.Resolver.resolve_name` for more
<span class="w"> </span>    information on the parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return await get_default_resolver().resolve_name(name, family, **kwargs)</span>


<span class="w"> </span>async def canonical_name(name: Union[dns.name.Name, str]) -&gt;dns.name.Name:
<span class="gu">@@ -172,7 +221,7 @@ async def canonical_name(name: Union[dns.name.Name, str]) -&gt;dns.name.Name:</span>
<span class="w"> </span>    See :py:func:`dns.resolver.Resolver.canonical_name` for more
<span class="w"> </span>    information on the parameters and possible exceptions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return await get_default_resolver().canonical_name(name)</span>


<span class="w"> </span>async def try_ddr(timeout: float=5.0) -&gt;None:
<span class="gu">@@ -182,7 +231,7 @@ async def try_ddr(timeout: float=5.0) -&gt;None:</span>

<span class="w"> </span>    See :py:func:`dns.resolver.Resolver.try_ddr` for more information.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    await get_default_resolver().try_ddr(timeout)</span>


<span class="w"> </span>async def zone_for_name(name: Union[dns.name.Name, str], rdclass: dns.
<span class="gu">@@ -194,7 +243,9 @@ async def zone_for_name(name: Union[dns.name.Name, str], rdclass: dns.</span>
<span class="w"> </span>    See :py:func:`dns.resolver.Resolver.zone_for_name` for more
<span class="w"> </span>    information on the parameters and possible exceptions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if resolver is None:</span>
<span class="gi">+        resolver = get_default_resolver()</span>
<span class="gi">+    return await resolver.zone_for_name(name, rdclass, tcp, backend)</span>


<span class="w"> </span>async def make_resolver_at(where: Union[dns.name.Name, str], port: int=53,
<span class="gu">@@ -217,7 +268,22 @@ async def make_resolver_at(where: Union[dns.name.Name, str], port: int=53,</span>

<span class="w"> </span>    Returns a ``dns.resolver.Resolver`` or raises an exception.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if resolver is None:</span>
<span class="gi">+        resolver = get_default_resolver()</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(where, str):</span>
<span class="gi">+        where = dns.name.from_text(where)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(where, dns.name.Name):</span>
<span class="gi">+        addresses = await resolver.resolve_name(where, family)</span>
<span class="gi">+        address = addresses[0].address</span>
<span class="gi">+    else:</span>
<span class="gi">+        address = where</span>
<span class="gi">+    </span>
<span class="gi">+    r = Resolver()</span>
<span class="gi">+    r.nameservers = [address]</span>
<span class="gi">+    r.port = port</span>
<span class="gi">+    return r</span>


<span class="w"> </span>async def resolve_at(where: Union[dns.name.Name, str], qname: Union[dns.
<span class="gu">@@ -241,4 +307,6 @@ async def resolve_at(where: Union[dns.name.Name, str], qname: Union[dns.</span>
<span class="w"> </span>    ``dns.asyncresolver.make_resolver_at()`` and then use that resolver for the queries
<span class="w"> </span>    instead of calling ``resolve_at()`` multiple times.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    r = await make_resolver_at(where, port, family, resolver)</span>
<span class="gi">+    return await r.resolve(qname, rdtype, rdclass, tcp, source, raise_on_no_answer,</span>
<span class="gi">+                           source_port, lifetime, search, backend)</span>
<span class="gh">diff --git a/dns/dnssec.py b/dns/dnssec.py</span>
<span class="gh">index 2787e8a..0f2e2fe 100644</span>
<span class="gd">--- a/dns/dnssec.py</span>
<span class="gi">+++ b/dns/dnssec.py</span>
<span class="gu">@@ -44,7 +44,11 @@ def algorithm_from_text(text: str) -&gt;Algorithm:</span>

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    text = text.upper()</span>
<span class="gi">+    try:</span>
<span class="gi">+        return Algorithm[text]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        raise dns.exception.SyntaxError(f&quot;Unknown algorithm: {text}&quot;)</span>


<span class="w"> </span>def algorithm_to_text(value: Union[Algorithm, int]) -&gt;str:
<span class="gu">@@ -54,12 +58,25 @@ def algorithm_to_text(value: Union[Algorithm, int]) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``, the name of a DNSSEC algorithm.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return Algorithm(value).name</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise dns.exception.SyntaxError(f&quot;Unknown algorithm: {value}&quot;)</span>


<span class="w"> </span>def to_timestamp(value: Union[datetime, str, float, int]) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Convert various format to a timestamp&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, datetime):</span>
<span class="gi">+        return int(value.timestamp())</span>
<span class="gi">+    elif isinstance(value, str):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return int(time.mktime(time.strptime(value, &quot;%Y%m%d%H%M%S&quot;)))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return int(float(value))</span>
<span class="gi">+    elif isinstance(value, (float, int)):</span>
<span class="gi">+        return int(value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Unsupported timestamp format&quot;)</span>


<span class="w"> </span>def key_id(key: Union[DNSKEY, CDNSKEY]) -&gt;int:
<span class="gu">@@ -69,7 +86,10 @@ def key_id(key: Union[DNSKEY, CDNSKEY]) -&gt;int:</span>

<span class="w"> </span>    Returns an ``int`` between 0 and 65535
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rdata = dns.rdata.from_text(dns.rdataclass.IN, dns.rdatatype.DNSKEY, </span>
<span class="gi">+                                f&quot;{key.flags} {key.protocol} {key.algorithm} {key.key}&quot;)</span>
<span class="gi">+    digest = hashlib.sha1(rdata.to_wire()).digest()</span>
<span class="gi">+    return (digest[-2] &lt;&lt; 8) | digest[-1]</span>


<span class="w"> </span>class Policy:
<span class="gu">@@ -128,7 +148,35 @@ def make_ds(name: Union[dns.name.Name, str], key: dns.rdata.Rdata,</span>

<span class="w"> </span>    Returns a ``dns.rdtypes.ANY.DS.DS``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(algorithm, str):</span>
<span class="gi">+        algorithm = DSDigest[algorithm.upper()]</span>
<span class="gi">+    </span>
<span class="gi">+    if policy is None:</span>
<span class="gi">+        policy = default_policy</span>
<span class="gi">+    </span>
<span class="gi">+    if validating:</span>
<span class="gi">+        if algorithm in policy._deny_validate_ds:</span>
<span class="gi">+            raise DeniedByPolicy(f&quot;DS digest algorithm {algorithm} denied by policy&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if algorithm in policy._deny_create_ds:</span>
<span class="gi">+            raise DeniedByPolicy(f&quot;DS digest algorithm {algorithm} denied by policy&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(name, str):</span>
<span class="gi">+        name = dns.name.from_text(name, origin)</span>
<span class="gi">+    </span>
<span class="gi">+    if algorithm == DSDigest.SHA1:</span>
<span class="gi">+        hash_func = hashlib.sha1</span>
<span class="gi">+    elif algorithm == DSDigest.SHA256:</span>
<span class="gi">+        hash_func = hashlib.sha256</span>
<span class="gi">+    elif algorithm == DSDigest.SHA384:</span>
<span class="gi">+        hash_func = hashlib.sha384</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise UnsupportedAlgorithm(f&quot;Unsupported DS digest algorithm: {algorithm}&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    key_rdata = key.to_wire()</span>
<span class="gi">+    digest = hash_func(name.to_wire() + key_rdata).hexdigest()</span>
<span class="gi">+    </span>
<span class="gi">+    return DS(name, dns.rdataclass.IN, key.key_tag, key.algorithm, algorithm, digest)</span>


<span class="w"> </span>def make_cds(name: Union[dns.name.Name, str], key: dns.rdata.Rdata,
<span class="gu">@@ -152,7 +200,8 @@ def make_cds(name: Union[dns.name.Name, str], key: dns.rdata.Rdata,</span>

<span class="w"> </span>    Returns a ``dns.rdtypes.ANY.DS.CDS``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ds = make_ds(name, key, algorithm, origin)</span>
<span class="gi">+    return CDS(ds.name, ds.rdclass, ds.key_tag, ds.algorithm, ds.digest_type, ds.digest)</span>


<span class="w"> </span>def _validate_rrsig(rrset: Union[dns.rrset.RRset, Tuple[dns.name.Name, dns.
<span class="gh">diff --git a/dns/dnssecalgs/base.py b/dns/dnssecalgs/base.py</span>
<span class="gh">index 9fc70e6..57c3916 100644</span>
<span class="gd">--- a/dns/dnssecalgs/base.py</span>
<span class="gi">+++ b/dns/dnssecalgs/base.py</span>
<span class="gu">@@ -27,7 +27,9 @@ class GenericPublicKey(ABC):</span>

<span class="w"> </span>    def to_dnskey(self, flags: int=Flag.ZONE, protocol: int=3) -&gt;DNSKEY:
<span class="w"> </span>        &quot;&quot;&quot;Return public key as DNSKEY&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return DNSKEY(dns.rdataclass.IN, dns.rdatatype.DNSKEY,</span>
<span class="gi">+                      flags, protocol, self.algorithm.value,</span>
<span class="gi">+                      self.encode_key_bytes())</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    @abstractmethod
<span class="gu">@@ -64,16 +66,16 @@ class GenericPrivateKey(ABC):</span>
<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def public_key(self) -&gt;&#39;GenericPublicKey&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Return public key instance&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;This method must be implemented by subclasses&quot;)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def from_pem(cls, private_pem: bytes, password: Optional[bytes]=None
<span class="w"> </span>        ) -&gt;&#39;GenericPrivateKey&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Create private key from PEM-encoded PKCS#8&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;This method must be implemented by subclasses&quot;)</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def to_pem(self, password: Optional[bytes]=None) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Return private key as PEM-encoded PKCS#8&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;This method must be implemented by subclasses&quot;)</span>
<span class="gh">diff --git a/dns/dnssecalgs/dsa.py b/dns/dnssecalgs/dsa.py</span>
<span class="gh">index d09a487..942820c 100644</span>
<span class="gd">--- a/dns/dnssecalgs/dsa.py</span>
<span class="gi">+++ b/dns/dnssecalgs/dsa.py</span>
<span class="gu">@@ -15,7 +15,18 @@ class PublicDSA(CryptographyPublicKey):</span>

<span class="w"> </span>    def encode_key_bytes(self) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Encode a public key per RFC 2536, section 2.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        y = self.key.public_numbers().y</span>
<span class="gi">+        p = self.key.public_numbers().parameter_numbers.p</span>
<span class="gi">+        q = self.key.public_numbers().parameter_numbers.q</span>
<span class="gi">+        g = self.key.public_numbers().parameter_numbers.g</span>
<span class="gi">+        </span>
<span class="gi">+        t = (p.bit_length() - 64) // 8 - 8</span>
<span class="gi">+        </span>
<span class="gi">+        return struct.pack(&quot;!B&quot;, t) + \</span>
<span class="gi">+               g.to_bytes(128, &#39;big&#39;) + \</span>
<span class="gi">+               y.to_bytes(128, &#39;big&#39;) + \</span>
<span class="gi">+               p.to_bytes(64 + t * 8, &#39;big&#39;) + \</span>
<span class="gi">+               q.to_bytes(20, &#39;big&#39;)</span>


<span class="w"> </span>class PrivateDSA(CryptographyPrivateKey):
<span class="gu">@@ -25,7 +36,22 @@ class PrivateDSA(CryptographyPrivateKey):</span>

<span class="w"> </span>    def sign(self, data: bytes, verify: bool=False) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Sign using a private key per RFC 2536, section 3.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        signature = self.key.sign(</span>
<span class="gi">+            data,</span>
<span class="gi">+            hashes.SHA1()</span>
<span class="gi">+        )</span>
<span class="gi">+        r, s = utils.decode_dss_signature(signature)</span>
<span class="gi">+        </span>
<span class="gi">+        encoded_signature = r.to_bytes(20, &#39;big&#39;) + s.to_bytes(20, &#39;big&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        if verify:</span>
<span class="gi">+            self.key.public_key().verify(</span>
<span class="gi">+                signature,</span>
<span class="gi">+                data,</span>
<span class="gi">+                hashes.SHA1()</span>
<span class="gi">+            )</span>
<span class="gi">+        </span>
<span class="gi">+        return encoded_signature</span>


<span class="w"> </span>class PublicDSANSEC3SHA1(PublicDSA):
<span class="gh">diff --git a/dns/dnssecalgs/ecdsa.py b/dns/dnssecalgs/ecdsa.py</span>
<span class="gh">index f482742..1a32e16 100644</span>
<span class="gd">--- a/dns/dnssecalgs/ecdsa.py</span>
<span class="gi">+++ b/dns/dnssecalgs/ecdsa.py</span>
<span class="gu">@@ -16,7 +16,10 @@ class PublicECDSA(CryptographyPublicKey):</span>

<span class="w"> </span>    def encode_key_bytes(self) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Encode a public key per RFC 6605, section 4.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        public_numbers = self.key.public_numbers()</span>
<span class="gi">+        x = public_numbers.x.to_bytes(self.octets, byteorder=&#39;big&#39;)</span>
<span class="gi">+        y = public_numbers.y.to_bytes(self.octets, byteorder=&#39;big&#39;)</span>
<span class="gi">+        return x + y</span>


<span class="w"> </span>class PrivateECDSA(CryptographyPrivateKey):
<span class="gu">@@ -26,7 +29,16 @@ class PrivateECDSA(CryptographyPrivateKey):</span>

<span class="w"> </span>    def sign(self, data: bytes, verify: bool=False) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Sign using a private key per RFC 6605, section 4.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        signature = self.key.sign(</span>
<span class="gi">+            data,</span>
<span class="gi">+            ec.ECDSA(self.public_cls.chosen_hash)</span>
<span class="gi">+        )</span>
<span class="gi">+        r, s = utils.decode_dss_signature(signature)</span>
<span class="gi">+        r_bytes = r.to_bytes(self.public_cls.octets, byteorder=&#39;big&#39;)</span>
<span class="gi">+        s_bytes = s.to_bytes(self.public_cls.octets, byteorder=&#39;big&#39;)</span>
<span class="gi">+        if verify:</span>
<span class="gi">+            self.public().verify(data, r_bytes + s_bytes)</span>
<span class="gi">+        return r_bytes + s_bytes</span>


<span class="w"> </span>class PublicECDSAP256SHA256(PublicECDSA):
<span class="gh">diff --git a/dns/dnssecalgs/eddsa.py b/dns/dnssecalgs/eddsa.py</span>
<span class="gh">index 7705e31..4f5e456 100644</span>
<span class="gd">--- a/dns/dnssecalgs/eddsa.py</span>
<span class="gi">+++ b/dns/dnssecalgs/eddsa.py</span>
<span class="gu">@@ -10,7 +10,10 @@ class PublicEDDSA(CryptographyPublicKey):</span>

<span class="w"> </span>    def encode_key_bytes(self) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Encode a public key per RFC 8080, section 3.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.key.public_bytes(</span>
<span class="gi">+            encoding=serialization.Encoding.Raw,</span>
<span class="gi">+            format=serialization.PublicFormat.Raw</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PrivateEDDSA(CryptographyPrivateKey):
<span class="gu">@@ -18,7 +21,10 @@ class PrivateEDDSA(CryptographyPrivateKey):</span>

<span class="w"> </span>    def sign(self, data: bytes, verify: bool=False) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Sign using a private key per RFC 8080, section 4.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        signature = self.key.sign(data)</span>
<span class="gi">+        if verify:</span>
<span class="gi">+            self.public_key().verify(signature, data)</span>
<span class="gi">+        return signature</span>


<span class="w"> </span>class PublicED25519(PublicEDDSA):
<span class="gh">diff --git a/dns/dnssecalgs/rsa.py b/dns/dnssecalgs/rsa.py</span>
<span class="gh">index 91f1eaf..c22f45c 100644</span>
<span class="gd">--- a/dns/dnssecalgs/rsa.py</span>
<span class="gi">+++ b/dns/dnssecalgs/rsa.py</span>
<span class="gu">@@ -16,7 +16,19 @@ class PublicRSA(CryptographyPublicKey):</span>

<span class="w"> </span>    def encode_key_bytes(self) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Encode a public key per RFC 3110, section 2.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        exponent = self.key.public_numbers().e</span>
<span class="gi">+        modulus = self.key.public_numbers().n</span>
<span class="gi">+        exponent_len = (exponent.bit_length() + 7) // 8</span>
<span class="gi">+        modulus_bytes = modulus.to_bytes((modulus.bit_length() + 7) // 8, byteorder=&#39;big&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        if exponent_len &lt;= 255:</span>
<span class="gi">+            return struct.pack(&#39;!B&#39;, exponent_len) + \</span>
<span class="gi">+                   exponent.to_bytes(exponent_len, byteorder=&#39;big&#39;) + \</span>
<span class="gi">+                   modulus_bytes</span>
<span class="gi">+        else:</span>
<span class="gi">+            return struct.pack(&#39;!BH&#39;, 0, exponent_len) + \</span>
<span class="gi">+                   exponent.to_bytes(exponent_len, byteorder=&#39;big&#39;) + \</span>
<span class="gi">+                   modulus_bytes</span>


<span class="w"> </span>class PrivateRSA(CryptographyPrivateKey):
<span class="gu">@@ -27,7 +39,25 @@ class PrivateRSA(CryptographyPrivateKey):</span>

<span class="w"> </span>    def sign(self, data: bytes, verify: bool=False) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Sign using a private key per RFC 3110, section 3.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        signature = self.key.sign(</span>
<span class="gi">+            data,</span>
<span class="gi">+            padding.PKCS1v15(),</span>
<span class="gi">+            self.public_cls.chosen_hash</span>
<span class="gi">+        )</span>
<span class="gi">+        </span>
<span class="gi">+        if verify:</span>
<span class="gi">+            public_key = self.key.public_key()</span>
<span class="gi">+            try:</span>
<span class="gi">+                public_key.verify(</span>
<span class="gi">+                    signature,</span>
<span class="gi">+                    data,</span>
<span class="gi">+                    padding.PKCS1v15(),</span>
<span class="gi">+                    self.public_cls.chosen_hash</span>
<span class="gi">+                )</span>
<span class="gi">+            except:</span>
<span class="gi">+                raise ValueError(&quot;Signature verification failed&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        return signature</span>


<span class="w"> </span>class PublicRSAMD5(PublicRSA):
<span class="gh">diff --git a/dns/e164.py b/dns/e164.py</span>
<span class="gh">index 94218a3..9b8d0b0 100644</span>
<span class="gd">--- a/dns/e164.py</span>
<span class="gi">+++ b/dns/e164.py</span>
<span class="gu">@@ -21,7 +21,17 @@ def from_e164(text: str, origin: Optional[dns.name.Name]=public_enum_domain</span>

<span class="w"> </span>    Returns a ``dns.name.Name``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    digits = &#39;&#39;.join(filter(str.isdigit, text))</span>
<span class="gi">+    if not digits:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;No digits found in E.164 number&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    labels = list(reversed(digits))</span>
<span class="gi">+    name = dns.name.Name(labels)</span>
<span class="gi">+    </span>
<span class="gi">+    if origin is not None:</span>
<span class="gi">+        name = name.derelativize(origin)</span>
<span class="gi">+    </span>
<span class="gi">+    return name</span>


<span class="w"> </span>def to_e164(name: dns.name.Name, origin: Optional[dns.name.Name]=
<span class="gu">@@ -45,7 +55,15 @@ def to_e164(name: dns.name.Name, origin: Optional[dns.name.Name]=</span>
<span class="w"> </span>    Returns a ``str``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if origin is not None:</span>
<span class="gi">+        name = name.relativize(origin)</span>
<span class="gi">+    </span>
<span class="gi">+    digits = &#39;&#39;.join(reversed(name.labels))</span>
<span class="gi">+    </span>
<span class="gi">+    if want_plus_prefix:</span>
<span class="gi">+        return &#39;+&#39; + digits</span>
<span class="gi">+    else:</span>
<span class="gi">+        return digits</span>


<span class="w"> </span>def query(number: str, domains: Iterable[Union[dns.name.Name, str]],
<span class="gu">@@ -61,4 +79,19 @@ def query(number: str, domains: Iterable[Union[dns.name.Name, str]],</span>
<span class="w"> </span>    *resolver*, a ``dns.resolver.Resolver``, is the resolver to use.  If
<span class="w"> </span>    ``None``, the default resolver is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if resolver is None:</span>
<span class="gi">+        resolver = dns.resolver.get_default_resolver()</span>
<span class="gi">+    </span>
<span class="gi">+    for domain in domains:</span>
<span class="gi">+        if isinstance(domain, str):</span>
<span class="gi">+            domain = dns.name.from_text(domain)</span>
<span class="gi">+        </span>
<span class="gi">+        e164_name = from_e164(number, domain)</span>
<span class="gi">+        </span>
<span class="gi">+        try:</span>
<span class="gi">+            answer = resolver.resolve(e164_name, &#39;NAPTR&#39;)</span>
<span class="gi">+            return answer</span>
<span class="gi">+        except dns.resolver.NXDOMAIN:</span>
<span class="gi">+            continue</span>
<span class="gi">+    </span>
<span class="gi">+    raise dns.resolver.NXDOMAIN(f&quot;No NAPTR records found for {number} in the specified domains&quot;)</span>
<span class="gh">diff --git a/dns/edns.py b/dns/edns.py</span>
<span class="gh">index ac75090..323ce18 100644</span>
<span class="gd">--- a/dns/edns.py</span>
<span class="gi">+++ b/dns/edns.py</span>
<span class="gu">@@ -40,7 +40,7 @@ class Option:</span>
<span class="w"> </span>        Returns a ``bytes`` or ``None``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_wire_parser(cls, otype: OptionType, parser: &#39;dns.wire.Parser&#39;
<span class="gu">@@ -54,14 +54,14 @@ class Option:</span>

<span class="w"> </span>        Returns a ``dns.edns.Option``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def _cmp(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Compare an EDNS option with another option of the same type.

<span class="w"> </span>        Returns &lt; 0 if &lt; *other*, 0 if == *other*, and &gt; 0 if &gt; *other*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, Option):
<span class="gu">@@ -181,7 +181,21 @@ class ECSOption(Option):</span>
<span class="w"> </span>        &gt;&gt;&gt; # it understands results from `dns.edns.ECSOption.to_text()`
<span class="w"> </span>        &gt;&gt;&gt; dns.edns.ECSOption.from_text(&#39;ECS 1.2.3.4/24/32&#39;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parts = text.split()</span>
<span class="gi">+        if parts[0] == &#39;ECS&#39;:</span>
<span class="gi">+            parts = parts[1:]</span>
<span class="gi">+        if len(parts) != 1:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Invalid ECS option format&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        address_parts = parts[0].split(&#39;/&#39;)</span>
<span class="gi">+        if len(address_parts) &lt; 2 or len(address_parts) &gt; 3:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Invalid ECS address format&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        address = address_parts[0]</span>
<span class="gi">+        srclen = int(address_parts[1])</span>
<span class="gi">+        scopelen = int(address_parts[2]) if len(address_parts) == 3 else 0</span>
<span class="gi">+        </span>
<span class="gi">+        return ECSOption(address, srclen, scopelen)</span>


<span class="w"> </span>class EDECode(dns.enum.IntEnum):
<span class="gu">@@ -247,7 +261,7 @@ def get_option_class(otype: OptionType) -&gt;Any:</span>
<span class="w"> </span>    The GenericOption class is used if a more specific class is not
<span class="w"> </span>    known.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _type_to_class.get(otype, GenericOption)</span>


<span class="w"> </span>def option_from_wire_parser(otype: Union[OptionType, str], parser:
<span class="gu">@@ -261,7 +275,9 @@ def option_from_wire_parser(otype: Union[OptionType, str], parser:</span>

<span class="w"> </span>    Returns an instance of a subclass of ``dns.edns.Option``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    otype = OptionType.make(otype)</span>
<span class="gi">+    cls = get_option_class(otype)</span>
<span class="gi">+    return cls.from_wire_parser(otype, parser)</span>


<span class="w"> </span>def option_from_wire(otype: Union[OptionType, str], wire: bytes, current:
<span class="gu">@@ -279,7 +295,11 @@ def option_from_wire(otype: Union[OptionType, str], wire: bytes, current:</span>

<span class="w"> </span>    Returns an instance of a subclass of ``dns.edns.Option``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    otype = OptionType.make(otype)</span>
<span class="gi">+    cls = get_option_class(otype)</span>
<span class="gi">+    parser = dns.wire.Parser(wire, current)</span>
<span class="gi">+    with parser.restrict_to(olen):</span>
<span class="gi">+        return cls.from_wire_parser(otype, parser)</span>


<span class="w"> </span>def register_type(implementation: Any, otype: OptionType) -&gt;None:
<span class="gu">@@ -289,7 +309,7 @@ def register_type(implementation: Any, otype: OptionType) -&gt;None:</span>

<span class="w"> </span>    *otype*, an ``int``, is the option type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _type_to_class[OptionType.make(otype)] = implementation</span>


<span class="w"> </span>NSID = OptionType.NSID
<span class="gh">diff --git a/dns/enum.py b/dns/enum.py</span>
<span class="gh">index c6d69c6..bcf169c 100644</span>
<span class="gd">--- a/dns/enum.py</span>
<span class="gi">+++ b/dns/enum.py</span>
<span class="gu">@@ -19,4 +19,15 @@ class IntEnum(enum.IntEnum):</span>
<span class="w"> </span>        Returns an enumeration from the calling class corresponding to the
<span class="w"> </span>        value, if one is defined, or an ``int`` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return cls[value.upper()]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                raise cls.UnknownValue(f&quot;Unknown {cls.__name__}: {value}&quot;)</span>
<span class="gi">+        elif isinstance(value, int):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return cls(value)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                return value</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(f&quot;Expected str or int, not {type(value).__name__}&quot;)</span>
<span class="gh">diff --git a/dns/exception.py b/dns/exception.py</span>
<span class="gh">index 4f53e7b..3d3493b 100644</span>
<span class="gd">--- a/dns/exception.py</span>
<span class="gi">+++ b/dns/exception.py</span>
<span class="gu">@@ -50,7 +50,10 @@ class DNSException(Exception):</span>
<span class="w"> </span>        &quot;&quot;&quot;Old exceptions supported only args and not kwargs.

<span class="w"> </span>        For sanity we do not allow to mix old and new behavior.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if args and kwargs:</span>
<span class="gi">+            raise ValueError(&quot;Cannot mix args and kwargs in exception initialization&quot;)</span>
<span class="gi">+        if kwargs and not set(kwargs.keys()).issubset(self.supp_kwargs):</span>
<span class="gi">+            raise ValueError(f&quot;Unsupported kwargs: {set(kwargs.keys()) - self.supp_kwargs}&quot;)</span>

<span class="w"> </span>    def _fmt_kwargs(self, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Format kwargs before printing them.
<span class="gu">@@ -58,7 +61,7 @@ class DNSException(Exception):</span>
<span class="w"> </span>        Resulting dictionary has to have keys necessary for str.format call
<span class="w"> </span>        on fmt class variable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {k: v for k, v in kwargs.items() if k in self.supp_kwargs}</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        if self.kwargs and self.fmt:
<span class="gh">diff --git a/dns/flags.py b/dns/flags.py</span>
<span class="gh">index f682e9b..9b49f8e 100644</span>
<span class="gd">--- a/dns/flags.py</span>
<span class="gi">+++ b/dns/flags.py</span>
<span class="gu">@@ -23,7 +23,10 @@ def from_text(text: str) -&gt;int:</span>

<span class="w"> </span>    Returns an ``int``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    flags = 0</span>
<span class="gi">+    for flag in text.upper().split():</span>
<span class="gi">+        flags |= Flag[flag]</span>
<span class="gi">+    return flags</span>


<span class="w"> </span>def to_text(flags: int) -&gt;str:
<span class="gu">@@ -32,7 +35,7 @@ def to_text(flags: int) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39; &#39;.join(flag.name for flag in Flag if flags &amp; flag)</span>


<span class="w"> </span>def edns_from_text(text: str) -&gt;int:
<span class="gu">@@ -41,7 +44,10 @@ def edns_from_text(text: str) -&gt;int:</span>

<span class="w"> </span>    Returns an ``int``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    flags = 0</span>
<span class="gi">+    for flag in text.upper().split():</span>
<span class="gi">+        flags |= EDNSFlag[flag]</span>
<span class="gi">+    return flags</span>


<span class="w"> </span>def edns_to_text(flags: int) -&gt;str:
<span class="gu">@@ -50,7 +56,7 @@ def edns_to_text(flags: int) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39; &#39;.join(flag.name for flag in EDNSFlag if flags &amp; flag)</span>


<span class="w"> </span>QR = Flag.QR
<span class="gh">diff --git a/dns/grange.py b/dns/grange.py</span>
<span class="gh">index af2c200..679c5ad 100644</span>
<span class="gd">--- a/dns/grange.py</span>
<span class="gi">+++ b/dns/grange.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;DNS GENERATE range conversion.&quot;&quot;&quot;
<span class="w"> </span>from typing import Tuple
<span class="w"> </span>import dns
<span class="gi">+import dns.exception</span>


<span class="w"> </span>def from_text(text: str) -&gt;Tuple[int, int, int]:
<span class="gu">@@ -11,4 +12,26 @@ def from_text(text: str) -&gt;Tuple[int, int, int]:</span>

<span class="w"> </span>    Returns a tuple of three ``int`` values ``(start, stop, step)``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = text.split(&#39;/&#39;)</span>
<span class="gi">+    if len(parts) == 1:</span>
<span class="gi">+        range_part = parts[0]</span>
<span class="gi">+        step = 1</span>
<span class="gi">+    elif len(parts) == 2:</span>
<span class="gi">+        range_part, step = parts</span>
<span class="gi">+        step = int(step)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;invalid range&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    range_values = range_part.split(&#39;-&#39;)</span>
<span class="gi">+    if len(range_values) != 2:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;invalid range&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    start, stop = map(int, range_values)</span>
<span class="gi">+    </span>
<span class="gi">+    if start &gt; stop:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;start must be &lt;= stop&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if step &lt;= 0:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;step must be positive&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return (start, stop, step)</span>
<span class="gh">diff --git a/dns/immutable.py b/dns/immutable.py</span>
<span class="gh">index 1170831..f58be62 100644</span>
<span class="gd">--- a/dns/immutable.py</span>
<span class="gi">+++ b/dns/immutable.py</span>
<span class="gu">@@ -43,4 +43,13 @@ def constify(o: Any) -&gt;Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert mutable types to immutable types.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(o, (str, int, float, bool, type(None))):</span>
<span class="gi">+        return o</span>
<span class="gi">+    elif isinstance(o, dict):</span>
<span class="gi">+        return Dict({k: constify(v) for k, v in o.items()})</span>
<span class="gi">+    elif isinstance(o, (list, tuple)):</span>
<span class="gi">+        return tuple(constify(item) for item in o)</span>
<span class="gi">+    elif isinstance(o, set):</span>
<span class="gi">+        return frozenset(constify(item) for item in o)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return o  # If it&#39;s not a known mutable type, return as is</span>
<span class="gh">diff --git a/dns/inet.py b/dns/inet.py</span>
<span class="gh">index 8c49f86..b8492f5 100644</span>
<span class="gd">--- a/dns/inet.py</span>
<span class="gi">+++ b/dns/inet.py</span>
<span class="gu">@@ -19,7 +19,12 @@ def inet_pton(family: int, text: str) -&gt;bytes:</span>

<span class="w"> </span>    Returns a ``bytes``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if family == AF_INET:</span>
<span class="gi">+        return dns.ipv4.inet_aton(text)</span>
<span class="gi">+    elif family == AF_INET6:</span>
<span class="gi">+        return dns.ipv6.inet_aton(text)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise NotImplementedError(f&quot;Address family {family} not supported&quot;)</span>


<span class="w"> </span>def inet_ntop(family: int, address: bytes) -&gt;str:
<span class="gu">@@ -34,7 +39,12 @@ def inet_ntop(family: int, address: bytes) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if family == AF_INET:</span>
<span class="gi">+        return dns.ipv4.inet_ntoa(address)</span>
<span class="gi">+    elif family == AF_INET6:</span>
<span class="gi">+        return dns.ipv6.inet_ntoa(address)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise NotImplementedError(f&quot;Address family {family} not supported&quot;)</span>


<span class="w"> </span>def af_for_address(text: str) -&gt;int:
<span class="gu">@@ -47,7 +57,15 @@ def af_for_address(text: str) -&gt;int:</span>

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        dns.ipv4.inet_aton(text)</span>
<span class="gi">+        return AF_INET</span>
<span class="gi">+    except dns.exception.SyntaxError:</span>
<span class="gi">+        try:</span>
<span class="gi">+            dns.ipv6.inet_aton(text)</span>
<span class="gi">+            return AF_INET6</span>
<span class="gi">+        except dns.exception.SyntaxError:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid IP address: {text}&quot;)</span>


<span class="w"> </span>def is_multicast(text: str) -&gt;bool:
<span class="gu">@@ -60,7 +78,13 @@ def is_multicast(text: str) -&gt;bool:</span>

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    family = af_for_address(text)</span>
<span class="gi">+    if family == AF_INET:</span>
<span class="gi">+        return text.startswith(&#39;224.&#39;) or text.startswith(&#39;239.&#39;)</span>
<span class="gi">+    elif family == AF_INET6:</span>
<span class="gi">+        return text.startswith(&#39;ff&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid IP address: {text}&quot;)</span>


<span class="w"> </span>def is_address(text: str) -&gt;bool:
<span class="gu">@@ -70,7 +94,11 @@ def is_address(text: str) -&gt;bool:</span>

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        af_for_address(text)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def low_level_address_tuple(high_tuple: Tuple[str, int], af: Optional[int]=None
<span class="gu">@@ -83,12 +111,26 @@ def low_level_address_tuple(high_tuple: Tuple[str, int], af: Optional[int]=None</span>
<span class="w"> </span>    address in the high-level tuple is valid and has that af.  If af
<span class="w"> </span>    is ``None``, then af_for_address will be called.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    address, port = high_tuple</span>
<span class="gi">+    if af is None:</span>
<span class="gi">+        af = af_for_address(address)</span>
<span class="gi">+    </span>
<span class="gi">+    if af == AF_INET:</span>
<span class="gi">+        return (address, port)</span>
<span class="gi">+    elif af == AF_INET6:</span>
<span class="gi">+        return (address, port, 0, 0)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid address family: {af}&quot;)</span>


<span class="w"> </span>def any_for_af(af):
<span class="w"> </span>    &quot;&quot;&quot;Return the &#39;any&#39; address for the specified address family.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if af == AF_INET:</span>
<span class="gi">+        return &#39;0.0.0.0&#39;</span>
<span class="gi">+    elif af == AF_INET6:</span>
<span class="gi">+        return &#39;::&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid address family: {af}&quot;)</span>


<span class="w"> </span>def canonicalize(text: str) -&gt;str:
<span class="gu">@@ -99,4 +141,13 @@ def canonicalize(text: str) -&gt;str:</span>

<span class="w"> </span>    Raises ``ValueError`` if the text is not valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        af = af_for_address(text)</span>
<span class="gi">+        if af == AF_INET:</span>
<span class="gi">+            return dns.ipv4.canonicalize(text)</span>
<span class="gi">+        elif af == AF_INET6:</span>
<span class="gi">+            if &#39;%&#39; in text:</span>
<span class="gi">+                raise ValueError(&quot;IPv6 addresses with scopes are not allowed&quot;)</span>
<span class="gi">+            return dns.ipv6.canonicalize(text)</span>
<span class="gi">+    except Exception as e:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid IP address: {text}&quot;) from e</span>
<span class="gh">diff --git a/dns/ipv4.py b/dns/ipv4.py</span>
<span class="gh">index 00864bd..3e3101b 100644</span>
<span class="gd">--- a/dns/ipv4.py</span>
<span class="gi">+++ b/dns/ipv4.py</span>
<span class="gu">@@ -11,7 +11,7 @@ def inet_ntoa(address: bytes) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;.&#39;.join(str(b) for b in address)</span>


<span class="w"> </span>def inet_aton(text: Union[str, bytes]) -&gt;bytes:
<span class="gu">@@ -21,7 +21,15 @@ def inet_aton(text: Union[str, bytes]) -&gt;bytes:</span>

<span class="w"> </span>    Returns a ``bytes``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(text, bytes):</span>
<span class="gi">+        text = text.decode()</span>
<span class="gi">+    parts = text.split(&#39;.&#39;)</span>
<span class="gi">+    if len(parts) != 4:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;Invalid IPv4 address&quot;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        return bytes(int(p) for p in parts)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;Invalid IPv4 address&quot;)</span>


<span class="w"> </span>def canonicalize(text: Union[str, bytes]) -&gt;str:
<span class="gu">@@ -32,4 +40,8 @@ def canonicalize(text: Union[str, bytes]) -&gt;str:</span>

<span class="w"> </span>    Raises ``dns.exception.SyntaxError`` if the text is not valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        binary = inet_aton(text)</span>
<span class="gi">+        return inet_ntoa(binary)</span>
<span class="gi">+    except dns.exception.SyntaxError:</span>
<span class="gi">+        raise</span>
<span class="gh">diff --git a/dns/ipv6.py b/dns/ipv6.py</span>
<span class="gh">index 94ddeaa..c3ac219 100644</span>
<span class="gd">--- a/dns/ipv6.py</span>
<span class="gi">+++ b/dns/ipv6.py</span>
<span class="gu">@@ -15,7 +15,37 @@ def inet_ntoa(address: bytes) -&gt;str:</span>
<span class="w"> </span>    Raises ``ValueError`` if the address isn&#39;t 16 bytes long.
<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(address) != 16:</span>
<span class="gi">+        raise ValueError(&quot;IPv6 addresses are 16 bytes long&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    hex_groups = [address[i:i+2].hex() for i in range(0, 16, 2)]</span>
<span class="gi">+    compressed = &quot;:&quot;.join(hex_groups)</span>
<span class="gi">+    </span>
<span class="gi">+    # Find the longest run of zeros to compress</span>
<span class="gi">+    best_start, best_len = 0, 0</span>
<span class="gi">+    current_start, current_len = None, 0</span>
<span class="gi">+    for i, group in enumerate(hex_groups):</span>
<span class="gi">+        if group == &quot;0000&quot;:</span>
<span class="gi">+            if current_start is None:</span>
<span class="gi">+                current_start = i</span>
<span class="gi">+            current_len += 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            if current_len &gt; best_len:</span>
<span class="gi">+                best_start, best_len = current_start, current_len</span>
<span class="gi">+            current_start, current_len = None, 0</span>
<span class="gi">+    </span>
<span class="gi">+    if current_len &gt; best_len:</span>
<span class="gi">+        best_start, best_len = current_start, current_len</span>
<span class="gi">+    </span>
<span class="gi">+    if best_len &gt; 1:</span>
<span class="gi">+        compressed_parts = hex_groups[:best_start] + [&#39;&#39;] + hex_groups[best_start + best_len:]</span>
<span class="gi">+        compressed = &quot;:&quot;.join(compressed_parts)</span>
<span class="gi">+        if compressed.startswith(&quot;:&quot;):</span>
<span class="gi">+            compressed = &quot;:&quot; + compressed</span>
<span class="gi">+        if compressed.endswith(&quot;:&quot;):</span>
<span class="gi">+            compressed += &quot;:&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    return compressed.lower()</span>


<span class="w"> </span>_v4_ending = re.compile(b&#39;(.*):(\\d+\\.\\d+\\.\\d+\\.\\d+)$&#39;)
<span class="gu">@@ -33,7 +63,31 @@ def inet_aton(text: Union[str, bytes], ignore_scope: bool=False) -&gt;bytes:</span>

<span class="w"> </span>    Returns a ``bytes``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(text, bytes):</span>
<span class="gi">+        text = text.decode()</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;%&#39; in text:</span>
<span class="gi">+        if ignore_scope:</span>
<span class="gi">+            text = text.split(&#39;%&#39;)[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;IPv6 address with a scope&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;::&#39; in text:</span>
<span class="gi">+        left, right = text.split(&#39;::&#39;, 1)</span>
<span class="gi">+        left_parts = left.split(&#39;:&#39;) if left else []</span>
<span class="gi">+        right_parts = right.split(&#39;:&#39;) if right else []</span>
<span class="gi">+        missing = 8 - (len(left_parts) + len(right_parts))</span>
<span class="gi">+        parts = left_parts + [&#39;0&#39;] * missing + right_parts</span>
<span class="gi">+    else:</span>
<span class="gi">+        parts = text.split(&#39;:&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if len(parts) != 8:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;Invalid IPv6 address&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return b&#39;&#39;.join(int(part, 16).to_bytes(2, &#39;big&#39;) for part in parts)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;Invalid hexadecimal in IPv6 address&quot;)</span>


<span class="w"> </span>_mapped_prefix = b&#39;\x00&#39; * 10 + b&#39;\xff\xff&#39;
<span class="gu">@@ -46,7 +100,7 @@ def is_mapped(address: bytes) -&gt;bool:</span>

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(address) == 16 and address.startswith(_mapped_prefix)</span>


<span class="w"> </span>def canonicalize(text: Union[str, bytes]) -&gt;str:
<span class="gu">@@ -57,4 +111,8 @@ def canonicalize(text: Union[str, bytes]) -&gt;str:</span>

<span class="w"> </span>    Raises ``dns.exception.SyntaxError`` if the text is not valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        binary = inet_aton(text)</span>
<span class="gi">+        return inet_ntoa(binary)</span>
<span class="gi">+    except ValueError as e:</span>
<span class="gi">+        raise dns.exception.SyntaxError(str(e))</span>
<span class="gh">diff --git a/dns/message.py b/dns/message.py</span>
<span class="gh">index 657451c..e2c959f 100644</span>
<span class="gd">--- a/dns/message.py</span>
<span class="gi">+++ b/dns/message.py</span>
<span class="gu">@@ -62,7 +62,7 @@ class Truncated(dns.exception.DNSException):</span>

<span class="w"> </span>        Returns a ``dns.message.Message``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.kwargs.get(&#39;message&#39;)</span>


<span class="w"> </span>class NotQueryResponse(dns.exception.DNSException):
<span class="gu">@@ -132,22 +132,22 @@ class Message:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def question(self) -&gt;List[dns.rrset.RRset]:
<span class="w"> </span>        &quot;&quot;&quot;The question section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[0]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def answer(self) -&gt;List[dns.rrset.RRset]:
<span class="w"> </span>        &quot;&quot;&quot;The answer section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[1]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def authority(self) -&gt;List[dns.rrset.RRset]:
<span class="w"> </span>        &quot;&quot;&quot;The authority section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[2]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def additional(self) -&gt;List[dns.rrset.RRset]:
<span class="w"> </span>        &quot;&quot;&quot;The additional data section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[3]</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;DNS message, ID &#39; + repr(self.id) + &#39;&gt;&#39;
<span class="gu">@@ -164,7 +164,17 @@ class Message:</span>

<span class="w"> </span>        Returns a ``str``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        s = io.StringIO()</span>
<span class="gi">+        s.write(f&quot;id {self.id}\n&quot;)</span>
<span class="gi">+        s.write(f&quot;opcode {dns.opcode.to_text(self.opcode())}\n&quot;)</span>
<span class="gi">+        s.write(f&quot;rcode {dns.rcode.to_text(self.rcode())}\n&quot;)</span>
<span class="gi">+        s.write(f&quot;flags {dns.flags.to_text(self.flags)}\n&quot;)</span>
<span class="gi">+        for i, section in enumerate(self.sections):</span>
<span class="gi">+            s.write(f&quot;;{self._section_enum.to_text(i)}:\n&quot;)</span>
<span class="gi">+            for rrset in section:</span>
<span class="gi">+                s.write(rrset.to_text(origin, relativize, **kw))</span>
<span class="gi">+                s.write(&quot;\n&quot;)</span>
<span class="gi">+        return s.getvalue()</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Two messages are equal if they have the same content in the
<span class="gu">@@ -197,7 +207,9 @@ class Message:</span>

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (self.id == other.id and</span>
<span class="gi">+                self.opcode() == other.opcode() and</span>
<span class="gi">+                (other.flags &amp; dns.flags.QR) != 0)</span>

<span class="w"> </span>    def section_number(self, section: List[dns.rrset.RRset]) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Return the &quot;section number&quot; of the specified section for use
<span class="gu">@@ -209,7 +221,10 @@ class Message:</span>

<span class="w"> </span>        Returns an ``int``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for i, s in enumerate(self.sections):</span>
<span class="gi">+            if section is s:</span>
<span class="gi">+                return i</span>
<span class="gi">+        raise ValueError(&#39;unknown section&#39;)</span>

<span class="w"> </span>    def section_from_number(self, number: int) -&gt;List[dns.rrset.RRset]:
<span class="w"> </span>        &quot;&quot;&quot;Return the section list associated with the specified section
<span class="gu">@@ -222,7 +237,12 @@ class Message:</span>

<span class="w"> </span>        Returns a ``list``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(number, str):</span>
<span class="gi">+            number = self._section_enum.from_text(number)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.sections[number]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            raise ValueError(&#39;invalid section&#39;)</span>

<span class="w"> </span>    def find_rrset(self, section: SectionType, name: dns.name.Name, rdclass:
<span class="w"> </span>        dns.rdataclass.RdataClass, rdtype: dns.rdatatype.RdataType, covers:
<span class="gh">diff --git a/dns/name.py b/dns/name.py</span>
<span class="gh">index b9a153e..3912f69 100644</span>
<span class="gd">--- a/dns/name.py</span>
<span class="gi">+++ b/dns/name.py</span>
<span class="gu">@@ -99,7 +99,9 @@ def _escapify(label: Union[bytes, str]) -&gt;str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Escape the characters in label which need it.
<span class="w"> </span>    @returns: the escaped string
<span class="w"> </span>    @rtype: string&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(label, bytes):</span>
<span class="gi">+        label = label.decode(&#39;ascii&#39;)</span>
<span class="gi">+    return &#39;&#39;.join((&#39;\\&#39; + c if c in _escaped_text else c) for c in label)</span>


<span class="w"> </span>class IDNACodec:
<span class="gu">@@ -186,7 +188,14 @@ def _validate_labels(labels: Tuple[bytes, ...]) -&gt;None:</span>
<span class="w"> </span>    sequence

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    total_length = sum(len(label) for label in labels) + len(labels)</span>
<span class="gi">+    if total_length &gt; 255:</span>
<span class="gi">+        raise NameTooLong</span>
<span class="gi">+    for i, label in enumerate(labels):</span>
<span class="gi">+        if len(label) &gt; 63:</span>
<span class="gi">+            raise LabelTooLong</span>
<span class="gi">+        if len(label) == 0 and i != len(labels) - 1:</span>
<span class="gi">+            raise EmptyLabel</span>


<span class="w"> </span>def _maybe_convert_to_binary(label: Union[bytes, str]) -&gt;bytes:
<span class="gu">@@ -194,7 +203,9 @@ def _maybe_convert_to_binary(label: Union[bytes, str]) -&gt;bytes:</span>
<span class="w"> </span>    ``bytes`` just return it.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(label, str):</span>
<span class="gi">+        return label.encode(&#39;ascii&#39;)</span>
<span class="gi">+    return label</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="gu">@@ -231,14 +242,14 @@ class Name:</span>

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.labels) &gt; 0 and self.labels[-1] == b&#39;&#39;</span>

<span class="w"> </span>    def is_wild(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Is this name wild?  (I.e. Is the least significant label &#39;*&#39;?)

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.labels) &gt; 0 and self.labels[0] == b&#39;*&#39;</span>

<span class="w"> </span>    def __hash__(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Return a case-insensitive hash of the name.
<span class="gu">@@ -282,7 +293,32 @@ class Name:</span>
<span class="w"> </span>        example1.      example2       none         &gt; 0    0
<span class="w"> </span>        =============  =============  ===========  =====  =======
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sabs = self.is_absolute()</span>
<span class="gi">+        oabs = other.is_absolute()</span>
<span class="gi">+        if sabs != oabs:</span>
<span class="gi">+            if sabs:</span>
<span class="gi">+                return (NameRelation.NONE, 1, 0)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return (NameRelation.NONE, -1, 0)</span>
<span class="gi">+        </span>
<span class="gi">+        la = len(self.labels)</span>
<span class="gi">+        lo = len(other.labels)</span>
<span class="gi">+        l = min(la, lo)</span>
<span class="gi">+        </span>
<span class="gi">+        for i in range(l):</span>
<span class="gi">+            sa = self.labels[la - i - 1].lower()</span>
<span class="gi">+            so = other.labels[lo - i - 1].lower()</span>
<span class="gi">+            if sa &lt; so:</span>
<span class="gi">+                return (NameRelation.NONE, -1, i)</span>
<span class="gi">+            elif sa &gt; so:</span>
<span class="gi">+                return (NameRelation.NONE, 1, i)</span>
<span class="gi">+        </span>
<span class="gi">+        if la == lo:</span>
<span class="gi">+            return (NameRelation.EQUAL, 0, l)</span>
<span class="gi">+        elif la &gt; lo:</span>
<span class="gi">+            return (NameRelation.SUBDOMAIN, 1, l)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (NameRelation.SUPERDOMAIN, -1, l)</span>

<span class="w"> </span>    def is_subdomain(self, other: &#39;Name&#39;) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Is self a subdomain of other?
<span class="gh">diff --git a/dns/namedict.py b/dns/namedict.py</span>
<span class="gh">index e2fcfff..7844d61 100644</span>
<span class="gd">--- a/dns/namedict.py</span>
<span class="gi">+++ b/dns/namedict.py</span>
<span class="gu">@@ -54,4 +54,12 @@ class NameDict(MutableMapping):</span>
<span class="w"> </span>        Returns a ``(key, value)`` where *key* is the deepest
<span class="w"> </span>        ``dns.name.Name``, and *value* is the value associated with *key*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(name, dns.name.Name):</span>
<span class="gi">+            raise ValueError(&#39;Name must be a dns.name.Name object&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        for i in range(len(name), -1, -1):</span>
<span class="gi">+            candidate = name[:i]</span>
<span class="gi">+            if candidate in self.__store:</span>
<span class="gi">+                return (candidate, self.__store[candidate])</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gh">diff --git a/dns/nameserver.py b/dns/nameserver.py</span>
<span class="gh">index 3c1878b..4cf5eb5 100644</span>
<span class="gd">--- a/dns/nameserver.py</span>
<span class="gi">+++ b/dns/nameserver.py</span>
<span class="gu">@@ -10,10 +10,10 @@ import dns.query</span>
<span class="w"> </span>class Nameserver:

<span class="w"> </span>    def __init__(self):
<span class="gd">-        pass</span>
<span class="gi">+        self.type = &quot;Generic Nameserver&quot;</span>

<span class="w"> </span>    def __str__(self):
<span class="gd">-        raise NotImplementedError</span>
<span class="gi">+        return f&quot;&lt;{self.type}&gt;&quot;</span>


<span class="w"> </span>class AddressAndPortNameserver(Nameserver):
<span class="gu">@@ -32,6 +32,10 @@ class Do53Nameserver(AddressAndPortNameserver):</span>

<span class="w"> </span>    def __init__(self, address: str, port: int=53):
<span class="w"> </span>        super().__init__(address, port)
<span class="gi">+        self.type = &quot;DNS-over-UDP/TCP&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def kind(self):</span>
<span class="gi">+        return &quot;do53&quot;</span>


<span class="w"> </span>class DoHNameserver(Nameserver):
<span class="gu">@@ -55,6 +59,10 @@ class DoTNameserver(AddressAndPortNameserver):</span>
<span class="w"> </span>        super().__init__(address, port)
<span class="w"> </span>        self.hostname = hostname
<span class="w"> </span>        self.verify = verify
<span class="gi">+        self.type = &quot;DNS-over-TLS&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def kind(self):</span>
<span class="gi">+        return &quot;dot&quot;</span>


<span class="w"> </span>class DoQNameserver(AddressAndPortNameserver):
<span class="gu">@@ -64,3 +72,7 @@ class DoQNameserver(AddressAndPortNameserver):</span>
<span class="w"> </span>        super().__init__(address, port)
<span class="w"> </span>        self.verify = verify
<span class="w"> </span>        self.server_hostname = server_hostname
<span class="gi">+        self.type = &quot;DNS-over-QUIC&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def kind(self):</span>
<span class="gi">+        return &quot;doq&quot;</span>
<span class="gh">diff --git a/dns/node.py b/dns/node.py</span>
<span class="gh">index 802f226..89e7f0d 100644</span>
<span class="gd">--- a/dns/node.py</span>
<span class="gi">+++ b/dns/node.py</span>
<span class="gu">@@ -53,7 +53,10 @@ class Node:</span>
<span class="w"> </span>        Returns a ``str``.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        for rdataset in self.rdatasets:</span>
<span class="gi">+            lines.append(rdataset.to_text(name, **kw))</span>
<span class="gi">+        return &#39;\n&#39;.join(lines)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;&lt;DNS node &#39; + str(id(self)) + &#39;&gt;&#39;
<span class="gu">@@ -85,7 +88,17 @@ class Node:</span>
<span class="w"> </span>        RRSIGs are deleted.  If the rdataset being appended has
<span class="w"> </span>        ``NodeKind.REGULAR`` then CNAME and RRSIG(CNAME) are deleted.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if rdataset.rdtype in _cname_types:</span>
<span class="gi">+            # Remove all rdatasets except KEY, NSEC, NSEC3, and their RRSIGs</span>
<span class="gi">+            self.rdatasets = [rds for rds in self.rdatasets if rds.rdtype in _neutral_types or</span>
<span class="gi">+                              (rds.rdtype == dns.rdatatype.RRSIG and</span>
<span class="gi">+                               rds.covers in _neutral_types)]</span>
<span class="gi">+        elif rdataset.rdtype not in _neutral_types:</span>
<span class="gi">+            # Remove CNAME and RRSIG(CNAME)</span>
<span class="gi">+            self.rdatasets = [rds for rds in self.rdatasets if rds.rdtype not in _cname_types and</span>
<span class="gi">+                              not (rds.rdtype == dns.rdatatype.RRSIG and</span>
<span class="gi">+                                   rds.covers in _cname_types)]</span>
<span class="gi">+        self.rdatasets.append(rdataset)</span>

<span class="w"> </span>    def find_rdataset(self, rdclass: dns.rdataclass.RdataClass, rdtype: dns
<span class="w"> </span>        .rdatatype.RdataType, covers: dns.rdatatype.RdataType=dns.rdatatype
<span class="gu">@@ -114,7 +127,15 @@ class Node:</span>

<span class="w"> </span>        Returns a ``dns.rdataset.Rdataset``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rds in self.rdatasets:</span>
<span class="gi">+            if rds.rdclass == rdclass and rds.rdtype == rdtype and rds.covers == covers:</span>
<span class="gi">+                return rds</span>
<span class="gi">+        if create:</span>
<span class="gi">+            rds = dns.rdataset.Rdataset(rdclass, rdtype)</span>
<span class="gi">+            rds.covers = covers</span>
<span class="gi">+            self._append_rdataset(rds)</span>
<span class="gi">+            return rds</span>
<span class="gi">+        raise KeyError</span>

<span class="w"> </span>    def get_rdataset(self, rdclass: dns.rdataclass.RdataClass, rdtype: dns.
<span class="w"> </span>        rdatatype.RdataType, covers: dns.rdatatype.RdataType=dns.rdatatype.
<span class="gu">@@ -142,7 +163,10 @@ class Node:</span>

<span class="w"> </span>        Returns a ``dns.rdataset.Rdataset`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.find_rdataset(rdclass, rdtype, covers, create)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def delete_rdataset(self, rdclass: dns.rdataclass.RdataClass, rdtype:
<span class="w"> </span>        dns.rdatatype.RdataType, covers: dns.rdatatype.RdataType=dns.
<span class="gu">@@ -158,7 +182,8 @@ class Node:</span>

<span class="w"> </span>        *covers*, an ``int``, the covered type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.rdatasets = [rds for rds in self.rdatasets if not (</span>
<span class="gi">+            rds.rdclass == rdclass and rds.rdtype == rdtype and rds.covers == covers)]</span>

<span class="w"> </span>    def replace_rdataset(self, replacement: dns.rdataset.Rdataset) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Replace an rdataset.
<span class="gu">@@ -174,7 +199,11 @@ class Node:</span>
<span class="w"> </span>        Raises ``ValueError`` if *replacement* is not a
<span class="w"> </span>        ``dns.rdataset.Rdataset``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(replacement, dns.rdataset.Rdataset):</span>
<span class="gi">+            raise ValueError(&quot;replacement must be a dns.rdataset.Rdataset&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        self.delete_rdataset(replacement.rdclass, replacement.rdtype, replacement.covers)</span>
<span class="gi">+        self._append_rdataset(replacement)</span>

<span class="w"> </span>    def classify(self) -&gt;NodeKind:
<span class="w"> </span>        &quot;&quot;&quot;Classify a node.
<span class="gu">@@ -191,7 +220,22 @@ class Node:</span>
<span class="w"> </span>        or a neutral type is a a ``NodeKind.REGULAR`` node.  Regular nodes are
<span class="w"> </span>        also commonly referred to as &quot;other data&quot;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        has_cname = False</span>
<span class="gi">+        has_regular = False</span>
<span class="gi">+        </span>
<span class="gi">+        for rdataset in self.rdatasets:</span>
<span class="gi">+            if rdataset.rdtype in _cname_types:</span>
<span class="gi">+                has_cname = True</span>
<span class="gi">+            elif rdataset.rdtype not in _neutral_types:</span>
<span class="gi">+                if rdataset.rdtype != dns.rdatatype.RRSIG or rdataset.covers not in _neutral_types:</span>
<span class="gi">+                    has_regular = True</span>
<span class="gi">+        </span>
<span class="gi">+        if has_cname:</span>
<span class="gi">+            return NodeKind.CNAME</span>
<span class="gi">+        elif has_regular:</span>
<span class="gi">+            return NodeKind.REGULAR</span>
<span class="gi">+        else:</span>
<span class="gi">+            return NodeKind.NEUTRAL</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="gh">diff --git a/dns/opcode.py b/dns/opcode.py</span>
<span class="gh">index dfea1ae..6027ada 100644</span>
<span class="gd">--- a/dns/opcode.py</span>
<span class="gi">+++ b/dns/opcode.py</span>
<span class="gu">@@ -24,7 +24,10 @@ def from_text(text: str) -&gt;Opcode:</span>

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return Opcode[text.upper()]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        raise UnknownOpcode(f&quot;Unknown opcode: {text}&quot;)</span>


<span class="w"> </span>def from_flags(flags: int) -&gt;Opcode:
<span class="gu">@@ -34,7 +37,7 @@ def from_flags(flags: int) -&gt;Opcode:</span>

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Opcode((flags &gt;&gt; 11) &amp; 0xF)</span>


<span class="w"> </span>def to_flags(value: Opcode) -&gt;int:
<span class="gu">@@ -45,7 +48,7 @@ def to_flags(value: Opcode) -&gt;int:</span>

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return int(value) &lt;&lt; 11</span>


<span class="w"> </span>def to_text(value: Opcode) -&gt;str:
<span class="gu">@@ -57,7 +60,10 @@ def to_text(value: Opcode) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return Opcode(value).name</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise UnknownOpcode(f&quot;Unknown opcode: {value}&quot;)</span>


<span class="w"> </span>def is_update(flags: int) -&gt;bool:
<span class="gu">@@ -67,7 +73,7 @@ def is_update(flags: int) -&gt;bool:</span>

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return from_flags(flags) == Opcode.UPDATE</span>


<span class="w"> </span>QUERY = Opcode.QUERY
<span class="gh">diff --git a/dns/query.py b/dns/query.py</span>
<span class="gh">index 2ec4b4f..f0ab424 100644</span>
<span class="gd">--- a/dns/query.py</span>
<span class="gi">+++ b/dns/query.py</span>
<span class="gu">@@ -165,7 +165,48 @@ def https(q: dns.message.Message, where: str, timeout: Optional[float]=None,</span>

<span class="w"> </span>    Returns a ``dns.message.Message``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not _have_httpx:</span>
<span class="gi">+        raise NoDOH(&#39;DNS over HTTPS (DOH) requires httpx&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if not session:</span>
<span class="gi">+        session = httpx.Client(verify=verify)</span>
<span class="gi">+</span>
<span class="gi">+    wire = q.to_wire()</span>
<span class="gi">+    try:</span>
<span class="gi">+        if dns.inet.is_address(where):</span>
<span class="gi">+            url = f&#39;https://{where}:{port}{path}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            url = where</span>
<span class="gi">+</span>
<span class="gi">+        headers = {</span>
<span class="gi">+            &#39;accept&#39;: &#39;application/dns-message&#39;,</span>
<span class="gi">+            &#39;content-type&#39;: &#39;application/dns-message&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        if post:</span>
<span class="gi">+            response = session.post(url, content=wire, headers=headers, timeout=timeout)</span>
<span class="gi">+        else:</span>
<span class="gi">+            params = {&#39;dns&#39;: base64.urlsafe_b64encode(wire).rstrip(b&#39;=&#39;).decode()}</span>
<span class="gi">+            response = session.get(url, params=params, headers=headers, timeout=timeout)</span>
<span class="gi">+</span>
<span class="gi">+        response.raise_for_status()</span>
<span class="gi">+        r = dns.message.from_wire(response.content,</span>
<span class="gi">+                                  keyring=q.keyring,</span>
<span class="gi">+                                  request_mac=q.mac,</span>
<span class="gi">+                                  one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+                                  ignore_trailing=ignore_trailing)</span>
<span class="gi">+        r.time = response.elapsed.total_seconds()</span>
<span class="gi">+        if not q.is_response(r):</span>
<span class="gi">+            raise BadResponse</span>
<span class="gi">+        return r</span>
<span class="gi">+    except httpx.HTTPStatusError as e:</span>
<span class="gi">+        if e.response.status_code == 413:</span>
<span class="gi">+            raise dns.exception.TooBig</span>
<span class="gi">+        elif e.response.status_code == 415:</span>
<span class="gi">+            raise dns.exception.UnsupportedMediaType</span>
<span class="gi">+        raise</span>
<span class="gi">+    except httpx.HTTPError as e:</span>
<span class="gi">+        raise dns.exception.Timeout(timeout=timeout) from e</span>


<span class="w"> </span>def _udp_recv(sock, max_size, expiration):
<span class="gu">@@ -173,7 +214,13 @@ def _udp_recv(sock, max_size, expiration):</span>
<span class="w"> </span>    A Timeout exception will be raised if the operation is not completed
<span class="w"> </span>    by the expiration time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return sock.recvfrom(max_size)</span>
<span class="gi">+        except BlockingIOError:</span>
<span class="gi">+            if expiration and time.time() &gt;= expiration:</span>
<span class="gi">+                raise dns.exception.Timeout</span>
<span class="gi">+        time.sleep(0.01)</span>


<span class="w"> </span>def _udp_send(sock, data, destination, expiration):
<span class="gu">@@ -181,7 +228,13 @@ def _udp_send(sock, data, destination, expiration):</span>
<span class="w"> </span>    A Timeout exception will be raised if the operation is not completed
<span class="w"> </span>    by the expiration time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return sock.sendto(data, destination)</span>
<span class="gi">+        except BlockingIOError:</span>
<span class="gi">+            if expiration and time.time() &gt;= expiration:</span>
<span class="gi">+                raise dns.exception.Timeout</span>
<span class="gi">+        time.sleep(0.01)</span>


<span class="w"> </span>def send_udp(sock: Any, what: Union[dns.message.Message, bytes],
<span class="gu">@@ -201,7 +254,11 @@ def send_udp(sock: Any, what: Union[dns.message.Message, bytes],</span>

<span class="w"> </span>    Returns an ``(int, float)`` tuple of bytes sent and the sent time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(what, dns.message.Message):</span>
<span class="gi">+        what = what.to_wire()</span>
<span class="gi">+    sent_time = time.time()</span>
<span class="gi">+    n = _udp_send(sock, what, destination, expiration)</span>
<span class="gi">+    return (n, sent_time)</span>


<span class="w"> </span>def receive_udp(sock: Any, destination: Optional[Any]=None, expiration:
<span class="gu">@@ -258,7 +315,43 @@ def receive_udp(sock: Any, destination: Optional[Any]=None, expiration:</span>
<span class="w"> </span>    *ignore_errors* is ``True``, check that the received message is a response
<span class="w"> </span>    to this query, and if not keep listening for a valid response.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            (wire, from_address) = _udp_recv(sock, 65535, expiration)</span>
<span class="gi">+        except dns.exception.Timeout:</span>
<span class="gi">+            raise</span>
<span class="gi">+        received_time = time.time()</span>
<span class="gi">+        if expiration and received_time &gt; expiration:</span>
<span class="gi">+            raise dns.exception.Timeout</span>
<span class="gi">+        if destination:</span>
<span class="gi">+            if not ignore_unexpected and from_address != destination:</span>
<span class="gi">+                if not ignore_errors:</span>
<span class="gi">+                    raise UnexpectedSource(f&#39;got a response from {from_address} instead of {destination}&#39;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            r = dns.message.from_wire(wire, keyring=keyring, request_mac=request_mac,</span>
<span class="gi">+                                      one_rr_per_rrset=one_rr_per_rrset,</span>
<span class="gi">+                                      ignore_trailing=ignore_trailing)</span>
<span class="gi">+        except dns.message.ShortHeader:</span>
<span class="gi">+            if not ignore_errors:</span>
<span class="gi">+                raise</span>
<span class="gi">+            continue</span>
<span class="gi">+        except dns.exception.FormError:</span>
<span class="gi">+            if not ignore_errors:</span>
<span class="gi">+                raise</span>
<span class="gi">+            continue</span>
<span class="gi">+        if query:</span>
<span class="gi">+            if not query.is_response(r):</span>
<span class="gi">+                if not ignore_errors:</span>
<span class="gi">+                    raise BadResponse</span>
<span class="gi">+                continue</span>
<span class="gi">+        if r.flags &amp; dns.flags.TC and raise_on_truncation:</span>
<span class="gi">+            raise dns.message.Truncated</span>
<span class="gi">+        if destination:</span>
<span class="gi">+            return (r, received_time)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (r, received_time, from_address)</span>


<span class="w"> </span>def udp(q: dns.message.Message, where: str, timeout: Optional[float]=None,
<span class="gh">diff --git a/dns/quic/_common.py b/dns/quic/_common.py</span>
<span class="gh">index d37beb9..9cf8091 100644</span>
<span class="gd">--- a/dns/quic/_common.py</span>
<span class="gi">+++ b/dns/quic/_common.py</span>
<span class="gu">@@ -22,6 +22,25 @@ class Buffer:</span>
<span class="w"> </span>        self._buffer = b&#39;&#39;
<span class="w"> </span>        self._seen_end = False

<span class="gi">+    def add(self, data):</span>
<span class="gi">+        self._buffer += data</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, size):</span>
<span class="gi">+        if len(self._buffer) &lt; size:</span>
<span class="gi">+            raise UnexpectedEOF</span>
<span class="gi">+        data = self._buffer[:size]</span>
<span class="gi">+        self._buffer = self._buffer[size:]</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def remaining(self):</span>
<span class="gi">+        return len(self._buffer)</span>
<span class="gi">+</span>
<span class="gi">+    def set_end(self):</span>
<span class="gi">+        self._seen_end = True</span>
<span class="gi">+</span>
<span class="gi">+    def at_end(self):</span>
<span class="gi">+        return self._seen_end and len(self._buffer) == 0</span>
<span class="gi">+</span>

<span class="w"> </span>class BaseQuicStream:

<span class="gu">@@ -31,6 +50,26 @@ class BaseQuicStream:</span>
<span class="w"> </span>        self._buffer = Buffer()
<span class="w"> </span>        self._expecting = 0

<span class="gi">+    def add(self, data, end):</span>
<span class="gi">+        self._buffer.add(data)</span>
<span class="gi">+        if end:</span>
<span class="gi">+            self._buffer.set_end()</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, size):</span>
<span class="gi">+        return self._buffer.get(size)</span>
<span class="gi">+</span>
<span class="gi">+    def remaining(self):</span>
<span class="gi">+        return self._buffer.remaining()</span>
<span class="gi">+</span>
<span class="gi">+    def at_end(self):</span>
<span class="gi">+        return self._buffer.at_end()</span>
<span class="gi">+</span>
<span class="gi">+    def expect(self, size):</span>
<span class="gi">+        self._expecting = size</span>
<span class="gi">+</span>
<span class="gi">+    def expecting(self):</span>
<span class="gi">+        return self._expecting</span>
<span class="gi">+</span>

<span class="w"> </span>class BaseQuicConnection:

<span class="gu">@@ -57,6 +96,30 @@ class BaseQuicConnection:</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self._source = None

<span class="gi">+    def close(self):</span>
<span class="gi">+        if not self._closed:</span>
<span class="gi">+            self._connection.close()</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+            if self._manager:</span>
<span class="gi">+                self._manager._remove_connection(self)</span>
<span class="gi">+</span>
<span class="gi">+    def is_closed(self):</span>
<span class="gi">+        return self._closed</span>
<span class="gi">+</span>
<span class="gi">+    def get_stream(self, stream_id):</span>
<span class="gi">+        if stream_id not in self._streams:</span>
<span class="gi">+            self._streams[stream_id] = self._connection_factory(self, stream_id)</span>
<span class="gi">+        return self._streams[stream_id]</span>
<span class="gi">+</span>
<span class="gi">+    def remove_stream(self, stream_id):</span>
<span class="gi">+        if stream_id in self._streams:</span>
<span class="gi">+            del self._streams[stream_id]</span>
<span class="gi">+</span>
<span class="gi">+    def handle_event(self, event):</span>
<span class="gi">+        if isinstance(event, aioquic.quic.events.StreamDataReceived):</span>
<span class="gi">+            stream = self.get_stream(event.stream_id)</span>
<span class="gi">+            stream.add(event.data, event.end_stream)</span>
<span class="gi">+</span>

<span class="w"> </span>class AsyncQuicConnection(BaseQuicConnection):
<span class="w"> </span>    pass
<span class="gu">@@ -81,6 +144,38 @@ class BaseQuicManager:</span>
<span class="w"> </span>                conf.load_verify_locations(verify_path)
<span class="w"> </span>        self._conf = conf

<span class="gi">+    def _remove_connection(self, connection):</span>
<span class="gi">+        key = (connection._address, connection._port)</span>
<span class="gi">+        if key in self._connections:</span>
<span class="gi">+            del self._connections[key]</span>
<span class="gi">+</span>
<span class="gi">+    def _add_connection(self, connection):</span>
<span class="gi">+        key = (connection._address, connection._port)</span>
<span class="gi">+        self._connections[key] = connection</span>
<span class="gi">+</span>
<span class="gi">+    def get_connection(self, address, port):</span>
<span class="gi">+        key = (address, port)</span>
<span class="gi">+        return self._connections.get(key)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self):</span>
<span class="gi">+        for connection in list(self._connections.values()):</span>
<span class="gi">+            connection.close()</span>
<span class="gi">+        self._connections.clear()</span>
<span class="gi">+</span>
<span class="gi">+    def save_session_ticket(self, ticket):</span>
<span class="gi">+        if len(self._session_tickets) &gt;= MAX_SESSION_TICKETS:</span>
<span class="gi">+            tickets_to_remove = sorted(self._session_tickets.items(), key=lambda x: x[1][1])[:SESSIONS_TO_DELETE]</span>
<span class="gi">+            for key, _ in tickets_to_remove:</span>
<span class="gi">+                del self._session_tickets[key]</span>
<span class="gi">+        self._session_tickets[ticket.ticket] = (ticket, time.time())</span>
<span class="gi">+</span>
<span class="gi">+    def get_session_ticket(self, server_name):</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+        valid_tickets = [(t, ts) for t, (ticket, ts) in self._session_tickets.items() if now - ts &lt; ticket.max_age]</span>
<span class="gi">+        if valid_tickets:</span>
<span class="gi">+            return max(valid_tickets, key=lambda x: x[1])[0]</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class AsyncQuicManager(BaseQuicManager):
<span class="w"> </span>    pass
<span class="gh">diff --git a/dns/rcode.py b/dns/rcode.py</span>
<span class="gh">index 820a695..5e7d590 100644</span>
<span class="gd">--- a/dns/rcode.py</span>
<span class="gi">+++ b/dns/rcode.py</span>
<span class="gu">@@ -41,7 +41,14 @@ def from_text(text: str) -&gt;Rcode:</span>

<span class="w"> </span>    Returns a ``dns.rcode.Rcode``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return Rcode[text.upper()]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = int(text)</span>
<span class="gi">+            return Rcode(value)</span>
<span class="gi">+        except (ValueError, KeyError):</span>
<span class="gi">+            raise UnknownRcode(f&quot;Unknown rcode mnemonic: {text}&quot;)</span>


<span class="w"> </span>def from_flags(flags: int, ednsflags: int) -&gt;Rcode:
<span class="gu">@@ -55,7 +62,10 @@ def from_flags(flags: int, ednsflags: int) -&gt;Rcode:</span>

<span class="w"> </span>    Returns a ``dns.rcode.Rcode``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rcode = (flags &amp; 0x000f) | ((ednsflags &amp; 0xff0000) &gt;&gt; 4)</span>
<span class="gi">+    if rcode &lt; 0 or rcode &gt; 4095:</span>
<span class="gi">+        raise ValueError(f&quot;rcode {rcode} is out of range&quot;)</span>
<span class="gi">+    return Rcode(rcode)</span>


<span class="w"> </span>def to_flags(value: Rcode) -&gt;Tuple[int, int]:
<span class="gu">@@ -67,7 +77,11 @@ def to_flags(value: Rcode) -&gt;Tuple[int, int]:</span>

<span class="w"> </span>    Returns an ``(int, int)`` tuple.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value &lt; 0 or value &gt; 4095:</span>
<span class="gi">+        raise ValueError(f&quot;rcode {value} is out of range&quot;)</span>
<span class="gi">+    flags = value &amp; 0x000f</span>
<span class="gi">+    ednsflags = (value &amp; 0xff0) &lt;&lt; 4</span>
<span class="gi">+    return (flags, ednsflags)</span>


<span class="w"> </span>def to_text(value: Rcode, tsig: bool=False) -&gt;str:
<span class="gu">@@ -79,7 +93,12 @@ def to_text(value: Rcode, tsig: bool=False) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value &lt; 0 or value &gt; 4095:</span>
<span class="gi">+        raise ValueError(f&quot;rcode {value} is out of range&quot;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        return Rcode(value).name</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return str(value)</span>


<span class="w"> </span>NOERROR = Rcode.NOERROR
<span class="gh">diff --git a/dns/rdata.py b/dns/rdata.py</span>
<span class="gh">index 11cbf5e..123a335 100644</span>
<span class="gd">--- a/dns/rdata.py</span>
<span class="gi">+++ b/dns/rdata.py</span>
<span class="gu">@@ -33,21 +33,23 @@ def _wordbreak(data, chunksize=_chunksize, separator=b&#39; &#39;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Break a binary string into chunks of chunksize characters separated by
<span class="w"> </span>    a space.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return separator.join(data[i:i+chunksize] for i in range(0, len(data), chunksize))</span>


<span class="w"> </span>def _hexify(data, chunksize=_chunksize, separator=b&#39; &#39;, **kw):
<span class="w"> </span>    &quot;&quot;&quot;Convert a binary string into its hex encoding, broken up into chunks
<span class="w"> </span>    of chunksize characters separated by a separator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hex_data = binascii.hexlify(data)</span>
<span class="gi">+    return _wordbreak(hex_data, chunksize, separator)</span>


<span class="w"> </span>def _base64ify(data, chunksize=_chunksize, separator=b&#39; &#39;, **kw):
<span class="w"> </span>    &quot;&quot;&quot;Convert a binary string into its base64 encoding, broken up into chunks
<span class="w"> </span>    of chunksize characters separated by a separator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    b64_data = base64.b64encode(data)</span>
<span class="gi">+    return _wordbreak(b64_data, chunksize, separator)</span>


<span class="w"> </span>__escaped = b&#39;&quot;\\&#39;
<span class="gu">@@ -55,14 +57,17 @@ __escaped = b&#39;&quot;\\&#39;</span>

<span class="w"> </span>def _escapify(qstring):
<span class="w"> </span>    &quot;&quot;&quot;Escape the characters in a quoted string which need it.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return b&#39;&#39;.join(b&#39;\\&#39; + ch if ch in __escaped else ch for ch in qstring)</span>


<span class="w"> </span>def _truncate_bitmap(what):
<span class="w"> </span>    &quot;&quot;&quot;Determine the index of greatest byte that isn&#39;t all zeros, and
<span class="w"> </span>    return the bitmap that contains all the bytes less than that index.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for i in range(len(what) - 1, -1, -1):</span>
<span class="gi">+        if what[i] != 0:</span>
<span class="gi">+            return what[:i+1]</span>
<span class="gi">+    return b&#39;&#39;</span>


<span class="w"> </span>_constify = dns.immutable.constify
<span class="gu">@@ -107,7 +112,7 @@ class Rdata:</span>

<span class="w"> </span>        Returns a ``dns.rdatatype.RdataType``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return dns.rdatatype.NONE</span>

<span class="w"> </span>    def extended_rdatatype(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Return a 32-bit type value, the least significant 16 bits of
<span class="gu">@@ -116,7 +121,7 @@ class Rdata:</span>

<span class="w"> </span>        Returns an ``int``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.covers() &lt;&lt; 16 | self.rdtype</span>

<span class="w"> </span>    def to_text(self, origin: Optional[dns.name.Name]=None, relativize:
<span class="w"> </span>        bool=True, **kw: Dict[str, Any]) -&gt;str:
<span class="gu">@@ -141,7 +146,7 @@ class Rdata:</span>

<span class="w"> </span>        Returns a ``dns.rdata.GenericRdata``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return dns.rdata.GenericRdata(self.rdclass, self.rdtype, self.to_wire(origin=origin))</span>

<span class="w"> </span>    def to_digestable(self, origin: Optional[dns.name.Name]=None) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Convert rdata to a format suitable for digesting in hashes.  This
<span class="gu">@@ -180,7 +185,23 @@ class Rdata:</span>
<span class="w"> </span>            In the future, all ordering comparisons for rdata with
<span class="w"> </span>            relative names will be disallowed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        our_relative = False</span>
<span class="gi">+        their_relative = False</span>
<span class="gi">+        try:</span>
<span class="gi">+            our = self.to_digestable()</span>
<span class="gi">+        except dns.name.NeedAbsoluteNameOrOrigin:</span>
<span class="gi">+            our = self.to_digestable(dns.name.root)</span>
<span class="gi">+            our_relative = True</span>
<span class="gi">+        try:</span>
<span class="gi">+            their = other.to_digestable()</span>
<span class="gi">+        except dns.name.NeedAbsoluteNameOrOrigin:</span>
<span class="gi">+            their = other.to_digestable(dns.name.root)</span>
<span class="gi">+            their_relative = True</span>
<span class="gi">+        if our_relative and not their_relative:</span>
<span class="gi">+            return -1</span>
<span class="gi">+        elif their_relative and not our_relative:</span>
<span class="gi">+            return 1</span>
<span class="gi">+        return (our &gt; their) - (our &lt; their)</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, Rdata):
<span class="gu">@@ -248,7 +269,9 @@ class Rdata:</span>

<span class="w"> </span>        Returns an instance of the same Rdata subclass as *self*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_kwargs = {slot: getattr(self, slot) for slot in self.__slots__ if slot not in [&#39;rdclass&#39;, &#39;rdtype&#39;]}</span>
<span class="gi">+        new_kwargs.update(kwargs)</span>
<span class="gi">+        return type(self)(**new_kwargs)</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="gu">@@ -311,7 +334,17 @@ def from_text(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype: Union</span>
<span class="w"> </span>    Returns an instance of the chosen Rdata subclass.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rdclass = dns.rdataclass.RdataClass.make(rdclass)</span>
<span class="gi">+    rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(tok, str):</span>
<span class="gi">+        tok = dns.tokenizer.Tokenizer(tok, idna_codec=idna_codec)</span>
<span class="gi">+</span>
<span class="gi">+    cls = _get_rdata_class(rdclass, rdtype)</span>
<span class="gi">+    if cls:</span>
<span class="gi">+        return cls.from_text(rdclass, rdtype, tok, origin, relativize, relativize_to)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return GenericRdata.from_text(rdclass, rdtype, tok, origin, relativize, relativize_to)</span>


<span class="w"> </span>def from_wire_parser(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype:
<span class="gu">@@ -339,7 +372,14 @@ def from_wire_parser(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype:</span>

<span class="w"> </span>    Returns an instance of the chosen Rdata subclass.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rdclass = dns.rdataclass.RdataClass.make(rdclass)</span>
<span class="gi">+    rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+</span>
<span class="gi">+    cls = _get_rdata_class(rdclass, rdtype)</span>
<span class="gi">+    if cls:</span>
<span class="gi">+        return cls.from_wire_parser(rdclass, rdtype, parser, origin)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return GenericRdata.from_wire_parser(rdclass, rdtype, parser, origin)</span>


<span class="w"> </span>def from_wire(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype: Union
<span class="gu">@@ -371,7 +411,12 @@ def from_wire(rdclass: Union[dns.rdataclass.RdataClass, str], rdtype: Union</span>

<span class="w"> </span>    Returns an instance of the chosen Rdata subclass.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rdclass = dns.rdataclass.RdataClass.make(rdclass)</span>
<span class="gi">+    rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+</span>
<span class="gi">+    parser = dns.wire.Parser(wire, current)</span>
<span class="gi">+    with parser.restrict_to(rdlen):</span>
<span class="gi">+        return from_wire_parser(rdclass, rdtype, parser, origin)</span>


<span class="w"> </span>class RdatatypeExists(dns.exception.DNSException):
<span class="gu">@@ -399,4 +444,16 @@ def register_type(implementation: Any, rdtype: int, rdtype_text: str,</span>
<span class="w"> </span>    *rdclass*, the rdataclass of the type, or ``dns.rdataclass.ANY`` if
<span class="w"> </span>    it applies to all classes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rdclass = dns.rdataclass.RdataClass.make(rdclass)</span>
<span class="gi">+    rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+    </span>
<span class="gi">+    if (rdclass, rdtype) in _rdata_classes:</span>
<span class="gi">+        raise RdatatypeExists(rdclass=rdclass, rdtype=rdtype)</span>
<span class="gi">+    </span>
<span class="gi">+    _rdata_classes[(rdclass, rdtype)] = implementation</span>
<span class="gi">+    </span>
<span class="gi">+    if rdclass == dns.rdataclass.ANY:</span>
<span class="gi">+        for c in dns.rdataclass.RdataClass:</span>
<span class="gi">+            dns.rdatatype.register_type(rdtype, rdtype_text, c, is_singleton)</span>
<span class="gi">+    else:</span>
<span class="gi">+        dns.rdatatype.register_type(rdtype, rdtype_text, rdclass, is_singleton)</span>
<span class="gh">diff --git a/dns/rdataclass.py b/dns/rdataclass.py</span>
<span class="gh">index 2db3e64..6c99cae 100644</span>
<span class="gd">--- a/dns/rdataclass.py</span>
<span class="gi">+++ b/dns/rdataclass.py</span>
<span class="gu">@@ -37,7 +37,20 @@ def from_text(text: str) -&gt;RdataClass:</span>

<span class="w"> </span>    Returns a ``dns.rdataclass.RdataClass``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    text = text.upper()</span>
<span class="gi">+    try:</span>
<span class="gi">+        return RdataClass[text]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        if text.startswith(&#39;CLASS&#39;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = int(text[5:])</span>
<span class="gi">+                if 0 &lt;= value &lt;= 65535:</span>
<span class="gi">+                    return RdataClass(value)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise ValueError(&quot;DNS rdata class must be between 0 and 65535&quot;)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                pass</span>
<span class="gi">+    raise UnknownRdataclass(f&quot;Unknown DNS class: {text}&quot;)</span>


<span class="w"> </span>def to_text(value: RdataClass) -&gt;str:
<span class="gu">@@ -50,7 +63,13 @@ def to_text(value: RdataClass) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not 0 &lt;= value &lt;= 65535:</span>
<span class="gi">+        raise ValueError(&quot;DNS rdata class must be between 0 and 65535&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    try:</span>
<span class="gi">+        return RdataClass(value).name</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return f&#39;CLASS{value}&#39;</span>


<span class="w"> </span>def is_metaclass(rdclass: RdataClass) -&gt;bool:
<span class="gu">@@ -60,7 +79,7 @@ def is_metaclass(rdclass: RdataClass) -&gt;bool:</span>

<span class="w"> </span>    *rdclass* is a ``dns.rdataclass.RdataClass``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return rdclass in _metaclasses</span>


<span class="w"> </span>RESERVED0 = RdataClass.RESERVED0
<span class="gh">diff --git a/dns/rdataset.py b/dns/rdataset.py</span>
<span class="gh">index 7228b61..87a37d6 100644</span>
<span class="gd">--- a/dns/rdataset.py</span>
<span class="gi">+++ b/dns/rdataset.py</span>
<span class="gu">@@ -56,7 +56,12 @@ class Rdataset(dns.set.Set):</span>

<span class="w"> </span>        *ttl*, an ``int`` or ``str``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(ttl, str):</span>
<span class="gi">+            ttl = dns.ttl.from_text(ttl)</span>
<span class="gi">+        if len(self) == 0:</span>
<span class="gi">+            self.ttl = ttl</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.ttl = min(self.ttl, ttl)</span>

<span class="w"> </span>    def add(self, rd: dns.rdata.Rdata, ttl: Optional[int]=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add the specified rdata to the rdataset.
<span class="gu">@@ -74,7 +79,20 @@ class Rdataset(dns.set.Set):</span>
<span class="w"> </span>        Raises ``dns.rdataset.DifferingCovers`` if the type is a signature
<span class="w"> </span>        type and the covered type does not match that of the rdataset.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if ttl is not None:</span>
<span class="gi">+            self.update_ttl(ttl)</span>
<span class="gi">+</span>
<span class="gi">+        if self.rdclass != rd.rdclass or self.rdtype != rd.rdtype:</span>
<span class="gi">+            raise IncompatibleTypes</span>
<span class="gi">+</span>
<span class="gi">+        if dns.rdatatype.is_singleton(self.rdtype) and len(self) &gt; 0:</span>
<span class="gi">+            self.clear()</span>
<span class="gi">+</span>
<span class="gi">+        if self.rdtype == dns.rdatatype.RRSIG:</span>
<span class="gi">+            if rd.covers != self.covers:</span>
<span class="gi">+                raise DifferingCovers</span>
<span class="gi">+</span>
<span class="gi">+        super().add(rd)</span>

<span class="w"> </span>    def update(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Add all rdatas in other to self.
<span class="gu">@@ -82,7 +100,15 @@ class Rdataset(dns.set.Set):</span>
<span class="w"> </span>        *other*, a ``dns.rdataset.Rdataset``, the rdataset from which
<span class="w"> </span>        to update.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.rdclass != other.rdclass or self.rdtype != other.rdtype:</span>
<span class="gi">+            raise IncompatibleTypes</span>
<span class="gi">+</span>
<span class="gi">+        if other.covers != self.covers:</span>
<span class="gi">+            raise DifferingCovers</span>
<span class="gi">+</span>
<span class="gi">+        self.update_ttl(other.ttl)</span>
<span class="gi">+        for rd in other:</span>
<span class="gi">+            self.add(rd)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        if self.covers == 0:
<span class="gu">@@ -135,7 +161,17 @@ class Rdataset(dns.set.Set):</span>
<span class="w"> </span>        *want_comments*, a ``bool``.  If ``True``, emit comments for rdata
<span class="w"> </span>        which have them.  The default is ``False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rdclass = self.rdclass if override_rdclass is None else override_rdclass</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for rd in self:</span>
<span class="gi">+            if name is not None:</span>
<span class="gi">+                result.append(f&quot;{name.choose_relativity(origin, relativize)} &quot;)</span>
<span class="gi">+            result.append(f&quot;{self.ttl} {dns.rdataclass.to_text(rdclass)} {dns.rdatatype.to_text(self.rdtype)} &quot;)</span>
<span class="gi">+            result.append(rd.to_text(origin=origin, relativize=relativize, **kw))</span>
<span class="gi">+            if want_comments and rd.rdcomment:</span>
<span class="gi">+                result.append(f&quot; ; {rd.rdcomment}&quot;)</span>
<span class="gi">+            result.append(&quot;\n&quot;)</span>
<span class="gi">+        return &quot;&quot;.join(result)</span>

<span class="w"> </span>    def to_wire(self, name: dns.name.Name, file: Any, compress: Optional[
<span class="w"> </span>        dns.name.CompressType]=None, origin: Optional[dns.name.Name]=None,
<span class="gu">@@ -164,14 +200,28 @@ class Rdataset(dns.set.Set):</span>

<span class="w"> </span>        Returns an ``int``, the number of records emitted.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rdclass = self.rdclass if override_rdclass is None else override_rdclass</span>
<span class="gi">+        rdatas = list(self)</span>
<span class="gi">+        if want_shuffle:</span>
<span class="gi">+            random.shuffle(rdatas)</span>
<span class="gi">+        </span>
<span class="gi">+        count = 0</span>
<span class="gi">+        for rd in rdatas:</span>
<span class="gi">+            name.to_wire(file, compress, origin)</span>
<span class="gi">+            file.write(struct.pack(&quot;!HHI&quot;, rdclass, self.rdtype, self.ttl))</span>
<span class="gi">+            rd.to_wire(file, compress, origin)</span>
<span class="gi">+            count += 1</span>
<span class="gi">+        </span>
<span class="gi">+        return count</span>

<span class="w"> </span>    def match(self, rdclass: dns.rdataclass.RdataClass, rdtype: dns.
<span class="w"> </span>        rdatatype.RdataType, covers: dns.rdatatype.RdataType) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if this rdataset matches the specified class,
<span class="w"> </span>        type, and covers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (self.rdclass == rdclass and</span>
<span class="gi">+                self.rdtype == rdtype and</span>
<span class="gi">+                self.covers == covers)</span>

<span class="w"> </span>    def processing_order(self) -&gt;List[dns.rdata.Rdata]:
<span class="w"> </span>        &quot;&quot;&quot;Return rdatas in a valid processing order according to the type&#39;s
<span class="gu">@@ -182,7 +232,23 @@ class Rdataset(dns.set.Set):</span>
<span class="w"> </span>        For types that do not define a processing order, the rdatas are
<span class="w"> </span>        simply shuffled.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rdatas = list(self)</span>
<span class="gi">+        if self.rdtype == dns.rdatatype.MX:</span>
<span class="gi">+            def key_func(rdata):</span>
<span class="gi">+                return rdata.preference</span>
<span class="gi">+            rdatas.sort(key=key_func)</span>
<span class="gi">+            </span>
<span class="gi">+            # Group and shuffle rdatas with the same preference</span>
<span class="gi">+            from itertools import groupby</span>
<span class="gi">+            shuffled = []</span>
<span class="gi">+            for _, group in groupby(rdatas, key=key_func):</span>
<span class="gi">+                group_list = list(group)</span>
<span class="gi">+                random.shuffle(group_list)</span>
<span class="gi">+                shuffled.extend(group_list)</span>
<span class="gi">+            return shuffled</span>
<span class="gi">+        else:</span>
<span class="gi">+            random.shuffle(rdatas)</span>
<span class="gi">+            return rdatas</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="gh">diff --git a/dns/rdatatype.py b/dns/rdatatype.py</span>
<span class="gh">index f375d83..025a2da 100644</span>
<span class="gd">--- a/dns/rdatatype.py</span>
<span class="gi">+++ b/dns/rdatatype.py</span>
<span class="gu">@@ -114,7 +114,21 @@ def from_text(text: str) -&gt;RdataType:</span>

<span class="w"> </span>    Returns a ``dns.rdatatype.RdataType``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    text = text.upper()</span>
<span class="gi">+    if text.startswith(&#39;TYPE&#39;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = int(text[4:])</span>
<span class="gi">+            if 0 &lt;= value &lt;= 65535:</span>
<span class="gi">+                return RdataType(value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&quot;Rdata type value must be between 0 and 65535&quot;)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise UnknownRdatatype(f&quot;Unknown rdatatype: {text}&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    try:</span>
<span class="gi">+        return RdataType[text]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        raise UnknownRdatatype(f&quot;Unknown rdatatype: {text}&quot;)</span>


<span class="w"> </span>def to_text(value: RdataType) -&gt;str:
<span class="gu">@@ -127,7 +141,16 @@ def to_text(value: RdataType) -&gt;str:</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(value, RdataType):</span>
<span class="gi">+        value = RdataType(value)</span>
<span class="gi">+    </span>
<span class="gi">+    if 0 &lt;= value &lt;= 65535:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _registered_by_value[value]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return f&#39;TYPE{value}&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Rdata type value must be between 0 and 65535&quot;)</span>


<span class="w"> </span>def is_metatype(rdtype: RdataType) -&gt;bool:
<span class="gu">@@ -140,7 +163,9 @@ def is_metatype(rdtype: RdataType) -&gt;bool:</span>

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return rdtype in {RdataType.TKEY, RdataType.TSIG, RdataType.IXFR, </span>
<span class="gi">+                      RdataType.AXFR, RdataType.MAILA, RdataType.MAILB, </span>
<span class="gi">+                      RdataType.ANY, RdataType.OPT}</span>


<span class="w"> </span>def is_singleton(rdtype: RdataType) -&gt;bool:
<span class="gu">@@ -156,7 +181,7 @@ def is_singleton(rdtype: RdataType) -&gt;bool:</span>

<span class="w"> </span>    Returns a ``bool``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return rdtype in _singletons</span>


<span class="w"> </span>def register_type(rdtype: RdataType, rdtype_text: str, is_singleton: bool=False
<span class="gu">@@ -170,7 +195,11 @@ def register_type(rdtype: RdataType, rdtype_text: str, is_singleton: bool=False</span>
<span class="w"> </span>    *is_singleton*, a ``bool``, indicating if the type is a singleton (i.e.
<span class="w"> </span>    RRsets of the type can have only one member.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rdtype_text = rdtype_text.upper()</span>
<span class="gi">+    _registered_by_text[rdtype_text] = rdtype</span>
<span class="gi">+    _registered_by_value[rdtype] = rdtype_text</span>
<span class="gi">+    if is_singleton:</span>
<span class="gi">+        _singletons.add(rdtype)</span>


<span class="w"> </span>TYPE0 = RdataType.TYPE0
<span class="gh">diff --git a/dns/rdtypes/ANY/AFSDB.py b/dns/rdtypes/ANY/AFSDB.py</span>
<span class="gh">index 085e3a6..11ba2c8 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/AFSDB.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/AFSDB.py</span>
<span class="gu">@@ -9,9 +9,9 @@ class AFSDB(dns.rdtypes.mxbase.UncompressedDowncasingMX):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def subtype(self):
<span class="w"> </span>        &quot;&quot;&quot;the AFSDB subtype&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.preference</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def hostname(self):
<span class="w"> </span>        &quot;&quot;&quot;the AFSDB hostname&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.exchange</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/GPOS.py b/dns/rdtypes/ANY/GPOS.py</span>
<span class="gh">index 1f28c06..e95f8dc 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/GPOS.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/GPOS.py</span>
<span class="gu">@@ -37,14 +37,14 @@ class GPOS(dns.rdata.Rdata):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def float_latitude(self):
<span class="w"> </span>        &quot;&quot;&quot;latitude as a floating point value&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return float(self.latitude.decode())</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def float_longitude(self):
<span class="w"> </span>        &quot;&quot;&quot;longitude as a floating point value&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return float(self.longitude.decode())</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def float_altitude(self):
<span class="w"> </span>        &quot;&quot;&quot;altitude as a floating point value&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return float(self.altitude.decode())</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/LOC.py b/dns/rdtypes/ANY/LOC.py</span>
<span class="gh">index 2be3324..68befe8 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/LOC.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/LOC.py</span>
<span class="gu">@@ -48,9 +48,39 @@ class LOC(dns.rdata.Rdata):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def float_latitude(self):
<span class="w"> </span>        &quot;&quot;&quot;latitude as a floating point value&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _tuple_to_float(self.latitude)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def float_longitude(self):
<span class="w"> </span>        &quot;&quot;&quot;longitude as a floating point value&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _tuple_to_float(self.longitude)</span>
<span class="gi">+</span>
<span class="gi">+def _tuple_to_float(tuple_coord):</span>
<span class="gi">+    &quot;&quot;&quot;Convert a coordinate tuple to a float value.&quot;&quot;&quot;</span>
<span class="gi">+    degrees, minutes, seconds, milliseconds = tuple_coord</span>
<span class="gi">+    return degrees + (minutes / 60.0) + (seconds / 3600.0) + (milliseconds / 3600000.0)</span>
<span class="gi">+</span>
<span class="gi">+def _float_to_tuple(float_coord):</span>
<span class="gi">+    &quot;&quot;&quot;Convert a float coordinate to a tuple.&quot;&quot;&quot;</span>
<span class="gi">+    degrees = int(float_coord)</span>
<span class="gi">+    minutes = int((float_coord - degrees) * 60)</span>
<span class="gi">+    seconds = int(((float_coord - degrees) * 60 - minutes) * 60)</span>
<span class="gi">+    milliseconds = int((((float_coord - degrees) * 60 - minutes) * 60 - seconds) * 1000)</span>
<span class="gi">+    return (degrees, minutes, seconds, milliseconds)</span>
<span class="gi">+</span>
<span class="gi">+def _check_coordinate_list(coordinate, low, high):</span>
<span class="gi">+    &quot;&quot;&quot;Check if the coordinate is within the specified range.&quot;&quot;&quot;</span>
<span class="gi">+    if len(coordinate) != 4:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&#39;LOC coordinate must be a 4-tuple&#39;)</span>
<span class="gi">+    for i in range(4):</span>
<span class="gi">+        if not isinstance(coordinate[i], int):</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;LOC coordinate must be integers&#39;)</span>
<span class="gi">+    degrees, minutes, seconds, milliseconds = coordinate</span>
<span class="gi">+    if degrees &lt; low or degrees &gt; high:</span>
<span class="gi">+        raise dns.exception.SyntaxError(f&#39;LOC degrees must be between {low} and {high}&#39;)</span>
<span class="gi">+    if minutes &lt; 0 or minutes &gt; 59:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&#39;LOC minutes must be between 0 and 59&#39;)</span>
<span class="gi">+    if seconds &lt; 0 or seconds &gt; 59:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&#39;LOC seconds must be between 0 and 59&#39;)</span>
<span class="gi">+    if milliseconds &lt; 0 or milliseconds &gt; 999:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&#39;LOC milliseconds must be between 0 and 999&#39;)</span>
<span class="gh">diff --git a/dns/rdtypes/ANY/OPT.py b/dns/rdtypes/ANY/OPT.py</span>
<span class="gh">index 096cbcb..02b59f6 100644</span>
<span class="gd">--- a/dns/rdtypes/ANY/OPT.py</span>
<span class="gi">+++ b/dns/rdtypes/ANY/OPT.py</span>
<span class="gu">@@ -31,4 +31,4 @@ class OPT(dns.rdata.Rdata):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def payload(self):
<span class="w"> </span>        &quot;&quot;&quot;payload size&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.rdclass</span>
<span class="gh">diff --git a/dns/rdtypes/svcbbase.py b/dns/rdtypes/svcbbase.py</span>
<span class="gh">index e82b8fd..6dd9ed5 100644</span>
<span class="gd">--- a/dns/rdtypes/svcbbase.py</span>
<span class="gi">+++ b/dns/rdtypes/svcbbase.py</span>
<span class="gu">@@ -110,10 +110,16 @@ class ECHParam(Param):</span>
<span class="w"> </span>        self.ech = dns.rdata.Rdata._as_bytes(ech, True)


<span class="gi">+@dns.immutable.immutable</span>
<span class="gi">+class DOHPathParam(Param):</span>
<span class="gi">+    def __init__(self, path):</span>
<span class="gi">+        self.path = dns.rdata.Rdata._as_bytes(path, True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_class_for_key = {ParamKey.MANDATORY: MandatoryParam, ParamKey.ALPN:
<span class="w"> </span>    ALPNParam, ParamKey.NO_DEFAULT_ALPN: NoDefaultALPNParam, ParamKey.PORT:
<span class="w"> </span>    PortParam, ParamKey.IPV4HINT: IPv4HintParam, ParamKey.ECH: ECHParam,
<span class="gd">-    ParamKey.IPV6HINT: IPv6HintParam}</span>
<span class="gi">+    ParamKey.IPV6HINT: IPv6HintParam, ParamKey.DOHPATH: DOHPathParam}</span>


<span class="w"> </span>@dns.immutable.immutable
<span class="gh">diff --git a/dns/renderer.py b/dns/renderer.py</span>
<span class="gh">index fbebb17..ad5c015 100644</span>
<span class="gd">--- a/dns/renderer.py</span>
<span class="gi">+++ b/dns/renderer.py</span>
<span class="gu">@@ -80,7 +80,11 @@ class Renderer:</span>
<span class="w"> </span>        compression table entries that pointed beyond the truncation
<span class="w"> </span>        point.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.output.truncate(where)</span>
<span class="gi">+        self.output.seek(where)</span>
<span class="gi">+        for k, v in list(self.compress.items()):</span>
<span class="gi">+            if v &gt;= where:</span>
<span class="gi">+                del self.compress[k]</span>

<span class="w"> </span>    def _set_section(self, section):
<span class="w"> </span>        &quot;&quot;&quot;Set the renderer&#39;s current section.
<span class="gu">@@ -91,11 +95,21 @@ class Renderer:</span>
<span class="w"> </span>        Raises dns.exception.FormError if an attempt was made to set
<span class="w"> </span>        a section value less than the current section.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if section &lt; self.section:</span>
<span class="gi">+            raise dns.exception.FormError(&#39;Invalid section ordering&#39;)</span>
<span class="gi">+        self.section = section</span>

<span class="w"> </span>    def add_question(self, qname, rdtype, rdclass=dns.rdataclass.IN):
<span class="w"> </span>        &quot;&quot;&quot;Add a question to the message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_section(QUESTION)</span>
<span class="gi">+        before = self.output.tell()</span>
<span class="gi">+        qname.to_wire(self.output, self.compress, self.origin)</span>
<span class="gi">+        self.output.write(struct.pack(&quot;!HH&quot;, rdtype, rdclass))</span>
<span class="gi">+        after = self.output.tell()</span>
<span class="gi">+        if after &gt;= self.max_size:</span>
<span class="gi">+            self._rollback(before)</span>
<span class="gi">+            raise dns.exception.TooBig</span>
<span class="gi">+        self.counts[QUESTION] += 1</span>

<span class="w"> </span>    def add_rrset(self, section, rrset, **kw):
<span class="w"> </span>        &quot;&quot;&quot;Add the rrset to the specified section.
<span class="gu">@@ -103,7 +117,15 @@ class Renderer:</span>
<span class="w"> </span>        Any keyword arguments are passed on to the rdataset&#39;s to_wire()
<span class="w"> </span>        routine.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_section(section)</span>
<span class="gi">+        before = self.output.tell()</span>
<span class="gi">+        n = rrset.name.to_wire(self.output, self.compress, self.origin)</span>
<span class="gi">+        rrset.to_wire(self.output, n, self.compress, self.origin, **kw)</span>
<span class="gi">+        after = self.output.tell()</span>
<span class="gi">+        if after &gt;= self.max_size:</span>
<span class="gi">+            self._rollback(before)</span>
<span class="gi">+            raise dns.exception.TooBig</span>
<span class="gi">+        self.counts[section] += len(rrset)</span>

<span class="w"> </span>    def add_rdataset(self, section, name, rdataset, **kw):
<span class="w"> </span>        &quot;&quot;&quot;Add the rdataset to the specified section, using the specified
<span class="gu">@@ -112,7 +134,15 @@ class Renderer:</span>
<span class="w"> </span>        Any keyword arguments are passed on to the rdataset&#39;s to_wire()
<span class="w"> </span>        routine.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_section(section)</span>
<span class="gi">+        before = self.output.tell()</span>
<span class="gi">+        n = name.to_wire(self.output, self.compress, self.origin)</span>
<span class="gi">+        rdataset.to_wire(self.output, n, self.compress, self.origin, **kw)</span>
<span class="gi">+        after = self.output.tell()</span>
<span class="gi">+        if after &gt;= self.max_size:</span>
<span class="gi">+            self._rollback(before)</span>
<span class="gi">+            raise dns.exception.TooBig</span>
<span class="gi">+        self.counts[section] += len(rdataset)</span>

<span class="w"> </span>    def add_opt(self, opt, pad=0, opt_size=0, tsig_size=0):
<span class="w"> </span>        &quot;&quot;&quot;Add *opt* to the additional section, applying padding if desired.  The
<span class="gu">@@ -121,16 +151,47 @@ class Renderer:</span>

<span class="w"> </span>        Note that we don&#39;t have reliable way of knowing how big a GSS-TSIG digest
<span class="w"> </span>        might be, so we we might not get an even multiple of the pad in that case.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_section(ADDITIONAL)</span>
<span class="gi">+        before = self.output.tell()</span>
<span class="gi">+        self.add_rrset(ADDITIONAL, opt)</span>
<span class="gi">+        after = self.output.tell()</span>
<span class="gi">+        if pad:</span>
<span class="gi">+            current_size = after + tsig_size</span>
<span class="gi">+            desired_size = (((current_size - 1) // pad) + 1) * pad</span>
<span class="gi">+            padding = desired_size - current_size</span>
<span class="gi">+            if padding &gt; 0:</span>
<span class="gi">+                self.output.write(b&#39;\x00&#39; * padding)</span>
<span class="gi">+                self.was_padded = True</span>
<span class="gi">+        if self.output.tell() &gt;= self.max_size:</span>
<span class="gi">+            self._rollback(before)</span>
<span class="gi">+            raise dns.exception.TooBig</span>

<span class="w"> </span>    def add_edns(self, edns, ednsflags, payload, options=None):
<span class="w"> </span>        &quot;&quot;&quot;Add an EDNS OPT record to the message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This is a simplified version. You might need to adjust it based on your specific EDNS implementation</span>
<span class="gi">+        opt = dns.message.make_opt(payload, edns, ednsflags, options)</span>
<span class="gi">+        self.add_opt(opt)</span>

<span class="w"> </span>    def add_tsig(self, keyname, secret, fudge, id, tsig_error, other_data,
<span class="w"> </span>        request_mac, algorithm=dns.tsig.default_algorithm):
<span class="w"> </span>        &quot;&quot;&quot;Add a TSIG signature to the message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_section(ADDITIONAL)</span>
<span class="gi">+        before = self.output.tell()</span>
<span class="gi">+        tsig = dns.tsig.generate(self.output.getvalue(), secret, int(time.time()),</span>
<span class="gi">+                                 fudge, id, tsig_error, other_data, request_mac,</span>
<span class="gi">+                                 algorithm=algorithm)</span>
<span class="gi">+        keyname.to_wire(self.output, self.compress, self.origin)</span>
<span class="gi">+        self.output.write(struct.pack(&#39;!HHIH&#39;, dns.rdatatype.TSIG,</span>
<span class="gi">+                                      dns.rdataclass.ANY, 0, 0))</span>
<span class="gi">+        rdata_start = self.output.tell()</span>
<span class="gi">+        self.output.write(tsig)</span>
<span class="gi">+        after = self.output.tell()</span>
<span class="gi">+        self.output.seek(rdata_start - 2)</span>
<span class="gi">+        self.output.write(struct.pack(&#39;!H&#39;, after - rdata_start))</span>
<span class="gi">+        self.counts[ADDITIONAL] += 1</span>
<span class="gi">+        if after &gt;= self.max_size:</span>
<span class="gi">+            self._rollback(before)</span>
<span class="gi">+            raise dns.exception.TooBig</span>

<span class="w"> </span>    def add_multi_tsig(self, ctx, keyname, secret, fudge, id, tsig_error,
<span class="w"> </span>        other_data, request_mac, algorithm=dns.tsig.default_algorithm):
<span class="gu">@@ -141,7 +202,26 @@ class Renderer:</span>
<span class="w"> </span>        For the first message in the sequence, give ctx=None. For each
<span class="w"> </span>        subsequent message, give the ctx that was returned from the
<span class="w"> </span>        add_multi_tsig() call for the previous message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_section(ADDITIONAL)</span>
<span class="gi">+        before = self.output.tell()</span>
<span class="gi">+        if ctx is None:</span>
<span class="gi">+            ctx = dns.tsig.generate_tsig_state()</span>
<span class="gi">+        tsig = dns.tsig.generate_tsig(self.output.getvalue(), secret, int(time.time()),</span>
<span class="gi">+                                      fudge, id, tsig_error, other_data, request_mac,</span>
<span class="gi">+                                      ctx, algorithm=algorithm)</span>
<span class="gi">+        keyname.to_wire(self.output, self.compress, self.origin)</span>
<span class="gi">+        self.output.write(struct.pack(&#39;!HHIH&#39;, dns.rdatatype.TSIG,</span>
<span class="gi">+                                      dns.rdataclass.ANY, 0, 0))</span>
<span class="gi">+        rdata_start = self.output.tell()</span>
<span class="gi">+        self.output.write(tsig)</span>
<span class="gi">+        after = self.output.tell()</span>
<span class="gi">+        self.output.seek(rdata_start - 2)</span>
<span class="gi">+        self.output.write(struct.pack(&#39;!H&#39;, after - rdata_start))</span>
<span class="gi">+        self.counts[ADDITIONAL] += 1</span>
<span class="gi">+        if after &gt;= self.max_size:</span>
<span class="gi">+            self._rollback(before)</span>
<span class="gi">+            raise dns.exception.TooBig</span>
<span class="gi">+        return ctx</span>

<span class="w"> </span>    def write_header(self):
<span class="w"> </span>        &quot;&quot;&quot;Write the DNS message header.
<span class="gu">@@ -150,16 +230,19 @@ class Renderer:</span>
<span class="w"> </span>        have been rendered, but before the optional TSIG signature
<span class="w"> </span>        is added.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.output.seek(0)</span>
<span class="gi">+        self.output.write(struct.pack(&#39;!HHHHHH&#39;, self.id, self.flags,</span>
<span class="gi">+                                      self.counts[0], self.counts[1],</span>
<span class="gi">+                                      self.counts[2], self.counts[3]))</span>

<span class="w"> </span>    def get_wire(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the wire format message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.output.getvalue()</span>

<span class="w"> </span>    def reserve(self, size: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Reserve *size* bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.reserved += size</span>

<span class="w"> </span>    def release_reserved(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Release the reserved bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.reserved = 0</span>
<span class="gh">diff --git a/dns/resolver.py b/dns/resolver.py</span>
<span class="gh">index 116ab15..ed70836 100644</span>
<span class="gd">--- a/dns/resolver.py</span>
<span class="gi">+++ b/dns/resolver.py</span>
<span class="gu">@@ -98,7 +98,7 @@ ErrorTuple = Tuple[Optional[str], bool, int, Union[Exception, str],</span>

<span class="w"> </span>def _errors_to_text(errors: List[ErrorTuple]) -&gt;List[str]:
<span class="w"> </span>    &quot;&quot;&quot;Turn a resolution errors trace into a list of text.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [f&quot;{error[0]}:{error[1]}:{error[2]}:{str(error[3])}&quot; for error in errors]</span>


<span class="w"> </span>class LifetimeTimeout(dns.exception.Timeout):
<span class="gu">@@ -244,15 +244,18 @@ class CacheBase:</span>

<span class="w"> </span>    def reset_statistics(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Reset all statistics to zero.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            self.statistics = CacheStatistics()</span>

<span class="w"> </span>    def hits(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;How many hits has the cache had?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            return self.statistics.hits</span>

<span class="w"> </span>    def misses(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;How many misses has the cache had?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            return self.statistics.misses</span>

<span class="w"> </span>    def get_statistics_snapshot(self) -&gt;CacheStatistics:
<span class="w"> </span>        &quot;&quot;&quot;Return a consistent snapshot of all the statistics.
<span class="gu">@@ -261,7 +264,8 @@ class CacheBase:</span>
<span class="w"> </span>        snapshot than to call statistics methods such as hits() and
<span class="w"> </span>        misses() individually.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            return CacheStatistics(self.statistics.hits, self.statistics.misses)</span>


<span class="w"> </span>CacheKey = Tuple[dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.
<span class="gu">@@ -282,7 +286,12 @@ class Cache(CacheBase):</span>

<span class="w"> </span>    def _maybe_clean(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Clean the cache if it&#39;s time to do so.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        now = time.time()</span>
<span class="gi">+        if self.next_cleaning &lt;= now:</span>
<span class="gi">+            keys_to_delete = [k for k, v in self.data.items() if v.expiration &lt;= now]</span>
<span class="gi">+            for key in keys_to_delete:</span>
<span class="gi">+                del self.data[key]</span>
<span class="gi">+            self.next_cleaning = now + self.cleaning_interval</span>

<span class="w"> </span>    def get(self, key: CacheKey) -&gt;Optional[Answer]:
<span class="w"> </span>        &quot;&quot;&quot;Get the answer associated with *key*.
<span class="gu">@@ -294,7 +303,14 @@ class Cache(CacheBase):</span>

<span class="w"> </span>        Returns a ``dns.resolver.Answer`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._maybe_clean()</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            answer = self.data.get(key)</span>
<span class="gi">+            if answer and answer.expiration &gt; time.time():</span>
<span class="gi">+                self.statistics.hits += 1</span>
<span class="gi">+                return answer</span>
<span class="gi">+            self.statistics.misses += 1</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def put(self, key: CacheKey, value: Answer) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Associate key and value in the cache.
<span class="gu">@@ -304,7 +320,9 @@ class Cache(CacheBase):</span>

<span class="w"> </span>        *value*, a ``dns.resolver.Answer``, the answer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._maybe_clean()</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            self.data[key] = value</span>

<span class="w"> </span>    def flush(self, key: Optional[CacheKey]=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Flush the cache.
<span class="gu">@@ -315,7 +333,12 @@ class Cache(CacheBase):</span>
<span class="w"> </span>        *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
<span class="w"> </span>        tuple whose values are the query name, rdtype, and rdclass respectively.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            if key is not None:</span>
<span class="gi">+                self.data.pop(key, None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.data.clear()</span>
<span class="gi">+            self.next_cleaning = time.time() + self.cleaning_interval</span>


<span class="w"> </span>class LRUCacheNode:
<span class="gu">@@ -360,11 +383,25 @@ class LRUCache(CacheBase):</span>

<span class="w"> </span>        Returns a ``dns.resolver.Answer`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            node = self.data.get(key)</span>
<span class="gi">+            if node is None:</span>
<span class="gi">+                self.statistics.misses += 1</span>
<span class="gi">+                return None</span>
<span class="gi">+            if node.value.expiration &lt;= time.time():</span>
<span class="gi">+                self.data.pop(key)</span>
<span class="gi">+                self.statistics.misses += 1</span>
<span class="gi">+                return None</span>
<span class="gi">+            node.hits += 1</span>
<span class="gi">+            self.statistics.hits += 1</span>
<span class="gi">+            self._move_to_front(node)</span>
<span class="gi">+            return node.value</span>

<span class="w"> </span>    def get_hits_for_key(self, key: CacheKey) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Return the number of cache hits associated with the specified key.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            node = self.data.get(key)</span>
<span class="gi">+            return node.hits if node else 0</span>

<span class="w"> </span>    def put(self, key: CacheKey, value: Answer) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Associate key and value in the cache.
<span class="gu">@@ -374,7 +411,18 @@ class LRUCache(CacheBase):</span>

<span class="w"> </span>        *value*, a ``dns.resolver.Answer``, the answer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            if key in self.data:</span>
<span class="gi">+                node = self.data[key]</span>
<span class="gi">+                node.value = value</span>
<span class="gi">+                node.hits = 0</span>
<span class="gi">+                self._move_to_front(node)</span>
<span class="gi">+            else:</span>
<span class="gi">+                while len(self.data) &gt;= self.max_size:</span>
<span class="gi">+                    self._remove_last()</span>
<span class="gi">+                node = LRUCacheNode(key, value)</span>
<span class="gi">+                self.data[key] = node</span>
<span class="gi">+                self._add_to_front(node)</span>

<span class="w"> </span>    def flush(self, key: Optional[CacheKey]=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Flush the cache.
<span class="gu">@@ -385,7 +433,31 @@ class LRUCache(CacheBase):</span>
<span class="w"> </span>        *key*, a ``(dns.name.Name, dns.rdatatype.RdataType, dns.rdataclass.RdataClass)``
<span class="w"> </span>        tuple whose values are the query name, rdtype, and rdclass respectively.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.lock:</span>
<span class="gi">+            if key is not None:</span>
<span class="gi">+                self.data.pop(key, None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.data.clear()</span>
<span class="gi">+                self.sentinel.prev = self.sentinel</span>
<span class="gi">+                self.sentinel.next = self.sentinel</span>
<span class="gi">+</span>
<span class="gi">+    def _move_to_front(self, node: LRUCacheNode) -&gt;None:</span>
<span class="gi">+        node.prev.next = node.next</span>
<span class="gi">+        node.next.prev = node.prev</span>
<span class="gi">+        self._add_to_front(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _add_to_front(self, node: LRUCacheNode) -&gt;None:</span>
<span class="gi">+        node.next = self.sentinel.next</span>
<span class="gi">+        node.prev = self.sentinel</span>
<span class="gi">+        self.sentinel.next.prev = node</span>
<span class="gi">+        self.sentinel.next = node</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_last(self) -&gt;None:</span>
<span class="gi">+        if self.data:</span>
<span class="gi">+            node = self.sentinel.prev</span>
<span class="gi">+            node.prev.next = self.sentinel</span>
<span class="gi">+            self.sentinel.prev = node.prev</span>
<span class="gi">+            del self.data[node.key]</span>


<span class="w"> </span>class _Resolution:
<span class="gu">@@ -438,7 +510,22 @@ class _Resolution:</span>
<span class="w"> </span>        Returns a (request, answer) tuple.  At most one of request or
<span class="w"> </span>        answer will not be None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while self.qnames:</span>
<span class="gi">+            self.qname = self.qnames.pop(0)</span>
<span class="gi">+            key = (self.qname, self.rdtype, self.rdclass)</span>
<span class="gi">+            answer = self.resolver.cache.get(key)</span>
<span class="gi">+            if answer:</span>
<span class="gi">+                return (None, answer)</span>
<span class="gi">+            request = dns.message.make_query(self.qname, self.rdtype, self.rdclass)</span>
<span class="gi">+            if self.resolver.keyname is not None:</span>
<span class="gi">+                request.use_tsig(self.resolver.keyring, self.resolver.keyname,</span>
<span class="gi">+                                 algorithm=self.resolver.keyalgorithm)</span>
<span class="gi">+            request.use_edns(self.resolver.edns, self.resolver.ednsflags,</span>
<span class="gi">+                             self.resolver.payload, options=self.resolver.ednsoptions)</span>
<span class="gi">+            if self.resolver.flags is not None:</span>
<span class="gi">+                request.flags = self.resolver.flags</span>
<span class="gi">+            return (request, None)</span>
<span class="gi">+        return (None, None)</span>


<span class="w"> </span>class BaseResolver:
<span class="gu">@@ -485,7 +572,26 @@ class BaseResolver:</span>

<span class="w"> </span>    def reset(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Reset all resolver configuration to the defaults.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.domain = dns.name.Name(labels=[])</span>
<span class="gi">+        self.nameserver_ports = {}</span>
<span class="gi">+        self.port = 53</span>
<span class="gi">+        self.search = []</span>
<span class="gi">+        self.use_search_by_default = False</span>
<span class="gi">+        self.timeout = 2.0</span>
<span class="gi">+        self.lifetime = 5.0</span>
<span class="gi">+        self.keyring = None</span>
<span class="gi">+        self.keyname = None</span>
<span class="gi">+        self.keyalgorithm = dns.tsig.default_algorithm</span>
<span class="gi">+        self.edns = -1</span>
<span class="gi">+        self.ednsflags = 0</span>
<span class="gi">+        self.ednsoptions = None</span>
<span class="gi">+        self.payload = 0</span>
<span class="gi">+        self.cache = Cache()</span>
<span class="gi">+        self.flags = None</span>
<span class="gi">+        self.retry_servfail = False</span>
<span class="gi">+        self.rotate = False</span>
<span class="gi">+        self.ndots = None</span>
<span class="gi">+        self._nameservers = []</span>

<span class="w"> </span>    def read_resolv_conf(self, f: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process *f* as a file in the /etc/resolv.conf format.  If f is
<span class="gu">@@ -503,11 +609,86 @@ class BaseResolver:</span>
<span class="w"> </span>        - options - supported options are rotate, timeout, edns0, and ndots

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(f, str):</span>
<span class="gi">+            try:</span>
<span class="gi">+                with open(f, &#39;r&#39;) as fp:</span>
<span class="gi">+                    self._process_resolv_conf(fp)</span>
<span class="gi">+            except IOError:</span>
<span class="gi">+                # /etc/resolv.conf doesn&#39;t exist, can&#39;t be read, etc.</span>
<span class="gi">+                # We&#39;ll just use the default resolver configuration.</span>
<span class="gi">+                pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._process_resolv_conf(f)</span>
<span class="gi">+</span>
<span class="gi">+    def _process_resolv_conf(self, f):</span>
<span class="gi">+        nameservers = []</span>
<span class="gi">+        domain = None</span>
<span class="gi">+        search = []</span>
<span class="gi">+        for line in f:</span>
<span class="gi">+            if line.startswith(&#39;#&#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+            tokens = line.split()</span>
<span class="gi">+            if len(tokens) == 0:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if tokens[0] == &#39;nameserver&#39;:</span>
<span class="gi">+                nameservers.extend(tokens[1:])</span>
<span class="gi">+            elif tokens[0] == &#39;domain&#39;:</span>
<span class="gi">+                domain = tokens[1]</span>
<span class="gi">+            elif tokens[0] == &#39;search&#39;:</span>
<span class="gi">+                search.extend(tokens[1:])</span>
<span class="gi">+            elif tokens[0] == &#39;options&#39;:</span>
<span class="gi">+                for token in tokens[1:]:</span>
<span class="gi">+                    if token.startswith(&#39;ndots:&#39;):</span>
<span class="gi">+                        self.ndots = int(token.split(&#39;:&#39;)[1])</span>
<span class="gi">+                    elif token == &#39;rotate&#39;:</span>
<span class="gi">+                        self.rotate = True</span>
<span class="gi">+                    elif token.startswith(&#39;timeout:&#39;):</span>
<span class="gi">+                        self.timeout = float(token.split(&#39;:&#39;)[1])</span>
<span class="gi">+                    elif token == &#39;edns0&#39;:</span>
<span class="gi">+                        self.use_edns()</span>
<span class="gi">+</span>
<span class="gi">+        if nameservers:</span>
<span class="gi">+            self.nameservers = nameservers</span>
<span class="gi">+        if domain:</span>
<span class="gi">+            self.domain = dns.name.from_text(domain)</span>
<span class="gi">+        if search:</span>
<span class="gi">+            self.search = [dns.name.from_text(s) for s in search]</span>

<span class="w"> </span>    def read_registry(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Extract resolver configuration from the Windows registry.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            import winreg</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            # Not on Windows, or winreg is not available</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        lm = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)</span>
<span class="gi">+        try:</span>
<span class="gi">+            tcp_params = winreg.OpenKey(lm, r&#39;SYSTEM\CurrentControlSet\Services\Tcpip\Parameters&#39;)</span>
<span class="gi">+        except WindowsError:</span>
<span class="gi">+            # Key not found, return without changing anything</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            search = winreg.QueryValueEx(tcp_params, &#39;SearchList&#39;)[0].split(&#39;,&#39;)</span>
<span class="gi">+            self.search = [dns.name.from_text(s) for s in search]</span>
<span class="gi">+        except WindowsError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            domain = winreg.QueryValueEx(tcp_params, &#39;Domain&#39;)[0]</span>
<span class="gi">+            self.domain = dns.name.from_text(domain)</span>
<span class="gi">+        except WindowsError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            nameservers = winreg.QueryValueEx(tcp_params, &#39;NameServer&#39;)[0].split(&#39;,&#39;)</span>
<span class="gi">+            self.nameservers = nameservers</span>
<span class="gi">+        except WindowsError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        winreg.CloseKey(tcp_params)</span>
<span class="gi">+        winreg.CloseKey(lm)</span>

<span class="w"> </span>    def use_tsig(self, keyring: Any, keyname: Optional[Union[dns.name.Name,
<span class="w"> </span>        str]]=None, algorithm: Union[dns.name.Name, str]=dns.tsig.
<span class="gh">diff --git a/dns/reversename.py b/dns/reversename.py</span>
<span class="gh">index 416c57f..48952fd 100644</span>
<span class="gd">--- a/dns/reversename.py</span>
<span class="gi">+++ b/dns/reversename.py</span>
<span class="gu">@@ -27,7 +27,19 @@ def from_address(text: str, v4_origin: dns.name.Name=ipv4_reverse_domain,</span>

<span class="w"> </span>    Returns a ``dns.name.Name``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Try parsing as IPv4</span>
<span class="gi">+        parts = dns.ipv4.inet_aton(text)</span>
<span class="gi">+        labels = [dns.name.from_text(str(byte)) for byte in reversed(parts)]</span>
<span class="gi">+        return dns.name.Name(labels + list(v4_origin.labels))</span>
<span class="gi">+    except dns.exception.SyntaxError:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Try parsing as IPv6</span>
<span class="gi">+            parts = dns.ipv6.inet_aton(text)</span>
<span class="gi">+            labels = [dns.name.from_text(f&quot;{x:x}&quot;) for x in reversed(parts)]</span>
<span class="gi">+            return dns.name.Name(labels + list(v6_origin.labels))</span>
<span class="gi">+        except dns.exception.SyntaxError:</span>
<span class="gi">+            raise dns.exception.SyntaxError(f&quot;Invalid IP address: {text}&quot;)</span>


<span class="w"> </span>def to_address(name: dns.name.Name, v4_origin: dns.name.Name=
<span class="gu">@@ -48,4 +60,26 @@ def to_address(name: dns.name.Name, v4_origin: dns.name.Name=</span>

<span class="w"> </span>    Returns a ``str``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name.is_subdomain(v4_origin):</span>
<span class="gi">+        # IPv4 address</span>
<span class="gi">+        labels = list(name.labels)</span>
<span class="gi">+        if len(labels) &gt; len(v4_origin.labels):</span>
<span class="gi">+            labels = labels[:-len(v4_origin.labels)]</span>
<span class="gi">+        labels.reverse()</span>
<span class="gi">+        octets = [int(label.decode()) for label in labels]</span>
<span class="gi">+        if len(octets) != 4:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;Invalid IPv4 reverse-map name&quot;)</span>
<span class="gi">+        return dns.ipv4.inet_ntoa(bytes(octets))</span>
<span class="gi">+    elif name.is_subdomain(v6_origin):</span>
<span class="gi">+        # IPv6 address</span>
<span class="gi">+        labels = list(name.labels)</span>
<span class="gi">+        if len(labels) &gt; len(v6_origin.labels):</span>
<span class="gi">+            labels = labels[:-len(v6_origin.labels)]</span>
<span class="gi">+        labels.reverse()</span>
<span class="gi">+        hexdigits = &#39;&#39;.join(label.decode() for label in labels)</span>
<span class="gi">+        if len(hexdigits) != 32:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&quot;Invalid IPv6 reverse-map name&quot;)</span>
<span class="gi">+        address = &#39;:&#39;.join(hexdigits[i:i+4] for i in range(0, 32, 4))</span>
<span class="gi">+        return dns.ipv6.inet_ntoa(dns.ipv6.inet_aton(address))</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise dns.exception.SyntaxError(&quot;Name is not a reverse-map domain name&quot;)</span>
<span class="gh">diff --git a/dns/rrset.py b/dns/rrset.py</span>
<span class="gh">index f235f64..93aae7f 100644</span>
<span class="gd">--- a/dns/rrset.py</span>
<span class="gi">+++ b/dns/rrset.py</span>
<span class="gu">@@ -62,7 +62,9 @@ class RRset(dns.rdataset.Rdataset):</span>
<span class="w"> </span>        makes RRsets matchable as Rdatasets while preserving backwards
<span class="w"> </span>        compatibility.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if args and isinstance(args[0], dns.name.Name):</span>
<span class="gi">+            return self.full_match(*args, **kwargs)</span>
<span class="gi">+        return super().match(*args, **kwargs)</span>

<span class="w"> </span>    def full_match(self, name: dns.name.Name, rdclass: dns.rdataclass.
<span class="w"> </span>        RdataClass, rdtype: dns.rdatatype.RdataType, covers: dns.rdatatype.
<span class="gu">@@ -70,7 +72,11 @@ class RRset(dns.rdataset.Rdataset):</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if this rrset matches the specified name, class,
<span class="w"> </span>        type, covers, and deletion state.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (self.name == name and</span>
<span class="gi">+                self.rdclass == rdclass and</span>
<span class="gi">+                self.rdtype == rdtype and</span>
<span class="gi">+                self.covers == covers and</span>
<span class="gi">+                self.deleting == deleting)</span>

<span class="w"> </span>    def to_text(self, origin: Optional[dns.name.Name]=None, relativize:
<span class="w"> </span>        bool=True, **kw: Dict[str, Any]) -&gt;str:
<span class="gu">@@ -89,7 +95,12 @@ class RRset(dns.rdataset.Rdataset):</span>
<span class="w"> </span>        *relativize*, a ``bool``.  If ``True``, names will be relativized
<span class="w"> </span>        to *origin*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = self.name.choose_relativity(origin, relativize)</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for rdata in self:</span>
<span class="gi">+            result.append(f&quot;{name} {self.ttl} {dns.rdataclass.to_text(self.rdclass)} &quot;</span>
<span class="gi">+                          f&quot;{dns.rdatatype.to_text(self.rdtype)} {rdata.to_text(**kw)}&quot;)</span>
<span class="gi">+        return &quot;\n&quot;.join(result)</span>

<span class="w"> </span>    def to_wire(self, file: Any, compress: Optional[dns.name.CompressType]=
<span class="w"> </span>        None, origin: Optional[dns.name.Name]=None, **kw: Dict[str, Any]
<span class="gu">@@ -101,14 +112,20 @@ class RRset(dns.rdataset.Rdataset):</span>

<span class="w"> </span>        Returns an ``int``, the number of records emitted.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        renderer = dns.renderer.Renderer(file, compress, origin)</span>
<span class="gi">+        renderer.add_name(self.name, None)</span>
<span class="gi">+        return super().to_wire(renderer, None, **kw)</span>

<span class="w"> </span>    def to_rdataset(self) -&gt;dns.rdataset.Rdataset:
<span class="w"> </span>        &quot;&quot;&quot;Convert an RRset into an Rdataset.

<span class="w"> </span>        Returns a ``dns.rdataset.Rdataset``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rdataset = dns.rdataset.Rdataset(self.rdclass, self.rdtype, self.covers)</span>
<span class="gi">+        rdataset.update_ttl(self.ttl)</span>
<span class="gi">+        for rdata in self:</span>
<span class="gi">+            rdataset.add(rdata)</span>
<span class="gi">+        return rdataset</span>


<span class="w"> </span>def from_text_list(name: Union[dns.name.Name, str], ttl: int, rdclass:
<span class="gu">@@ -133,7 +150,22 @@ def from_text_list(name: Union[dns.name.Name, str], ttl: int, rdclass:</span>

<span class="w"> </span>    Returns a ``dns.rrset.RRset`` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(name, str):</span>
<span class="gi">+        name = dns.name.from_text(name, origin, idna_codec)</span>
<span class="gi">+    if relativize:</span>
<span class="gi">+        name = name.relativize(relativize_to or origin)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(rdclass, str):</span>
<span class="gi">+        rdclass = dns.rdataclass.from_text(rdclass)</span>
<span class="gi">+    if isinstance(rdtype, str):</span>
<span class="gi">+        rdtype = dns.rdatatype.from_text(rdtype)</span>
<span class="gi">+    </span>
<span class="gi">+    r = RRset(name, rdclass, rdtype)</span>
<span class="gi">+    r.update_ttl(ttl)</span>
<span class="gi">+    for text_rdata in text_rdatas:</span>
<span class="gi">+        rd = dns.rdata.from_text(r.rdclass, r.rdtype, text_rdata, origin, relativize, idna_codec)</span>
<span class="gi">+        r.add(rd)</span>
<span class="gi">+    return r</span>


<span class="w"> </span>def from_text(name: Union[dns.name.Name, str], ttl: int, rdclass: Union[dns
<span class="gu">@@ -144,7 +176,7 @@ def from_text(name: Union[dns.name.Name, str], ttl: int, rdclass: Union[dns</span>

<span class="w"> </span>    Returns a ``dns.rrset.RRset`` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return from_text_list(name, ttl, rdclass, rdtype, text_rdatas)</span>


<span class="w"> </span>def from_rdata_list(name: Union[dns.name.Name, str], ttl: int, rdatas:
<span class="gu">@@ -160,7 +192,18 @@ def from_rdata_list(name: Union[dns.name.Name, str], ttl: int, rdatas:</span>
<span class="w"> </span>    Returns a ``dns.rrset.RRset`` object.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(name, str):</span>
<span class="gi">+        name = dns.name.from_text(name, None, idna_codec)</span>
<span class="gi">+    </span>
<span class="gi">+    if not rdatas:</span>
<span class="gi">+        raise ValueError(&quot;rdatas must not be empty&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    first_rdata = next(iter(rdatas))</span>
<span class="gi">+    r = RRset(name, first_rdata.rdclass, first_rdata.rdtype)</span>
<span class="gi">+    r.update_ttl(ttl)</span>
<span class="gi">+    for rdata in rdatas:</span>
<span class="gi">+        r.add(rdata)</span>
<span class="gi">+    return r</span>


<span class="w"> </span>def from_rdata(name: Union[dns.name.Name, str], ttl: int, *rdatas: Any
<span class="gu">@@ -170,4 +213,4 @@ def from_rdata(name: Union[dns.name.Name, str], ttl: int, *rdatas: Any</span>

<span class="w"> </span>    Returns a ``dns.rrset.RRset`` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return from_rdata_list(name, ttl, rdatas)</span>
<span class="gh">diff --git a/dns/set.py b/dns/set.py</span>
<span class="gh">index d90e21f..79de295 100644</span>
<span class="gd">--- a/dns/set.py</span>
<span class="gi">+++ b/dns/set.py</span>
<span class="gu">@@ -26,19 +26,21 @@ class Set:</span>

<span class="w"> </span>    def add(self, item):
<span class="w"> </span>        &quot;&quot;&quot;Add an item to the set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.items[item] = None</span>

<span class="w"> </span>    def remove(self, item):
<span class="w"> </span>        &quot;&quot;&quot;Remove an item from the set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        del self.items[item]</span>

<span class="w"> </span>    def discard(self, item):
<span class="w"> </span>        &quot;&quot;&quot;Remove an item from the set if present.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.items.pop(item, None)</span>

<span class="w"> </span>    def pop(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove an arbitrary item from the set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.items:</span>
<span class="gi">+            raise KeyError(&#39;pop from an empty set&#39;)</span>
<span class="gi">+        return self.items.popitem()[0]</span>

<span class="w"> </span>    def _clone(self) -&gt;&#39;Set&#39;:
<span class="w"> </span>        &quot;&quot;&quot;Make a (shallow) copy of the set.
<span class="gu">@@ -52,7 +54,9 @@ class Set:</span>
<span class="w"> </span>        return new instances (e.g. union) once, and keep using them in
<span class="w"> </span>        subclasses.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        clone = Set()</span>
<span class="gi">+        clone.items = self.items.copy()</span>
<span class="gi">+        return clone</span>

<span class="w"> </span>    def __copy__(self):
<span class="w"> </span>        &quot;&quot;&quot;Make a (shallow) copy of the set.&quot;&quot;&quot;
<span class="gu">@@ -60,36 +64,43 @@ class Set:</span>

<span class="w"> </span>    def copy(self):
<span class="w"> </span>        &quot;&quot;&quot;Make a (shallow) copy of the set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._clone()</span>

<span class="w"> </span>    def union_update(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Update the set, adding any elements from other which are not
<span class="w"> </span>        already in the set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for item in other:</span>
<span class="gi">+            self.add(item)</span>

<span class="w"> </span>    def intersection_update(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Update the set, removing any elements from other which are not
<span class="w"> </span>        in both sets.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.items = {item: None for item in self.items if item in other}</span>

<span class="w"> </span>    def difference_update(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Update the set, removing any elements from other which are in
<span class="w"> </span>        the set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for item in other:</span>
<span class="gi">+            self.discard(item)</span>

<span class="w"> </span>    def symmetric_difference_update(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Update the set, retaining only elements unique to both sets.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        temp = self.union(other)</span>
<span class="gi">+        self.intersection_update(other)</span>
<span class="gi">+        temp.difference_update(self)</span>
<span class="gi">+        self.update(temp)</span>

<span class="w"> </span>    def union(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Return a new set which is the union of ``self`` and ``other``.

<span class="w"> </span>        Returns the same Set type as this set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = self._clone()</span>
<span class="gi">+        result.union_update(other)</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def intersection(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Return a new set which is the intersection of ``self`` and
<span class="gu">@@ -97,7 +108,9 @@ class Set:</span>

<span class="w"> </span>        Returns the same Set type as this set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = self._clone()</span>
<span class="gi">+        result.intersection_update(other)</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def difference(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Return a new set which ``self`` - ``other``, i.e. the items
<span class="gu">@@ -105,7 +118,9 @@ class Set:</span>

<span class="w"> </span>        Returns the same Set type as this set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = self._clone()</span>
<span class="gi">+        result.difference_update(other)</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def symmetric_difference(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Return a new set which (``self`` - ``other``) | (``other``
<span class="gu">@@ -114,7 +129,9 @@ class Set:</span>

<span class="w"> </span>        Returns the same Set type as this set.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = self._clone()</span>
<span class="gi">+        result.symmetric_difference_update(other)</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def __or__(self, other):
<span class="w"> </span>        return self.union(other)
<span class="gu">@@ -158,11 +175,12 @@ class Set:</span>
<span class="w"> </span>        *other*, the collection of items with which to update the set, which
<span class="w"> </span>        may be any iterable type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for item in other:</span>
<span class="gi">+            self.add(item)</span>

<span class="w"> </span>    def clear(self):
<span class="w"> </span>        &quot;&quot;&quot;Make the set empty.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.items.clear()</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        return self.items == other.items
<span class="gu">@@ -194,11 +212,11 @@ class Set:</span>

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return all(item in other for item in self.items)</span>

<span class="w"> </span>    def issuperset(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Is this set a superset of *other*?

<span class="w"> </span>        Returns a ``bool``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return all(item in self.items for item in other)</span>
<span class="gh">diff --git a/dns/tokenizer.py b/dns/tokenizer.py</span>
<span class="gh">index c6a389f..d625eb8 100644</span>
<span class="gd">--- a/dns/tokenizer.py</span>
<span class="gi">+++ b/dns/tokenizer.py</span>
<span class="gu">@@ -128,7 +128,17 @@ class Tokenizer:</span>

<span class="w"> </span>    def _get_char(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Read a character from input.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ungotten_char is not None:</span>
<span class="gi">+            c = self.ungotten_char</span>
<span class="gi">+            self.ungotten_char = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            c = self.file.read(1)</span>
<span class="gi">+            if c == &#39;\n&#39;:</span>
<span class="gi">+                self.line_number += 1</span>
<span class="gi">+            elif c == &#39;&#39;:</span>
<span class="gi">+                self.eof = True</span>
<span class="gi">+                self.file.close()</span>
<span class="gi">+        return c</span>

<span class="w"> </span>    def where(self) -&gt;Tuple[str, int]:
<span class="w"> </span>        &quot;&quot;&quot;Return the current location in the input.
<span class="gu">@@ -136,7 +146,7 @@ class Tokenizer:</span>
<span class="w"> </span>        Returns a (string, int) tuple.  The first item is the filename of
<span class="w"> </span>        the input, the second is the current line number.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (self.filename, self.line_number)</span>

<span class="w"> </span>    def _unget_char(self, c: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Unget a character.
<span class="gu">@@ -148,7 +158,11 @@ class Tokenizer:</span>
<span class="w"> </span>        c: the character to unget
<span class="w"> </span>        raises UngetBufferFull: there is already an ungotten char
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ungotten_char is not None:</span>
<span class="gi">+            raise UngetBufferFull</span>
<span class="gi">+        self.ungotten_char = c</span>
<span class="gi">+        if c == &#39;\n&#39;:</span>
<span class="gi">+            self.line_number -= 1</span>

<span class="w"> </span>    def skip_whitespace(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Consume input until a non-whitespace character is encountered.
<span class="gu">@@ -160,7 +174,17 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns the number of characters skipped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        skipped = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            c = self._get_char()</span>
<span class="gi">+            if c == &#39;&#39; or c not in (&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;):</span>
<span class="gi">+                if c != &#39;&#39;:</span>
<span class="gi">+                    self._unget_char(c)</span>
<span class="gi">+                return skipped</span>
<span class="gi">+            if c == &#39;\n&#39; and self.multiline == 0:</span>
<span class="gi">+                self._unget_char(c)</span>
<span class="gi">+                return skipped</span>
<span class="gi">+            skipped += 1</span>

<span class="w"> </span>    def get(self, want_leading: bool=False, want_comment: bool=False) -&gt;Token:
<span class="w"> </span>        &quot;&quot;&quot;Get the next token.
<span class="gu">@@ -177,7 +201,76 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns a Token.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ungotten_token is not None:</span>
<span class="gi">+            token = self.ungotten_token</span>
<span class="gi">+            self.ungotten_token = None</span>
<span class="gi">+            return token</span>
<span class="gi">+        </span>
<span class="gi">+        skipped = self.skip_whitespace()</span>
<span class="gi">+        if want_leading and skipped &gt; 0:</span>
<span class="gi">+            return Token(WHITESPACE, &#39; &#39; * skipped)</span>
<span class="gi">+        </span>
<span class="gi">+        token = self._get_token()</span>
<span class="gi">+        if token.ttype == COMMENT and not want_comment:</span>
<span class="gi">+            return self.get(want_leading, want_comment)</span>
<span class="gi">+        </span>
<span class="gi">+        return token</span>
<span class="gi">+</span>
<span class="gi">+    def _get_token(self) -&gt;Token:</span>
<span class="gi">+        c = self._get_char()</span>
<span class="gi">+        if c == &#39;&#39;:</span>
<span class="gi">+            return Token(EOF)</span>
<span class="gi">+        elif c == &#39;\n&#39;:</span>
<span class="gi">+            return Token(EOL)</span>
<span class="gi">+        elif c in self.delimiters:</span>
<span class="gi">+            if c == &#39;&quot;&#39;:</span>
<span class="gi">+                return self._get_quoted_string()</span>
<span class="gi">+            elif c == &#39;(&#39;:</span>
<span class="gi">+                self.multiline += 1</span>
<span class="gi">+            elif c == &#39;)&#39;:</span>
<span class="gi">+                self.multiline = max(0, self.multiline - 1)</span>
<span class="gi">+            elif c == &#39;;&#39;:</span>
<span class="gi">+                return self._get_comment()</span>
<span class="gi">+            return Token(DELIMITER, c)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._get_identifier(c)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_quoted_string(self) -&gt;Token:</span>
<span class="gi">+        value = &#39;&#39;</span>
<span class="gi">+        while True:</span>
<span class="gi">+            c = self._get_char()</span>
<span class="gi">+            if c == &#39;&#39;:</span>
<span class="gi">+                raise dns.exception.SyntaxError(&#39;Unexpected end of input in quoted string&#39;)</span>
<span class="gi">+            if c == &#39;&quot;&#39;:</span>
<span class="gi">+                break</span>
<span class="gi">+            if c == &#39;\\&#39;:</span>
<span class="gi">+                c = self._get_char()</span>
<span class="gi">+                if c == &#39;&#39;:</span>
<span class="gi">+                    raise dns.exception.SyntaxError(&#39;Unexpected end of input in quoted string&#39;)</span>
<span class="gi">+            value += c</span>
<span class="gi">+        return Token(QUOTED_STRING, value, True)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_comment(self) -&gt;Token:</span>
<span class="gi">+        comment = &#39;&#39;</span>
<span class="gi">+        while True:</span>
<span class="gi">+            c = self._get_char()</span>
<span class="gi">+            if c == &#39;&#39; or c == &#39;\n&#39;:</span>
<span class="gi">+                if c == &#39;\n&#39;:</span>
<span class="gi">+                    self._unget_char(c)</span>
<span class="gi">+                break</span>
<span class="gi">+            comment += c</span>
<span class="gi">+        return Token(COMMENT, comment)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_identifier(self, initial: str) -&gt;Token:</span>
<span class="gi">+        value = initial</span>
<span class="gi">+        while True:</span>
<span class="gi">+            c = self._get_char()</span>
<span class="gi">+            if c == &#39;&#39; or c in self.delimiters:</span>
<span class="gi">+                if c != &#39;&#39;:</span>
<span class="gi">+                    self._unget_char(c)</span>
<span class="gi">+                break</span>
<span class="gi">+            value += c</span>
<span class="gi">+        return Token(IDENTIFIER, value)</span>

<span class="w"> </span>    def unget(self, token: Token) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Unget a token.
<span class="gu">@@ -190,14 +283,16 @@ class Tokenizer:</span>

<span class="w"> </span>        Raises UngetBufferFull: there is already an ungotten token
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ungotten_token is not None:</span>
<span class="gi">+            raise UngetBufferFull</span>
<span class="gi">+        self.ungotten_token = token</span>

<span class="w"> </span>    def next(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the next item in an iteration.

<span class="w"> </span>        Returns a Token.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get()</span>
<span class="w"> </span>    __next__ = next

<span class="w"> </span>    def __iter__(self):
<span class="gu">@@ -210,7 +305,13 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = self.get()</span>
<span class="gi">+        if token.ttype != IDENTIFIER:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Expected an identifier&#39;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return int(token.value, base)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Invalid integer&#39;)</span>

<span class="w"> </span>    def get_uint8(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as an 8-bit unsigned
<span class="gu">@@ -220,7 +321,10 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = self.get_int()</span>
<span class="gi">+        if value &lt; 0 or value &gt; 255:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Invalid 8-bit unsigned integer&#39;)</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    def get_uint16(self, base: int=10) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as a 16-bit unsigned
<span class="gu">@@ -230,7 +334,10 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = self.get_int(base)</span>
<span class="gi">+        if value &lt; 0 or value &gt; 65535:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Invalid 16-bit unsigned integer&#39;)</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    def get_uint32(self, base: int=10) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as a 32-bit unsigned
<span class="gu">@@ -240,7 +347,10 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = self.get_int(base)</span>
<span class="gi">+        if value &lt; 0 or value &gt; 4294967295:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Invalid 32-bit unsigned integer&#39;)</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    def get_uint48(self, base: int=10) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as a 48-bit unsigned
<span class="gu">@@ -250,7 +360,10 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value = self.get_int(base)</span>
<span class="gi">+        if value &lt; 0 or value &gt; 281474976710655:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Invalid 48-bit unsigned integer&#39;)</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    def get_string(self, max_length: Optional[int]=None) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as a string.
<span class="gu">@@ -261,7 +374,12 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = self.get()</span>
<span class="gi">+        if token.ttype not in (IDENTIFIER, QUOTED_STRING):</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Expected a string&#39;)</span>
<span class="gi">+        if max_length is not None and len(token.value) &gt; max_length:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;String length exceeds maximum&#39;)</span>
<span class="gi">+        return token.value</span>

<span class="w"> </span>    def get_identifier(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Read the next token, which should be an identifier.
<span class="gu">@@ -270,7 +388,10 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = self.get()</span>
<span class="gi">+        if token.ttype != IDENTIFIER:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Expected an identifier&#39;)</span>
<span class="gi">+        return token.value</span>

<span class="w"> </span>    def get_remaining(self, max_tokens: Optional[int]=None) -&gt;List[Token]:
<span class="w"> </span>        &quot;&quot;&quot;Return the remaining tokens on the line, until an EOL or EOF is seen.
<span class="gu">@@ -279,7 +400,16 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns a list of tokens.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tokens = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            token = self.get()</span>
<span class="gi">+            if token.ttype in (EOL, EOF):</span>
<span class="gi">+                self.unget(token)</span>
<span class="gi">+                break</span>
<span class="gi">+            tokens.append(token)</span>
<span class="gi">+            if max_tokens is not None and len(tokens) &gt;= max_tokens:</span>
<span class="gi">+                break</span>
<span class="gi">+        return tokens</span>

<span class="w"> </span>    def concatenate_remaining_identifiers(self, allow_empty: bool=False) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Read the remaining tokens on the line, which should be identifiers.
<span class="gu">@@ -293,7 +423,15 @@ class Tokenizer:</span>
<span class="w"> </span>        Returns a string containing a concatenation of the remaining
<span class="w"> </span>        identifiers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tokens = self.get_remaining()</span>
<span class="gi">+        if not tokens and not allow_empty:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;No remaining identifiers&#39;)</span>
<span class="gi">+        result = &#39;&#39;</span>
<span class="gi">+        for token in tokens:</span>
<span class="gi">+            if token.ttype != IDENTIFIER:</span>
<span class="gi">+                raise dns.exception.SyntaxError(&#39;Expected an identifier&#39;)</span>
<span class="gi">+            result += token.value</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def as_name(self, token: Token, origin: Optional[dns.name.Name]=None,
<span class="w"> </span>        relativize: bool=False, relativize_to: Optional[dns.name.Name]=None
<span class="gu">@@ -304,7 +442,15 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns a dns.name.Name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if token.ttype != IDENTIFIER:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Expected a name&#39;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            name = dns.name.from_text(token.value, origin, self.idna_codec)</span>
<span class="gi">+            if relativize:</span>
<span class="gi">+                name = name.relativize(relativize_to or origin)</span>
<span class="gi">+            return name</span>
<span class="gi">+        except dns.exception.DNSException:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Invalid name&#39;)</span>

<span class="w"> </span>    def get_name(self, origin: Optional[dns.name.Name]=None, relativize:
<span class="w"> </span>        bool=False, relativize_to: Optional[dns.name.Name]=None
<span class="gu">@@ -315,7 +461,8 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns a dns.name.Name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = self.get()</span>
<span class="gi">+        return self.as_name(token, origin, relativize, relativize_to)</span>

<span class="w"> </span>    def get_eol_as_token(self) -&gt;Token:
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and raise an exception if it isn&#39;t EOL or
<span class="gu">@@ -323,7 +470,10 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = self.get()</span>
<span class="gi">+        if token.ttype not in (EOL, EOF):</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Expected EOL or EOF&#39;)</span>
<span class="gi">+        return token</span>

<span class="w"> </span>    def get_ttl(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Read the next token and interpret it as a DNS TTL.
<span class="gu">@@ -333,4 +483,10 @@ class Tokenizer:</span>

<span class="w"> </span>        Returns an int.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = self.get()</span>
<span class="gi">+        if token.ttype != IDENTIFIER:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Expected a TTL&#39;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return dns.ttl.from_text(token.value)</span>
<span class="gi">+        except dns.ttl.BadTTL:</span>
<span class="gi">+            raise dns.exception.SyntaxError(&#39;Invalid TTL&#39;)</span>
<span class="gh">diff --git a/dns/transaction.py b/dns/transaction.py</span>
<span class="gh">index 3acb2f4..f1b34eb 100644</span>
<span class="gd">--- a/dns/transaction.py</span>
<span class="gi">+++ b/dns/transaction.py</span>
<span class="gu">@@ -101,14 +101,19 @@ class Transaction:</span>

<span class="w"> </span>        Note that the returned rdataset is immutable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        name = dns.name.from_text(name) if isinstance(name, str) else name</span>
<span class="gi">+        rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+        covers = dns.rdatatype.RdataType.make(covers)</span>
<span class="gi">+        return self._get_rdataset(name, rdtype, covers)</span>

<span class="w"> </span>    def get_node(self, name: dns.name.Name) -&gt;Optional[dns.node.Node]:
<span class="w"> </span>        &quot;&quot;&quot;Return the node at *name*, if any.

<span class="w"> </span>        Returns an immutable node or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        return self._get_node(name)</span>

<span class="w"> </span>    def add(self, *args: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add records.
<span class="gu">@@ -121,7 +126,28 @@ class Transaction:</span>

<span class="w"> </span>            - name, ttl, rdata...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        if self.read_only:</span>
<span class="gi">+            raise ReadOnly</span>
<span class="gi">+</span>
<span class="gi">+        if len(args) == 1:</span>
<span class="gi">+            rrset = args[0]</span>
<span class="gi">+            self._put_rdataset(rrset.name, rrset)</span>
<span class="gi">+        elif len(args) == 2:</span>
<span class="gi">+            name, rdataset = args</span>
<span class="gi">+            self._put_rdataset(name, rdataset)</span>
<span class="gi">+        elif len(args) &gt;= 3:</span>
<span class="gi">+            name, ttl = args[:2]</span>
<span class="gi">+            if isinstance(name, str):</span>
<span class="gi">+                name = dns.name.from_text(name, None)</span>
<span class="gi">+            rdtype = args[2]</span>
<span class="gi">+            if isinstance(rdtype, str):</span>
<span class="gi">+                rdtype = dns.rdatatype.from_text(rdtype)</span>
<span class="gi">+            rdata = args[3:]</span>
<span class="gi">+            rdataset = dns.rdataset.from_rdata_list(ttl, rdata)</span>
<span class="gi">+            self._put_rdataset(name, rdataset)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;add() requires at least one argument&quot;)</span>

<span class="w"> </span>    def replace(self, *args: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Replace the existing rdataset at the name with the specified
<span class="gu">@@ -140,7 +166,31 @@ class Transaction:</span>
<span class="w"> </span>        a delete of the name followed by one or more calls to add() or
<span class="w"> </span>        replace().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        if self.read_only:</span>
<span class="gi">+            raise ReadOnly</span>
<span class="gi">+</span>
<span class="gi">+        if len(args) == 1:</span>
<span class="gi">+            rrset = args[0]</span>
<span class="gi">+            self._delete_rdataset(rrset.name, rrset.rdtype, rrset.covers)</span>
<span class="gi">+            self._put_rdataset(rrset.name, rrset)</span>
<span class="gi">+        elif len(args) == 2:</span>
<span class="gi">+            name, rdataset = args</span>
<span class="gi">+            self._delete_rdataset(name, rdataset.rdtype, rdataset.covers)</span>
<span class="gi">+            self._put_rdataset(name, rdataset)</span>
<span class="gi">+        elif len(args) &gt;= 3:</span>
<span class="gi">+            name, ttl = args[:2]</span>
<span class="gi">+            if isinstance(name, str):</span>
<span class="gi">+                name = dns.name.from_text(name, None)</span>
<span class="gi">+            rdtype = args[2]</span>
<span class="gi">+            if isinstance(rdtype, str):</span>
<span class="gi">+                rdtype = dns.rdatatype.from_text(rdtype)</span>
<span class="gi">+            rdata = args[3:]</span>
<span class="gi">+            rdataset = dns.rdataset.from_rdata_list(ttl, rdata)</span>
<span class="gi">+            self._delete_rdataset(name, rdtype, dns.rdatatype.NONE)</span>
<span class="gi">+            self._put_rdataset(name, rdataset)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;replace() requires at least one argument&quot;)</span>

<span class="w"> </span>    def delete(self, *args: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Delete records.
<span class="gu">@@ -160,7 +210,35 @@ class Transaction:</span>

<span class="w"> </span>            - name, rdata...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_ended()</span>
<span class="gi">+        if self.read_only:</span>
<span class="gi">+            raise ReadOnly</span>
<span class="gi">+</span>
<span class="gi">+        if len(args) == 1:</span>
<span class="gi">+            arg = args[0]</span>
<span class="gi">+            if isinstance(arg, dns.rrset.RRset):</span>
<span class="gi">+                self._delete_rdataset(arg.name, arg.rdtype, arg.covers)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._delete_name(arg)</span>
<span class="gi">+        elif len(args) == 2:</span>
<span class="gi">+            name, rdataset = args</span>
<span class="gi">+            self._delete_rdataset(name, rdataset.rdtype, rdataset.covers)</span>
<span class="gi">+        elif len(args) &gt;= 3:</span>
<span class="gi">+            name = args[0]</span>
<span class="gi">+            if isinstance(name, str):</span>
<span class="gi">+                name = dns.name.from_text(name, None)</span>
<span class="gi">+            rdtype = args[1]</span>
<span class="gi">+            if isinstance(rdtype, str):</span>
<span class="gi">+                rdtype = dns.rdatatype.from_text(rdtype)</span>
<span class="gi">+            if len(args) == 3:</span>
<span class="gi">+                covers = args[2]</span>
<span class="gi">+                if isinstance(covers, str):</span>
<span class="gi">+                    covers = dns.rdatatype.from_text(covers)</span>
<span class="gi">+            else:</span>
<span class="gi">+                covers = dns.rdatatype.NONE</span>
<span class="gi">+            self._delete_rdataset(name, rdtype, covers)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;delete() requires at least one argument&quot;)</span>

<span class="w"> </span>    def delete_exact(self, *args: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Delete records.
<span class="gh">diff --git a/dns/tsig.py b/dns/tsig.py</span>
<span class="gh">index 38ac6a5..d5315d3 100644</span>
<span class="gd">--- a/dns/tsig.py</span>
<span class="gi">+++ b/dns/tsig.py</span>
<span class="gu">@@ -128,7 +128,30 @@ def _digest(wire, key, rdata, time=None, request_mac=None, ctx=None, multi=None</span>
<span class="w"> </span>    @raises ValueError: I{other_data} is too long
<span class="w"> </span>    @raises NotImplementedError: I{algorithm} is not supported
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(key, Key):</span>
<span class="gi">+        if key.algorithm == GSS_TSIG:</span>
<span class="gi">+            ctx = GSSTSig(key.secret)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ctx = HMACTSig(key.secret, key.algorithm)</span>
<span class="gi">+    elif ctx is None:</span>
<span class="gi">+        raise ValueError(&quot;A key or context must be specified&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(ctx, GSSTSig):</span>
<span class="gi">+        if time is None:</span>
<span class="gi">+            time = rdata.time_signed</span>
<span class="gi">+        ctx.gssapi_context.verify_mic(wire, request_mac)</span>
<span class="gi">+        return ctx</span>
<span class="gi">+    </span>
<span class="gi">+    if time is None:</span>
<span class="gi">+        time = rdata.time_signed</span>
<span class="gi">+    time_bytes = struct.pack(&quot;!H&quot;, time)</span>
<span class="gi">+    ctx.hmac_context.update(wire)</span>
<span class="gi">+    ctx.hmac_context.update(rdata.to_wire())</span>
<span class="gi">+    ctx.hmac_context.update(time_bytes)</span>
<span class="gi">+    if request_mac is not None:</span>
<span class="gi">+        ctx.hmac_context.update(request_mac)</span>
<span class="gi">+    </span>
<span class="gi">+    return ctx</span>


<span class="w"> </span>def _maybe_start_digest(key, mac, multi):
<span class="gu">@@ -136,7 +159,17 @@ def _maybe_start_digest(key, mac, multi):</span>
<span class="w"> </span>    start a new context.
<span class="w"> </span>    @rtype: dns.tsig.HMACTSig or dns.tsig.GSSTSig object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if multi:</span>
<span class="gi">+        if isinstance(key, Key):</span>
<span class="gi">+            if key.algorithm == GSS_TSIG:</span>
<span class="gi">+                ctx = GSSTSig(key.secret)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ctx = HMACTSig(key.secret, key.algorithm)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ctx = key</span>
<span class="gi">+        ctx.hmac_context.update(mac)</span>
<span class="gi">+        return ctx</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def sign(wire, key, rdata, time=None, request_mac=None, ctx=None, multi=False):
<span class="gu">@@ -147,7 +180,19 @@ def sign(wire, key, rdata, time=None, request_mac=None, ctx=None, multi=False):</span>
<span class="w"> </span>    @raises ValueError: I{other_data} is too long
<span class="w"> </span>    @raises NotImplementedError: I{algorithm} is not supported
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ctx = _digest(wire, key, rdata, time, request_mac, ctx, multi)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(ctx, GSSTSig):</span>
<span class="gi">+        mac = ctx.gssapi_context.get_mic(wire)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if ctx.size:</span>
<span class="gi">+            mac = ctx.hmac_context.digest()[:ctx.size // 8]</span>
<span class="gi">+        else:</span>
<span class="gi">+            mac = ctx.hmac_context.digest()</span>
<span class="gi">+    </span>
<span class="gi">+    rdata.mac = mac</span>
<span class="gi">+    </span>
<span class="gi">+    return (rdata.to_wire(), mac, ctx)</span>


<span class="w"> </span>def validate(wire, key, owner, rdata, now, request_mac, tsig_start, ctx=
<span class="gu">@@ -159,7 +204,35 @@ def validate(wire, key, owner, rdata, now, request_mac, tsig_start, ctx=</span>
<span class="w"> </span>    server.
<span class="w"> </span>    @raises BadSignature: The TSIG signature did not validate
<span class="w"> </span>    @rtype: dns.tsig.HMACTSig or dns.tsig.GSSTSig object&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(key, Key):</span>
<span class="gi">+        if key.name != owner:</span>
<span class="gi">+            raise BadKey</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(key, Key) and key.algorithm != rdata.algorithm:</span>
<span class="gi">+        raise BadAlgorithm</span>
<span class="gi">+    </span>
<span class="gi">+    time_low = now - 300</span>
<span class="gi">+    time_high = now + 300</span>
<span class="gi">+    if rdata.time_signed &lt; time_low or rdata.time_signed &gt; time_high:</span>
<span class="gi">+        raise BadTime</span>
<span class="gi">+    </span>
<span class="gi">+    ctx = _digest(wire[:tsig_start], key, rdata, rdata.time_signed, request_mac, ctx, multi)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(ctx, GSSTSig):</span>
<span class="gi">+        try:</span>
<span class="gi">+            ctx.gssapi_context.verify_mic(wire[:tsig_start], rdata.mac)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise BadSignature</span>
<span class="gi">+    else:</span>
<span class="gi">+        if ctx.size:</span>
<span class="gi">+            computed_mac = ctx.hmac_context.digest()[:ctx.size // 8]</span>
<span class="gi">+        else:</span>
<span class="gi">+            computed_mac = ctx.hmac_context.digest()</span>
<span class="gi">+        </span>
<span class="gi">+        if computed_mac != rdata.mac:</span>
<span class="gi">+            raise BadSignature</span>
<span class="gi">+    </span>
<span class="gi">+    return ctx</span>


<span class="w"> </span>def get_context(key):
<span class="gu">@@ -168,7 +241,13 @@ def get_context(key):</span>
<span class="w"> </span>    @rtype: HMAC context
<span class="w"> </span>    @raises NotImplementedError: I{algorithm} is not supported
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(key, Key):</span>
<span class="gi">+        if key.algorithm == GSS_TSIG:</span>
<span class="gi">+            return GSSTSig(key.secret)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return HMACTSig(key.secret, key.algorithm)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;A Key object must be specified&quot;)</span>


<span class="w"> </span>class Key:
<span class="gh">diff --git a/dns/tsigkeyring.py b/dns/tsigkeyring.py</span>
<span class="gh">index 83df7bd..1393367 100644</span>
<span class="gd">--- a/dns/tsigkeyring.py</span>
<span class="gi">+++ b/dns/tsigkeyring.py</span>
<span class="gu">@@ -11,7 +11,21 @@ def from_text(textring: Dict[str, Any]) -&gt;Dict[dns.name.Name, dns.tsig.Key]:</span>
<span class="w"> </span>    a dictionary containing (textual DNS name, (algorithm, base64 secret))
<span class="w"> </span>    pairs into a binary keyring which has (dns.name.Name, dns.tsig.Key) pairs.
<span class="w"> </span>    @rtype: dict&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    keyring = {}</span>
<span class="gi">+    for name, value in textring.items():</span>
<span class="gi">+        key_name = dns.name.from_text(name)</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            # Case 1: (textual DNS name, base64 secret)</span>
<span class="gi">+            secret = base64.b64decode(value)</span>
<span class="gi">+            keyring[key_name] = secret</span>
<span class="gi">+        elif isinstance(value, tuple) and len(value) == 2:</span>
<span class="gi">+            # Case 2: (textual DNS name, (algorithm, base64 secret))</span>
<span class="gi">+            algorithm, secret = value</span>
<span class="gi">+            key = dns.tsig.Key(algorithm, base64.b64decode(secret))</span>
<span class="gi">+            keyring[key_name] = key</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid value for key {name}&quot;)</span>
<span class="gi">+    return keyring</span>


<span class="w"> </span>def to_text(keyring: Dict[dns.name.Name, Any]) -&gt;Dict[str, Any]:
<span class="gu">@@ -20,4 +34,17 @@ def to_text(keyring: Dict[dns.name.Name, Any]) -&gt;Dict[str, Any]:</span>
<span class="w"> </span>    base64 secret)) pairs, or a dictionary containing (dns.name.Name, bytes)
<span class="w"> </span>    pairs into a text keyring which has (textual DNS name, base64 secret) pairs.
<span class="w"> </span>    @rtype: dict&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    textring = {}</span>
<span class="gi">+    for name, value in keyring.items():</span>
<span class="gi">+        text_name = name.to_text()</span>
<span class="gi">+        if isinstance(value, bytes):</span>
<span class="gi">+            # Case 1: (dns.name.Name, bytes)</span>
<span class="gi">+            textring[text_name] = base64.b64encode(value).decode(&#39;ascii&#39;)</span>
<span class="gi">+        elif isinstance(value, dns.tsig.Key):</span>
<span class="gi">+            # Case 2: (dns.name.Name, dns.tsig.Key)</span>
<span class="gi">+            algorithm = value.algorithm</span>
<span class="gi">+            secret = base64.b64encode(value.secret).decode(&#39;ascii&#39;)</span>
<span class="gi">+            textring[text_name] = (algorithm, secret)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid value for key {name}&quot;)</span>
<span class="gi">+    return textring</span>
<span class="gh">diff --git a/dns/ttl.py b/dns/ttl.py</span>
<span class="gh">index 0ade6bc..67fd19e 100644</span>
<span class="gd">--- a/dns/ttl.py</span>
<span class="gi">+++ b/dns/ttl.py</span>
<span class="gu">@@ -19,4 +19,41 @@ def from_text(text: str) -&gt;int:</span>

<span class="w"> </span>    Returns an ``int``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not text:</span>
<span class="gi">+        raise BadTTL(&quot;TTL cannot be empty&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    total_seconds = 0</span>
<span class="gi">+    current_value = &quot;&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    for char in text:</span>
<span class="gi">+        if char.isdigit():</span>
<span class="gi">+            current_value += char</span>
<span class="gi">+        elif char.isalpha():</span>
<span class="gi">+            if not current_value:</span>
<span class="gi">+                raise BadTTL(f&quot;Invalid TTL format: {text}&quot;)</span>
<span class="gi">+            </span>
<span class="gi">+            value = int(current_value)</span>
<span class="gi">+            current_value = &quot;&quot;</span>
<span class="gi">+            </span>
<span class="gi">+            if char == &#39;w&#39;:</span>
<span class="gi">+                total_seconds += value * 7 * 24 * 3600</span>
<span class="gi">+            elif char == &#39;d&#39;:</span>
<span class="gi">+                total_seconds += value * 24 * 3600</span>
<span class="gi">+            elif char == &#39;h&#39;:</span>
<span class="gi">+                total_seconds += value * 3600</span>
<span class="gi">+            elif char == &#39;m&#39;:</span>
<span class="gi">+                total_seconds += value * 60</span>
<span class="gi">+            elif char == &#39;s&#39;:</span>
<span class="gi">+                total_seconds += value</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise BadTTL(f&quot;Invalid unit: {char}&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise BadTTL(f&quot;Invalid character in TTL: {char}&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if current_value:</span>
<span class="gi">+        total_seconds += int(current_value)</span>
<span class="gi">+    </span>
<span class="gi">+    if total_seconds &gt; MAX_TTL:</span>
<span class="gi">+        raise BadTTL(f&quot;TTL value {total_seconds} is greater than maximum allowed value {MAX_TTL}&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    return total_seconds</span>
<span class="gh">diff --git a/dns/update.py b/dns/update.py</span>
<span class="gh">index d53b842..2d56fb7 100644</span>
<span class="gd">--- a/dns/update.py</span>
<span class="gi">+++ b/dns/update.py</span>
<span class="gu">@@ -57,12 +57,12 @@ class UpdateMessage(dns.message.Message):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def zone(self) -&gt;List[dns.rrset.RRset]:
<span class="w"> </span>        &quot;&quot;&quot;The zone section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[self._section_enum.ZONE]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def prerequisite(self) -&gt;List[dns.rrset.RRset]:
<span class="w"> </span>        &quot;&quot;&quot;The prerequisite section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.sections[self._section_enum.PREREQ]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def update(self) -&gt;List[dns.rrset.RRset]:
<span class="gu">@@ -71,7 +71,11 @@ class UpdateMessage(dns.message.Message):</span>

<span class="w"> </span>    def _add_rr(self, name, ttl, rd, deleting=None, section=None):
<span class="w"> </span>        &quot;&quot;&quot;Add a single RR to the update section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if section is None:</span>
<span class="gi">+            section = self.update</span>
<span class="gi">+        rrset = self.find_rrset(section, name, rd.rdclass, rd.rdtype,</span>
<span class="gi">+                                deleting, True, True)</span>
<span class="gi">+        rrset.add(rd, ttl)</span>

<span class="w"> </span>    def _add(self, replace, section, name, *args):
<span class="w"> </span>        &quot;&quot;&quot;Add records.
<span class="gu">@@ -88,7 +92,24 @@ class UpdateMessage(dns.message.Message):</span>

<span class="w"> </span>                - ttl, rdtype, string...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        if isinstance(args[0], dns.rdataset.Rdataset):</span>
<span class="gi">+            rdataset = args[0]</span>
<span class="gi">+            for rdata in rdataset:</span>
<span class="gi">+                self._add_rr(name, rdataset.ttl, rdata, replace, section)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ttl = args[0]</span>
<span class="gi">+            if isinstance(args[1], dns.rdata.Rdata):</span>
<span class="gi">+                rdata = args[1]</span>
<span class="gi">+                self._add_rr(name, ttl, rdata, replace, section)</span>
<span class="gi">+            else:</span>
<span class="gi">+                rdtype = args[1]</span>
<span class="gi">+                rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+                rdata = dns.rdata.from_text(self.zone_rdclass, rdtype,</span>
<span class="gi">+                                            args[2], origin=self.origin,</span>
<span class="gi">+                                            relativize=False)</span>
<span class="gi">+                self._add_rr(name, ttl, rdata, replace, section)</span>

<span class="w"> </span>    def add(self, name: Union[dns.name.Name, str], *args: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add records.
<span class="gu">@@ -102,7 +123,7 @@ class UpdateMessage(dns.message.Message):</span>

<span class="w"> </span>                - ttl, rdtype, string...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._add(False, self.update, name, *args)</span>

<span class="w"> </span>    def delete(self, name: Union[dns.name.Name, str], *args: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Delete records.
<span class="gu">@@ -118,7 +139,39 @@ class UpdateMessage(dns.message.Message):</span>

<span class="w"> </span>                - rdtype, [string...]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        if len(args) == 0:</span>
<span class="gi">+            rrset = self.find_rrset(self.update, name, dns.rdataclass.ANY,</span>
<span class="gi">+                                    dns.rdatatype.ANY, True, True)</span>
<span class="gi">+        elif isinstance(args[0], dns.rdataset.Rdataset):</span>
<span class="gi">+            rrset = self.find_rrset(self.update, name,</span>
<span class="gi">+                                    args[0].rdclass,</span>
<span class="gi">+                                    args[0].rdtype,</span>
<span class="gi">+                                    True, True)</span>
<span class="gi">+            for rd in args[0]:</span>
<span class="gi">+                rrset.add(rd)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(args[0], dns.rdata.Rdata):</span>
<span class="gi">+                rdclass = args[0].rdclass</span>
<span class="gi">+                rdtype = args[0].rdtype</span>
<span class="gi">+                args = args[:]</span>
<span class="gi">+                rd = args.pop(0)</span>
<span class="gi">+                rrset = self.find_rrset(self.update, name,</span>
<span class="gi">+                                        rdclass, rdtype,</span>
<span class="gi">+                                        True, True)</span>
<span class="gi">+                rrset.add(rd)</span>
<span class="gi">+            else:</span>
<span class="gi">+                rdtype = args[0]</span>
<span class="gi">+                rdclass = self.zone_rdclass</span>
<span class="gi">+                rrset = self.find_rrset(self.update, name,</span>
<span class="gi">+                                        rdclass, rdtype,</span>
<span class="gi">+                                        True, True)</span>
<span class="gi">+            for arg in args[1:]:</span>
<span class="gi">+                rd = dns.rdata.from_text(rdclass, rdtype, arg,</span>
<span class="gi">+                                         origin=self.origin,</span>
<span class="gi">+                                         relativize=False)</span>
<span class="gi">+                rrset.add(rd)</span>

<span class="w"> </span>    def replace(self, name: Union[dns.name.Name, str], *args: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Replace records.
<span class="gu">@@ -135,7 +188,7 @@ class UpdateMessage(dns.message.Message):</span>
<span class="w"> </span>        Note that if you want to replace the entire node, you should do
<span class="w"> </span>        a delete of the name followed by one or more calls to add.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._add(True, self.update, name, *args)</span>

<span class="w"> </span>    def present(self, name: Union[dns.name.Name, str], *args: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Require that an owner name (and optionally an rdata type,
<span class="gu">@@ -151,13 +204,58 @@ class UpdateMessage(dns.message.Message):</span>

<span class="w"> </span>                - rdtype, string...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        if len(args) == 0:</span>
<span class="gi">+            rrset = self.find_rrset(self.prerequisite, name,</span>
<span class="gi">+                                    dns.rdataclass.ANY,</span>
<span class="gi">+                                    dns.rdatatype.ANY,</span>
<span class="gi">+                                    False, True, True)</span>
<span class="gi">+        elif isinstance(args[0], dns.rdataset.Rdataset):</span>
<span class="gi">+            rrset = self.find_rrset(self.prerequisite, name,</span>
<span class="gi">+                                    self.zone_rdclass,</span>
<span class="gi">+                                    args[0].rdtype,</span>
<span class="gi">+                                    False, True, True)</span>
<span class="gi">+            for rd in args[0]:</span>
<span class="gi">+                rrset.add(rd)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(args[0], dns.rdata.Rdata):</span>
<span class="gi">+                rdclass = self.zone_rdclass</span>
<span class="gi">+                rdtype = args[0].rdtype</span>
<span class="gi">+                args = args[:]</span>
<span class="gi">+                rdata = args.pop(0)</span>
<span class="gi">+                rrset = self.find_rrset(self.prerequisite, name,</span>
<span class="gi">+                                        rdclass, rdtype,</span>
<span class="gi">+                                        False, True, True)</span>
<span class="gi">+                rrset.add(rdata)</span>
<span class="gi">+            else:</span>
<span class="gi">+                rdtype = args[0]</span>
<span class="gi">+                rdclass = self.zone_rdclass</span>
<span class="gi">+                rrset = self.find_rrset(self.prerequisite, name,</span>
<span class="gi">+                                        rdclass, rdtype,</span>
<span class="gi">+                                        False, True, True)</span>
<span class="gi">+            for arg in args[1:]:</span>
<span class="gi">+                rdata = dns.rdata.from_text(rdclass, rdtype, arg,</span>
<span class="gi">+                                            origin=self.origin,</span>
<span class="gi">+                                            relativize=False)</span>
<span class="gi">+                rrset.add(rdata)</span>

<span class="w"> </span>    def absent(self, name: Union[dns.name.Name, str], rdtype: Optional[
<span class="w"> </span>        Union[dns.rdatatype.RdataType, str]]=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Require that an owner name (and optionally an rdata type) does
<span class="w"> </span>        not exist as a prerequisite to the execution of the update.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(name, str):</span>
<span class="gi">+            name = dns.name.from_text(name, None)</span>
<span class="gi">+        if rdtype is None:</span>
<span class="gi">+            rrset = self.find_rrset(self.prerequisite, name,</span>
<span class="gi">+                                    dns.rdataclass.NONE,</span>
<span class="gi">+                                    dns.rdatatype.ANY,</span>
<span class="gi">+                                    False, True, True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+            rrset = self.find_rrset(self.prerequisite, name,</span>
<span class="gi">+                                    dns.rdataclass.NONE,</span>
<span class="gi">+                                    rdtype, False, True, True)</span>


<span class="w"> </span>Update = UpdateMessage
<span class="gh">diff --git a/dns/versioned.py b/dns/versioned.py</span>
<span class="gh">index d716a34..f8ef94b 100644</span>
<span class="gd">--- a/dns/versioned.py</span>
<span class="gi">+++ b/dns/versioned.py</span>
<span class="gu">@@ -67,7 +67,12 @@ class Zone(dns.zone.Zone):</span>
<span class="w"> </span>        &quot;&quot;&quot;Set a pruning policy that retains up to the specified number
<span class="w"> </span>        of versions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if max_versions is None:</span>
<span class="gi">+            self._pruning_policy = self._default_pruning_policy</span>
<span class="gi">+        else:</span>
<span class="gi">+            def max_versions_policy(zone: &#39;Zone&#39;, version: Version) -&gt; Optional[bool]:</span>
<span class="gi">+                return len(zone._versions) &gt; max_versions</span>
<span class="gi">+            self._pruning_policy = max_versions_policy</span>

<span class="w"> </span>    def set_pruning_policy(self, policy: Optional[Callable[[&#39;Zone&#39;, Version
<span class="w"> </span>        ], Optional[bool]]]) -&gt;None:
<span class="gu">@@ -82,4 +87,7 @@ class Zone(dns.zone.Zone):</span>
<span class="w"> </span>        time the function returns `False`, the checking stops.  I.e. the
<span class="w"> </span>        retained versions are always a consecutive sequence.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if policy is None:</span>
<span class="gi">+            self._pruning_policy = self._default_pruning_policy</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._pruning_policy = policy</span>
<span class="gh">diff --git a/dns/win32util.py b/dns/win32util.py</span>
<span class="gh">index aee6d5a..417414f 100644</span>
<span class="gd">--- a/dns/win32util.py</span>
<span class="gi">+++ b/dns/win32util.py</span>
<span class="gu">@@ -32,6 +32,20 @@ if sys.platform == &#39;win32&#39;:</span>
<span class="w"> </span>            def __init__(self):
<span class="w"> </span>                super().__init__()
<span class="w"> </span>                self.info = DnsInfo()
<span class="gi">+</span>
<span class="gi">+            def run(self):</span>
<span class="gi">+                pythoncom.CoInitialize()</span>
<span class="gi">+                try:</span>
<span class="gi">+                    c = wmi.WMI()</span>
<span class="gi">+                    for interface in c.Win32_NetworkAdapterConfiguration(IPEnabled=True):</span>
<span class="gi">+                        if interface.DNSDomain:</span>
<span class="gi">+                            self.info.domain = interface.DNSDomain</span>
<span class="gi">+                        if interface.DNSServerSearchOrder:</span>
<span class="gi">+                            self.info.nameservers.extend(interface.DNSServerSearchOrder)</span>
<span class="gi">+                        if interface.DNSDomainSuffixSearchOrder:</span>
<span class="gi">+                            self.info.search.extend(interface.DNSDomainSuffixSearchOrder)</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    pythoncom.CoUninitialize()</span>
<span class="w"> </span>    else:


<span class="gu">@@ -46,7 +60,36 @@ if sys.platform == &#39;win32&#39;:</span>

<span class="w"> </span>        def get(self):
<span class="w"> </span>            &quot;&quot;&quot;Extract resolver configuration from the Windows registry.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,</span>
<span class="gi">+                                    r&#39;SYSTEM\CurrentControlSet\Services\Tcpip\Parameters&#39;) as key:</span>
<span class="gi">+                    self.info.domain = winreg.QueryValueEx(key, &#39;Domain&#39;)[0]</span>
<span class="gi">+            except WindowsError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,</span>
<span class="gi">+                                    r&#39;SYSTEM\CurrentControlSet\Services\Tcpip\Parameters&#39;) as key:</span>
<span class="gi">+                    search = winreg.QueryValueEx(key, &#39;SearchList&#39;)[0]</span>
<span class="gi">+                    self.info.search = search.split(&#39;,&#39;)</span>
<span class="gi">+            except WindowsError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,</span>
<span class="gi">+                                    r&#39;SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces&#39;) as key:</span>
<span class="gi">+                    for i in range(winreg.QueryInfoKey(key)[0]):</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            interface_key = winreg.OpenKey(key, winreg.EnumKey(key, i))</span>
<span class="gi">+                            nameservers = winreg.QueryValueEx(interface_key, &#39;NameServer&#39;)[0]</span>
<span class="gi">+                            if nameservers:</span>
<span class="gi">+                                self.info.nameservers.extend(nameservers.split(&#39;,&#39;))</span>
<span class="gi">+                        except WindowsError:</span>
<span class="gi">+                            pass</span>
<span class="gi">+            except WindowsError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+            return self.info</span>
<span class="w"> </span>    _getter_class: Any
<span class="w"> </span>    if _have_wmi and _prefer_wmi:
<span class="w"> </span>        _getter_class = _WMIGetter
<span class="gu">@@ -55,4 +98,10 @@ if sys.platform == &#39;win32&#39;:</span>

<span class="w"> </span>    def get_dns_info():
<span class="w"> </span>        &quot;&quot;&quot;Extract resolver configuration.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        getter = _getter_class()</span>
<span class="gi">+        if isinstance(getter, _WMIGetter):</span>
<span class="gi">+            getter.start()</span>
<span class="gi">+            getter.join()</span>
<span class="gi">+        else:</span>
<span class="gi">+            getter.get()</span>
<span class="gi">+        return getter.info</span>
<span class="gh">diff --git a/dns/xfr.py b/dns/xfr.py</span>
<span class="gh">index 3d6d66f..4207cb7 100644</span>
<span class="gd">--- a/dns/xfr.py</span>
<span class="gi">+++ b/dns/xfr.py</span>
<span class="gu">@@ -74,7 +74,49 @@ class Inbound:</span>

<span class="w"> </span>        Returns `True` if the transfer is complete, and `False` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if message.rcode() != dns.rcode.NOERROR:</span>
<span class="gi">+            raise TransferError(message.rcode())</span>
<span class="gi">+</span>
<span class="gi">+        if self.done:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        for rrset in message.answer:</span>
<span class="gi">+            if rrset.rdtype == dns.rdatatype.SOA:</span>
<span class="gi">+                self._process_soa(rrset)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._process_rrset(rrset)</span>
<span class="gi">+</span>
<span class="gi">+        if self.done:</span>
<span class="gi">+            if self.txn:</span>
<span class="gi">+                self.txn.commit()</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _process_soa(self, rrset):</span>
<span class="gi">+        if self.soa_rdataset is None:</span>
<span class="gi">+            self.soa_rdataset = rrset</span>
<span class="gi">+            if self.txn is None:</span>
<span class="gi">+                self.txn = self.txn_manager.writer()</span>
<span class="gi">+            if self.rdtype == dns.rdatatype.IXFR:</span>
<span class="gi">+                if dns.serial.Serial(rrset[0].serial) &lt;= dns.serial.Serial(self.serial):</span>
<span class="gi">+                    raise SerialWentBackwards()</span>
<span class="gi">+                self.delete_mode = True</span>
<span class="gi">+            self.txn.replace(self.origin, rrset)</span>
<span class="gi">+        elif self.expecting_SOA:</span>
<span class="gi">+            self.expecting_SOA = False</span>
<span class="gi">+            if self.rdtype == dns.rdatatype.IXFR:</span>
<span class="gi">+                self.delete_mode = not self.delete_mode</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.done = True</span>
<span class="gi">+</span>
<span class="gi">+    def _process_rrset(self, rrset):</span>
<span class="gi">+        if self.txn is None:</span>
<span class="gi">+            self.txn = self.txn_manager.writer()</span>
<span class="gi">+        if self.delete_mode:</span>
<span class="gi">+            self.txn.delete(rrset.name, rrset)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.txn.add(rrset.name, rrset)</span>
<span class="gi">+        self.expecting_SOA = True</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -111,7 +153,34 @@ def make_query(txn_manager: dns.transaction.TransactionManager, serial:</span>

<span class="w"> </span>    Returns a `(query, serial)` tuple.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rdtype = dns.rdatatype.AXFR</span>
<span class="gi">+    current_serial = None</span>
<span class="gi">+    origin, _, _ = txn_manager.origin_information()</span>
<span class="gi">+</span>
<span class="gi">+    if serial is not None:</span>
<span class="gi">+        rdtype = dns.rdatatype.IXFR</span>
<span class="gi">+        if serial == 0:</span>
<span class="gi">+            with txn_manager.reader() as txn:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    current_serial = txn.get(origin, dns.rdatatype.SOA)[0].serial</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    rdtype = dns.rdatatype.AXFR</span>
<span class="gi">+        else:</span>
<span class="gi">+            current_serial = serial</span>
<span class="gi">+</span>
<span class="gi">+    query = dns.message.make_query(origin, rdtype, use_edns=use_edns,</span>
<span class="gi">+                                   ednsflags=ednsflags, payload=payload,</span>
<span class="gi">+                                   request_payload=request_payload,</span>
<span class="gi">+                                   options=options)</span>
<span class="gi">+</span>
<span class="gi">+    if rdtype == dns.rdatatype.IXFR:</span>
<span class="gi">+        query.authority = [dns.rrset.from_text(origin, 0, &#39;IN&#39;, &#39;SOA&#39;,</span>
<span class="gi">+                                               f&#39;{origin} 0 0 0 0 0 {current_serial}&#39;)]</span>
<span class="gi">+</span>
<span class="gi">+    if keyring is not None:</span>
<span class="gi">+        query.use_tsig(keyring, keyname, algorithm=keyalgorithm)</span>
<span class="gi">+</span>
<span class="gi">+    return query, current_serial</span>


<span class="w"> </span>def extract_serial_from_query(query: dns.message.Message) -&gt;Optional[int]:
<span class="gu">@@ -123,4 +192,24 @@ def extract_serial_from_query(query: dns.message.Message) -&gt;Optional[int]:</span>
<span class="w"> </span>    Raises if the query is not an IXFR or AXFR, or if an IXFR doesn&#39;t have
<span class="w"> </span>    an appropriate SOA RRset in the authority section.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(query, dns.message.QueryMessage):</span>
<span class="gi">+        raise ValueError(&quot;query must be a dns.message.QueryMessage&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if len(query.question) != 1:</span>
<span class="gi">+        raise ValueError(&quot;query must have exactly one question&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    qname, qtype, _ = query.question[0]</span>
<span class="gi">+</span>
<span class="gi">+    if qtype == dns.rdatatype.AXFR:</span>
<span class="gi">+        return None</span>
<span class="gi">+    elif qtype == dns.rdatatype.IXFR:</span>
<span class="gi">+        if len(query.authority) != 1:</span>
<span class="gi">+            raise ValueError(&quot;IXFR query must have exactly one SOA in the authority section&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        rrset = query.authority[0]</span>
<span class="gi">+        if rrset.rdtype != dns.rdatatype.SOA:</span>
<span class="gi">+            raise ValueError(&quot;IXFR authority section must contain an SOA record&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return rrset[0].serial</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;query must be an IXFR or AXFR request&quot;)</span>
<span class="gh">diff --git a/dns/zone.py b/dns/zone.py</span>
<span class="gh">index 464b98d..154fc9d 100644</span>
<span class="gd">--- a/dns/zone.py</span>
<span class="gi">+++ b/dns/zone.py</span>
<span class="gu">@@ -156,7 +156,14 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``dns.node.Node``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = self._validate_name(name)</span>
<span class="gi">+        node = self.nodes.get(name)</span>
<span class="gi">+        if node is None:</span>
<span class="gi">+            if not create:</span>
<span class="gi">+                raise KeyError(f&quot;Node &#39;{name}&#39; does not exist&quot;)</span>
<span class="gi">+            node = self.node_factory()</span>
<span class="gi">+            self.nodes[name] = node</span>
<span class="gi">+        return node</span>

<span class="w"> </span>    def get_node(self, name: Union[dns.name.Name, str], create: bool=False
<span class="w"> </span>        ) -&gt;Optional[dns.node.Node]:
<span class="gu">@@ -176,7 +183,10 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``dns.node.Node`` or ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.find_node(name, create)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return None</span>

<span class="w"> </span>    def delete_node(self, name: Union[dns.name.Name, str]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Delete the specified node if it exists.
<span class="gu">@@ -188,7 +198,9 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        It is not an error if the node does not exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = self._validate_name(name)</span>
<span class="gi">+        if name in self.nodes:</span>
<span class="gi">+            del self.nodes[name]</span>

<span class="w"> </span>    def find_rdataset(self, name: Union[dns.name.Name, str], rdtype: Union[
<span class="w"> </span>        dns.rdatatype.RdataType, str], covers: Union[dns.rdatatype.
<span class="gu">@@ -227,7 +239,17 @@ class Zone(dns.transaction.TransactionManager):</span>

<span class="w"> </span>        Returns a ``dns.rdataset.Rdataset``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node = self.find_node(name, create)</span>
<span class="gi">+        rdtype = dns.rdatatype.RdataType.make(rdtype)</span>
<span class="gi">+        covers = dns.rdatatype.RdataType.make(covers)</span>
<span class="gi">+        for rdataset in node.rdatasets:</span>
<span class="gi">+            if rdataset.rdtype == rdtype and rdataset.covers == covers:</span>
<span class="gi">+                return rdataset</span>
<span class="gi">+        if create:</span>
<span class="gi">+            rdataset = dns.rdataset.Rdataset(self.rdclass, rdtype, covers)</span>
<span class="gi">+            node.rdatasets.append(rdataset)</span>
<span class="gi">+            return rdataset</span>
<span class="gi">+        raise KeyError(f&quot;rdataset with rdtype &#39;{rdtype}&#39; and covers &#39;{covers}&#39; does not exist&quot;)</span>

<span class="w"> </span>    def get_rdataset(self, name: Union[dns.name.Name, str], rdtype: Union[
<span class="w"> </span>        dns.rdatatype.RdataType, str], covers: Union[dns.rdatatype.
<span class="gh">diff --git a/dns/zonefile.py b/dns/zonefile.py</span>
<span class="gh">index c5e5731..d7d42a4 100644</span>
<span class="gd">--- a/dns/zonefile.py</span>
<span class="gi">+++ b/dns/zonefile.py</span>
<span class="gu">@@ -74,12 +74,79 @@ class Reader:</span>

<span class="w"> </span>    def _rr_line(self):
<span class="w"> </span>        &quot;&quot;&quot;Process one line from a DNS zone file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = self.tok.get()</span>
<span class="gi">+        if token.is_whitespace():</span>
<span class="gi">+            token = self.tok.get()</span>
<span class="gi">+        if token.is_eol():</span>
<span class="gi">+            return</span>
<span class="gi">+        self.tok.unget(token)</span>
<span class="gi">+        </span>
<span class="gi">+        (name, ttl, rdclass, rdtype, covers) = self.tok.get_rr_header()</span>
<span class="gi">+        if self.force_name is not None:</span>
<span class="gi">+            name = self.force_name</span>
<span class="gi">+        if self.force_ttl is not None:</span>
<span class="gi">+            ttl = self.force_ttl</span>
<span class="gi">+        if self.force_rdclass is not None:</span>
<span class="gi">+            rdclass = self.force_rdclass</span>
<span class="gi">+        if self.force_rdtype is not None:</span>
<span class="gi">+            rdtype = self.force_rdtype</span>
<span class="gi">+        </span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            name = self.last_name</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.last_name = name</span>
<span class="gi">+        if ttl is None:</span>
<span class="gi">+            ttl = self.last_ttl</span>
<span class="gi">+            if ttl is None:</span>
<span class="gi">+                ttl = self.default_ttl</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.last_ttl = ttl</span>
<span class="gi">+        if rdclass is None:</span>
<span class="gi">+            rdclass = self.zone_rdclass</span>
<span class="gi">+        </span>
<span class="gi">+        token = self.tok.get()</span>
<span class="gi">+        if not token.is_identifier():</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+        </span>
<span class="gi">+        rd = dns.rdata.from_text(rdclass, rdtype, token.value,</span>
<span class="gi">+                                 origin=self.current_origin,</span>
<span class="gi">+                                 relativize=self.relativize)</span>
<span class="gi">+        self.txn.add(name, ttl, rd)</span>

<span class="w"> </span>    def _generate_line(self):
<span class="w"> </span>        &quot;&quot;&quot;Process one line containing the GENERATE statement from a DNS
<span class="w"> </span>        zone file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = self.tok.get()</span>
<span class="gi">+        if not token.is_identifier() or token.value != &#39;$GENERATE&#39;:</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+</span>
<span class="gi">+        start = self.tok.get().value</span>
<span class="gi">+        stop = self.tok.get().value</span>
<span class="gi">+        step = self.tok.get().value</span>
<span class="gi">+        pattern = self.tok.get().value</span>
<span class="gi">+        ttl = self.default_ttl</span>
<span class="gi">+        rdclass = self.zone_rdclass</span>
<span class="gi">+        rdtype = None</span>
<span class="gi">+        covers = dns.rdatatype.NONE</span>
<span class="gi">+</span>
<span class="gi">+        token = self.tok.get()</span>
<span class="gi">+        if token.is_identifier():</span>
<span class="gi">+            rdtype = dns.rdatatype.from_text(token.value)</span>
<span class="gi">+            token = self.tok.get()</span>
<span class="gi">+            if token.is_identifier():</span>
<span class="gi">+                covers = dns.rdatatype.from_text(token.value)</span>
<span class="gi">+        </span>
<span class="gi">+        if not token.is_eol_or_eof():</span>
<span class="gi">+            raise dns.exception.SyntaxError</span>
<span class="gi">+</span>
<span class="gi">+        for i in dns.grange.from_text(start, stop, step):</span>
<span class="gi">+            name = pattern.replace(&#39;$&#39;, str(i))</span>
<span class="gi">+            name = dns.name.from_text(name, self.current_origin)</span>
<span class="gi">+            rdata = pattern.replace(&#39;$&#39;, str(i))</span>
<span class="gi">+            rd = dns.rdata.from_text(rdclass, rdtype, rdata,</span>
<span class="gi">+                                     origin=self.current_origin,</span>
<span class="gi">+                                     relativize=self.relativize)</span>
<span class="gi">+            self.txn.add(name, ttl, rd)</span>

<span class="w"> </span>    def read(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Read a DNS zone file and build a zone object.
<span class="gu">@@ -87,7 +154,41 @@ class Reader:</span>
<span class="w"> </span>        @raises dns.zone.NoSOA: No SOA RR was found at the zone origin
<span class="w"> </span>        @raises dns.zone.NoNS: No NS RRset was found at the zone origin
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                token = self.tok.get(True, True)</span>
<span class="gi">+                if token.is_eof():</span>
<span class="gi">+                    break</span>
<span class="gi">+                if token.is_eol():</span>
<span class="gi">+                    continue</span>
<span class="gi">+                self.tok.unget(token)</span>
<span class="gi">+                if token.value == &#39;$GENERATE&#39;:</span>
<span class="gi">+                    self._generate_line()</span>
<span class="gi">+                elif token.value.startswith(&#39;$&#39;):</span>
<span class="gi">+                    self._directive_line()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._rr_line()</span>
<span class="gi">+        except dns.exception.SyntaxError:</span>
<span class="gi">+            raise</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise dns.exception.SyntaxError(f&quot;error reading zone: {e}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Check if SOA and NS records exist at the zone origin</span>
<span class="gi">+        has_soa = False</span>
<span class="gi">+        has_ns = False</span>
<span class="gi">+        for (name, rdataset) in self.txn._iterate_rdatasets():</span>
<span class="gi">+            if name == self.zone_origin:</span>
<span class="gi">+                if rdataset.rdtype == dns.rdatatype.SOA:</span>
<span class="gi">+                    has_soa = True</span>
<span class="gi">+                elif rdataset.rdtype == dns.rdatatype.NS:</span>
<span class="gi">+                    has_ns = True</span>
<span class="gi">+            if has_soa and has_ns:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if not has_soa:</span>
<span class="gi">+            raise dns.zone.NoSOA</span>
<span class="gi">+        if not has_ns:</span>
<span class="gi">+            raise dns.zone.NoNS</span>


<span class="w"> </span>class RRsetsReaderTransaction(dns.transaction.Transaction):
<span class="gu">@@ -165,4 +266,37 @@ def read_rrsets(text: Any, name: Optional[Union[dns.name.Name, str]]=None,</span>
<span class="w"> </span>    if ``False`` then any relative names in the input are made absolute by
<span class="w"> </span>    appending the *origin*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(text, str):</span>
<span class="gi">+        text = StringIO(text)</span>
<span class="gi">+    </span>
<span class="gi">+    tok = dns.tokenizer.Tokenizer(text, filename=&#39;&lt;string&gt;&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(origin, str):</span>
<span class="gi">+        origin = dns.name.from_text(origin, dns.name.root)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(default_rdclass, str):</span>
<span class="gi">+        default_rdclass = dns.rdataclass.from_text(default_rdclass)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(rdclass, str):</span>
<span class="gi">+        rdclass = dns.rdataclass.from_text(rdclass)</span>
<span class="gi">+    elif rdclass is None:</span>
<span class="gi">+        rdclass = default_rdclass</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(rdtype, str):</span>
<span class="gi">+        rdtype = dns.rdatatype.from_text(rdtype)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(ttl, str):</span>
<span class="gi">+        ttl = dns.ttl.from_text(ttl)</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(default_ttl, str):</span>
<span class="gi">+        default_ttl = dns.ttl.from_text(default_ttl)</span>
<span class="gi">+    </span>
<span class="gi">+    manager = RRSetsReaderManager(origin, relativize, rdclass)</span>
<span class="gi">+    with manager.transaction(True) as txn:</span>
<span class="gi">+        reader = Reader(tok, rdclass, txn, allow_include=False,</span>
<span class="gi">+                        allow_directives=False, force_name=name,</span>
<span class="gi">+                        force_ttl=ttl, force_rdclass=rdclass,</span>
<span class="gi">+                        force_rdtype=rdtype, default_ttl=default_ttl)</span>
<span class="gi">+        reader.read()</span>
<span class="gi">+    </span>
<span class="gi">+    return manager.rrsets</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>