
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands scrapy - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-scrapy" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands scrapy
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#initpycmdlinecrawlpipelinetesttest_open_spider_normally_in_pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      init.py::CmdlineCrawlPipelineTest::test_open_spider_normally_in_pipeline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_fetchpyfetchtesttest_headers" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_fetch.py::FetchTest::test_headers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_fetchpyfetchtesttest_output" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_fetch.py::FetchTest::test_output
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_fetchpyfetchtesttest_redirect_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_fetch.py::FetchTest::test_redirect_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_fetchpyfetchtesttest_redirect_disabled" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_fetch.py::FetchTest::test_redirect_disabled
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_dns_failures" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_dns_failures
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_fetch_redirect_follow_302" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_fetch_redirect_follow_302
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_fetch_redirect_not_follow_302" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_fetch_redirect_not_follow_302
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_local_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_local_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_local_nofile" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_local_nofile
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_redirect" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_redirect
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_redirect_follow_302" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_redirect_follow_302
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_redirect_not_follow_302" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_redirect_not_follow_302
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_request_replace" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_request_replace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_response_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_response_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_response_encoding_gb18030" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_response_encoding_gb18030
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_response_selector_html" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_response_selector_html
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_response_type_html" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_response_type_html
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_response_type_text" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_response_type_text
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_scrapy_import" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_scrapy_import
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyshelltesttest_shell_fetch_async" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::ShellTest::test_shell_fetch_async
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_shellpyinteractiveshelltesttest_fetch" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_shell.py::InteractiveShellTest::test_fetch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_versionpyversiontesttest_output" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_version.py::VersionTest::test_output
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_versionpyversiontesttest_verbose_output" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_version.py::VersionTest::test_verbose_output
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_downloadermiddleware_httpauthpyhttpauthmiddlewarelegacytesttest_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareLegacyTest::test_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_downloadermiddleware_httpauthpyhttpauthmiddlewarelegacytesttest_auth_already_set" class="md-nav__link">
    <span class="md-ellipsis">
      test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareLegacyTest::test_auth_already_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_downloadermiddleware_httpauthpyhttpauthmiddlewaretesttest_auth_already_set" class="md-nav__link">
    <span class="md-ellipsis">
      test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_auth_already_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_downloadermiddleware_httpauthpyhttpauthmiddlewaretesttest_auth_domain" class="md-nav__link">
    <span class="md-ellipsis">
      test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_auth_domain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_downloadermiddleware_httpauthpyhttpauthmiddlewaretesttest_auth_subdomain" class="md-nav__link">
    <span class="md-ellipsis">
      test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_auth_subdomain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_downloadermiddleware_httpauthpyhttpauthmiddlewaretesttest_no_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_no_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_downloadermiddleware_httpauthpyhttpauthanymiddlewaretesttest_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_downloadermiddleware_httpauth.py::HttpAuthAnyMiddlewareTest::test_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_downloadermiddleware_httpauthpyhttpauthanymiddlewaretesttest_auth_already_set" class="md-nav__link">
    <span class="md-ellipsis">
      test_downloadermiddleware_httpauth.py::HttpAuthAnyMiddlewareTest::test_auth_already_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspybaseitemexportertesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::BaseItemExporterTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspybaseitemexportertesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::BaseItemExporterTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspybaseitemexportertesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::BaseItemExporterTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspybaseitemexportertesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::BaseItemExporterTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspybaseitemexportertesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::BaseItemExporterTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspybaseitemexporterdataclasstesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::BaseItemExporterDataclassTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspybaseitemexporterdataclasstesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::BaseItemExporterDataclassTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspybaseitemexporterdataclasstesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::BaseItemExporterDataclassTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspybaseitemexporterdataclasstesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::BaseItemExporterDataclassTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspybaseitemexporterdataclasstesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::BaseItemExporterDataclassTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexportertesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexportertesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexportertesttest_export_item_dict_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterTest::test_export_item_dict_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexportertesttest_export_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterTest::test_export_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexportertesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexportertesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexportertesttest_invalid_option" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterTest::test_invalid_option
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexportertesttest_nested_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterTest::test_nested_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexportertesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexportertesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexporterdataclasstesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterDataclassTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexporterdataclasstesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterDataclassTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexporterdataclasstesttest_export_item_dict_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterDataclassTest::test_export_item_dict_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexporterdataclasstesttest_export_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterDataclassTest::test_export_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexporterdataclasstesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterDataclassTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexporterdataclasstesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterDataclassTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexporterdataclasstesttest_invalid_option" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterDataclassTest::test_invalid_option
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexporterdataclasstesttest_nested_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterDataclassTest::test_nested_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexporterdataclasstesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterDataclassTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypythonitemexporterdataclasstesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PythonItemExporterDataclassTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypprintitemexportertesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PprintItemExporterTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypprintitemexportertesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PprintItemExporterTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypprintitemexportertesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PprintItemExporterTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypprintitemexportertesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PprintItemExporterTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypprintitemexportertesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PprintItemExporterTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypprintitemexporterdataclasstesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PprintItemExporterDataclassTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypprintitemexporterdataclasstesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PprintItemExporterDataclassTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypprintitemexporterdataclasstesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PprintItemExporterDataclassTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypprintitemexporterdataclasstesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PprintItemExporterDataclassTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypprintitemexporterdataclasstesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PprintItemExporterDataclassTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexportertesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexportertesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexportertesttest_export_multiple_items" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterTest::test_export_multiple_items
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexportertesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexportertesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexportertesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexportertesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexporterdataclasstesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterDataclassTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexporterdataclasstesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterDataclassTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexporterdataclasstesttest_export_multiple_items" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterDataclassTest::test_export_multiple_items
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexporterdataclasstesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterDataclassTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexporterdataclasstesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterDataclassTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexporterdataclasstesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterDataclassTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspypickleitemexporterdataclasstesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::PickleItemExporterDataclassTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexportertesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexportertesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexportertesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexportertesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexportertesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexportertesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexporterdataclasstesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterDataclassTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexporterdataclasstesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterDataclassTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexporterdataclasstesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterDataclassTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexporterdataclasstesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterDataclassTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexporterdataclasstesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterDataclassTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspymarshalitemexporterdataclasstesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::MarshalItemExporterDataclassTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_errors_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_errors_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_errors_xmlcharrefreplace" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_errors_xmlcharrefreplace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_header_export_all" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_header_export_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_header_export_all_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_header_export_all_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_header_export_single_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_header_export_single_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_header_export_two_items" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_header_export_two_items
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_header_no_header_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_header_no_header_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_join_multivalue" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_join_multivalue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_join_multivalue_not_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_join_multivalue_not_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexportertesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_errors_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_errors_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_errors_xmlcharrefreplace" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_errors_xmlcharrefreplace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_header_export_all" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_header_export_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_header_export_all_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_header_export_all_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_header_export_single_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_header_export_single_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_header_export_two_items" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_header_export_two_items
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_header_no_header_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_header_no_header_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_join_multivalue" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_join_multivalue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_join_multivalue_not_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_join_multivalue_not_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycsvitemexporterdataclasstesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CsvItemExporterDataclassTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexportertesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexportertesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexportertesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexportertesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexportertesttest_multivalued_fields" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterTest::test_multivalued_fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexportertesttest_nested_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterTest::test_nested_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexportertesttest_nested_list_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterTest::test_nested_list_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexportertesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexportertesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexporterdataclasstesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterDataclassTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexporterdataclasstesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterDataclassTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexporterdataclasstesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterDataclassTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexporterdataclasstesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterDataclassTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexporterdataclasstesttest_multivalued_fields" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterDataclassTest::test_multivalued_fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexporterdataclasstesttest_nested_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterDataclassTest::test_nested_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexporterdataclasstesttest_nested_list_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterDataclassTest::test_nested_list_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexporterdataclasstesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterDataclassTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyxmlitemexporterdataclasstesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::XmlItemExporterDataclassTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexportertesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexportertesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexportertesttest_extra_keywords" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterTest::test_extra_keywords
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexportertesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexportertesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexportertesttest_nested_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterTest::test_nested_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexportertesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexportertesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexporterdataclasstesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterDataclassTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexporterdataclasstesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterDataclassTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexporterdataclasstesttest_extra_keywords" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterDataclassTest::test_extra_keywords
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexporterdataclasstesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterDataclassTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexporterdataclasstesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterDataclassTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexporterdataclasstesttest_nested_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterDataclassTest::test_nested_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexporterdataclasstesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterDataclassTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonlinesitemexporterdataclasstesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonLinesItemExporterDataclassTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_extra_keywords" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_extra_keywords
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_nested_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_nested_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_nested_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_nested_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_two_dict_items" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_two_dict_items
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_two_items" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_two_items
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertesttest_two_items_with_failure_between" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterTest::test_two_items_with_failure_between
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertobytestesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterToBytesTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertobytestesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterToBytesTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertobytestesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterToBytesTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertobytestesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterToBytesTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertobytestesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterToBytesTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexportertobytestesttest_two_items_with_failure_between" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterToBytesTest::test_two_items_with_failure_between
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_export_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_export_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_export_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_export_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_extra_keywords" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_extra_keywords
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_field_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_field_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_fields_to_export" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_fields_to_export
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_nested_dict_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_nested_dict_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_nested_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_nested_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_nonstring_types_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_nonstring_types_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_serialize_field" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_serialize_field
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_two_dict_items" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_two_dict_items
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_two_items" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_two_items
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspyjsonitemexporterdataclasstesttest_two_items_with_failure_between" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::JsonItemExporterDataclassTest::test_two_items_with_failure_between
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycustomexporteritemtesttest_exporter_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CustomExporterItemTest::test_exporter_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exporterspycustomexporterdataclasstesttest_exporter_custom_serializer" class="md-nav__link">
    <span class="md-ellipsis">
      test_exporters.py::CustomExporterDataclassTest::test_exporter_custom_serializer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedrequesttesttest_add_unredirected_header" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedRequestTest::test_add_unredirected_header
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedrequesttesttest_get_full_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedRequestTest::test_get_full_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedrequesttesttest_get_header" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedRequestTest::test_get_header
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedrequesttesttest_get_host" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedRequestTest::test_get_host
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedrequesttesttest_get_origin_req_host" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedRequestTest::test_get_origin_req_host
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedrequesttesttest_get_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedRequestTest::test_get_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedrequesttesttest_has_header" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedRequestTest::test_has_header
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedrequesttesttest_header_items" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedRequestTest::test_header_items
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedrequesttesttest_is_unverifiable" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedRequestTest::test_is_unverifiable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedrequesttesttest_is_unverifiable2" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedRequestTest::test_is_unverifiable2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedresponsetesttest_get_all" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedResponseTest::test_get_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_cookiespywrappedresponsetesttest_info" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_cookies.py::WrappedResponseTest::test_info
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_appendlist" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_appendlist
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_basics" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_basics
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_encode_latin1" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_encode_latin1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_encode_multiple" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_encode_multiple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_encode_utf8" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_encode_utf8
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_int_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_int_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_invalid_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_invalid_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_iterables" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_iterables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_multivalue" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_multivalue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_multivalue_for_one_header" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_multivalue_for_one_header
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_none_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_none_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_setdefault" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_setdefault
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_setlist" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_setlist
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_setlistdefault" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_setlistdefault
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_single_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_single_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_headerspyheaderstesttest_update" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_headers.py::HeadersTest::test_update
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyrequesttesttest_ajax_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::RequestTest::test_ajax_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyrequesttesttest_from_curl" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::RequestTest::test_from_curl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyrequesttesttest_from_curl_ignore_unknown_options" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::RequestTest::test_from_curl_ignore_unknown_options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyrequesttesttest_from_curl_with_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::RequestTest::test_from_curl_with_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyrequesttesttest_headers" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::RequestTest::test_headers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyrequesttesttest_immutable_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::RequestTest::test_immutable_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyrequesttesttest_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::RequestTest::test_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_ajax_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_ajax_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_custom_encoding_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_custom_encoding_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_custom_encoding_textual_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_custom_encoding_textual_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_default_encoding_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_default_encoding_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_default_encoding_mixed_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_default_encoding_mixed_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_default_encoding_textual_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_default_encoding_textual_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_formdata_overrides_querystring" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_formdata_overrides_querystring
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_curl" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_curl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_curl_ignore_unknown_options" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_curl_ignore_unknown_options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_curl_with_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_curl_with_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_ambiguous_clickdata" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_ambiguous_clickdata
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_button_notype" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_button_notype
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_button_novalue" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_button_novalue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_button_submit" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_button_submit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_case_insensitive" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_case_insensitive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_checkbox" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_checkbox
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_clickdata_does_not_ignore_image" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_clickdata_does_not_ignore_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_descendants" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_descendants
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_dont_click" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_dont_click
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_dont_submit_image_as_input" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_dont_submit_image_as_input
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_dont_submit_reset_as_input" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_dont_submit_reset_as_input
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_drop_params" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_drop_params
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_duplicate_form_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_duplicate_form_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_errors_formnumber" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_errors_formnumber
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_errors_noform" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_errors_noform
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_extra_headers" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_extra_headers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_formid_errors_formnumber" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_formid_errors_formnumber
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_formid_exists" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_formid_exists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_formid_nonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_formid_nonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_formname_errors_formnumber" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_formname_errors_formnumber
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_formname_exists" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_formname_exists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_formname_nonexistent" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_formname_nonexistent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_formname_nonexistent_fallback_formid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_formname_nonexistent_fallback_formid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_get" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_get
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_input_hidden" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_input_hidden
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_input_text" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_input_text
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_input_textarea" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_input_textarea
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_invalid_html5" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_invalid_html5
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_invalid_nr_index_clickdata" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_invalid_nr_index_clickdata
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_multiple_clickdata" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_multiple_clickdata
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_multiple_forms_clickdata" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_multiple_forms_clickdata
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_noformname" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_noformname
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_non_matching_clickdata" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_non_matching_clickdata
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_nr_index_clickdata" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_nr_index_clickdata
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_override_clickable" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_override_clickable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_override_duplicate_form_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_override_duplicate_form_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_override_method" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_override_method
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_override_params" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_override_params
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_override_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_override_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_post" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_post
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_post_nonascii_bytes_latin1" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_post_nonascii_bytes_latin1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_post_nonascii_bytes_utf8" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_post_nonascii_bytes_utf8
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_post_nonascii_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_post_nonascii_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_radio" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_radio
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_select" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_select
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_submit_first_clickable" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_submit_first_clickable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_submit_not_first_clickable" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_submit_not_first_clickable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_submit_novalue" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_submit_novalue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_unicode_clickdata" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_unicode_clickdata
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_unicode_clickdata_latin1" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_unicode_clickdata_latin1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_unicode_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_unicode_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_valid_form_methods" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_valid_form_methods
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_from_response_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_from_response_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_headers" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_headers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_html_base_form_action" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_html_base_form_action
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_immutable_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_immutable_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_multi_key_values" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_multi_key_values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyformrequesttesttest_spaces_in_action" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::FormRequestTest::test_spaces_in_action
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyxmlrpcrequesttesttest_ajax_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::XmlRpcRequestTest::test_ajax_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyxmlrpcrequesttesttest_from_curl" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::XmlRpcRequestTest::test_from_curl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyxmlrpcrequesttesttest_from_curl_ignore_unknown_options" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::XmlRpcRequestTest::test_from_curl_ignore_unknown_options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyxmlrpcrequesttesttest_from_curl_with_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::XmlRpcRequestTest::test_from_curl_with_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyxmlrpcrequesttesttest_headers" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::XmlRpcRequestTest::test_headers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyxmlrpcrequesttesttest_immutable_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::XmlRpcRequestTest::test_immutable_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyxmlrpcrequesttesttest_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::XmlRpcRequestTest::test_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyxmlrpcrequesttesttest_latin1" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::XmlRpcRequestTest::test_latin1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyxmlrpcrequesttesttest_replace" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::XmlRpcRequestTest::test_replace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyxmlrpcrequesttesttest_xmlrpc_dumps" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::XmlRpcRequestTest::test_xmlrpc_dumps
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_ajax_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_ajax_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_body_none_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_body_none_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_copy_inherited_classes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_copy_inherited_classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_dumps_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_dumps_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_dumps_sort_keys" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_dumps_sort_keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_from_curl" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_from_curl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_from_curl_ignore_unknown_options" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_from_curl_ignore_unknown_options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_from_curl_with_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_from_curl_with_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_headers" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_headers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_immutable_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_immutable_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_replace" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_replace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_replace_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_replace_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_replace_dumps_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_replace_dumps_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_requestpyjsonrequesttesttest_replace_sort_keys" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_request.py::JsonRequestTest::test_replace_sort_keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepybaseresponsetesttest_immutable_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::BaseResponseTest::test_immutable_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepybaseresponsetesttest_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::BaseResponseTest::test_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_bom_is_removed_from_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_bom_is_removed_from_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_cache_json_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_cache_json_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_copy_inherited_classes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_copy_inherited_classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_declared_encoding_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_declared_encoding_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_none_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_None_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_all_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_all_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_all_css_skip_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_all_css_skip_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_all_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_all_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_all_flags" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_all_flags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_all_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_all_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_all_too_many_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_all_too_many_arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_all_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_all_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_all_xpath_skip_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_all_xpath_skip_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_flags" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_flags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_link" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_link
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_selector_attribute" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_selector_attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_selector_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_selector_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_selector_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_selector_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_selector_no_href" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_selector_no_href
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_url_absolute" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_url_absolute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_url_relative" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_url_relative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_whitespace_link" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_whitespace_link
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_whitespace_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_whitespace_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_follow_whitespace_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_follow_whitespace_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_immutable_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_immutable_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_invalid_utf8_encoded_body_with_valid_utf8_bom" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_json_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_json_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_replace" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_replace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_replace_wrong_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_replace_wrong_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_selector_shortcuts" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_selector_shortcuts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_selector_shortcuts_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_selector_shortcuts_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_shortcut_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_shortcut_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_unicode_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_unicode_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_unicode_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_unicode_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_urljoin" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_urljoin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_urljoin_with_base_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_urljoin_with_base_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepytextresponsetesttest_utf16" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::TextResponseTest::test_utf16
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_bom_is_removed_from_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_bom_is_removed_from_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_cache_json_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_cache_json_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_copy_inherited_classes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_copy_inherited_classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_declared_encoding_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_declared_encoding_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_none_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_None_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_all_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_all_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_all_css_skip_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_all_css_skip_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_all_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_all_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_all_flags" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_all_flags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_all_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_all_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_all_too_many_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_all_too_many_arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_all_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_all_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_all_xpath_skip_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_all_xpath_skip_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_flags" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_flags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_link" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_link
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_selector_attribute" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_selector_attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_selector_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_selector_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_selector_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_selector_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_selector_no_href" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_selector_no_href
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_url_absolute" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_url_absolute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_url_relative" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_url_relative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_whitespace_link" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_whitespace_link
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_whitespace_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_whitespace_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_follow_whitespace_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_follow_whitespace_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_html5_meta_charset" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_html5_meta_charset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_html_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_html_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_immutable_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_immutable_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_invalid_utf8_encoded_body_with_valid_utf8_bom" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_json_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_json_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_replace" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_replace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_replace_wrong_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_replace_wrong_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_selector_shortcuts" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_selector_shortcuts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_selector_shortcuts_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_selector_shortcuts_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_shortcut_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_shortcut_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_unicode_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_unicode_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_unicode_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_unicode_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_urljoin" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_urljoin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_urljoin_with_base_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_urljoin_with_base_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyhtmlresponsetesttest_utf16" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::HtmlResponseTest::test_utf16
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_bom_is_removed_from_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_bom_is_removed_from_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_cache_json_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_cache_json_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_copy_inherited_classes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_copy_inherited_classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_declared_encoding_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_declared_encoding_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_none_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_None_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_all_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_all_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_all_css_skip_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_all_css_skip_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_all_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_all_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_all_flags" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_all_flags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_all_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_all_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_all_too_many_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_all_too_many_arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_all_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_all_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_all_xpath_skip_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_all_xpath_skip_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_flags" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_flags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_link" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_link
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_selector_attribute" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_selector_attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_selector_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_selector_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_selector_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_selector_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_selector_no_href" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_selector_no_href
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_url_absolute" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_url_absolute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_url_relative" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_url_relative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_whitespace_link" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_whitespace_link
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_whitespace_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_whitespace_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_follow_whitespace_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_follow_whitespace_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_immutable_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_immutable_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_invalid_utf8_encoded_body_with_valid_utf8_bom" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_json_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_json_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_replace" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_replace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_replace_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_replace_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_replace_wrong_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_replace_wrong_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_selector_shortcuts" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_selector_shortcuts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_selector_shortcuts_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_selector_shortcuts_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_shortcut_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_shortcut_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_unicode_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_unicode_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_unicode_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_unicode_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_urljoin" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_urljoin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_urljoin_with_base_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_urljoin_with_base_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_utf16" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_utf16
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepyxmlresponsetesttest_xml_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::XmlResponseTest::test_xml_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_bom_is_removed_from_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_bom_is_removed_from_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_cache_json_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_cache_json_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_copy_inherited_classes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_copy_inherited_classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_declared_encoding_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_declared_encoding_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_none_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_None_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_all_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_all_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_all_css_skip_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_all_css_skip_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_all_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_all_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_all_flags" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_all_flags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_all_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_all_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_all_too_many_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_all_too_many_arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_all_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_all_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_all_xpath_skip_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_all_xpath_skip_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_flags" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_flags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_link" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_link
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_selector_attribute" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_selector_attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_selector_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_selector_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_selector_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_selector_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_selector_no_href" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_selector_no_href
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_url_absolute" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_url_absolute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_url_relative" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_url_relative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_whitespace_link" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_whitespace_link
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_whitespace_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_whitespace_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_follow_whitespace_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_follow_whitespace_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_immutable_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_immutable_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_invalid_utf8_encoded_body_with_valid_utf8_bom" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_json_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_json_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_replace" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_replace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_replace_wrong_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_replace_wrong_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_selector_shortcuts" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_selector_shortcuts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_selector_shortcuts_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_selector_shortcuts_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_shortcut_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_shortcut_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_unicode_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_unicode_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_unicode_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_unicode_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_urljoin" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_urljoin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_urljoin_with_base_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_urljoin_with_base_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_http_responsepycustomresponsetesttest_utf16" class="md-nav__link">
    <span class="md-ellipsis">
      test_http_response.py::CustomResponseTest::test_utf16
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_itempyitemtesttest_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_item.py::ItemTest::test_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_itempyitemtesttest_deepcopy" class="md-nav__link">
    <span class="md-ellipsis">
      test_item.py::ItemTest::test_deepcopy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_area_tag_with_unicode_present" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_area_tag_with_unicode_present
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_attrs" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_attrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_base_url_with_restrict_xpaths" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_base_url_with_restrict_xpaths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_encoded_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_encoded_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_encoded_url_in_restricted_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_encoded_url_in_restricted_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_extract_all_links" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_all_links
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allow" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allow_and_deny" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_and_deny
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allow_no_duplicates_canonicalize" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_no_duplicates_canonicalize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allow_with_duplicates" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_with_duplicates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allow_with_duplicates_canonicalize" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_with_duplicates_canonicalize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allowed_domains" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allowed_domains
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_extraction_using_single_values" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_extraction_using_single_values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_ftp_links" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_ftp_links
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_ignored_extensions" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_ignored_extensions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_link_extractor_aggregation" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_link_extractor_aggregation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_link_restrict_text" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_link_restrict_text
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_link_wrong_href" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_link_wrong_href
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_matches" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_matches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_nofollow" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_nofollow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_process_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_process_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_restrict_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_restrict_css_and_restrict_xpaths_together" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_css_and_restrict_xpaths_together
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_restrict_xpaths" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_restrict_xpaths_concat_in_handle_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths_concat_in_handle_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_restrict_xpaths_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_restrict_xpaths_with_html_entities" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths_with_html_entities
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_skip_bad_links" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_skip_bad_links
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_tags" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_tags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_tags_attrs" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_tags_attrs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_urls_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_urls_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_linkextractorspylxmllinkextractortestcasetest_xhtml" class="md-nav__link">
    <span class="md-ellipsis">
      test_linkextractors.py::LxmlLinkExtractorTestCase::test_xhtml
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_add_css_re" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_add_css_re
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_add_xpath_re" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_add_xpath_re
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_get_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_get_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_get_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_get_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_init_method_with_base_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_init_method_with_base_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_init_method_with_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_init_method_with_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_init_method_with_response_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_init_method_with_response_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_init_method_with_selector" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_init_method_with_selector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_init_method_with_selector_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_init_method_with_selector_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_replace_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_replace_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_replace_css_multi_fields" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_replace_css_multi_fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_replace_css_re" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_replace_css_re
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_replace_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_replace_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_replace_xpath_multi_fields" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_replace_xpath_multi_fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpyselectortemloadertesttest_replace_xpath_re" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SelectortemLoaderTest::test_replace_xpath_re
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpysubselectorloadertesttest_nested_css" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SubselectorLoaderTest::test_nested_css
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpysubselectorloadertesttest_nested_load_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SubselectorLoaderTest::test_nested_load_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpysubselectorloadertesttest_nested_ordering" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SubselectorLoaderTest::test_nested_ordering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpysubselectorloadertesttest_nested_replace" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SubselectorLoaderTest::test_nested_replace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loaderpysubselectorloadertesttest_nested_xpath" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader.py::SubselectorLoaderTest::test_nested_xpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loader_deprecatedpydeprecatedutilityfunctionstestcasetest_deprecated_extract_regex" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader_deprecated.py::DeprecatedUtilityFunctionsTestCase::test_deprecated_extract_regex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loader_deprecatedpydeprecatedutilityfunctionstestcasetest_deprecated_wrap_loader_context" class="md-nav__link">
    <span class="md-ellipsis">
      test_loader_deprecated.py::DeprecatedUtilityFunctionsTestCase::test_deprecated_wrap_loader_context
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mailpymailsendertesttest_create_sender_factory_with_host" class="md-nav__link">
    <span class="md-ellipsis">
      test_mail.py::MailSenderTest::test_create_sender_factory_with_host
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mailpymailsendertesttest_send" class="md-nav__link">
    <span class="md-ellipsis">
      test_mail.py::MailSenderTest::test_send
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mailpymailsendertesttest_send_attach" class="md-nav__link">
    <span class="md-ellipsis">
      test_mail.py::MailSenderTest::test_send_attach
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mailpymailsendertesttest_send_attach_utf8" class="md-nav__link">
    <span class="md-ellipsis">
      test_mail.py::MailSenderTest::test_send_attach_utf8
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mailpymailsendertesttest_send_html" class="md-nav__link">
    <span class="md-ellipsis">
      test_mail.py::MailSenderTest::test_send_html
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mailpymailsendertesttest_send_single_values_to_and_cc" class="md-nav__link">
    <span class="md-ellipsis">
      test_mail.py::MailSenderTest::test_send_single_values_to_and_cc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mailpymailsendertesttest_send_utf8" class="md-nav__link">
    <span class="md-ellipsis">
      test_mail.py::MailSenderTest::test_send_utf8
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_middlewarepymiddlewaremanagertesttest_enabled" class="md-nav__link">
    <span class="md-ellipsis">
      test_middleware.py::MiddlewareManagerTest::test_enabled
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_middlewarepymiddlewaremanagertesttest_enabled_from_settings" class="md-nav__link">
    <span class="md-ellipsis">
      test_middleware.py::MiddlewareManagerTest::test_enabled_from_settings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_middlewarepymiddlewaremanagertesttest_init" class="md-nav__link">
    <span class="md-ellipsis">
      test_middleware.py::MiddlewareManagerTest::test_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_middlewarepymiddlewaremanagertesttest_methods" class="md-nav__link">
    <span class="md-ellipsis">
      test_middleware.py::MiddlewareManagerTest::test_methods
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_request_dictpyrequestserializationtesttest_callback_not_available" class="md-nav__link">
    <span class="md-ellipsis">
      test_request_dict.py::RequestSerializationTest::test_callback_not_available
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_request_dictpyrequestserializationtesttest_request_class" class="md-nav__link">
    <span class="md-ellipsis">
      test_request_dict.py::RequestSerializationTest::test_request_class
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_responsetypespyresponsetypestesttest_from_args" class="md-nav__link">
    <span class="md-ellipsis">
      test_responsetypes.py::ResponseTypesTest::test_from_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_responsetypespyresponsetypestesttest_from_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_responsetypes.py::ResponseTypesTest::test_from_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_responsetypespyresponsetypestesttest_from_content_disposition" class="md-nav__link">
    <span class="md-ellipsis">
      test_responsetypes.py::ResponseTypesTest::test_from_content_disposition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_responsetypespyresponsetypestesttest_from_content_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_responsetypes.py::ResponseTypesTest::test_from_content_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_responsetypespyresponsetypestesttest_from_filename" class="md-nav__link">
    <span class="md-ellipsis">
      test_responsetypes.py::ResponseTypesTest::test_from_filename
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_responsetypespyresponsetypestesttest_from_headers" class="md-nav__link">
    <span class="md-ellipsis">
      test_responsetypes.py::ResponseTypesTest::test_from_headers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_badly_encoded_body" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_badly_encoded_body
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_flavor_detection" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_flavor_detection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_http_header_encoding_precedence" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_http_header_encoding_precedence
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_root_base_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_root_base_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_simple_selection" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_simple_selection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyselectortestcasetest_weakref_slots" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::SelectorTestCase::test_weakref_slots
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyjmespathtestcasetest_html_has_json" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::JMESPathTestCase::test_html_has_json
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyjmespathtestcasetest_jmestpath_with_re" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::JMESPathTestCase::test_jmestpath_with_re
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selectorpyjmespathtestcasetest_json_has_html" class="md-nav__link">
    <span class="md-ellipsis">
      test_selector.py::JMESPathTestCase::test_json_has_html
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#initpybasesettingstesttest_update_iterable" class="md-nav__link">
    <span class="md-ellipsis">
      init.py::BaseSettingsTest::test_update_iterable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#initpybasesettingstesttest_update_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      init.py::BaseSettingsTest::test_update_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#initpysettingstesttest_passing_objects_as_values" class="md-nav__link">
    <span class="md-ellipsis">
      init.py::SettingsTest::test_passing_objects_as_values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestreferermiddlewaretest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRefererMiddleware::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestreferermiddlewaredefaulttest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRefererMiddlewareDefault::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingsnoreferrertest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsNoReferrer::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingsnoreferrerwhendowngradetest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsNoReferrerWhenDowngrade::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingssameorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsSameOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingsorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingsstrictorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsStrictOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingsoriginwhencrossorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsOriginWhenCrossOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingsstrictoriginwhencrossorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsStrictOriginWhenCrossOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingsunsafeurltest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsUnsafeUrl::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingscustompolicytest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsCustomPolicy::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetadefaulttest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaDefault::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetanoreferrertest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaNoReferrer::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetanoreferrerwhendowngradetest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaNoReferrerWhenDowngrade::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetasameorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaSameOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetaorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetasrictorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaSrictOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetaoriginwhencrossorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaOriginWhenCrossOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetastrictoriginwhencrossorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaStrictOriginWhenCrossOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetaunsafeurltest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaUnsafeUrl::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetaprecedence001test" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaPrecedence001::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetaprecedence002test" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaPrecedence002::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetaprecedence003test" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaPrecedence003::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestrequestmetasettingfallbacktest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestRequestMetaSettingFallback::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingspolicybynametest_invalid_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsPolicyByName::test_invalid_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingspolicybynametest_valid_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsPolicyByName::test_valid_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestsettingspolicybynametest_valid_name_casevariants" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestSettingsPolicyByName::test_valid_name_casevariants
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestpolicyheaderprecedence001test" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence001::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestpolicyheaderprecedence002test" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence002::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestpolicyheaderprecedence003test" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence003::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestpolicyheaderprecedence004test" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence004::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestreferreronredirecttest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestReferrerOnRedirect::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestreferreronredirectnoreferrertest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestReferrerOnRedirectNoReferrer::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestreferreronredirectsameorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestReferrerOnRedirectSameOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestreferreronredirectstrictorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestReferrerOnRedirectStrictOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestreferreronredirectoriginwhencrossorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestReferrerOnRedirectOriginWhenCrossOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_spidermiddleware_refererpytestreferreronredirectstrictoriginwhencrossorigintest" class="md-nav__link">
    <span class="md-ellipsis">
      test_spidermiddleware_referer.py::TestReferrerOnRedirectStrictOriginWhenCrossOrigin::test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_asynciopyasynciotesttest_install_asyncio_reactor" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_asyncio.py::AsyncioTest::test_install_asyncio_reactor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpybuildcomponentlisttesttest_backward_compatible_build_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::BuildComponentListTest::test_backward_compatible_build_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpybuildcomponentlisttesttest_duplicate_components_in_basesettings" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::BuildComponentListTest::test_duplicate_components_in_basesettings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpybuildcomponentlisttesttest_duplicate_components_in_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::BuildComponentListTest::test_duplicate_components_in_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpybuildcomponentlisttesttest_duplicate_components_in_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::BuildComponentListTest::test_duplicate_components_in_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpybuildcomponentlisttesttest_map_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::BuildComponentListTest::test_map_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpybuildcomponentlisttesttest_map_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::BuildComponentListTest::test_map_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpybuildcomponentlisttesttest_return_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::BuildComponentListTest::test_return_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpybuildcomponentlisttesttest_valid_numbers" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::BuildComponentListTest::test_valid_numbers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpyfeedexportconfigtestcasetest_feed_complete_default_values_from_settings_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::FeedExportConfigTestCase::test_feed_complete_default_values_from_settings_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpyfeedexportconfigtestcasetest_feed_complete_default_values_from_settings_non_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::FeedExportConfigTestCase::test_feed_complete_default_values_from_settings_non_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpyfeedexportconfigtestcasetest_feed_export_config_backward_compatible" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_backward_compatible
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpyfeedexportconfigtestcasetest_feed_export_config_explicit_formats" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_explicit_formats
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpyfeedexportconfigtestcasetest_feed_export_config_implicit_formats" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_implicit_formats
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpyfeedexportconfigtestcasetest_feed_export_config_overwrite" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_overwrite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_confpyfeedexportconfigtestcasetest_feed_export_config_stdout" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_stdout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_consolepyutilsconsoletestcasetest_get_shell_embed_func" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_console.py::UtilsConsoleTestCase::test_get_shell_embed_func
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_delete" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_explicit_get_with_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_explicit_get_with_data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_get" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_get
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_get_basic_auth" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_get_basic_auth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_get_complex" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_get_complex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_get_silent" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_get_silent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_get_without_scheme" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_get_without_scheme
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_ignore_unknown_options" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_ignore_unknown_options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_must_start_with_curl_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_must_start_with_curl_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_patch" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_patch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_post" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_post
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_post_data_raw" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_post_data_raw
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_post_data_raw_with_string_prefix" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_post_data_raw_with_string_prefix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_curlpycurltorequestkwargstesttest_too_few_arguments_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_curl.py::CurlToRequestKwargsTest::test_too_few_arguments_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deferpymustbedeferredtesttest_success_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_defer.py::MustbeDeferredTest::test_success_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deferpymustbedeferredtesttest_unfired_deferred" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_defer.py::MustbeDeferredTest::test_unfired_deferred
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deferpydeferutilstesttest_process_chain" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_defer.py::DeferUtilsTest::test_process_chain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deferpydeferutilstesttest_process_chain_both" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_defer.py::DeferUtilsTest::test_process_chain_both
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deferpydeferutilstesttest_process_parallel" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_defer.py::DeferUtilsTest::test_process_parallel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deferpydeferutilstesttest_process_parallel_failure" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_defer.py::DeferUtilsTest::test_process_parallel_failure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deferpyitererrbacktesttest_iter_errback_bad" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_defer.py::IterErrbackTest::test_iter_errback_bad
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deferpyitererrbacktesttest_iter_errback_good" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_defer.py::IterErrbackTest::test_iter_errback_good
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deferpyasynccooperatortesttest_delays" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_defer.py::AsyncCooperatorTest::test_delays
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deferpyasynccooperatortesttest_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_defer.py::AsyncCooperatorTest::test_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepywarnwhensubclassedtesttest_clsdict" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::WarnWhenSubclassedTest::test_clsdict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepywarnwhensubclassedtesttest_custom_class_paths" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::WarnWhenSubclassedTest::test_custom_class_paths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepywarnwhensubclassedtesttest_deprecate_subclass_of_deprecated_class" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::WarnWhenSubclassedTest::test_deprecate_subclass_of_deprecated_class
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepywarnwhensubclassedtesttest_inspect_stack" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::WarnWhenSubclassedTest::test_inspect_stack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepywarnwhensubclassedtesttest_isinstance" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::WarnWhenSubclassedTest::test_isinstance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepywarnwhensubclassedtesttest_issubclass" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::WarnWhenSubclassedTest::test_issubclass
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepywarnwhensubclassedtesttest_subclassing_warning_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::WarnWhenSubclassedTest::test_subclassing_warning_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepywarnwhensubclassedtesttest_subclassing_warns_once_by_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::WarnWhenSubclassedTest::test_subclassing_warns_once_by_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepywarnwhensubclassedtesttest_subclassing_warns_only_on_direct_children" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::WarnWhenSubclassedTest::test_subclassing_warns_only_on_direct_children
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepywarnwhensubclassedtesttest_warning_auto_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::WarnWhenSubclassedTest::test_warning_auto_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepywarnwhensubclassedtesttest_warning_on_instance" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::WarnWhenSubclassedTest::test_warning_on_instance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepyupdateclasspathtesttest_old_path_gets_fixed" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::UpdateClassPathTest::test_old_path_gets_fixed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepyupdateclasspathtesttest_returns_nonstring" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::UpdateClassPathTest::test_returns_nonstring
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepyupdateclasspathtesttest_sorted_replacement" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::UpdateClassPathTest::test_sorted_replacement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_deprecatepyupdateclasspathtesttest_unmatched_path_stays_the_same" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_deprecate.py::UpdateClassPathTest::test_unmatched_path_stays_the_same
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_displaypytestdisplaytest_pformat" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_display.py::TestDisplay::test_pformat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_displaypytestdisplaytest_pformat_dont_colorize" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_display.py::TestDisplay::test_pformat_dont_colorize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_displaypytestdisplaytest_pformat_old_windows" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_display.py::TestDisplay::test_pformat_old_windows
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_displaypytestdisplaytest_pformat_windows" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_display.py::TestDisplay::test_pformat_windows
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_gzpygunziptesttest_gunzip_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_gz.py::GunzipTest::test_gunzip_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_gzpygunziptesttest_gunzip_illegal_eof" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_gz.py::GunzipTest::test_gunzip_illegal_eof
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_gzpygunziptesttest_gunzip_no_gzip_file_raises" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_gz.py::GunzipTest::test_gunzip_no_gzip_file_raises
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_gzpygunziptesttest_gunzip_truncated" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_gz.py::GunzipTest::test_gunzip_truncated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_gzpygunziptesttest_gunzip_truncated_short" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_gz.py::GunzipTest::test_gunzip_truncated_short
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_gzpygunziptesttest_is_gzipped_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_gz.py::GunzipTest::test_is_gzipped_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_httpobjpyhttpobjutilstesttest_urlparse_cached" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_httpobj.py::HttpobjUtilsTest::test_urlparse_cached
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyxmlitertestcasetest_deprecation" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::XmliterTestCase::test_deprecation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyxmlitertestcasetest_xmliter" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::XmliterTestCase::test_xmliter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyxmlitertestcasetest_xmliter_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::XmliterTestCase::test_xmliter_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyxmlitertestcasetest_xmliter_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::XmliterTestCase::test_xmliter_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyxmlitertestcasetest_xmliter_namespaced_nodename" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::XmliterTestCase::test_xmliter_namespaced_nodename
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyxmlitertestcasetest_xmliter_namespaced_nodename_missing" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::XmliterTestCase::test_xmliter_namespaced_nodename_missing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyxmlitertestcasetest_xmliter_namespaces" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::XmliterTestCase::test_xmliter_namespaces
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyxmlitertestcasetest_xmliter_objtype_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::XmliterTestCase::test_xmliter_objtype_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyxmlitertestcasetest_xmliter_text" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::XmliterTestCase::test_xmliter_text
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyxmlitertestcasetest_xmliter_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::XmliterTestCase::test_xmliter_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyxmlitertestcasetest_xmliter_unusual_node" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::XmliterTestCase::test_xmliter_unusual_node
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_iterate_namespace" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_iterate_namespace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_namespaced_nodename" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaced_nodename
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_namespaced_nodename_missing" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaced_nodename_missing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_namespaces" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaces
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_namespaces_prefix" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaces_prefix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_objtype_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_objtype_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_text" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_text
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_unicode" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_unicode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_unusual_node" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_unusual_node
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyutilscsvtestcasetest_csviter_defaults" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::UtilsCsvTestCase::test_csviter_defaults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyutilscsvtestcasetest_csviter_delimiter" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::UtilsCsvTestCase::test_csviter_delimiter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyutilscsvtestcasetest_csviter_delimiter_binary_response_assume_utf8_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::UtilsCsvTestCase::test_csviter_delimiter_binary_response_assume_utf8_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyutilscsvtestcasetest_csviter_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::UtilsCsvTestCase::test_csviter_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyutilscsvtestcasetest_csviter_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::UtilsCsvTestCase::test_csviter_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyutilscsvtestcasetest_csviter_falserow" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::UtilsCsvTestCase::test_csviter_falserow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyutilscsvtestcasetest_csviter_headers" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::UtilsCsvTestCase::test_csviter_headers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyutilscsvtestcasetest_csviter_quotechar" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::UtilsCsvTestCase::test_csviter_quotechar
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspyutilscsvtestcasetest_csviter_wrong_quotechar" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::UtilsCsvTestCase::test_csviter_wrong_quotechar
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_iteratorspytesthelpertest_body_or_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_iterators.py::TestHelper::test_body_or_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#initpyutilsmisctestcasetest_arg_to_iter" class="md-nav__link">
    <span class="md-ellipsis">
      init.py::UtilsMiscTestCase::test_arg_to_iter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#initpyutilsmisctestcasetest_rel_has_nofollow" class="md-nav__link">
    <span class="md-ellipsis">
      init.py::UtilsMiscTestCase::test_rel_has_nofollow
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#initpyutilsmisctestcasetest_set_environ" class="md-nav__link">
    <span class="md-ellipsis">
      init.py::UtilsMiscTestCase::test_set_environ
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_return_with_argument_inside_generatorpyutilsmiscpy3testcasetest_generators_return_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_generators_return_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_return_with_argument_inside_generatorpyutilsmiscpy3testcasetest_generators_return_none_with_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_generators_return_none_with_decorator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_return_with_argument_inside_generatorpyutilsmiscpy3testcasetest_generators_return_something" class="md-nav__link">
    <span class="md-ellipsis">
      test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_generators_return_something
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_return_with_argument_inside_generatorpyutilsmiscpy3testcasetest_indentation_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_indentation_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_return_with_argument_inside_generatorpyutilsmiscpy3testcasetest_partial" class="md-nav__link">
    <span class="md-ellipsis">
      test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_partial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_projectpyprojectutilstesttest_data_path_inside_project" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_project.py::ProjectUtilsTest::test_data_path_inside_project
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_projectpyprojectutilstesttest_data_path_outside_project" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_project.py::ProjectUtilsTest::test_data_path_outside_project
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_projectpygetprojectsettingstestcasetest_invalid_envvar" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_project.py::GetProjectSettingsTestCase::test_invalid_envvar
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_projectpygetprojectsettingstestcasetest_valid_and_invalid_envvars" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_project.py::GetProjectSettingsTestCase::test_valid_and_invalid_envvars
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_projectpygetprojectsettingstestcasetest_valid_envvar" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_project.py::GetProjectSettingsTestCase::test_valid_envvar
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_pythonpymutablechaintesttest_mutablechain" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_python.py::MutableChainTest::test_mutablechain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_pythonpyutilspythontestcasetest_equal_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_python.py::UtilsPythonTestCase::test_equal_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_pythonpyutilspythontestcasetest_get_func_args" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_python.py::UtilsPythonTestCase::test_get_func_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_responsepyresponseutilstesttest_get_base_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_response.py::ResponseUtilsTest::test_get_base_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_responsepyresponseutilstesttest_get_meta_refresh" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_response.py::ResponseUtilsTest::test_get_meta_refresh
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_responsepyresponseutilstesttest_open_in_browser_redos_head" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_response.py::ResponseUtilsTest::test_open_in_browser_redos_head
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_responsepyresponseutilstesttest_response_httprepr" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_response.py::ResponseUtilsTest::test_response_httprepr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_responsepytest_remove_html_commentsa-a" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_response.py::test_remove_html_comments[a&lt;!---a]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_responsepytest_remove_html_commentsab-ab" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_response.py::test_remove_html_comments[ab-ab]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_responsepytest_remove_html_commentsac-ac" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_response.py::test_remove_html_comments[ac-ac]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_responsepytest_remove_html_commentsac-ac_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_response.py::test_remove_html_comments[ac&lt;!---ac]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_responsepytest_remove_html_commentsac-d-ac" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_response.py::test_remove_html_comments[ac&lt;!--d-ac]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_responsepytest_remove_html_commentsacd-acd" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_response.py::test_remove_html_comments[acd-acd]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_responsepytest_remove_html_commentsad-ad" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_response.py::test_remove_html_comments[ad-ad]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_serializepyjsonencodertestcasetest_encode_attrs_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_serialize.py::JsonEncoderTestCase::test_encode_attrs_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_serializepyjsonencodertestcasetest_encode_dataclass_item" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_serialize.py::JsonEncoderTestCase::test_encode_dataclass_item
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_serializepyjsonencodertestcasetest_encode_decode" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_serialize.py::JsonEncoderTestCase::test_encode_decode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_serializepyjsonencodertestcasetest_encode_deferred" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_serialize.py::JsonEncoderTestCase::test_encode_deferred
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_serializepyjsonencodertestcasetest_encode_request" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_serialize.py::JsonEncoderTestCase::test_encode_request
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_serializepyjsonencodertestcasetest_encode_response" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_serialize.py::JsonEncoderTestCase::test_encode_response
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_sitemappysitemaptesttest_sitemap_urls_from_robots" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_sitemap.py::SitemapTest::test_sitemap_urls_from_robots
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_spiderpyutilsspiderstestcasetest_iterate_spider_output" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_spider.py::UtilsSpidersTestCase::test_iterate_spider_output
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_templatepyutilsrendertemplatefiletestcasetest_simple_render" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_template.py::UtilsRenderTemplateFileTestCase::test_simple_render
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_trackrefpytrackreftestcasetest_format_live_refs" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_trackref.py::TrackrefTestCase::test_format_live_refs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_trackrefpytrackreftestcasetest_get_oldest" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_trackref.py::TrackrefTestCase::test_get_oldest
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_trackrefpytrackreftestcasetest_iter_all" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_trackref.py::TrackrefTestCase::test_iter_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_trackrefpytrackreftestcasetest_print_live_refs_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_trackref.py::TrackrefTestCase::test_print_live_refs_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_trackrefpytrackreftestcasetest_print_live_refs_with_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_trackref.py::TrackrefTestCase::test_print_live_refs_with_objects
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyurlutilstesttest_url_has_any_extension" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::UrlUtilsTest::test_url_has_any_extension
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyurlutilstesttest_url_is_from_any_domain" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::UrlUtilsTest::test_url_is_from_any_domain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyurlutilstesttest_url_is_from_spider" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::UrlUtilsTest::test_url_is_from_spider
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyurlutilstesttest_url_is_from_spider_class_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::UrlUtilsTest::test_url_is_from_spider_class_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyurlutilstesttest_url_is_from_spider_with_allowed_domains" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::UrlUtilsTest::test_url_is_from_spider_with_allowed_domains
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyurlutilstesttest_url_is_from_spider_with_allowed_domains_class_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::UrlUtilsTest::test_url_is_from_spider_with_allowed_domains_class_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyaddhttpifnoschemetest_protocol_relative" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyaddhttpifnoschemetest_protocol_relative_complete_url" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_complete_url
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyaddhttpifnoschemetest_protocol_relative_fragment" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_fragment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyaddhttpifnoschemetest_protocol_relative_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyaddhttpifnoschemetest_protocol_relative_port" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_port
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyaddhttpifnoschemetest_protocol_relative_query" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_query
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyaddhttpifnoschemetest_protocol_relative_username_password" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_username_password
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyaddhttpifnoschemetest_protocol_relative_without_subdomain" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_without_subdomain
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyguessschemetesttest_uri_003" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::GuessSchemeTest::test_uri_003
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyguessschemetesttest_uri_004" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::GuessSchemeTest::test_uri_004
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyguessschemetesttest_uri_005" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::GuessSchemeTest::test_uri_005
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyguessschemetesttest_uri_006" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::GuessSchemeTest::test_uri_006
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyguessschemetesttest_uri_007" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::GuessSchemeTest::test_uri_007
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyguessschemetesttest_uri_009" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::GuessSchemeTest::test_uri_009
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpystripurltest_credentials" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::StripUrl::test_credentials
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpystripurltest_credentials_encoded_delims" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::StripUrl::test_credentials_encoded_delims
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpystripurltest_default_ports" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::StripUrl::test_default_ports
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpystripurltest_default_ports_creds_off" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::StripUrl::test_default_ports_creds_off
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpystripurltest_default_ports_keep" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::StripUrl::test_default_ports_keep
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpystripurltest_fragments" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::StripUrl::test_fragments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpystripurltest_noop" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::StripUrl::test_noop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpystripurltest_noop_query_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::StripUrl::test_noop_query_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpystripurltest_origin_only" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::StripUrl::test_origin_only
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpystripurltest_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::StripUrl::test_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utils_urlpyispathtestcasetest_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils_url.py::IsPathTestCase::test_path
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-scrapy"><strong>OpenHands</strong>: scrapy</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">400</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">800</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">31</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">1233</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">1233</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="initpycmdlinecrawlpipelinetesttest_open_spider_normally_in_pipeline"><strong>init</strong>.py::CmdlineCrawlPipelineTest::test_open_spider_normally_in_pipeline</h3>
<details><summary> <pre>__init__.py::CmdlineCrawlPipelineTest::test_open_spider_normally_in_pipeline</pre></summary><pre>
self = <tests.test_cmdline_crawl_with_pipeline.CmdlineCrawlPipelineTest testMethod=test_open_spider_normally_in_pipeline>

    def test_open_spider_normally_in_pipeline(self):
>       self.assertEqual(self._execute("normal"), 0)
E       AssertionError: 1 != 0

/testbed/tests/test_cmdline_crawl_with_pipeline/__init__.py:16: AssertionError
</pre>
</details>
<h3 id="test_command_fetchpyfetchtesttest_headers">test_command_fetch.py::FetchTest::test_headers</h3>
<details><summary> <pre>test_command_fetch.py::FetchTest::test_headers</pre></summary><pre>
self = <tests.test_command_fetch.FetchTest testMethod=test_headers>

    @defer.inlineCallbacks
    def test_headers(self):
>       _, out, _ = yield self.execute([self.url("/text"), "--headers"])
E       AttributeError: 'FetchTest' object has no attribute 'execute'

/testbed/tests/test_command_fetch.py:32: AttributeError
</pre>
</details>
<h3 id="test_command_fetchpyfetchtesttest_output">test_command_fetch.py::FetchTest::test_output</h3>
<details><summary> <pre>test_command_fetch.py::FetchTest::test_output</pre></summary><pre>
self = <tests.test_command_fetch.FetchTest testMethod=test_output>

    @defer.inlineCallbacks
    def test_output(self):
>       _, out, _ = yield self.execute([self.url("/text")])
E       AttributeError: 'FetchTest' object has no attribute 'execute'

/testbed/tests/test_command_fetch.py:13: AttributeError
</pre>
</details>
<h3 id="test_command_fetchpyfetchtesttest_redirect_default">test_command_fetch.py::FetchTest::test_redirect_default</h3>
<details><summary> <pre>test_command_fetch.py::FetchTest::test_redirect_default</pre></summary><pre>
self = <tests.test_command_fetch.FetchTest testMethod=test_redirect_default>

    @defer.inlineCallbacks
    def test_redirect_default(self):
>       _, out, _ = yield self.execute([self.url("/redirect")])
E       AttributeError: 'FetchTest' object has no attribute 'execute'

/testbed/tests/test_command_fetch.py:18: AttributeError
</pre>
</details>
<h3 id="test_command_fetchpyfetchtesttest_redirect_disabled">test_command_fetch.py::FetchTest::test_redirect_disabled</h3>
<details><summary> <pre>test_command_fetch.py::FetchTest::test_redirect_disabled</pre></summary><pre>
self = <tests.test_command_fetch.FetchTest testMethod=test_redirect_disabled>

    @defer.inlineCallbacks
    def test_redirect_disabled(self):
>       _, out, err = yield self.execute(
            ["--no-redirect", self.url("/redirect-no-meta-refresh")]
        )
E       AttributeError: 'FetchTest' object has no attribute 'execute'

/testbed/tests/test_command_fetch.py:23: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_dns_failures">test_command_shell.py::ShellTest::test_dns_failures</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_dns_failures</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_dns_failures>

    @defer.inlineCallbacks
    def test_dns_failures(self):
        if NON_EXISTING_RESOLVABLE:
            raise unittest.SkipTest("Non-existing hosts are resolvable")
        url = "www.somedomainthatdoesntexi.st"
>       errcode, out, err = yield self.execute([url, "-c", "item"], check_code=False)
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:129: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_empty">test_command_shell.py::ShellTest::test_empty</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_empty</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_empty>

    @defer.inlineCallbacks
    def test_empty(self):
>       _, out, _ = yield self.execute(["-c", "item"])
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:21: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_fetch_redirect_follow_302">test_command_shell.py::ShellTest::test_fetch_redirect_follow_302</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_fetch_redirect_follow_302</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_fetch_redirect_follow_302>

    @defer.inlineCallbacks
    def test_fetch_redirect_follow_302(self):
        """Test that calling ``fetch(url)`` follows HTTP redirects by default."""
>       url = self.url("/redirect-no-meta-refresh")
E       AttributeError: 'ShellTest' object has no attribute 'url'

/testbed/tests/test_command_shell.py:79: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_fetch_redirect_not_follow_302">test_command_shell.py::ShellTest::test_fetch_redirect_not_follow_302</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_fetch_redirect_not_follow_302</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_fetch_redirect_not_follow_302>

    @defer.inlineCallbacks
    def test_fetch_redirect_not_follow_302(self):
        """Test that calling ``fetch(url, redirect=False)`` disables automatic redirects."""
>       url = self.url("/redirect-no-meta-refresh")
E       AttributeError: 'ShellTest' object has no attribute 'url'

/testbed/tests/test_command_shell.py:89: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_local_file">test_command_shell.py::ShellTest::test_local_file</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_local_file</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_local_file>

    @defer.inlineCallbacks
    def test_local_file(self):
        filepath = Path(tests_datadir, "test_site", "index.html")
>       _, out, _ = yield self.execute([str(filepath), "-c", "item"])
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:112: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_local_nofile">test_command_shell.py::ShellTest::test_local_nofile</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_local_nofile</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_local_nofile>

    @defer.inlineCallbacks
    def test_local_nofile(self):
        filepath = "file:///tests/sample_data/test_site/nothinghere.html"
>       errcode, out, err = yield self.execute(
            [filepath, "-c", "item"], check_code=False
        )
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:118: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_redirect">test_command_shell.py::ShellTest::test_redirect</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_redirect</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_redirect>

    @defer.inlineCallbacks
    def test_redirect(self):
>       _, out, _ = yield self.execute([self.url("/redirect"), "-c", "response.url"])
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:54: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_redirect_follow_302">test_command_shell.py::ShellTest::test_redirect_follow_302</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_redirect_follow_302</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_redirect_follow_302>

    @defer.inlineCallbacks
    def test_redirect_follow_302(self):
>       _, out, _ = yield self.execute(
            [self.url("/redirect-no-meta-refresh"), "-c", "response.status"]
        )
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:59: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_redirect_not_follow_302">test_command_shell.py::ShellTest::test_redirect_not_follow_302</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_redirect_not_follow_302</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_redirect_not_follow_302>

    @defer.inlineCallbacks
    def test_redirect_not_follow_302(self):
>       _, out, _ = yield self.execute(
            [
                "--no-redirect",
                self.url("/redirect-no-meta-refresh"),
                "-c",
                "response.status",
            ]
        )
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:66: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_request_replace">test_command_shell.py::ShellTest::test_request_replace</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_request_replace</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_request_replace>

    @defer.inlineCallbacks
    def test_request_replace(self):
>       url = self.url("/text")
E       AttributeError: 'ShellTest' object has no attribute 'url'

/testbed/tests/test_command_shell.py:97: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_response_body">test_command_shell.py::ShellTest::test_response_body</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_response_body</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_response_body>

    @defer.inlineCallbacks
    def test_response_body(self):
>       _, out, _ = yield self.execute([self.url("/text"), "-c", "response.body"])
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:26: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_response_encoding_gb18030">test_command_shell.py::ShellTest::test_response_encoding_gb18030</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_response_encoding_gb18030</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_response_encoding_gb18030>

    @defer.inlineCallbacks
    def test_response_encoding_gb18030(self):
>       _, out, _ = yield self.execute(
            [self.url("/enc-gb18030"), "-c", "response.encoding"]
        )
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:47: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_response_selector_html">test_command_shell.py::ShellTest::test_response_selector_html</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_response_selector_html</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_response_selector_html>

    @defer.inlineCallbacks
    def test_response_selector_html(self):
        xpath = "response.xpath(\"//p[@class='one']/text()\").get()"
>       _, out, _ = yield self.execute([self.url("/html"), "-c", xpath])
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:42: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_response_type_html">test_command_shell.py::ShellTest::test_response_type_html</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_response_type_html</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_response_type_html>

    @defer.inlineCallbacks
    def test_response_type_html(self):
>       _, out, _ = yield self.execute([self.url("/html"), "-c", "type(response)"])
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:36: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_response_type_text">test_command_shell.py::ShellTest::test_response_type_text</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_response_type_text</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_response_type_text>

    @defer.inlineCallbacks
    def test_response_type_text(self):
>       _, out, _ = yield self.execute([self.url("/text"), "-c", "type(response)"])
E       AttributeError: 'ShellTest' object has no attribute 'execute'

/testbed/tests/test_command_shell.py:31: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_scrapy_import">test_command_shell.py::ShellTest::test_scrapy_import</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_scrapy_import</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_scrapy_import>

    @defer.inlineCallbacks
    def test_scrapy_import(self):
>       url = self.url("/text")
E       AttributeError: 'ShellTest' object has no attribute 'url'

/testbed/tests/test_command_shell.py:104: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyshelltesttest_shell_fetch_async">test_command_shell.py::ShellTest::test_shell_fetch_async</h3>
<details><summary> <pre>test_command_shell.py::ShellTest::test_shell_fetch_async</pre></summary><pre>
self = <tests.test_command_shell.ShellTest testMethod=test_shell_fetch_async>

    @defer.inlineCallbacks
    def test_shell_fetch_async(self):
        reactor_path = "twisted.internet.asyncioreactor.AsyncioSelectorReactor"
>       url = self.url("/html")
E       AttributeError: 'ShellTest' object has no attribute 'url'

/testbed/tests/test_command_shell.py:136: AttributeError
</pre>
</details>
<h3 id="test_command_shellpyinteractiveshelltesttest_fetch">test_command_shell.py::InteractiveShellTest::test_fetch</h3>
<details><summary> <pre>test_command_shell.py::InteractiveShellTest::test_fetch</pre></summary><pre>
self = <tests.test_command_shell.InteractiveShellTest testMethod=test_fetch>

    def test_fetch(self):
        args = (
            sys.executable,
            "-m",
            "scrapy.cmdline",
            "shell",
        )
        env = os.environ.copy()
        env["SCRAPY_PYTHON_SHELL"] = "python"
        logfile = BytesIO()
        p = PopenSpawn(args, env=env, timeout=5)
        p.logfile_read = logfile
>       p.expect_exact("Available Scrapy objects")

/testbed/tests/test_command_shell.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/pexpect/spawnbase.py:432: in expect_exact
    return exp.expect_loop(timeout)
/testbed/.venv/lib/python3.12/site-packages/pexpect/expect.py:179: in expect_loop
    return self.eof(e)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pexpect.expect.Expecter object at 0x7fcb96d8f7a0>
err = EOF('End Of File (EOF).')

    def eof(self, err=None):
        spawn = self.spawn

        spawn.before = spawn._before.getvalue()
        spawn._buffer = spawn.buffer_type()
        spawn._before = spawn.buffer_type()
        spawn.after = EOF
        index = self.searcher.eof_index
        if index >= 0:
            spawn.match = EOF
            spawn.match_index = index
            return index
        else:
            spawn.match = None
            spawn.match_index = None
            msg = str(spawn)
            msg += '\nsearcher: %s' % self.searcher
            if err is not None:
                msg = str(err) + '\n' + msg

            exc = EOF(msg)
            exc.__cause__ = None # in Python 3.x we can use "raise exc from None"
>           raise exc
E           pexpect.exceptions.EOF: End Of File (EOF).
E           <pexpect.popen_spawn.PopenSpawn object at 0x7fcb96d8ce60>
E           searcher: searcher_string:
E               0: b'Available Scrapy objects'

/testbed/.venv/lib/python3.12/site-packages/pexpect/expect.py:122: EOF
</pre>
</details>
<h3 id="test_command_versionpyversiontesttest_output">test_command_version.py::VersionTest::test_output</h3>
<details><summary> <pre>test_command_version.py::VersionTest::test_output</pre></summary><pre>
self = <tests.test_command_version.VersionTest testMethod=test_output>

    @defer.inlineCallbacks
    def test_output(self):
        encoding = getattr(sys.stdout, "encoding") or "utf-8"
>       _, out, _ = yield self.execute([])
E       AttributeError: 'VersionTest' object has no attribute 'execute'

/testbed/tests/test_command_version.py:16: AttributeError
</pre>
</details>
<h3 id="test_command_versionpyversiontesttest_verbose_output">test_command_version.py::VersionTest::test_verbose_output</h3>
<details><summary> <pre>test_command_version.py::VersionTest::test_verbose_output</pre></summary><pre>
self = <tests.test_command_version.VersionTest testMethod=test_verbose_output>

    @defer.inlineCallbacks
    def test_verbose_output(self):
        encoding = getattr(sys.stdout, "encoding") or "utf-8"
>       _, out, _ = yield self.execute(["-v"])
E       AttributeError: 'VersionTest' object has no attribute 'execute'

/testbed/tests/test_command_version.py:25: AttributeError
</pre>
</details>
<h3 id="test_downloadermiddleware_httpauthpyhttpauthmiddlewarelegacytesttest_auth">test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareLegacyTest::test_auth</h3>
<details><summary> <pre>test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareLegacyTest::test_auth</pre></summary><pre>
self = <tests.test_downloadermiddleware_httpauth.HttpAuthMiddlewareLegacyTest testMethod=test_auth>

    def test_auth(self):
        with pytest.warns(
            ScrapyDeprecationWarning,
            match="Using HttpAuthMiddleware without http_auth_domain is deprecated",
        ):
            mw = HttpAuthMiddleware()
>           mw.spider_opened(self.spider)
E           AttributeError: 'HttpAuthMiddleware' object has no attribute 'spider_opened'

/testbed/tests/test_downloadermiddleware_httpauth.py:39: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_downloadermiddleware_httpauth.HttpAuthMiddlewareLegacyTest testMethod=test_auth>

    def test_auth(self):
>       with pytest.warns(
            ScrapyDeprecationWarning,
            match="Using HttpAuthMiddleware without http_auth_domain is deprecated",
        ):
E       Failed: DID NOT WARN. No warnings of type (<class 'scrapy.exceptions.ScrapyDeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

/testbed/tests/test_downloadermiddleware_httpauth.py:34: Failed
</pre>
</details>
<h3 id="test_downloadermiddleware_httpauthpyhttpauthmiddlewarelegacytesttest_auth_already_set">test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareLegacyTest::test_auth_already_set</h3>
<details><summary> <pre>test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareLegacyTest::test_auth_already_set</pre></summary><pre>
self = <tests.test_downloadermiddleware_httpauth.HttpAuthMiddlewareLegacyTest testMethod=test_auth_already_set>

    def test_auth_already_set(self):
        with pytest.warns(
            ScrapyDeprecationWarning,
            match="Using HttpAuthMiddleware without http_auth_domain is deprecated",
        ):
            mw = HttpAuthMiddleware()
>           mw.spider_opened(self.spider)
E           AttributeError: 'HttpAuthMiddleware' object has no attribute 'spider_opened'

/testbed/tests/test_downloadermiddleware_httpauth.py:62: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_downloadermiddleware_httpauth.HttpAuthMiddlewareLegacyTest testMethod=test_auth_already_set>

    def test_auth_already_set(self):
>       with pytest.warns(
            ScrapyDeprecationWarning,
            match="Using HttpAuthMiddleware without http_auth_domain is deprecated",
        ):
E       Failed: DID NOT WARN. No warnings of type (<class 'scrapy.exceptions.ScrapyDeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

/testbed/tests/test_downloadermiddleware_httpauth.py:57: Failed
</pre>
</details>
<h3 id="test_downloadermiddleware_httpauthpyhttpauthmiddlewaretesttest_auth_already_set">test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_auth_already_set</h3>
<details><summary> <pre>test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_auth_already_set</pre></summary><pre>
self = <tests.test_downloadermiddleware_httpauth.HttpAuthMiddlewareTest testMethod=test_auth_already_set>

    def setUp(self):
        self.mw = HttpAuthMiddleware()
        self.spider = TestSpider("foo")
>       self.mw.spider_opened(self.spider)
E       AttributeError: 'HttpAuthMiddleware' object has no attribute 'spider_opened'

/testbed/tests/test_downloadermiddleware_httpauth.py:72: AttributeError
</pre>
</details>
<h3 id="test_downloadermiddleware_httpauthpyhttpauthmiddlewaretesttest_auth_domain">test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_auth_domain</h3>
<details><summary> <pre>test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_auth_domain</pre></summary><pre>
self = <tests.test_downloadermiddleware_httpauth.HttpAuthMiddlewareTest testMethod=test_auth_domain>

    def setUp(self):
        self.mw = HttpAuthMiddleware()
        self.spider = TestSpider("foo")
>       self.mw.spider_opened(self.spider)
E       AttributeError: 'HttpAuthMiddleware' object has no attribute 'spider_opened'

/testbed/tests/test_downloadermiddleware_httpauth.py:72: AttributeError
</pre>
</details>
<h3 id="test_downloadermiddleware_httpauthpyhttpauthmiddlewaretesttest_auth_subdomain">test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_auth_subdomain</h3>
<details><summary> <pre>test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_auth_subdomain</pre></summary><pre>
self = <tests.test_downloadermiddleware_httpauth.HttpAuthMiddlewareTest testMethod=test_auth_subdomain>

    def setUp(self):
        self.mw = HttpAuthMiddleware()
        self.spider = TestSpider("foo")
>       self.mw.spider_opened(self.spider)
E       AttributeError: 'HttpAuthMiddleware' object has no attribute 'spider_opened'

/testbed/tests/test_downloadermiddleware_httpauth.py:72: AttributeError
</pre>
</details>
<h3 id="test_downloadermiddleware_httpauthpyhttpauthmiddlewaretesttest_no_auth">test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_no_auth</h3>
<details><summary> <pre>test_downloadermiddleware_httpauth.py::HttpAuthMiddlewareTest::test_no_auth</pre></summary><pre>
self = <tests.test_downloadermiddleware_httpauth.HttpAuthMiddlewareTest testMethod=test_no_auth>

    def setUp(self):
        self.mw = HttpAuthMiddleware()
        self.spider = TestSpider("foo")
>       self.mw.spider_opened(self.spider)
E       AttributeError: 'HttpAuthMiddleware' object has no attribute 'spider_opened'

/testbed/tests/test_downloadermiddleware_httpauth.py:72: AttributeError
</pre>
</details>
<h3 id="test_downloadermiddleware_httpauthpyhttpauthanymiddlewaretesttest_auth">test_downloadermiddleware_httpauth.py::HttpAuthAnyMiddlewareTest::test_auth</h3>
<details><summary> <pre>test_downloadermiddleware_httpauth.py::HttpAuthAnyMiddlewareTest::test_auth</pre></summary><pre>
self = <tests.test_downloadermiddleware_httpauth.HttpAuthAnyMiddlewareTest testMethod=test_auth>

    def setUp(self):
        self.mw = HttpAuthMiddleware()
        self.spider = TestSpiderAny("foo")
>       self.mw.spider_opened(self.spider)
E       AttributeError: 'HttpAuthMiddleware' object has no attribute 'spider_opened'

/testbed/tests/test_downloadermiddleware_httpauth.py:102: AttributeError
</pre>
</details>
<h3 id="test_downloadermiddleware_httpauthpyhttpauthanymiddlewaretesttest_auth_already_set">test_downloadermiddleware_httpauth.py::HttpAuthAnyMiddlewareTest::test_auth_already_set</h3>
<details><summary> <pre>test_downloadermiddleware_httpauth.py::HttpAuthAnyMiddlewareTest::test_auth_already_set</pre></summary><pre>
self = <tests.test_downloadermiddleware_httpauth.HttpAuthAnyMiddlewareTest testMethod=test_auth_already_set>

    def setUp(self):
        self.mw = HttpAuthMiddleware()
        self.spider = TestSpiderAny("foo")
>       self.mw.spider_opened(self.spider)
E       AttributeError: 'HttpAuthMiddleware' object has no attribute 'spider_opened'

/testbed/tests/test_downloadermiddleware_httpauth.py:102: AttributeError
</pre>
</details>
<h3 id="test_exporterspybaseitemexportertesttest_export_dict_item">test_exporters.py::BaseItemExporterTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::BaseItemExporterTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.BaseItemExporterTest testMethod=test_export_dict_item>

    def test_export_dict_item(self):
>       self.assertItemExportWorks(ItemAdapter(self.i).asdict())

/testbed/tests/test_exporters.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.BaseItemExporterTest testMethod=test_export_dict_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'BaseItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspybaseitemexportertesttest_export_item">test_exporters.py::BaseItemExporterTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::BaseItemExporterTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.BaseItemExporterTest testMethod=test_export_item>

    def test_export_item(self):
>       self.assertItemExportWorks(self.i)

/testbed/tests/test_exporters.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.BaseItemExporterTest testMethod=test_export_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'BaseItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspybaseitemexportertesttest_field_custom_serializer">test_exporters.py::BaseItemExporterTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::BaseItemExporterTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.BaseItemExporterTest testMethod=test_field_custom_serializer>

    def test_field_custom_serializer(self):
        i = self.custom_field_item_class(name="John\xa3", age="22")
        a = ItemAdapter(i)
        ie = self._get_exporter()
        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John\xa3"
        )
E       AttributeError: 'BaseItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:130: AttributeError
</pre>
</details>
<h3 id="test_exporterspybaseitemexportertesttest_fields_to_export">test_exporters.py::BaseItemExporterTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::BaseItemExporterTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.BaseItemExporterTest testMethod=test_fields_to_export>

    def test_fields_to_export(self):
        ie = self._get_exporter(fields_to_export=["name"])
        self.assertEqual(
>           list(ie._get_serialized_fields(self.i)), [("name", "John\xa3")]
        )
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_exporters.py:114: TypeError
</pre>
</details>
<h3 id="test_exporterspybaseitemexportertesttest_serialize_field">test_exporters.py::BaseItemExporterTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::BaseItemExporterTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.BaseItemExporterTest testMethod=test_serialize_field>

    def test_serialize_field(self):
        a = ItemAdapter(self.i)
>       res = self.ie.serialize_field(a.get_field_meta("name"), "name", a["name"])
E       AttributeError: 'BaseItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:105: AttributeError
</pre>
</details>
<h3 id="test_exporterspybaseitemexporterdataclasstesttest_export_dict_item">test_exporters.py::BaseItemExporterDataclassTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::BaseItemExporterDataclassTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.BaseItemExporterDataclassTest testMethod=test_export_dict_item>

    def test_export_dict_item(self):
>       self.assertItemExportWorks(ItemAdapter(self.i).asdict())

/testbed/tests/test_exporters.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.BaseItemExporterDataclassTest testMethod=test_export_dict_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'BaseItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspybaseitemexporterdataclasstesttest_export_item">test_exporters.py::BaseItemExporterDataclassTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::BaseItemExporterDataclassTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.BaseItemExporterDataclassTest testMethod=test_export_item>

    def test_export_item(self):
>       self.assertItemExportWorks(self.i)

/testbed/tests/test_exporters.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.BaseItemExporterDataclassTest testMethod=test_export_item>
item = TestDataClass(name='John£', age='22')

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'BaseItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspybaseitemexporterdataclasstesttest_field_custom_serializer">test_exporters.py::BaseItemExporterDataclassTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::BaseItemExporterDataclassTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.BaseItemExporterDataclassTest testMethod=test_field_custom_serializer>

    def test_field_custom_serializer(self):
        i = self.custom_field_item_class(name="John\xa3", age="22")
        a = ItemAdapter(i)
        ie = self._get_exporter()
        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John\xa3"
        )
E       AttributeError: 'BaseItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:130: AttributeError
</pre>
</details>
<h3 id="test_exporterspybaseitemexporterdataclasstesttest_fields_to_export">test_exporters.py::BaseItemExporterDataclassTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::BaseItemExporterDataclassTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.BaseItemExporterDataclassTest testMethod=test_fields_to_export>

    def test_fields_to_export(self):
        ie = self._get_exporter(fields_to_export=["name"])
        self.assertEqual(
>           list(ie._get_serialized_fields(self.i)), [("name", "John\xa3")]
        )
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_exporters.py:114: TypeError
</pre>
</details>
<h3 id="test_exporterspybaseitemexporterdataclasstesttest_serialize_field">test_exporters.py::BaseItemExporterDataclassTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::BaseItemExporterDataclassTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.BaseItemExporterDataclassTest testMethod=test_serialize_field>

    def test_serialize_field(self):
        a = ItemAdapter(self.i)
>       res = self.ie.serialize_field(a.get_field_meta("name"), "name", a["name"])
E       AttributeError: 'BaseItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:105: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexportertesttest_export_dict_item">test_exporters.py::PythonItemExporterTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterTest testMethod=test_export_dict_item>

    def test_export_dict_item(self):
>       self.assertItemExportWorks(ItemAdapter(self.i).asdict())

/testbed/tests/test_exporters.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PythonItemExporterTest testMethod=test_export_dict_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PythonItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexportertesttest_export_item">test_exporters.py::PythonItemExporterTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterTest testMethod=test_export_item>

    def test_export_item(self):
>       self.assertItemExportWorks(self.i)

/testbed/tests/test_exporters.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PythonItemExporterTest testMethod=test_export_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PythonItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexportertesttest_export_item_dict_list">test_exporters.py::PythonItemExporterTest::test_export_item_dict_list</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterTest::test_export_item_dict_list</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterTest testMethod=test_export_item_dict_list>

    def test_export_item_dict_list(self):
        i1 = self.item_class(name="Joseph", age="22")
        i2 = dict(name="Maria", age=[i1])
        i3 = self.item_class(name="Jesus", age=[i2])
        ie = self._get_exporter()
>       exported = ie.export_item(i3)
E       AttributeError: 'PythonItemExporter' object has no attribute 'export_item'

/testbed/tests/test_exporters.py:188: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexportertesttest_export_list">test_exporters.py::PythonItemExporterTest::test_export_list</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterTest::test_export_list</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterTest testMethod=test_export_list>

    def test_export_list(self):
        i1 = self.item_class(name="Joseph", age="22")
        i2 = self.item_class(name="Maria", age=[i1])
        i3 = self.item_class(name="Jesus", age=[i2])
        ie = self._get_exporter()
>       exported = ie.export_item(i3)
E       AttributeError: 'PythonItemExporter' object has no attribute 'export_item'

/testbed/tests/test_exporters.py:172: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexportertesttest_field_custom_serializer">test_exporters.py::PythonItemExporterTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterTest testMethod=test_field_custom_serializer>

    def test_field_custom_serializer(self):
        i = self.custom_field_item_class(name="John\xa3", age="22")
        a = ItemAdapter(i)
        ie = self._get_exporter()
        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John\xa3"
        )
E       AttributeError: 'PythonItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:130: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexportertesttest_fields_to_export">test_exporters.py::PythonItemExporterTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterTest testMethod=test_fields_to_export>

    def test_fields_to_export(self):
        ie = self._get_exporter(fields_to_export=["name"])
        self.assertEqual(
>           list(ie._get_serialized_fields(self.i)), [("name", "John\xa3")]
        )
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_exporters.py:114: TypeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexportertesttest_invalid_option">test_exporters.py::PythonItemExporterTest::test_invalid_option</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterTest::test_invalid_option</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterTest testMethod=test_invalid_option>

    def test_invalid_option(self):
>       with self.assertRaisesRegex(TypeError, "Unexpected options: invalid_option"):
E       AssertionError: TypeError not raised

/testbed/tests/test_exporters.py:147: AssertionError
</pre>
</details>
<h3 id="test_exporterspypythonitemexportertesttest_nested_item">test_exporters.py::PythonItemExporterTest::test_nested_item</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterTest::test_nested_item</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterTest testMethod=test_nested_item>

    def test_nested_item(self):
        i1 = self.item_class(name="Joseph", age="22")
        i2 = dict(name="Maria", age=i1)
        i3 = self.item_class(name="Jesus", age=i2)
        ie = self._get_exporter()
>       exported = ie.export_item(i3)
E       AttributeError: 'PythonItemExporter' object has no attribute 'export_item'

/testbed/tests/test_exporters.py:155: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexportertesttest_nonstring_types_item">test_exporters.py::PythonItemExporterTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterTest testMethod=test_nonstring_types_item>

    def test_nonstring_types_item(self):
        item = self._get_nonstring_types_item()
        ie = self._get_exporter()
>       exported = ie.export_item(item)
E       AttributeError: 'PythonItemExporter' object has no attribute 'export_item'

/testbed/tests/test_exporters.py:202: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexportertesttest_serialize_field">test_exporters.py::PythonItemExporterTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterTest testMethod=test_serialize_field>

    def test_serialize_field(self):
        a = ItemAdapter(self.i)
>       res = self.ie.serialize_field(a.get_field_meta("name"), "name", a["name"])
E       AttributeError: 'PythonItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:105: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexporterdataclasstesttest_export_dict_item">test_exporters.py::PythonItemExporterDataclassTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterDataclassTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_export_dict_item>

    def test_export_dict_item(self):
>       self.assertItemExportWorks(ItemAdapter(self.i).asdict())

/testbed/tests/test_exporters.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_export_dict_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PythonItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexporterdataclasstesttest_export_item">test_exporters.py::PythonItemExporterDataclassTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterDataclassTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_export_item>

    def test_export_item(self):
>       self.assertItemExportWorks(self.i)

/testbed/tests/test_exporters.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_export_item>
item = TestDataClass(name='John£', age='22')

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PythonItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexporterdataclasstesttest_export_item_dict_list">test_exporters.py::PythonItemExporterDataclassTest::test_export_item_dict_list</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterDataclassTest::test_export_item_dict_list</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_export_item_dict_list>

    def test_export_item_dict_list(self):
        i1 = self.item_class(name="Joseph", age="22")
        i2 = dict(name="Maria", age=[i1])
        i3 = self.item_class(name="Jesus", age=[i2])
        ie = self._get_exporter()
>       exported = ie.export_item(i3)
E       AttributeError: 'PythonItemExporter' object has no attribute 'export_item'

/testbed/tests/test_exporters.py:188: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexporterdataclasstesttest_export_list">test_exporters.py::PythonItemExporterDataclassTest::test_export_list</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterDataclassTest::test_export_list</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_export_list>

    def test_export_list(self):
        i1 = self.item_class(name="Joseph", age="22")
        i2 = self.item_class(name="Maria", age=[i1])
        i3 = self.item_class(name="Jesus", age=[i2])
        ie = self._get_exporter()
>       exported = ie.export_item(i3)
E       AttributeError: 'PythonItemExporter' object has no attribute 'export_item'

/testbed/tests/test_exporters.py:172: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexporterdataclasstesttest_field_custom_serializer">test_exporters.py::PythonItemExporterDataclassTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterDataclassTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_field_custom_serializer>

    def test_field_custom_serializer(self):
        i = self.custom_field_item_class(name="John\xa3", age="22")
        a = ItemAdapter(i)
        ie = self._get_exporter()
        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John\xa3"
        )
E       AttributeError: 'PythonItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:130: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexporterdataclasstesttest_fields_to_export">test_exporters.py::PythonItemExporterDataclassTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterDataclassTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_fields_to_export>

    def test_fields_to_export(self):
        ie = self._get_exporter(fields_to_export=["name"])
        self.assertEqual(
>           list(ie._get_serialized_fields(self.i)), [("name", "John\xa3")]
        )
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_exporters.py:114: TypeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexporterdataclasstesttest_invalid_option">test_exporters.py::PythonItemExporterDataclassTest::test_invalid_option</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterDataclassTest::test_invalid_option</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_invalid_option>

    def test_invalid_option(self):
>       with self.assertRaisesRegex(TypeError, "Unexpected options: invalid_option"):
E       AssertionError: TypeError not raised

/testbed/tests/test_exporters.py:147: AssertionError
</pre>
</details>
<h3 id="test_exporterspypythonitemexporterdataclasstesttest_nested_item">test_exporters.py::PythonItemExporterDataclassTest::test_nested_item</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterDataclassTest::test_nested_item</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_nested_item>

    def test_nested_item(self):
        i1 = self.item_class(name="Joseph", age="22")
        i2 = dict(name="Maria", age=i1)
        i3 = self.item_class(name="Jesus", age=i2)
        ie = self._get_exporter()
>       exported = ie.export_item(i3)
E       AttributeError: 'PythonItemExporter' object has no attribute 'export_item'

/testbed/tests/test_exporters.py:155: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexporterdataclasstesttest_nonstring_types_item">test_exporters.py::PythonItemExporterDataclassTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterDataclassTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_nonstring_types_item>

    def test_nonstring_types_item(self):
        item = self._get_nonstring_types_item()
        ie = self._get_exporter()
>       exported = ie.export_item(item)
E       AttributeError: 'PythonItemExporter' object has no attribute 'export_item'

/testbed/tests/test_exporters.py:202: AttributeError
</pre>
</details>
<h3 id="test_exporterspypythonitemexporterdataclasstesttest_serialize_field">test_exporters.py::PythonItemExporterDataclassTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::PythonItemExporterDataclassTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.PythonItemExporterDataclassTest testMethod=test_serialize_field>

    def test_serialize_field(self):
        a = ItemAdapter(self.i)
>       res = self.ie.serialize_field(a.get_field_meta("name"), "name", a["name"])
E       AttributeError: 'PythonItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:105: AttributeError
</pre>
</details>
<h3 id="test_exporterspypprintitemexportertesttest_export_dict_item">test_exporters.py::PprintItemExporterTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::PprintItemExporterTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.PprintItemExporterTest testMethod=test_export_dict_item>

    def test_export_dict_item(self):
>       self.assertItemExportWorks(ItemAdapter(self.i).asdict())

/testbed/tests/test_exporters.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PprintItemExporterTest testMethod=test_export_dict_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PprintItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypprintitemexportertesttest_export_item">test_exporters.py::PprintItemExporterTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::PprintItemExporterTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.PprintItemExporterTest testMethod=test_export_item>

    def test_export_item(self):
>       self.assertItemExportWorks(self.i)

/testbed/tests/test_exporters.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PprintItemExporterTest testMethod=test_export_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PprintItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypprintitemexportertesttest_field_custom_serializer">test_exporters.py::PprintItemExporterTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::PprintItemExporterTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.PprintItemExporterTest testMethod=test_field_custom_serializer>

    def test_field_custom_serializer(self):
        i = self.custom_field_item_class(name="John\xa3", age="22")
        a = ItemAdapter(i)
        ie = self._get_exporter()
        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John\xa3"
        )
E       AttributeError: 'PprintItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:130: AttributeError
</pre>
</details>
<h3 id="test_exporterspypprintitemexportertesttest_fields_to_export">test_exporters.py::PprintItemExporterTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::PprintItemExporterTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.PprintItemExporterTest testMethod=test_fields_to_export>

    def test_fields_to_export(self):
        ie = self._get_exporter(fields_to_export=["name"])
        self.assertEqual(
>           list(ie._get_serialized_fields(self.i)), [("name", "John\xa3")]
        )
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_exporters.py:114: TypeError
</pre>
</details>
<h3 id="test_exporterspypprintitemexportertesttest_serialize_field">test_exporters.py::PprintItemExporterTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::PprintItemExporterTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.PprintItemExporterTest testMethod=test_serialize_field>

    def test_serialize_field(self):
        a = ItemAdapter(self.i)
>       res = self.ie.serialize_field(a.get_field_meta("name"), "name", a["name"])
E       AttributeError: 'PprintItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:105: AttributeError
</pre>
</details>
<h3 id="test_exporterspypprintitemexporterdataclasstesttest_export_dict_item">test_exporters.py::PprintItemExporterDataclassTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::PprintItemExporterDataclassTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.PprintItemExporterDataclassTest testMethod=test_export_dict_item>

    def test_export_dict_item(self):
>       self.assertItemExportWorks(ItemAdapter(self.i).asdict())

/testbed/tests/test_exporters.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PprintItemExporterDataclassTest testMethod=test_export_dict_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PprintItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypprintitemexporterdataclasstesttest_export_item">test_exporters.py::PprintItemExporterDataclassTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::PprintItemExporterDataclassTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.PprintItemExporterDataclassTest testMethod=test_export_item>

    def test_export_item(self):
>       self.assertItemExportWorks(self.i)

/testbed/tests/test_exporters.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PprintItemExporterDataclassTest testMethod=test_export_item>
item = TestDataClass(name='John£', age='22')

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PprintItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypprintitemexporterdataclasstesttest_field_custom_serializer">test_exporters.py::PprintItemExporterDataclassTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::PprintItemExporterDataclassTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.PprintItemExporterDataclassTest testMethod=test_field_custom_serializer>

    def test_field_custom_serializer(self):
        i = self.custom_field_item_class(name="John\xa3", age="22")
        a = ItemAdapter(i)
        ie = self._get_exporter()
        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John\xa3"
        )
E       AttributeError: 'PprintItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:130: AttributeError
</pre>
</details>
<h3 id="test_exporterspypprintitemexporterdataclasstesttest_fields_to_export">test_exporters.py::PprintItemExporterDataclassTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::PprintItemExporterDataclassTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.PprintItemExporterDataclassTest testMethod=test_fields_to_export>

    def test_fields_to_export(self):
        ie = self._get_exporter(fields_to_export=["name"])
        self.assertEqual(
>           list(ie._get_serialized_fields(self.i)), [("name", "John\xa3")]
        )
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_exporters.py:114: TypeError
</pre>
</details>
<h3 id="test_exporterspypprintitemexporterdataclasstesttest_serialize_field">test_exporters.py::PprintItemExporterDataclassTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::PprintItemExporterDataclassTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.PprintItemExporterDataclassTest testMethod=test_serialize_field>

    def test_serialize_field(self):
        a = ItemAdapter(self.i)
>       res = self.ie.serialize_field(a.get_field_meta("name"), "name", a["name"])
E       AttributeError: 'PprintItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:105: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexportertesttest_export_dict_item">test_exporters.py::PickleItemExporterTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterTest testMethod=test_export_dict_item>

    def test_export_dict_item(self):
>       self.assertItemExportWorks(ItemAdapter(self.i).asdict())

/testbed/tests/test_exporters.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PickleItemExporterTest testMethod=test_export_dict_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PickleItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexportertesttest_export_item">test_exporters.py::PickleItemExporterTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterTest testMethod=test_export_item>

    def test_export_item(self):
>       self.assertItemExportWorks(self.i)

/testbed/tests/test_exporters.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PickleItemExporterTest testMethod=test_export_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PickleItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexportertesttest_export_multiple_items">test_exporters.py::PickleItemExporterTest::test_export_multiple_items</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterTest::test_export_multiple_items</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterTest testMethod=test_export_multiple_items>

    def test_export_multiple_items(self):
        i1 = self.item_class(name="hello", age="world")
        i2 = self.item_class(name="bye", age="world")
        f = BytesIO()
        ie = PickleItemExporter(f)
>       ie.start_exporting()
E       AttributeError: 'PickleItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:236: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexportertesttest_field_custom_serializer">test_exporters.py::PickleItemExporterTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterTest testMethod=test_field_custom_serializer>

    def test_field_custom_serializer(self):
        i = self.custom_field_item_class(name="John\xa3", age="22")
        a = ItemAdapter(i)
        ie = self._get_exporter()
        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John\xa3"
        )
E       AttributeError: 'PickleItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:130: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexportertesttest_fields_to_export">test_exporters.py::PickleItemExporterTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterTest testMethod=test_fields_to_export>

    def test_fields_to_export(self):
        ie = self._get_exporter(fields_to_export=["name"])
        self.assertEqual(
>           list(ie._get_serialized_fields(self.i)), [("name", "John\xa3")]
        )
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_exporters.py:114: TypeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexportertesttest_nonstring_types_item">test_exporters.py::PickleItemExporterTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterTest testMethod=test_nonstring_types_item>

    def test_nonstring_types_item(self):
        item = self._get_nonstring_types_item()
        fp = BytesIO()
        ie = PickleItemExporter(fp)
>       ie.start_exporting()
E       AttributeError: 'PickleItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:249: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexportertesttest_serialize_field">test_exporters.py::PickleItemExporterTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterTest testMethod=test_serialize_field>

    def test_serialize_field(self):
        a = ItemAdapter(self.i)
>       res = self.ie.serialize_field(a.get_field_meta("name"), "name", a["name"])
E       AttributeError: 'PickleItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:105: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexporterdataclasstesttest_export_dict_item">test_exporters.py::PickleItemExporterDataclassTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterDataclassTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterDataclassTest testMethod=test_export_dict_item>

    def test_export_dict_item(self):
>       self.assertItemExportWorks(ItemAdapter(self.i).asdict())

/testbed/tests/test_exporters.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PickleItemExporterDataclassTest testMethod=test_export_dict_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PickleItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexporterdataclasstesttest_export_item">test_exporters.py::PickleItemExporterDataclassTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterDataclassTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterDataclassTest testMethod=test_export_item>

    def test_export_item(self):
>       self.assertItemExportWorks(self.i)

/testbed/tests/test_exporters.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.PickleItemExporterDataclassTest testMethod=test_export_item>
item = TestDataClass(name='John£', age='22')

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'PickleItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexporterdataclasstesttest_export_multiple_items">test_exporters.py::PickleItemExporterDataclassTest::test_export_multiple_items</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterDataclassTest::test_export_multiple_items</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterDataclassTest testMethod=test_export_multiple_items>

    def test_export_multiple_items(self):
        i1 = self.item_class(name="hello", age="world")
        i2 = self.item_class(name="bye", age="world")
        f = BytesIO()
        ie = PickleItemExporter(f)
>       ie.start_exporting()
E       AttributeError: 'PickleItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:236: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexporterdataclasstesttest_field_custom_serializer">test_exporters.py::PickleItemExporterDataclassTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterDataclassTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterDataclassTest testMethod=test_field_custom_serializer>

    def test_field_custom_serializer(self):
        i = self.custom_field_item_class(name="John\xa3", age="22")
        a = ItemAdapter(i)
        ie = self._get_exporter()
        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John\xa3"
        )
E       AttributeError: 'PickleItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:130: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexporterdataclasstesttest_fields_to_export">test_exporters.py::PickleItemExporterDataclassTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterDataclassTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterDataclassTest testMethod=test_fields_to_export>

    def test_fields_to_export(self):
        ie = self._get_exporter(fields_to_export=["name"])
        self.assertEqual(
>           list(ie._get_serialized_fields(self.i)), [("name", "John\xa3")]
        )
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_exporters.py:114: TypeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexporterdataclasstesttest_nonstring_types_item">test_exporters.py::PickleItemExporterDataclassTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterDataclassTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterDataclassTest testMethod=test_nonstring_types_item>

    def test_nonstring_types_item(self):
        item = self._get_nonstring_types_item()
        fp = BytesIO()
        ie = PickleItemExporter(fp)
>       ie.start_exporting()
E       AttributeError: 'PickleItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:249: AttributeError
</pre>
</details>
<h3 id="test_exporterspypickleitemexporterdataclasstesttest_serialize_field">test_exporters.py::PickleItemExporterDataclassTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::PickleItemExporterDataclassTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.PickleItemExporterDataclassTest testMethod=test_serialize_field>

    def test_serialize_field(self):
        a = ItemAdapter(self.i)
>       res = self.ie.serialize_field(a.get_field_meta("name"), "name", a["name"])
E       AttributeError: 'PickleItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:105: AttributeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexportertesttest_export_dict_item">test_exporters.py::MarshalItemExporterTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterTest testMethod=test_export_dict_item>

    def test_export_dict_item(self):
>       self.assertItemExportWorks(ItemAdapter(self.i).asdict())

/testbed/tests/test_exporters.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.MarshalItemExporterTest testMethod=test_export_dict_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'MarshalItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexportertesttest_export_item">test_exporters.py::MarshalItemExporterTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterTest testMethod=test_export_item>

    def test_export_item(self):
>       self.assertItemExportWorks(self.i)

/testbed/tests/test_exporters.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.MarshalItemExporterTest testMethod=test_export_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'MarshalItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexportertesttest_field_custom_serializer">test_exporters.py::MarshalItemExporterTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterTest testMethod=test_field_custom_serializer>

    def test_field_custom_serializer(self):
        i = self.custom_field_item_class(name="John\xa3", age="22")
        a = ItemAdapter(i)
        ie = self._get_exporter()
        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John\xa3"
        )
E       AttributeError: 'MarshalItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:130: AttributeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexportertesttest_fields_to_export">test_exporters.py::MarshalItemExporterTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterTest testMethod=test_fields_to_export>

    def test_fields_to_export(self):
        ie = self._get_exporter(fields_to_export=["name"])
        self.assertEqual(
>           list(ie._get_serialized_fields(self.i)), [("name", "John\xa3")]
        )
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_exporters.py:114: TypeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexportertesttest_nonstring_types_item">test_exporters.py::MarshalItemExporterTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterTest testMethod=test_nonstring_types_item>

    def test_nonstring_types_item(self):
        item = self._get_nonstring_types_item()
        item.pop("time")  # datetime is not marshallable
        fp = tempfile.TemporaryFile()
        ie = MarshalItemExporter(fp)
>       ie.start_exporting()
E       AttributeError: 'MarshalItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:275: AttributeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexportertesttest_serialize_field">test_exporters.py::MarshalItemExporterTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterTest testMethod=test_serialize_field>

    def test_serialize_field(self):
        a = ItemAdapter(self.i)
>       res = self.ie.serialize_field(a.get_field_meta("name"), "name", a["name"])
E       AttributeError: 'MarshalItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:105: AttributeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexporterdataclasstesttest_export_dict_item">test_exporters.py::MarshalItemExporterDataclassTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterDataclassTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterDataclassTest testMethod=test_export_dict_item>

    def test_export_dict_item(self):
>       self.assertItemExportWorks(ItemAdapter(self.i).asdict())

/testbed/tests/test_exporters.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.MarshalItemExporterDataclassTest testMethod=test_export_dict_item>
item = {'age': '22', 'name': 'John£'}

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'MarshalItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexporterdataclasstesttest_export_item">test_exporters.py::MarshalItemExporterDataclassTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterDataclassTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterDataclassTest testMethod=test_export_item>

    def test_export_item(self):
>       self.assertItemExportWorks(self.i)

/testbed/tests/test_exporters.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.MarshalItemExporterDataclassTest testMethod=test_export_item>
item = TestDataClass(name='John£', age='22')

    def assertItemExportWorks(self, item):
>       self.ie.start_exporting()
E       AttributeError: 'MarshalItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:84: AttributeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexporterdataclasstesttest_field_custom_serializer">test_exporters.py::MarshalItemExporterDataclassTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterDataclassTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterDataclassTest testMethod=test_field_custom_serializer>

    def test_field_custom_serializer(self):
        i = self.custom_field_item_class(name="John\xa3", age="22")
        a = ItemAdapter(i)
        ie = self._get_exporter()
        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John\xa3"
        )
E       AttributeError: 'MarshalItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:130: AttributeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexporterdataclasstesttest_fields_to_export">test_exporters.py::MarshalItemExporterDataclassTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterDataclassTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterDataclassTest testMethod=test_fields_to_export>

    def test_fields_to_export(self):
        ie = self._get_exporter(fields_to_export=["name"])
        self.assertEqual(
>           list(ie._get_serialized_fields(self.i)), [("name", "John\xa3")]
        )
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_exporters.py:114: TypeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexporterdataclasstesttest_nonstring_types_item">test_exporters.py::MarshalItemExporterDataclassTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterDataclassTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterDataclassTest testMethod=test_nonstring_types_item>

    def test_nonstring_types_item(self):
        item = self._get_nonstring_types_item()
        item.pop("time")  # datetime is not marshallable
        fp = tempfile.TemporaryFile()
        ie = MarshalItemExporter(fp)
>       ie.start_exporting()
E       AttributeError: 'MarshalItemExporter' object has no attribute 'start_exporting'

/testbed/tests/test_exporters.py:275: AttributeError
</pre>
</details>
<h3 id="test_exporterspymarshalitemexporterdataclasstesttest_serialize_field">test_exporters.py::MarshalItemExporterDataclassTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::MarshalItemExporterDataclassTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.MarshalItemExporterDataclassTest testMethod=test_serialize_field>

    def test_serialize_field(self):
        a = ItemAdapter(self.i)
>       res = self.ie.serialize_field(a.get_field_meta("name"), "name", a["name"])
E       AttributeError: 'MarshalItemExporter' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:105: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_errors_default">test_exporters.py::CsvItemExporterTest::test_errors_default</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_errors_default</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_errors_default>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb98f57740>
file = <_io.BufferedRandom name=16>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_errors_xmlcharrefreplace">test_exporters.py::CsvItemExporterTest::test_errors_xmlcharrefreplace</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_errors_xmlcharrefreplace</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_errors_xmlcharrefreplace>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96e50500>
file = <_io.BufferedRandom name=17>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_export_dict_item">test_exporters.py::CsvItemExporterTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_export_dict_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb972cc8c0>
file = <_io.BufferedRandom name=18>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_export_item">test_exporters.py::CsvItemExporterTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_export_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb972306b0>
file = <_io.BufferedRandom name=19>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_field_custom_serializer">test_exporters.py::CsvItemExporterTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_field_custom_serializer>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d1bd10>
file = <_io.BufferedRandom name=20>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_fields_to_export">test_exporters.py::CsvItemExporterTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_fields_to_export>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d1a480>
file = <_io.BufferedRandom name=21>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_header_export_all">test_exporters.py::CsvItemExporterTest::test_header_export_all</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_header_export_all</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_header_export_all>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96e0d070>
file = <_io.BufferedRandom name=15>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_header_export_all_dict">test_exporters.py::CsvItemExporterTest::test_header_export_all_dict</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_header_export_all_dict</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_header_export_all_dict>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb9722a8a0>
file = <_io.BufferedRandom name=16>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_header_export_single_field">test_exporters.py::CsvItemExporterTest::test_header_export_single_field</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_header_export_single_field</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_header_export_single_field>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d19bb0>
file = <_io.BufferedRandom name=17>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_header_export_two_items">test_exporters.py::CsvItemExporterTest::test_header_export_two_items</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_header_export_two_items</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_header_export_two_items>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d18680>
file = <_io.BufferedRandom name=18>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_header_no_header_line">test_exporters.py::CsvItemExporterTest::test_header_no_header_line</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_header_no_header_line</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_header_no_header_line>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb97899430>
file = <_io.BufferedRandom name=19>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_join_multivalue">test_exporters.py::CsvItemExporterTest::test_join_multivalue</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_join_multivalue</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_join_multivalue>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d94110>
file = <_io.BufferedRandom name=20>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_join_multivalue_not_strings">test_exporters.py::CsvItemExporterTest::test_join_multivalue_not_strings</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_join_multivalue_not_strings</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_join_multivalue_not_strings>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb972ae9f0>
file = <_io.BufferedRandom name=15>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_nonstring_types_item">test_exporters.py::CsvItemExporterTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_nonstring_types_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb9a5a7200>
file = <_io.BufferedRandom name=16>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexportertesttest_serialize_field">test_exporters.py::CsvItemExporterTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterTest testMethod=test_serialize_field>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d96930>
file = <_io.BufferedRandom name=17>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_errors_default">test_exporters.py::CsvItemExporterDataclassTest::test_errors_default</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_errors_default</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_errors_default>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96e50800>
file = <_io.BufferedRandom name=18>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_errors_xmlcharrefreplace">test_exporters.py::CsvItemExporterDataclassTest::test_errors_xmlcharrefreplace</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_errors_xmlcharrefreplace</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_errors_xmlcharrefreplace>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb9819c6b0>
file = <_io.BufferedRandom name=19>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_export_dict_item">test_exporters.py::CsvItemExporterDataclassTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_export_dict_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d8e420>
file = <_io.BufferedRandom name=22>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_export_item">test_exporters.py::CsvItemExporterDataclassTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_export_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d94140>
file = <_io.BufferedRandom name=15>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_field_custom_serializer">test_exporters.py::CsvItemExporterDataclassTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_field_custom_serializer>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d18a40>
file = <_io.BufferedRandom name=16>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_fields_to_export">test_exporters.py::CsvItemExporterDataclassTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_fields_to_export>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d8c050>
file = <_io.BufferedRandom name=17>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_header_export_all">test_exporters.py::CsvItemExporterDataclassTest::test_header_export_all</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_header_export_all</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_header_export_all>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d80cb0>
file = <_io.BufferedRandom name=18>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_header_export_all_dict">test_exporters.py::CsvItemExporterDataclassTest::test_header_export_all_dict</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_header_export_all_dict</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_header_export_all_dict>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d80800>
file = <_io.BufferedRandom name=19>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_header_export_single_field">test_exporters.py::CsvItemExporterDataclassTest::test_header_export_single_field</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_header_export_single_field</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_header_export_single_field>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d29220>
file = <_io.BufferedRandom name=23>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_header_export_two_items">test_exporters.py::CsvItemExporterDataclassTest::test_header_export_two_items</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_header_export_two_items</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_header_export_two_items>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb97825e20>
file = <_io.BufferedRandom name=15>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_header_no_header_line">test_exporters.py::CsvItemExporterDataclassTest::test_header_no_header_line</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_header_no_header_line</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_header_no_header_line>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96e0d070>
file = <_io.BufferedRandom name=16>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_join_multivalue">test_exporters.py::CsvItemExporterDataclassTest::test_join_multivalue</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_join_multivalue</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_join_multivalue>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d28c50>
file = <_io.BufferedRandom name=17>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_join_multivalue_not_strings">test_exporters.py::CsvItemExporterDataclassTest::test_join_multivalue_not_strings</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_join_multivalue_not_strings</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_join_multivalue_not_strings>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d28950>
file = <_io.BufferedRandom name=18>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_nonstring_types_item">test_exporters.py::CsvItemExporterDataclassTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_nonstring_types_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96d28d40>
file = <_io.BufferedRandom name=19>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspycsvitemexporterdataclasstesttest_serialize_field">test_exporters.py::CsvItemExporterDataclassTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::CsvItemExporterDataclassTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.CsvItemExporterDataclassTest testMethod=test_serialize_field>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:291: in _get_exporter
    return CsvItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.CsvItemExporter object at 0x7fcb96ccee40>
file = <_io.BufferedRandom name=24>, include_headers_line = True
join_multivalued = ',', errors = None, kwargs = {}

    def __init__(self, file, include_headers_line=True, join_multivalued=',', errors=None, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
>       if not self.encoding:
E       AttributeError: 'CsvItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:69: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexportertesttest_export_dict_item">test_exporters.py::XmlItemExporterTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterTest testMethod=test_export_dict_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96d289e0>
file = <_io.BytesIO object at 0x7fcb973e7920>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexportertesttest_export_item">test_exporters.py::XmlItemExporterTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterTest testMethod=test_export_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb9789a8a0>
file = <_io.BytesIO object at 0x7fcb96ca5300>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexportertesttest_field_custom_serializer">test_exporters.py::XmlItemExporterTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterTest testMethod=test_field_custom_serializer>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96ccd1f0>
file = <_io.BytesIO object at 0x7fcb96ca6980>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexportertesttest_fields_to_export">test_exporters.py::XmlItemExporterTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterTest testMethod=test_fields_to_export>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96ccfd40>
file = <_io.BytesIO object at 0x7fcb96ca7740>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexportertesttest_multivalued_fields">test_exporters.py::XmlItemExporterTest::test_multivalued_fields</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterTest::test_multivalued_fields</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterTest testMethod=test_multivalued_fields>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96ccf3e0>
file = <_io.BytesIO object at 0x7fcb96ca5a80>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexportertesttest_nested_item">test_exporters.py::XmlItemExporterTest::test_nested_item</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterTest::test_nested_item</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterTest testMethod=test_nested_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96ccf920>
file = <_io.BytesIO object at 0x7fcb96ca4630>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexportertesttest_nested_list_item">test_exporters.py::XmlItemExporterTest::test_nested_list_item</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterTest::test_nested_list_item</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterTest testMethod=test_nested_list_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96d28dd0>
file = <_io.BytesIO object at 0x7fcb96f62840>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexportertesttest_nonstring_types_item">test_exporters.py::XmlItemExporterTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterTest testMethod=test_nonstring_types_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96cce9f0>
file = <_io.BytesIO object at 0x7fcb96dbd760>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexportertesttest_serialize_field">test_exporters.py::XmlItemExporterTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterTest testMethod=test_serialize_field>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96ccef30>
file = <_io.BytesIO object at 0x7fcb96dbd1c0>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexporterdataclasstesttest_export_dict_item">test_exporters.py::XmlItemExporterDataclassTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterDataclassTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterDataclassTest testMethod=test_export_dict_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96ccd6d0>
file = <_io.BytesIO object at 0x7fcb96dbc590>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexporterdataclasstesttest_export_item">test_exporters.py::XmlItemExporterDataclassTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterDataclassTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterDataclassTest testMethod=test_export_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96ccd6a0>
file = <_io.BytesIO object at 0x7fcb96ca7060>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexporterdataclasstesttest_field_custom_serializer">test_exporters.py::XmlItemExporterDataclassTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterDataclassTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterDataclassTest testMethod=test_field_custom_serializer>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96ccfad0>
file = <_io.BytesIO object at 0x7fcb96ca4f40>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexporterdataclasstesttest_fields_to_export">test_exporters.py::XmlItemExporterDataclassTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterDataclassTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterDataclassTest testMethod=test_fields_to_export>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96ccc530>
file = <_io.BytesIO object at 0x7fcb96ca7330>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexporterdataclasstesttest_multivalued_fields">test_exporters.py::XmlItemExporterDataclassTest::test_multivalued_fields</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterDataclassTest::test_multivalued_fields</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterDataclassTest testMethod=test_multivalued_fields>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96d28170>
file = <_io.BytesIO object at 0x7fcb96ca7bf0>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexporterdataclasstesttest_nested_item">test_exporters.py::XmlItemExporterDataclassTest::test_nested_item</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterDataclassTest::test_nested_item</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterDataclassTest testMethod=test_nested_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96c3af90>
file = <_io.BytesIO object at 0x7fcb96ca5cb0>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexporterdataclasstesttest_nested_list_item">test_exporters.py::XmlItemExporterDataclassTest::test_nested_list_item</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterDataclassTest::test_nested_list_item</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterDataclassTest testMethod=test_nested_list_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96c3bdd0>
file = <_io.BytesIO object at 0x7fcb96dbccc0>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexporterdataclasstesttest_nonstring_types_item">test_exporters.py::XmlItemExporterDataclassTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterDataclassTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterDataclassTest testMethod=test_nonstring_types_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96c39850>
file = <_io.BytesIO object at 0x7fcb96c2e4d0>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyxmlitemexporterdataclasstesttest_serialize_field">test_exporters.py::XmlItemExporterDataclassTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::XmlItemExporterDataclassTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.XmlItemExporterDataclassTest testMethod=test_serialize_field>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:410: in _get_exporter
    return XmlItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.XmlItemExporter object at 0x7fcb96c3aed0>
file = <_io.BytesIO object at 0x7fcb96c2eb60>, kwargs = {}

    def __init__(self, file, **kwargs):
        self.item_element = kwargs.pop('item_element', 'item')
        self.root_element = kwargs.pop('root_element', 'items')
        super().__init__(**kwargs)
>       if not self.encoding:
E       AttributeError: 'XmlItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:61: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexportertesttest_export_dict_item">test_exporters.py::JsonLinesItemExporterTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterTest testMethod=test_export_dict_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96f05010>
file = <_io.BytesIO object at 0x7fcb96f62bb0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexportertesttest_export_item">test_exporters.py::JsonLinesItemExporterTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterTest testMethod=test_export_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96d8efc0>
file = <_io.BytesIO object at 0x7fcb96c2ebb0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexportertesttest_extra_keywords">test_exporters.py::JsonLinesItemExporterTest::test_extra_keywords</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterTest::test_extra_keywords</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterTest testMethod=test_extra_keywords>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb97a0bbc0>
file = <_io.BytesIO object at 0x7fcb96c2f650>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexportertesttest_field_custom_serializer">test_exporters.py::JsonLinesItemExporterTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterTest testMethod=test_field_custom_serializer>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96d1a870>
file = <_io.BytesIO object at 0x7fcb96c2f4c0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexportertesttest_fields_to_export">test_exporters.py::JsonLinesItemExporterTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterTest testMethod=test_fields_to_export>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96cceab0>
file = <_io.BytesIO object at 0x7fcb96c2f920>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexportertesttest_nested_item">test_exporters.py::JsonLinesItemExporterTest::test_nested_item</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterTest::test_nested_item</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterTest testMethod=test_nested_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96ccf200>
file = <_io.BytesIO object at 0x7fcb96c2c040>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexportertesttest_nonstring_types_item">test_exporters.py::JsonLinesItemExporterTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterTest testMethod=test_nonstring_types_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96d1a870>
file = <_io.BytesIO object at 0x7fcb96c2c270>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexportertesttest_serialize_field">test_exporters.py::JsonLinesItemExporterTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterTest testMethod=test_serialize_field>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96d8cfe0>
file = <_io.BytesIO object at 0x7fcb96c2c810>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexporterdataclasstesttest_export_dict_item">test_exporters.py::JsonLinesItemExporterDataclassTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterDataclassTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterDataclassTest testMethod=test_export_dict_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96c3aa80>
file = <_io.BytesIO object at 0x7fcb96c2f9c0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexporterdataclasstesttest_export_item">test_exporters.py::JsonLinesItemExporterDataclassTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterDataclassTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterDataclassTest testMethod=test_export_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96c3a480>
file = <_io.BytesIO object at 0x7fcb96c2cae0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexporterdataclasstesttest_extra_keywords">test_exporters.py::JsonLinesItemExporterDataclassTest::test_extra_keywords</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterDataclassTest::test_extra_keywords</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterDataclassTest testMethod=test_extra_keywords>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96c3ba10>
file = <_io.BytesIO object at 0x7fcb96c2cea0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexporterdataclasstesttest_field_custom_serializer">test_exporters.py::JsonLinesItemExporterDataclassTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterDataclassTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterDataclassTest testMethod=test_field_custom_serializer>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96c39e20>
file = <_io.BytesIO object at 0x7fcb96c2dad0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexporterdataclasstesttest_fields_to_export">test_exporters.py::JsonLinesItemExporterDataclassTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterDataclassTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterDataclassTest testMethod=test_fields_to_export>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96d1a330>
file = <_io.BytesIO object at 0x7fcb96c2d760>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexporterdataclasstesttest_nested_item">test_exporters.py::JsonLinesItemExporterDataclassTest::test_nested_item</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterDataclassTest::test_nested_item</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterDataclassTest testMethod=test_nested_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96c3ba70>
file = <_io.BytesIO object at 0x7fcb96c2dda0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexporterdataclasstesttest_nonstring_types_item">test_exporters.py::JsonLinesItemExporterDataclassTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterDataclassTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterDataclassTest testMethod=test_nonstring_types_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96c3bfe0>
file = <_io.BytesIO object at 0x7fcb96c2e0c0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonlinesitemexporterdataclasstesttest_serialize_field">test_exporters.py::JsonLinesItemExporterDataclassTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::JsonLinesItemExporterDataclassTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.JsonLinesItemExporterDataclassTest testMethod=test_serialize_field>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:526: in _get_exporter
    return JsonLinesItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonLinesItemExporter object at 0x7fcb96cc5760>
file = <_io.BytesIO object at 0x7fcb96c2f1a0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       self._kwargs.setdefault('ensure_ascii', not self.encoding)
E       AttributeError: 'JsonLinesItemExporter' object has no attribute 'encoding'

/testbed/scrapy/exporters.py:41: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_export_dict_item">test_exporters.py::JsonItemExporterTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_export_dict_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc7ad0>
file = <_io.BytesIO object at 0x7fcb96c2e5c0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_export_item">test_exporters.py::JsonItemExporterTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_export_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc7e60>
file = <_io.BytesIO object at 0x7fcb973e7100>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_extra_keywords">test_exporters.py::JsonItemExporterTest::test_extra_keywords</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_extra_keywords</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_extra_keywords>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c3ba70>
file = <_io.BytesIO object at 0x7fcb96ca46d0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_field_custom_serializer">test_exporters.py::JsonItemExporterTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_field_custom_serializer>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc51f0>
file = <_io.BytesIO object at 0x7fcb96c2dda0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_fields_to_export">test_exporters.py::JsonItemExporterTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_fields_to_export>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc62a0>
file = <_io.BytesIO object at 0x7fcb96c2d7b0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_nested_dict_item">test_exporters.py::JsonItemExporterTest::test_nested_dict_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_nested_dict_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_nested_dict_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc56d0>
file = <_io.BytesIO object at 0x7fcb96c94360>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_nested_item">test_exporters.py::JsonItemExporterTest::test_nested_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_nested_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_nested_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc49e0>
file = <_io.BytesIO object at 0x7fcb96c94770>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_nonstring_types_item">test_exporters.py::JsonItemExporterTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_nonstring_types_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc5460>
file = <_io.BytesIO object at 0x7fcb96c94d10>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_serialize_field">test_exporters.py::JsonItemExporterTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_serialize_field>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc5070>
file = <_io.BytesIO object at 0x7fcb96c94c20>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_two_dict_items">test_exporters.py::JsonItemExporterTest::test_two_dict_items</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_two_dict_items</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_two_dict_items>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc5760>
file = <_io.BytesIO object at 0x7fcb96c95210>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_two_items">test_exporters.py::JsonItemExporterTest::test_two_items</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_two_items</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_two_items>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc6450>
file = <_io.BytesIO object at 0x7fcb96c95530>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertesttest_two_items_with_failure_between">test_exporters.py::JsonItemExporterTest::test_two_items_with_failure_between</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterTest::test_two_items_with_failure_between</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterTest testMethod=test_two_items_with_failure_between>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c6cef0>
file = <_io.BytesIO object at 0x7fcb96c95ad0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertobytestesttest_export_dict_item">test_exporters.py::JsonItemExporterToBytesTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterToBytesTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterToBytesTest testMethod=test_export_dict_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:647: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc6a50>
file = <_io.BytesIO object at 0x7fcb96ca6f70>, kwargs = {'encoding': 'latin'}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertobytestesttest_export_item">test_exporters.py::JsonItemExporterToBytesTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterToBytesTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterToBytesTest testMethod=test_export_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:647: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c6ff20>
file = <_io.BytesIO object at 0x7fcb96c94130>, kwargs = {'encoding': 'latin'}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertobytestesttest_field_custom_serializer">test_exporters.py::JsonItemExporterToBytesTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterToBytesTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterToBytesTest testMethod=test_field_custom_serializer>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:647: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc4b00>
file = <_io.BytesIO object at 0x7fcb96c95bc0>, kwargs = {'encoding': 'latin'}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertobytestesttest_fields_to_export">test_exporters.py::JsonItemExporterToBytesTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterToBytesTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterToBytesTest testMethod=test_fields_to_export>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:647: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c6dc10>
file = <_io.BytesIO object at 0x7fcb96c95fd0>, kwargs = {'encoding': 'latin'}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertobytestesttest_serialize_field">test_exporters.py::JsonItemExporterToBytesTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterToBytesTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterToBytesTest testMethod=test_serialize_field>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:647: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c6d910>
file = <_io.BytesIO object at 0x7fcb96c95580>, kwargs = {'encoding': 'latin'}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexportertobytestesttest_two_items_with_failure_between">test_exporters.py::JsonItemExporterToBytesTest::test_two_items_with_failure_between</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterToBytesTest::test_two_items_with_failure_between</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterToBytesTest testMethod=test_two_items_with_failure_between>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:647: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c6c200>
file = <_io.BytesIO object at 0x7fcb96c96a20>, kwargs = {'encoding': 'latin'}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_export_dict_item">test_exporters.py::JsonItemExporterDataclassTest::test_export_dict_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_export_dict_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_export_dict_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c6c320>
file = <_io.BytesIO object at 0x7fcb96dbccc0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_export_item">test_exporters.py::JsonItemExporterDataclassTest::test_export_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_export_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_export_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c6cc50>
file = <_io.BytesIO object at 0x7fcb96c96930>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_extra_keywords">test_exporters.py::JsonItemExporterDataclassTest::test_extra_keywords</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_extra_keywords</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_extra_keywords>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96cc6510>
file = <_io.BytesIO object at 0x7fcb96c97920>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_field_custom_serializer">test_exporters.py::JsonItemExporterDataclassTest::test_field_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_field_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_field_custom_serializer>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c6c0b0>
file = <_io.BytesIO object at 0x7fcb96c95ee0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_fields_to_export">test_exporters.py::JsonItemExporterDataclassTest::test_fields_to_export</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_fields_to_export</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_fields_to_export>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c6d640>
file = <_io.BytesIO object at 0x7fcb96c97790>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_nested_dict_item">test_exporters.py::JsonItemExporterDataclassTest::test_nested_dict_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_nested_dict_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_nested_dict_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c6f470>
file = <_io.BytesIO object at 0x7fcb96c96200>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_nested_item">test_exporters.py::JsonItemExporterDataclassTest::test_nested_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_nested_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_nested_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c3ee10>
file = <_io.BytesIO object at 0x7fcb96c97f60>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_nonstring_types_item">test_exporters.py::JsonItemExporterDataclassTest::test_nonstring_types_item</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_nonstring_types_item</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_nonstring_types_item>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c3fe90>
file = <_io.BytesIO object at 0x7fcb96cbc450>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_serialize_field">test_exporters.py::JsonItemExporterDataclassTest::test_serialize_field</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_serialize_field</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_serialize_field>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c6f4d0>
file = <_io.BytesIO object at 0x7fcb96c97790>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_two_dict_items">test_exporters.py::JsonItemExporterDataclassTest::test_two_dict_items</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_two_dict_items</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_two_dict_items>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb97915bb0>
file = <_io.BytesIO object at 0x7fcb96c2c6d0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_two_items">test_exporters.py::JsonItemExporterDataclassTest::test_two_items</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_two_items</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_two_items>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c3fce0>
file = <_io.BytesIO object at 0x7fcb96cbc5e0>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspyjsonitemexporterdataclasstesttest_two_items_with_failure_between">test_exporters.py::JsonItemExporterDataclassTest::test_two_items_with_failure_between</h3>
<details><summary> <pre>test_exporters.py::JsonItemExporterDataclassTest::test_two_items_with_failure_between</pre></summary><pre>
self = <tests.test_exporters.JsonItemExporterDataclassTest testMethod=test_two_items_with_failure_between>

    def setUp(self):
        self.i = self.item_class(name="John\xa3", age="22")
        self.output = BytesIO()
>       self.ie = self._get_exporter()

/testbed/tests/test_exporters.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_exporters.py:569: in _get_exporter
    return JsonItemExporter(self.output, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.exporters.JsonItemExporter object at 0x7fcb96c3c740>
file = <_io.BytesIO object at 0x7fcb96cbcc70>, kwargs = {}

    def __init__(self, file, **kwargs):
        super().__init__(dont_fail=True, **kwargs)
        self.file = file
>       json_indent = self.indent if self.indent is not None and self.indent > 0 else None
E       AttributeError: 'JsonItemExporter' object has no attribute 'indent'

/testbed/scrapy/exporters.py:49: AttributeError
</pre>
</details>
<h3 id="test_exporterspycustomexporteritemtesttest_exporter_custom_serializer">test_exporters.py::CustomExporterItemTest::test_exporter_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::CustomExporterItemTest::test_exporter_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.CustomExporterItemTest testMethod=test_exporter_custom_serializer>

    def test_exporter_custom_serializer(self):
        class CustomItemExporter(BaseItemExporter):
            def serialize_field(self, field, name, value):
                if name == "age":
                    return str(int(value) + 1)
                return super().serialize_field(field, name, value)

        i = self.item_class(name="John", age="22")
        a = ItemAdapter(i)
        ie = CustomItemExporter()

        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John"
        )

/testbed/tests/test_exporters.py:686: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.CustomExporterItemTest.test_exporter_custom_serializer.<locals>.CustomItemExporter object at 0x7fcb96c3f7d0>
field = mappingproxy({}), name = 'name', value = 'John'

    def serialize_field(self, field, name, value):
        if name == "age":
            return str(int(value) + 1)
>       return super().serialize_field(field, name, value)
E       AttributeError: 'super' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:679: AttributeError
</pre>
</details>
<h3 id="test_exporterspycustomexporterdataclasstesttest_exporter_custom_serializer">test_exporters.py::CustomExporterDataclassTest::test_exporter_custom_serializer</h3>
<details><summary> <pre>test_exporters.py::CustomExporterDataclassTest::test_exporter_custom_serializer</pre></summary><pre>
self = <tests.test_exporters.CustomExporterDataclassTest testMethod=test_exporter_custom_serializer>

    def test_exporter_custom_serializer(self):
        class CustomItemExporter(BaseItemExporter):
            def serialize_field(self, field, name, value):
                if name == "age":
                    return str(int(value) + 1)
                return super().serialize_field(field, name, value)

        i = self.item_class(name="John", age="22")
        a = ItemAdapter(i)
        ie = CustomItemExporter()

        self.assertEqual(
>           ie.serialize_field(a.get_field_meta("name"), "name", a["name"]), "John"
        )

/testbed/tests/test_exporters.py:686: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_exporters.CustomExporterItemTest.test_exporter_custom_serializer.<locals>.CustomItemExporter object at 0x7fcb96c3d040>
field = mappingproxy({}), name = 'name', value = 'John'

    def serialize_field(self, field, name, value):
        if name == "age":
            return str(int(value) + 1)
>       return super().serialize_field(field, name, value)
E       AttributeError: 'super' object has no attribute 'serialize_field'

/testbed/tests/test_exporters.py:679: AttributeError
</pre>
</details>
<h3 id="test_http_cookiespywrappedrequesttesttest_add_unredirected_header">test_http_cookies.py::WrappedRequestTest::test_add_unredirected_header</h3>
<details><summary> <pre>test_http_cookies.py::WrappedRequestTest::test_add_unredirected_header</pre></summary><pre>
self = <tests.test_http_cookies.WrappedRequestTest testMethod=test_add_unredirected_header>

    def test_add_unredirected_header(self):
>       self.wrapped.add_unredirected_header("hello", "world")
E       AttributeError: 'WrappedRequest' object has no attribute 'add_unredirected_header'

/testbed/tests/test_http_cookies.py:58: AttributeError
</pre>
</details>
<h3 id="test_http_cookiespywrappedrequesttesttest_get_full_url">test_http_cookies.py::WrappedRequestTest::test_get_full_url</h3>
<details><summary> <pre>test_http_cookies.py::WrappedRequestTest::test_get_full_url</pre></summary><pre>
self = <tests.test_http_cookies.WrappedRequestTest testMethod=test_get_full_url>

    def test_get_full_url(self):
>       self.assertEqual(self.wrapped.get_full_url(), self.request.url)
E       AttributeError: 'WrappedRequest' object has no attribute 'get_full_url'

/testbed/tests/test_http_cookies.py:16: AttributeError
</pre>
</details>
<h3 id="test_http_cookiespywrappedrequesttesttest_get_header">test_http_cookies.py::WrappedRequestTest::test_get_header</h3>
<details><summary> <pre>test_http_cookies.py::WrappedRequestTest::test_get_header</pre></summary><pre>
self = <tests.test_http_cookies.WrappedRequestTest testMethod=test_get_header>

    def test_get_header(self):
>       self.assertEqual(self.wrapped.get_header("content-type"), "text/html")
E       AttributeError: 'WrappedRequest' object has no attribute 'get_header'

/testbed/tests/test_http_cookies.py:44: AttributeError
</pre>
</details>
<h3 id="test_http_cookiespywrappedrequesttesttest_get_host">test_http_cookies.py::WrappedRequestTest::test_get_host</h3>
<details><summary> <pre>test_http_cookies.py::WrappedRequestTest::test_get_host</pre></summary><pre>
self = <tests.test_http_cookies.WrappedRequestTest testMethod=test_get_host>

    def test_get_host(self):
>       self.assertEqual(self.wrapped.get_host(), urlparse(self.request.url).netloc)
E       AttributeError: 'WrappedRequest' object has no attribute 'get_host'

/testbed/tests/test_http_cookies.py:20: AttributeError
</pre>
</details>
<h3 id="test_http_cookiespywrappedrequesttesttest_get_origin_req_host">test_http_cookies.py::WrappedRequestTest::test_get_origin_req_host</h3>
<details><summary> <pre>test_http_cookies.py::WrappedRequestTest::test_get_origin_req_host</pre></summary><pre>
self = <tests.test_http_cookies.WrappedRequestTest testMethod=test_get_origin_req_host>

    def test_get_origin_req_host(self):
>       self.assertEqual(self.wrapped.origin_req_host, "www.example.com")
E       AttributeError: 'WrappedRequest' object has no attribute 'origin_req_host'

/testbed/tests/test_http_cookies.py:37: AttributeError
</pre>
</details>
<h3 id="test_http_cookiespywrappedrequesttesttest_get_type">test_http_cookies.py::WrappedRequestTest::test_get_type</h3>
<details><summary> <pre>test_http_cookies.py::WrappedRequestTest::test_get_type</pre></summary><pre>
self = <tests.test_http_cookies.WrappedRequestTest testMethod=test_get_type>

    def test_get_type(self):
>       self.assertEqual(self.wrapped.get_type(), urlparse(self.request.url).scheme)
E       AttributeError: 'WrappedRequest' object has no attribute 'get_type'

/testbed/tests/test_http_cookies.py:24: AttributeError
</pre>
</details>
<h3 id="test_http_cookiespywrappedrequesttesttest_has_header">test_http_cookies.py::WrappedRequestTest::test_has_header</h3>
<details><summary> <pre>test_http_cookies.py::WrappedRequestTest::test_has_header</pre></summary><pre>
self = <tests.test_http_cookies.WrappedRequestTest testMethod=test_has_header>

    def test_has_header(self):
>       self.assertTrue(self.wrapped.has_header("content-type"))
E       AttributeError: 'WrappedRequest' object has no attribute 'has_header'

/testbed/tests/test_http_cookies.py:40: AttributeError
</pre>
</details>
<h3 id="test_http_cookiespywrappedrequesttesttest_header_items">test_http_cookies.py::WrappedRequestTest::test_header_items</h3>
<details><summary> <pre>test_http_cookies.py::WrappedRequestTest::test_header_items</pre></summary><pre>
self = <tests.test_http_cookies.WrappedRequestTest testMethod=test_header_items>

    def test_header_items(self):
>       self.assertEqual(self.wrapped.header_items(), [("Content-Type", ["text/html"])])
E       AttributeError: 'WrappedRequest' object has no attribute 'header_items'

/testbed/tests/test_http_cookies.py:55: AttributeError
</pre>
</details>
<h3 id="test_http_cookiespywrappedrequesttesttest_is_unverifiable">test_http_cookies.py::WrappedRequestTest::test_is_unverifiable</h3>
<details><summary> <pre>test_http_cookies.py::WrappedRequestTest::test_is_unverifiable</pre></summary><pre>
self = <tests.test_http_cookies.WrappedRequestTest testMethod=test_is_unverifiable>

    def test_is_unverifiable(self):
        self.assertFalse(self.wrapped.is_unverifiable())
>       self.assertFalse(self.wrapped.unverifiable)
E       AttributeError: 'WrappedRequest' object has no attribute 'unverifiable'. Did you mean: 'is_unverifiable'?

/testbed/tests/test_http_cookies.py:29: AttributeError
</pre>
</details>
<h3 id="test_http_cookiespywrappedrequesttesttest_is_unverifiable2">test_http_cookies.py::WrappedRequestTest::test_is_unverifiable2</h3>
<details><summary> <pre>test_http_cookies.py::WrappedRequestTest::test_is_unverifiable2</pre></summary><pre>
self = <tests.test_http_cookies.WrappedRequestTest testMethod=test_is_unverifiable2>

    def test_is_unverifiable2(self):
        self.request.meta["is_unverifiable"] = True
>       self.assertTrue(self.wrapped.is_unverifiable())
E       AssertionError: None is not true

/testbed/tests/test_http_cookies.py:33: AssertionError
</pre>
</details>
<h3 id="test_http_cookiespywrappedresponsetesttest_get_all">test_http_cookies.py::WrappedResponseTest::test_get_all</h3>
<details><summary> <pre>test_http_cookies.py::WrappedResponseTest::test_get_all</pre></summary><pre>
self = <tests.test_http_cookies.WrappedResponseTest testMethod=test_get_all>

    def test_get_all(self):
        # get_all result must be native string
>       self.assertEqual(self.wrapped.get_all("content-type"), ["text/html"])
E       AttributeError: 'WrappedResponse' object has no attribute 'get_all'

/testbed/tests/test_http_cookies.py:74: AttributeError
</pre>
</details>
<h3 id="test_http_cookiespywrappedresponsetesttest_info">test_http_cookies.py::WrappedResponseTest::test_info</h3>
<details><summary> <pre>test_http_cookies.py::WrappedResponseTest::test_info</pre></summary><pre>
self = <tests.test_http_cookies.WrappedResponseTest testMethod=test_info>

    def test_info(self):
>       self.assertIs(self.wrapped.info(), self.wrapped)
E       AttributeError: 'WrappedResponse' object has no attribute 'info'

/testbed/tests/test_http_cookies.py:70: AttributeError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_appendlist">test_http_headers.py::HeadersTest::test_appendlist</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_appendlist</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_appendlist>

    def test_appendlist(self):
        h1 = Headers({"header1": "value1"})
>       h1.appendlist("header1", "value3")
E       AttributeError: 'Headers' object has no attribute 'appendlist'

/testbed/tests/test_http_headers.py:115: AttributeError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_basics">test_http_headers.py::HeadersTest::test_basics</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_basics</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_basics>

    def test_basics(self):
        h = Headers({"Content-Type": "text/html", "Content-Length": 1234})
>       assert h["Content-Type"]

/testbed/tests/test_http_headers.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/headers.py:23: in __getitem__
    return super().__getitem__(key)[-1]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {'Content-Type': 'text/html', 'Content-Length': 1234}
key = 'Content-Type'

    def __getitem__(self, key):
>       return dict.__getitem__(self, self.normkey(key))
E       KeyError: None

/testbed/scrapy/utils/datatypes.py:31: KeyError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_copy">test_http_headers.py::HeadersTest::test_copy</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_copy</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_copy>

    def test_copy(self):
        h1 = Headers({"header1": ["value1", "value2"]})
        h2 = copy.copy(h1)
        self.assertEqual(h1, h2)
>       self.assertEqual(h1.getlist("header1"), h2.getlist("header1"))
E       AttributeError: 'Headers' object has no attribute 'getlist'

/testbed/tests/test_http_headers.py:109: AttributeError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_encode_latin1">test_http_headers.py::HeadersTest::test_encode_latin1</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_encode_latin1</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_encode_latin1>

    def test_encode_latin1(self):
        h = Headers({"key": "\xa3"}, encoding="latin1")
        key, val = dict(h).popitem()
>       self.assertEqual(val[0], b"\xa3")
E       AssertionError: '£' != b'\xa3'

/testbed/tests/test_http_headers.py:58: AssertionError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_encode_multiple">test_http_headers.py::HeadersTest::test_encode_multiple</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_encode_multiple</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_encode_multiple>

    def test_encode_multiple(self):
        h = Headers({"key": ["\xa3"]}, encoding="utf-8")
        key, val = dict(h).popitem()
>       self.assertEqual(val[0], b"\xc2\xa3")
E       AssertionError: '£' != b'\xc2\xa3'

/testbed/tests/test_http_headers.py:63: AssertionError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_encode_utf8">test_http_headers.py::HeadersTest::test_encode_utf8</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_encode_utf8</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_encode_utf8>

    def test_encode_utf8(self):
        h = Headers({"key": "\xa3"}, encoding="utf-8")
        key, val = dict(h).popitem()
>       assert isinstance(key, bytes), key
E       AssertionError: key

/testbed/tests/test_http_headers.py:51: AssertionError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_int_value">test_http_headers.py::HeadersTest::test_int_value</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_int_value</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_int_value>

    def test_int_value(self):
        h1 = Headers({"hey": 5})
        h1["foo"] = 1
        h1.setdefault("bar", 2)
>       h1.setlist("buz", [1, "dos", 3])
E       AttributeError: 'Headers' object has no attribute 'setlist'

/testbed/tests/test_http_headers.py:148: AttributeError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_invalid_value">test_http_headers.py::HeadersTest::test_invalid_value</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_invalid_value</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_invalid_value>

    def test_invalid_value(self):
>       self.assertRaisesRegex(
            TypeError, "Unsupported value type", Headers, {"foo": object()}
        )
E       AssertionError: TypeError not raised by Headers

/testbed/tests/test_http_headers.py:155: AssertionError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_iterables">test_http_headers.py::HeadersTest::test_iterables</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_iterables</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_iterables>

    def test_iterables(self):
        idict = {"Content-Type": "text/html", "X-Forwarded-For": ["ip1", "ip2"]}

        h = Headers(idict)
>       self.assertDictEqual(
            dict(h),
            {b"Content-Type": [b"text/html"], b"X-Forwarded-For": [b"ip1", b"ip2"]},
        )
E       AssertionError: {'Content-Type': 'text/html', 'X-Forwarded-For': ['ip1', 'ip2']} != {b'Content-Type': [b'text/html'], b'X-Forwarded-For': [b'ip1', b'ip2']}
E       - {'Content-Type': 'text/html', 'X-Forwarded-For': ['ip1', 'ip2']}
E       + {b'Content-Type': [b'text/html'], b'X-Forwarded-For': [b'ip1', b'ip2']}
E       ?  +                ++           +  +                    +       +

/testbed/tests/test_http_headers.py:88: AssertionError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_multivalue">test_http_headers.py::HeadersTest::test_multivalue</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_multivalue</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_multivalue>

    def test_multivalue(self):
        h = Headers()
        h["X-Forwarded-For"] = hlist = ["ip1", "ip2"]
>       self.assertEqual(h["X-Forwarded-For"], b"ip2")

/testbed/tests/test_http_headers.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {None: None}, key = 'X-Forwarded-For'

    def __getitem__(self, key):
        try:
>           return super().__getitem__(key)[-1]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/http/headers.py:23: TypeError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_multivalue_for_one_header">test_http_headers.py::HeadersTest::test_multivalue_for_one_header</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_multivalue_for_one_header</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_multivalue_for_one_header>

    def test_multivalue_for_one_header(self):
        h = Headers((("a", "b"), ("a", "c")))
>       self.assertEqual(h["a"], b"c")

/testbed/tests/test_http_headers.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/headers.py:23: in __getitem__
    return super().__getitem__(key)[-1]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {'a': 'c'}, key = 'a'

    def __getitem__(self, key):
>       return dict.__getitem__(self, self.normkey(key))
E       KeyError: None

/testbed/scrapy/utils/datatypes.py:31: KeyError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_none_value">test_http_headers.py::HeadersTest::test_none_value</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_none_value</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_none_value>

    def test_none_value(self):
        h1 = Headers()
        h1["foo"] = "bar"
        h1["foo"] = None
        h1.setdefault("foo", "bar")
>       self.assertEqual(h1.get("foo"), None)
E       AssertionError: 'bar' != None

/testbed/tests/test_http_headers.py:141: AssertionError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_setdefault">test_http_headers.py::HeadersTest::test_setdefault</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_setdefault</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_setdefault>

    def test_setdefault(self):
        h = Headers()
        hlist = ["ip1", "ip2"]
        olist = h.setdefault("X-Forwarded-For", hlist)
>       assert h.getlist("X-Forwarded-For") is not hlist
E       AttributeError: 'Headers' object has no attribute 'getlist'

/testbed/tests/test_http_headers.py:76: AttributeError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_setlist">test_http_headers.py::HeadersTest::test_setlist</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_setlist</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_setlist>

    def test_setlist(self):
        h1 = Headers({"header1": "value1"})
>       self.assertEqual(h1.getlist("header1"), [b"value1"])
E       AttributeError: 'Headers' object has no attribute 'getlist'

/testbed/tests/test_http_headers.py:125: AttributeError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_setlistdefault">test_http_headers.py::HeadersTest::test_setlistdefault</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_setlistdefault</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_setlistdefault>

    def test_setlistdefault(self):
        h1 = Headers({"header1": "value1"})
>       h1.setlistdefault("header1", ["value2", "value3"])
E       AttributeError: 'Headers' object has no attribute 'setlistdefault'. Did you mean: 'setdefault'?

/testbed/tests/test_http_headers.py:131: AttributeError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_single_value">test_http_headers.py::HeadersTest::test_single_value</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_single_value</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_single_value>

    def test_single_value(self):
        h = Headers()
        h["Content-Type"] = "text/html"
>       self.assertEqual(h["Content-Type"], b"text/html")

/testbed/tests/test_http_headers.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {None: None}, key = 'Content-Type'

    def __getitem__(self, key):
        try:
>           return super().__getitem__(key)[-1]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/http/headers.py:23: TypeError
</pre>
</details>
<h3 id="test_http_headerspyheaderstesttest_update">test_http_headers.py::HeadersTest::test_update</h3>
<details><summary> <pre>test_http_headers.py::HeadersTest::test_update</pre></summary><pre>
self = <tests.test_http_headers.HeadersTest testMethod=test_update>

    def test_update(self):
        h = Headers()
        h.update({"Content-Type": "text/html", "X-Forwarded-For": ["ip1", "ip2"]})
>       self.assertEqual(h.getlist("Content-Type"), [b"text/html"])
E       AttributeError: 'Headers' object has no attribute 'getlist'

/testbed/tests/test_http_headers.py:102: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyrequesttesttest_ajax_url">test_http_request.py::RequestTest::test_ajax_url</h3>
<details><summary> <pre>test_http_request.py::RequestTest::test_ajax_url</pre></summary><pre>
self = <tests.test_http_request.RequestTest testMethod=test_ajax_url>

    def test_ajax_url(self):
        # ascii url
        r = self.request_class(url="http://www.example.com/ajax.html#!key=value")
>       self.assertEqual(
            r.url, "http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue"
        )
E       AssertionError: 'http://www.example.com/ajax.html?_escaped_fragment_=key=value' != 'http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'
E       - http://www.example.com/ajax.html?_escaped_fragment_=key=value
E       ?                                                        ^
E       + http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue
E       ?                                                        ^^^

/testbed/tests/test_http_request.py:191: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyrequesttesttest_from_curl">test_http_request.py::RequestTest::test_from_curl</h3>
<details><summary> <pre>test_http_request.py::RequestTest::test_from_curl</pre></summary><pre>
self = <tests.test_http_request.RequestTest testMethod=test_from_curl>

    def test_from_curl(self):
        # Note: more curated tests regarding curl conversion are in
        # `test_utils_curl.py`
        curl_command = (
            "curl 'http://httpbin.org/post' -X POST -H 'Cookie: _gauges_unique"
            "_year=1; _gauges_unique=1; _gauges_unique_month=1; _gauges_unique"
            "_hour=1; _gauges_unique_day=1' -H 'Origin: http://httpbin.org' -H"
            " 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en-US,en;q"
            "=0.9,ru;q=0.8,es;q=0.7' -H 'Upgrade-Insecure-Requests: 1' -H 'Use"
            "r-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTM"
            "L, like Gecko) Ubuntu Chromium/62.0.3202.75 Chrome/62.0.3202.75 S"
            "afari/537.36' -H 'Content-Type: application /x-www-form-urlencode"
            "d' -H 'Accept: text/html,application/xhtml+xml,application/xml;q="
            "0.9,image/webp,image/apng,*/*;q=0.8' -H 'Cache-Control: max-age=0"
            "' -H 'Referer: http://httpbin.org/forms/post' -H 'Connection: kee"
            "p-alive' --data 'custname=John+Smith&custtel=500&custemail=jsmith"
            "%40example.org&size=small&topping=cheese&topping=onion&delivery=1"
            "2%3A15&comments=' --compressed"
        )
>       r = self.request_class.from_curl(curl_command)

/testbed/tests/test_http_request.py:356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.Request'>
curl_command = "curl 'http://httpbin.org/post' -X POST -H 'Cookie: _gauges_unique_year=1; _gauges_unique=1; _gauges_unique_month=1; _...el=500&custemail=jsmith%40example.org&size=small&topping=cheese&topping=onion&delivery=12%3A15&comments=' --compressed"
ignore_unknown_options = True, kwargs = {}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyrequesttesttest_from_curl_ignore_unknown_options">test_http_request.py::RequestTest::test_from_curl_ignore_unknown_options</h3>
<details><summary> <pre>test_http_request.py::RequestTest::test_from_curl_ignore_unknown_options</pre></summary><pre>
self = <tests.test_http_request.RequestTest testMethod=test_from_curl_ignore_unknown_options>

    def test_from_curl_ignore_unknown_options(self):
        # By default: it works and ignores the unknown options: --foo and -z
        with warnings.catch_warnings():  # avoid warning when executing tests
            warnings.simplefilter("ignore")
>           r = self.request_class.from_curl(
                'curl -X DELETE "http://example.org" --foo -z',
            )

/testbed/tests/test_http_request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.Request'>
curl_command = 'curl -X DELETE "http://example.org" --foo -z'
ignore_unknown_options = True, kwargs = {}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyrequesttesttest_from_curl_with_kwargs">test_http_request.py::RequestTest::test_from_curl_with_kwargs</h3>
<details><summary> <pre>test_http_request.py::RequestTest::test_from_curl_with_kwargs</pre></summary><pre>
self = <tests.test_http_request.RequestTest testMethod=test_from_curl_with_kwargs>

    def test_from_curl_with_kwargs(self):
>       r = self.request_class.from_curl(
            'curl -X PATCH "http://example.org"', method="POST", meta={"key": "value"}
        )

/testbed/tests/test_http_request.py:399: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.Request'>
curl_command = 'curl -X PATCH "http://example.org"'
ignore_unknown_options = True
kwargs = {'meta': {'key': 'value'}, 'method': 'POST'}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyrequesttesttest_headers">test_http_request.py::RequestTest::test_headers</h3>
<details><summary> <pre>test_http_request.py::RequestTest::test_headers</pre></summary><pre>
self = <tests.test_http_request.RequestTest testMethod=test_headers>

    def test_headers(self):
        # Different ways of setting headers attribute
        url = "http://www.scrapy.org"
        headers = {b"Accept": "gzip", b"Custom-Header": "nothing to tell you"}
        r = self.request_class(url=url, headers=headers)
        p = self.request_class(url=url, headers=r.headers)

        self.assertEqual(r.headers, p.headers)
        self.assertFalse(r.headers is headers)
        self.assertFalse(p.headers is r.headers)

        # headers must not be unicode
        h = Headers({"key1": "val1", "key2": "val2"})
        h["newkey"] = "newval"
        for k, v in h.items():
>           self.assertIsInstance(k, bytes)
E           AssertionError: 'key1' is not an instance of <class 'bytes'>

/testbed/tests/test_http_request.py:84: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyrequesttesttest_immutable_attributes">test_http_request.py::RequestTest::test_immutable_attributes</h3>
<details><summary> <pre>test_http_request.py::RequestTest::test_immutable_attributes</pre></summary><pre>
self = <tests.test_http_request.RequestTest testMethod=test_immutable_attributes>

    def test_immutable_attributes(self):
        r = self.request_class("http://example.com")
>       self.assertRaises(AttributeError, setattr, r, "url", "http://example2.com")

/testbed/tests/test_http_request.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def wrapper(self, value):
        private_name = f"_{name}"
        if not hasattr(self, private_name):
>           warnings.warn(f"Property {name} is deprecated.", category=warn_category, stacklevel=2)
E           TypeError: category must be a Warning subclass, not 'str'

/testbed/scrapy/http/common.py:10: TypeError
</pre>
</details>
<h3 id="test_http_requestpyrequesttesttest_init">test_http_request.py::RequestTest::test_init</h3>
<details><summary> <pre>test_http_request.py::RequestTest::test_init</pre></summary><pre>
self = <tests.test_http_request.RequestTest testMethod=test_init>

    def test_init(self):
        # Request requires url in the __init__ method
        self.assertRaises(Exception, self.request_class)

        # url argument must be basestring
        self.assertRaises(TypeError, self.request_class, 123)
        r = self.request_class("http://www.example.com")

        r = self.request_class("http://www.example.com")
        assert isinstance(r.url, str)
        self.assertEqual(r.url, "http://www.example.com")
        self.assertEqual(r.method, self.default_method)

        assert isinstance(r.headers, Headers)
        self.assertEqual(r.headers, self.default_headers)
        self.assertEqual(r.meta, self.default_meta)

        meta = {"lala": "lolo"}
        headers = {b"caca": b"coco"}
        r = self.request_class(
            "http://www.example.com", meta=meta, headers=headers, body="a body"
        )

        assert r.meta is not meta
        self.assertEqual(r.meta, meta)
        assert r.headers is not headers
>       self.assertEqual(r.headers[b"caca"], b"coco")

/testbed/tests/test_http_request.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/headers.py:23: in __getitem__
    return super().__getitem__(key)[-1]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {b'caca': b'coco'}, key = b'caca'

    def __getitem__(self, key):
>       return dict.__getitem__(self, self.normkey(key))
E       KeyError: None

/testbed/scrapy/utils/datatypes.py:31: KeyError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_ajax_url">test_http_request.py::FormRequestTest::test_ajax_url</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_ajax_url</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_ajax_url>

    def test_ajax_url(self):
        # ascii url
        r = self.request_class(url="http://www.example.com/ajax.html#!key=value")
>       self.assertEqual(
            r.url, "http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue"
        )
E       AssertionError: 'http://www.example.com/ajax.html?_escaped_fragment_=key=value' != 'http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'
E       - http://www.example.com/ajax.html?_escaped_fragment_=key=value
E       ?                                                        ^
E       + http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue
E       ?                                                        ^^^

/testbed/tests/test_http_request.py:191: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_custom_encoding_bytes">test_http_request.py::FormRequestTest::test_custom_encoding_bytes</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_custom_encoding_bytes</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_custom_encoding_bytes>

    def test_custom_encoding_bytes(self):
        data = {b"\xb5 one": b"two", b"price": b"\xa3 100"}
>       r2 = self.request_class(
            "http://www.example.com", formdata=data, encoding="latin1"
        )

/testbed/tests/test_http_request.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <POST http://www.example.com>
formdata = {b'price': b'\xa3 100', b'\xb5 one': b'two'}
args = ('http://www.example.com',)
kwargs = {'encoding': 'latin1', 'method': 'POST'}
items = dict_items([(b'\xb5 one', b'two'), (b'price', b'\xa3 100')])

    def __init__(self, *args, formdata: FormdataType=None, **kwargs) -> None:
        if formdata and kwargs.get('method') is None:
            kwargs['method'] = 'POST'
        super().__init__(*args, **kwargs)
        if formdata:
            items = formdata.items() if isinstance(formdata, dict) else formdata
>           form_query_str = _urlencode(items, self.encoding)
E           NameError: name '_urlencode' is not defined

/testbed/scrapy/http/request/form.py:31: NameError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_custom_encoding_textual_data">test_http_request.py::FormRequestTest::test_custom_encoding_textual_data</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_custom_encoding_textual_data</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_custom_encoding_textual_data>

    def test_custom_encoding_textual_data(self):
        data = {"price": "£ 100"}
>       r3 = self.request_class(
            "http://www.example.com", formdata=data, encoding="latin1"
        )

/testbed/tests/test_http_request.py:501: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <POST http://www.example.com>, formdata = {'price': '£ 100'}
args = ('http://www.example.com',)
kwargs = {'encoding': 'latin1', 'method': 'POST'}
items = dict_items([('price', '£ 100')])

    def __init__(self, *args, formdata: FormdataType=None, **kwargs) -> None:
        if formdata and kwargs.get('method') is None:
            kwargs['method'] = 'POST'
        super().__init__(*args, **kwargs)
        if formdata:
            items = formdata.items() if isinstance(formdata, dict) else formdata
>           form_query_str = _urlencode(items, self.encoding)
E           NameError: name '_urlencode' is not defined

/testbed/scrapy/http/request/form.py:31: NameError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_default_encoding_bytes">test_http_request.py::FormRequestTest::test_default_encoding_bytes</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_default_encoding_bytes</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_default_encoding_bytes>

    def test_default_encoding_bytes(self):
        # using default encoding (utf-8)
        data = {b"one": b"two", b"price": b"\xc2\xa3 100"}
>       r2 = self.request_class("http://www.example.com", formdata=data)

/testbed/tests/test_http_request.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <POST http://www.example.com>
formdata = {b'one': b'two', b'price': b'\xc2\xa3 100'}
args = ('http://www.example.com',), kwargs = {'method': 'POST'}
items = dict_items([(b'one', b'two'), (b'price', b'\xc2\xa3 100')])

    def __init__(self, *args, formdata: FormdataType=None, **kwargs) -> None:
        if formdata and kwargs.get('method') is None:
            kwargs['method'] = 'POST'
        super().__init__(*args, **kwargs)
        if formdata:
            items = formdata.items() if isinstance(formdata, dict) else formdata
>           form_query_str = _urlencode(items, self.encoding)
E           NameError: name '_urlencode' is not defined

/testbed/scrapy/http/request/form.py:31: NameError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_default_encoding_mixed_data">test_http_request.py::FormRequestTest::test_default_encoding_mixed_data</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_default_encoding_mixed_data</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_default_encoding_mixed_data>

    def test_default_encoding_mixed_data(self):
        # using default encoding (utf-8)
        data = {"\u00b5one": b"two", b"price\xc2\xa3": "\u00a3 100"}
>       r2 = self.request_class("http://www.example.com", formdata=data)

/testbed/tests/test_http_request.py:479: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <POST http://www.example.com>
formdata = {'µone': b'two', b'price\xc2\xa3': '£ 100'}
args = ('http://www.example.com',), kwargs = {'method': 'POST'}
items = dict_items([('µone', b'two'), (b'price\xc2\xa3', '£ 100')])

    def __init__(self, *args, formdata: FormdataType=None, **kwargs) -> None:
        if formdata and kwargs.get('method') is None:
            kwargs['method'] = 'POST'
        super().__init__(*args, **kwargs)
        if formdata:
            items = formdata.items() if isinstance(formdata, dict) else formdata
>           form_query_str = _urlencode(items, self.encoding)
E           NameError: name '_urlencode' is not defined

/testbed/scrapy/http/request/form.py:31: NameError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_default_encoding_textual_data">test_http_request.py::FormRequestTest::test_default_encoding_textual_data</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_default_encoding_textual_data</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_default_encoding_textual_data>

    def test_default_encoding_textual_data(self):
        # using default encoding (utf-8)
        data = {"µ one": "two", "price": "£ 100"}
>       r2 = self.request_class("http://www.example.com", formdata=data)

/testbed/tests/test_http_request.py:468: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <POST http://www.example.com>
formdata = {'price': '£ 100', 'µ one': 'two'}
args = ('http://www.example.com',), kwargs = {'method': 'POST'}
items = dict_items([('µ one', 'two'), ('price', '£ 100')])

    def __init__(self, *args, formdata: FormdataType=None, **kwargs) -> None:
        if formdata and kwargs.get('method') is None:
            kwargs['method'] = 'POST'
        super().__init__(*args, **kwargs)
        if formdata:
            items = formdata.items() if isinstance(formdata, dict) else formdata
>           form_query_str = _urlencode(items, self.encoding)
E           NameError: name '_urlencode' is not defined

/testbed/scrapy/http/request/form.py:31: NameError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_formdata_overrides_querystring">test_http_request.py::FormRequestTest::test_formdata_overrides_querystring</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_formdata_overrides_querystring</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_formdata_overrides_querystring>

    def test_formdata_overrides_querystring(self):
        data = (("a", "one"), ("a", "two"), ("b", "2"))
>       url = self.request_class(
            "http://www.example.com/?a=0&b=1&c=3#fragment", method="GET", formdata=data
        ).url.split("#")[0]

/testbed/tests/test_http_request.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <GET http://www.example.com/?a=0&b=1&c=3#fragment>
formdata = (('a', 'one'), ('a', 'two'), ('b', '2'))
args = ('http://www.example.com/?a=0&b=1&c=3#fragment',)
kwargs = {'method': 'GET'}, items = (('a', 'one'), ('a', 'two'), ('b', '2'))

    def __init__(self, *args, formdata: FormdataType=None, **kwargs) -> None:
        if formdata and kwargs.get('method') is None:
            kwargs['method'] = 'POST'
        super().__init__(*args, **kwargs)
        if formdata:
            items = formdata.items() if isinstance(formdata, dict) else formdata
>           form_query_str = _urlencode(items, self.encoding)
E           NameError: name '_urlencode' is not defined

/testbed/scrapy/http/request/form.py:31: NameError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_curl">test_http_request.py::FormRequestTest::test_from_curl</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_curl</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_curl>

    def test_from_curl(self):
        # Note: more curated tests regarding curl conversion are in
        # `test_utils_curl.py`
        curl_command = (
            "curl 'http://httpbin.org/post' -X POST -H 'Cookie: _gauges_unique"
            "_year=1; _gauges_unique=1; _gauges_unique_month=1; _gauges_unique"
            "_hour=1; _gauges_unique_day=1' -H 'Origin: http://httpbin.org' -H"
            " 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en-US,en;q"
            "=0.9,ru;q=0.8,es;q=0.7' -H 'Upgrade-Insecure-Requests: 1' -H 'Use"
            "r-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTM"
            "L, like Gecko) Ubuntu Chromium/62.0.3202.75 Chrome/62.0.3202.75 S"
            "afari/537.36' -H 'Content-Type: application /x-www-form-urlencode"
            "d' -H 'Accept: text/html,application/xhtml+xml,application/xml;q="
            "0.9,image/webp,image/apng,*/*;q=0.8' -H 'Cache-Control: max-age=0"
            "' -H 'Referer: http://httpbin.org/forms/post' -H 'Connection: kee"
            "p-alive' --data 'custname=John+Smith&custtel=500&custemail=jsmith"
            "%40example.org&size=small&topping=cheese&topping=onion&delivery=1"
            "2%3A15&comments=' --compressed"
        )
>       r = self.request_class.from_curl(curl_command)

/testbed/tests/test_http_request.py:356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.form.FormRequest'>
curl_command = "curl 'http://httpbin.org/post' -X POST -H 'Cookie: _gauges_unique_year=1; _gauges_unique=1; _gauges_unique_month=1; _...el=500&custemail=jsmith%40example.org&size=small&topping=cheese&topping=onion&delivery=12%3A15&comments=' --compressed"
ignore_unknown_options = True, kwargs = {}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_curl_ignore_unknown_options">test_http_request.py::FormRequestTest::test_from_curl_ignore_unknown_options</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_curl_ignore_unknown_options</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_curl_ignore_unknown_options>

    def test_from_curl_ignore_unknown_options(self):
        # By default: it works and ignores the unknown options: --foo and -z
        with warnings.catch_warnings():  # avoid warning when executing tests
            warnings.simplefilter("ignore")
>           r = self.request_class.from_curl(
                'curl -X DELETE "http://example.org" --foo -z',
            )

/testbed/tests/test_http_request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.form.FormRequest'>
curl_command = 'curl -X DELETE "http://example.org" --foo -z'
ignore_unknown_options = True, kwargs = {}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_curl_with_kwargs">test_http_request.py::FormRequestTest::test_from_curl_with_kwargs</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_curl_with_kwargs</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_curl_with_kwargs>

    def test_from_curl_with_kwargs(self):
>       r = self.request_class.from_curl(
            'curl -X PATCH "http://example.org"', method="POST", meta={"key": "value"}
        )

/testbed/tests/test_http_request.py:399: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.form.FormRequest'>
curl_command = 'curl -X PATCH "http://example.org"'
ignore_unknown_options = True
kwargs = {'meta': {'key': 'value'}, 'method': 'POST'}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_ambiguous_clickdata">test_http_request.py::FormRequestTest::test_from_response_ambiguous_clickdata</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_ambiguous_clickdata</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_ambiguous_clickdata>

    def test_from_response_ambiguous_clickdata(self):
>       response = _buildresponse(
            """
            <form action="get.php" method="GET">
            <input type="submit" name="clickable1" value="clicked1">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="3">
            <input type="submit" name="clickable2" value="clicked2">
            </form>"""
        )

/testbed/tests/test_http_request.py:901: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962e9f70>
body = '\n            <form action="get.php" method="GET">\n            <input type="submit" name="clickable1" value="clicked...dden" name="two" value="3">\n            <input type="submit" name="clickable2" value="clicked2">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_button_notype">test_http_request.py::FormRequestTest::test_from_response_button_notype</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_button_notype</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_button_notype>

    def test_from_response_button_notype(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="test1" value="val1">
            <input type="hidden" name="test2" value="val2">
            <button name="button1" value="submit1">Submit</button>
            </form>""",
            url="http://www.example.com/this/list.html",
        )

/testbed/tests/test_http_request.py:1303: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962ea2a0>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="test1" value="val1">\n            <inp...n" name="test2" value="val2">\n            <button name="button1" value="submit1">Submit</button>\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_button_novalue">test_http_request.py::FormRequestTest::test_from_response_button_novalue</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_button_novalue</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_button_novalue>

    def test_from_response_button_novalue(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="test1" value="val1">
            <input type="hidden" name="test2" value="val2">
            <button type="submit" name="button1">Submit</button>
            </form>""",
            url="http://www.example.com/this/list.html",
        )

/testbed/tests/test_http_request.py:1343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962eb050>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="test1" value="val1">\n            <inp...den" name="test2" value="val2">\n            <button type="submit" name="button1">Submit</button>\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_button_submit">test_http_request.py::FormRequestTest::test_from_response_button_submit</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_button_submit</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_button_submit>

    def test_from_response_button_submit(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="test1" value="val1">
            <input type="hidden" name="test2" value="val2">
            <button type="submit" name="button1" value="submit1">Submit</button>
            </form>""",
            url="http://www.example.com/this/list.html",
        )

/testbed/tests/test_http_request.py:1283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9635d910>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="test1" value="val1">\n            <inp..." value="val2">\n            <button type="submit" name="button1" value="submit1">Submit</button>\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_case_insensitive">test_http_request.py::FormRequestTest::test_from_response_case_insensitive</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_case_insensitive</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_case_insensitive>

    def test_from_response_case_insensitive(self):
>       response = _buildresponse(
            """<form action="get.php" method="GET">
            <input type="SuBmIt" name="clickable1" value="clicked1">
            <input type="iMaGe" name="i1" src="http://my.image.org/1.jpg">
            <input type="submit" name="clickable2" value="clicked2">
            </form>"""
        )

/testbed/tests/test_http_request.py:725: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962e99d0>
body = '<form action="get.php" method="GET">\n            <input type="SuBmIt" name="clickable1" value="clicked1">\n         ...http://my.image.org/1.jpg">\n            <input type="submit" name="clickable2" value="clicked2">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_checkbox">test_http_request.py::FormRequestTest::test_from_response_checkbox</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_checkbox</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_checkbox>

    def test_from_response_checkbox(self):
>       res = _buildresponse(
            """<form>
            <input type="checkbox" name="i1" value="i1v1">
            <input type="checkbox" name="i1" value="iv2" checked>
            <input type="checkbox" name="i2" checked>
            <input type="checkbox" name="i2">
            <input type="checkbox" name="i3" value="i3v1">
            <input type="checkbox" name="i3">
            <input type="checkbox" value="i4v1">
            <input type="checkbox">
            </form>"""
        )

/testbed/tests/test_http_request.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962eb200>
body = '<form>\n            <input type="checkbox" name="i1" value="i1v1">\n            <input type="checkbox" name="i1" valu...name="i3">\n            <input type="checkbox" value="i4v1">\n            <input type="checkbox">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_clickdata_does_not_ignore_image">test_http_request.py::FormRequestTest::test_from_response_clickdata_does_not_ignore_image</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_clickdata_does_not_ignore_image</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_clickdata_does_not_ignore_image>

    def test_from_response_clickdata_does_not_ignore_image(self):
>       response = _buildresponse(
            """<form>
            <input type="text" name="i1" value="i1v">
            <input id="image" name="i2" type="image" value="i2v" alt="Login" src="http://my.image.org/1.jpg">
            </form>"""
        )

/testbed/tests/test_http_request.py:798: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962e9f40>
body = '<form>\n            <input type="text" name="i1" value="i1v">\n            <input id="image" name="i2" type="image" value="i2v" alt="Login" src="http://my.image.org/1.jpg">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_css">test_http_request.py::FormRequestTest::test_from_response_css</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_css</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_css>

    def test_from_response_css(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="2">
            </form>
            <form action="post2.php" method="POST">
            <input type="hidden" name="three" value="3">
            <input type="hidden" name="four" value="4">
            </form>"""
        )

/testbed/tests/test_http_request.py:1386: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962e9a90>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="one" value="1">\n            <input ty...ut type="hidden" name="three" value="3">\n            <input type="hidden" name="four" value="4">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_descendants">test_http_request.py::FormRequestTest::test_from_response_descendants</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_descendants</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_descendants>

    def test_from_response_descendants(self):
>       res = _buildresponse(
            """<form>
            <div>
              <fieldset>
                <input type="text" name="i1">
                <select name="i2">
                    <option value="v1" selected>
                </select>
              </fieldset>
              <input type="radio" name="i3" value="i3v2" checked>
              <input type="checkbox" name="i4" value="i4v2" checked>
              <textarea name="i5"></textarea>
              <input type="hidden" name="h1" value="h1v">
              </div>
            <input type="hidden" name="h2" value="h2v">
            </form>"""
        )

/testbed/tests/test_http_request.py:1214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962ebdd0>
body = '<form>\n            <div>\n              <fieldset>\n                <input type="text" name="i1">\n                <...="h1" value="h1v">\n              </div>\n            <input type="hidden" name="h2" value="h2v">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_dont_click">test_http_request.py::FormRequestTest::test_from_response_dont_click</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_dont_click</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_dont_click>

    def test_from_response_dont_click(self):
>       response = _buildresponse(
            """<form action="get.php" method="GET">
            <input type="submit" name="clickable1" value="clicked1">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="3">
            <input type="submit" name="clickable2" value="clicked2">
            </form>"""
        )

/testbed/tests/test_http_request.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962e82f0>
body = '<form action="get.php" method="GET">\n            <input type="submit" name="clickable1" value="clicked1">\n         ...dden" name="two" value="3">\n            <input type="submit" name="clickable2" value="clicked2">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_dont_submit_image_as_input">test_http_request.py::FormRequestTest::test_from_response_dont_submit_image_as_input</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_dont_submit_image_as_input</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_dont_submit_image_as_input>

    def test_from_response_dont_submit_image_as_input(self):
>       response = _buildresponse(
            """<form>
            <input type="hidden" name="i1" value="i1v">
            <input type="image" name="i2" src="http://my.image.org/1.jpg">
            <input type="submit" name="i3" value="i3v">
            </form>"""
        )

/testbed/tests/test_http_request.py:773: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb963ebd40>
body = '<form>\n            <input type="hidden" name="i1" value="i1v">\n            <input type="image" name="i2" src="http://my.image.org/1.jpg">\n            <input type="submit" name="i3" value="i3v">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_dont_submit_reset_as_input">test_http_request.py::FormRequestTest::test_from_response_dont_submit_reset_as_input</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_dont_submit_reset_as_input</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_dont_submit_reset_as_input>

    def test_from_response_dont_submit_reset_as_input(self):
>       response = _buildresponse(
            """<form>
            <input type="hidden" name="i1" value="i1v">
            <input type="text" name="i2" value="i2v">
            <input type="reset" name="resetme">
            <input type="submit" name="i3" value="i3v">
            </form>"""
        )

/testbed/tests/test_http_request.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb963e5250>
body = '<form>\n            <input type="hidden" name="i1" value="i1v">\n            <input type="text" name="i2" value="i2v"...     <input type="reset" name="resetme">\n            <input type="submit" name="i3" value="i3v">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_drop_params">test_http_request.py::FormRequestTest::test_from_response_drop_params</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_drop_params</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_drop_params>

    def test_from_response_drop_params(self):
>       response = _buildresponse(
            """<form action="get.php" method="POST">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="3">
            </form>"""
        )

/testbed/tests/test_http_request.py:689: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb963e63c0>
body = '<form action="get.php" method="POST">\n            <input type="hidden" name="one" value="1">\n            <input type="hidden" name="two" value="3">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_duplicate_form_key">test_http_request.py::FormRequestTest::test_from_response_duplicate_form_key</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_duplicate_form_key</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_duplicate_form_key>

    def test_from_response_duplicate_form_key(self):
>       response = _buildresponse("<form></form>", url="http://www.example.com")

/testbed/tests/test_http_request.py:613: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb963e76e0>
body = '<form></form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_errors_formnumber">test_http_request.py::FormRequestTest::test_from_response_errors_formnumber</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_errors_formnumber</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_errors_formnumber>

    def test_from_response_errors_formnumber(self):
>       response = _buildresponse(
            """<form action="get.php" method="GET">
            <input type="hidden" name="test" value="val1">
            <input type="hidden" name="test" value="val2">
            <input type="hidden" name="test2" value="xxx">
            </form>"""
        )

/testbed/tests/test_http_request.py:969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb963e46e0>
body = '<form action="get.php" method="GET">\n            <input type="hidden" name="test" value="val1">\n            <input type="hidden" name="test" value="val2">\n            <input type="hidden" name="test2" value="xxx">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_errors_noform">test_http_request.py::FormRequestTest::test_from_response_errors_noform</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_errors_noform</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_errors_noform>

    def test_from_response_errors_noform(self):
>       response = _buildresponse("""<html></html>""")

/testbed/tests/test_http_request.py:955: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb963e4890>
body = '<html></html>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_extra_headers">test_http_request.py::FormRequestTest::test_from_response_extra_headers</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_extra_headers</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_extra_headers>

    def test_from_response_extra_headers(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="test" value="val1">
            <input type="hidden" name="test" value="val2">
            <input type="hidden" name="test2" value="xxx">
            </form>"""
        )

/testbed/tests/test_http_request.py:637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb963e4d70>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="test" value="val1">\n            <inpu...pe="hidden" name="test" value="val2">\n            <input type="hidden" name="test2" value="xxx">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_formid_errors_formnumber">test_http_request.py::FormRequestTest::test_from_response_formid_errors_formnumber</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_formid_errors_formnumber</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_formid_errors_formnumber>

    def test_from_response_formid_errors_formnumber(self):
>       response = _buildresponse(
            """<form id="form1" action="post.php" method="POST">
            <input type="hidden" name="one" value="1">
            </form>
            <form id="form2" name="form2" action="post.php" method="POST">
            <input type="hidden" name="two" value="2">
            </form>"""
        )

/testbed/tests/test_http_request.py:1091: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb963e52b0>
body = '<form id="form1" action="post.php" method="POST">\n            <input type="hidden" name="one" value="1">\n          ...="form2" action="post.php" method="POST">\n            <input type="hidden" name="two" value="2">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_formid_exists">test_http_request.py::FormRequestTest::test_from_response_formid_exists</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_formid_exists</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_formid_exists>

    def test_from_response_formid_exists(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="2">
            </form>
            <form id="form2" action="post.php" method="POST">
            <input type="hidden" name="three" value="3">
            <input type="hidden" name="four" value="4">
            </form>"""
        )

/testbed/tests/test_http_request.py:1043: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb963e69f0>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="one" value="1">\n            <input ty...ut type="hidden" name="three" value="3">\n            <input type="hidden" name="four" value="4">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_formid_nonexistent">test_http_request.py::FormRequestTest::test_from_response_formid_nonexistent</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_formid_nonexistent</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_formid_nonexistent>

    def test_from_response_formid_nonexistent(self):
>       response = _buildresponse(
            """<form id="form1" action="post.php" method="POST">
            <input type="hidden" name="one" value="1">
            </form>
            <form id="form2" action="post.php" method="POST">
            <input type="hidden" name="two" value="2">
            </form>"""
        )

/testbed/tests/test_http_request.py:1077: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb96265040>
body = '<form id="form1" action="post.php" method="POST">\n            <input type="hidden" name="one" value="1">\n          ...="form2" action="post.php" method="POST">\n            <input type="hidden" name="two" value="2">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_formname_errors_formnumber">test_http_request.py::FormRequestTest::test_from_response_formname_errors_formnumber</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_formname_errors_formnumber</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_formname_errors_formnumber>

    def test_from_response_formname_errors_formnumber(self):
>       response = _buildresponse(
            """<form name="form1" action="post.php" method="POST">
            <input type="hidden" name="one" value="1">
            </form>
            <form name="form2" action="post.php" method="POST">
            <input type="hidden" name="two" value="2">
            </form>"""
        )

/testbed/tests/test_http_request.py:1026: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb96265c70>
body = '<form name="form1" action="post.php" method="POST">\n            <input type="hidden" name="one" value="1">\n        ...="form2" action="post.php" method="POST">\n            <input type="hidden" name="two" value="2">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_formname_exists">test_http_request.py::FormRequestTest::test_from_response_formname_exists</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_formname_exists</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_formname_exists>

    def test_from_response_formname_exists(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="2">
            </form>
            <form name="form2" action="post.php" method="POST">
            <input type="hidden" name="three" value="3">
            <input type="hidden" name="four" value="4">
            </form>"""
        )

/testbed/tests/test_http_request.py:996: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb963e4ec0>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="one" value="1">\n            <input ty...ut type="hidden" name="three" value="3">\n            <input type="hidden" name="four" value="4">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_formname_nonexistent">test_http_request.py::FormRequestTest::test_from_response_formname_nonexistent</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_formname_nonexistent</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_formname_nonexistent>

    def test_from_response_formname_nonexistent(self):
>       response = _buildresponse(
            """<form name="form1" action="post.php" method="POST">
            <input type="hidden" name="one" value="1">
            </form>
            <form name="form2" action="post.php" method="POST">
            <input type="hidden" name="two" value="2">
            </form>"""
        )

/testbed/tests/test_http_request.py:1012: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb96266c00>
body = '<form name="form1" action="post.php" method="POST">\n            <input type="hidden" name="one" value="1">\n        ...="form2" action="post.php" method="POST">\n            <input type="hidden" name="two" value="2">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_formname_nonexistent_fallback_formid">test_http_request.py::FormRequestTest::test_from_response_formname_nonexistent_fallback_formid</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_formname_nonexistent_fallback_formid</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_formname_nonexistent_fallback_formid>

    def test_from_response_formname_nonexistent_fallback_formid(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="2">
            </form>
            <form id="form2" name="form2" action="post.php" method="POST">
            <input type="hidden" name="three" value="3">
            <input type="hidden" name="four" value="4">
            </form>"""
        )

/testbed/tests/test_http_request.py:1059: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962664b0>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="one" value="1">\n            <input ty...ut type="hidden" name="three" value="3">\n            <input type="hidden" name="four" value="4">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_get">test_http_request.py::FormRequestTest::test_from_response_get</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_get</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_get>

    def test_from_response_get(self):
>       response = _buildresponse(
            """<form action="get.php" method="GET">
            <input type="hidden" name="test" value="val1">
            <input type="hidden" name="test" value="val2">
            <input type="hidden" name="test2" value="xxx">
            </form>""",
            url="http://www.example.com/this/list.html",
        )

/testbed/tests/test_http_request.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb96265df0>
body = '<form action="get.php" method="GET">\n            <input type="hidden" name="test" value="val1">\n            <input type="hidden" name="test" value="val2">\n            <input type="hidden" name="test2" value="xxx">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_input_hidden">test_http_request.py::FormRequestTest::test_from_response_input_hidden</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_input_hidden</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_input_hidden>

    def test_from_response_input_hidden(self):
>       res = _buildresponse(
            """<form>
            <input type="hidden" name="i1" value="i1v1">
            <input type="hidden" name="i2">
            <input type="hidden" value="i3v1">
            <input type="hidden">
            </form>"""
        )

/testbed/tests/test_http_request.py:1188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb96264680>
body = '<form>\n            <input type="hidden" name="i1" value="i1v1">\n            <input type="hidden" name="i2">\n            <input type="hidden" value="i3v1">\n            <input type="hidden">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_input_text">test_http_request.py::FormRequestTest::test_from_response_input_text</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_input_text</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_input_text>

    def test_from_response_input_text(self):
>       res = _buildresponse(
            """<form>
            <input type="text" name="i1" value="i1v1">
            <input type="text" name="i2">
            <input type="text" value="i3v1">
            <input type="text">
            <input name="i4" value="i4v1">
            </form>"""
        )

/testbed/tests/test_http_request.py:1174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb96265a30>
body = '<form>\n            <input type="text" name="i1" value="i1v1">\n            <input type="text" name="i2">\n          ..."text" value="i3v1">\n            <input type="text">\n            <input name="i4" value="i4v1">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_input_textarea">test_http_request.py::FormRequestTest::test_from_response_input_textarea</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_input_textarea</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_input_textarea>

    def test_from_response_input_textarea(self):
>       res = _buildresponse(
            """<form>
            <textarea name="i1">i1v</textarea>
            <textarea name="i2"></textarea>
            <textarea name="i3"/>
            <textarea>i4v</textarea>
            </form>"""
        )

/testbed/tests/test_http_request.py:1201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb96266420>
body = '<form>\n            <textarea name="i1">i1v</textarea>\n            <textarea name="i2"></textarea>\n            <textarea name="i3"/>\n            <textarea>i4v</textarea>\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_invalid_html5">test_http_request.py::FormRequestTest::test_from_response_invalid_html5</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_invalid_html5</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_invalid_html5>

    def test_from_response_invalid_html5(self):
>       response = _buildresponse(
            """<!DOCTYPE html><body></html><form>"""
            """<input type="text" name="foo" value="xxx">"""
            """</form></body></html>"""
        )

/testbed/tests/test_http_request.py:959: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb96264e00>
body = '<!DOCTYPE html><body></html><form><input type="text" name="foo" value="xxx"></form></body></html>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_invalid_nr_index_clickdata">test_http_request.py::FormRequestTest::test_from_response_invalid_nr_index_clickdata</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_invalid_nr_index_clickdata</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_invalid_nr_index_clickdata>

    def test_from_response_invalid_nr_index_clickdata(self):
>       response = _buildresponse(
            """<form>
            <input type="submit" name="clickable" value="clicked">
            </form>
            """
        )

/testbed/tests/test_http_request.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb96267bf0>
body = '<form>\n            <input type="submit" name="clickable" value="clicked">\n            </form>\n            '

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_multiple_clickdata">test_http_request.py::FormRequestTest::test_from_response_multiple_clickdata</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_multiple_clickdata</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_multiple_clickdata>

    def test_from_response_multiple_clickdata(self):
>       response = _buildresponse(
            """<form action="get.php" method="GET">
            <input type="submit" name="clickable" value="clicked1">
            <input type="submit" name="clickable" value="clicked2">
            <input type="hidden" name="one" value="clicked1">
            <input type="hidden" name="two" value="clicked2">
            </form>"""
        )

/testbed/tests/test_http_request.py:809: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962d1ac0>
body = '<form action="get.php" method="GET">\n            <input type="submit" name="clickable" value="clicked1">\n          ...dden" name="one" value="clicked1">\n            <input type="hidden" name="two" value="clicked2">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_multiple_forms_clickdata">test_http_request.py::FormRequestTest::test_from_response_multiple_forms_clickdata</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_multiple_forms_clickdata</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_multiple_forms_clickdata>

    def test_from_response_multiple_forms_clickdata(self):
>       response = _buildresponse(
            """<form name="form1">
            <input type="submit" name="clickable" value="clicked1">
            <input type="hidden" name="field1" value="value1">
            </form>
            <form name="form2">
            <input type="submit" name="clickable" value="clicked2">
            <input type="hidden" name="field2" value="value2">
            </form>
            """
        )

/testbed/tests/test_http_request.py:857: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962d26c0>
body = '<form name="form1">\n            <input type="submit" name="clickable" value="clicked1">\n            <input type="hi..." value="clicked2">\n            <input type="hidden" name="field2" value="value2">\n            </form>\n            '

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_noformname">test_http_request.py::FormRequestTest::test_from_response_noformname</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_noformname</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_noformname>

    def test_from_response_noformname(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="2">
            </form>"""
        )

/testbed/tests/test_http_request.py:981: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962d3620>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="one" value="1">\n            <input type="hidden" name="two" value="2">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_non_matching_clickdata">test_http_request.py::FormRequestTest::test_from_response_non_matching_clickdata</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_non_matching_clickdata</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_non_matching_clickdata>

    def test_from_response_non_matching_clickdata(self):
>       response = _buildresponse(
            """<form>
            <input type="submit" name="clickable" value="clicked">
            </form>"""
        )

/testbed/tests/test_http_request.py:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb96266240>
body = '<form>\n            <input type="submit" name="clickable" value="clicked">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_nr_index_clickdata">test_http_request.py::FormRequestTest::test_from_response_nr_index_clickdata</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_nr_index_clickdata</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_nr_index_clickdata>

    def test_from_response_nr_index_clickdata(self):
>       response = _buildresponse(
            """<form>
            <input type="submit" name="clickable1" value="clicked1">
            <input type="submit" name="clickable2" value="clicked2">
            </form>
            """
        )

/testbed/tests/test_http_request.py:931: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962d2ae0>
body = '<form>\n            <input type="submit" name="clickable1" value="clicked1">\n            <input type="submit" name="clickable2" value="clicked2">\n            </form>\n            '

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_override_clickable">test_http_request.py::FormRequestTest::test_from_response_override_clickable</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_override_clickable</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_override_clickable>

    def test_from_response_override_clickable(self):
>       response = _buildresponse(
            """<form><input type="submit" name="clickme" value="one"> </form>"""
        )

/testbed/tests/test_http_request.py:877: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962d0ad0>
body = '<form><input type="submit" name="clickme" value="one"> </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_override_duplicate_form_key">test_http_request.py::FormRequestTest::test_from_response_override_duplicate_form_key</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_override_duplicate_form_key</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_override_duplicate_form_key>

    def test_from_response_override_duplicate_form_key(self):
>       response = _buildresponse(
            """<form action="get.php" method="POST">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="3">
            </form>"""
        )

/testbed/tests/test_http_request.py:623: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962d10d0>
body = '<form action="get.php" method="POST">\n            <input type="hidden" name="one" value="1">\n            <input type="hidden" name="two" value="3">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_override_method">test_http_request.py::FormRequestTest::test_from_response_override_method</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_override_method</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_override_method>

    def test_from_response_override_method(self):
>       response = _buildresponse(
            """<html><body>
            <form action="/app"></form>
            </body></html>"""
        )

/testbed/tests/test_http_request.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962d26f0>
body = '<html><body>\n            <form action="/app"></form>\n            </body></html>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_override_params">test_http_request.py::FormRequestTest::test_from_response_override_params</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_override_params</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_override_params>

    def test_from_response_override_params(self):
>       response = _buildresponse(
            """<form action="get.php" method="POST">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="3">
            </form>"""
        )

/testbed/tests/test_http_request.py:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9628c2c0>
body = '<form action="get.php" method="POST">\n            <input type="hidden" name="one" value="1">\n            <input type="hidden" name="two" value="3">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_override_url">test_http_request.py::FormRequestTest::test_from_response_override_url</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_override_url</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_override_url>

    def test_from_response_override_url(self):
>       response = _buildresponse(
            """<html><body>
            <form action="/app"></form>
            </body></html>"""
        )

/testbed/tests/test_http_request.py:712: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962d2810>
body = '<html><body>\n            <form action="/app"></form>\n            </body></html>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_post">test_http_request.py::FormRequestTest::test_from_response_post</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_post</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_post>

    def test_from_response_post(self):
        response = _buildresponse(
            b"""<form action="post.php" method="POST">
            <input type="hidden" name="test" value="val1">
            <input type="hidden" name="test" value="val2">
            <input type="hidden" name="test2" value="xxx">
            </form>""",
            url="http://www.example.com/this/list.html",
        )
>       req = self.request_class.from_response(
            response, formdata={"one": ["two", "three"], "six": "seven"}
        )
E       AttributeError: type object 'FormRequest' has no attribute 'from_response'

/testbed/tests/test_http_request.py:524: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_post_nonascii_bytes_latin1">test_http_request.py::FormRequestTest::test_from_response_post_nonascii_bytes_latin1</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_post_nonascii_bytes_latin1</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_post_nonascii_bytes_latin1>

    def test_from_response_post_nonascii_bytes_latin1(self):
        response = _buildresponse(
            b"""<form action="post.php" method="POST">
            <input type="hidden" name="test \xa3" value="val1">
            <input type="hidden" name="test \xa3" value="val2">
            <input type="hidden" name="test2" value="xxx \xb5">
            </form>""",
            url="http://www.example.com/this/list.html",
            encoding="latin1",
        )
>       req = self.request_class.from_response(
            response, formdata={"one": ["two", "three"], "six": "seven"}
        )
E       AttributeError: type object 'FormRequest' has no attribute 'from_response'

/testbed/tests/test_http_request.py:573: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_post_nonascii_bytes_utf8">test_http_request.py::FormRequestTest::test_from_response_post_nonascii_bytes_utf8</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_post_nonascii_bytes_utf8</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_post_nonascii_bytes_utf8>

    def test_from_response_post_nonascii_bytes_utf8(self):
        response = _buildresponse(
            b"""<form action="post.php" method="POST">
            <input type="hidden" name="test \xc2\xa3" value="val1">
            <input type="hidden" name="test \xc2\xa3" value="val2">
            <input type="hidden" name="test2" value="xxx \xc2\xb5">
            </form>""",
            url="http://www.example.com/this/list.html",
        )
>       req = self.request_class.from_response(
            response, formdata={"one": ["two", "three"], "six": "seven"}
        )
E       AttributeError: type object 'FormRequest' has no attribute 'from_response'

/testbed/tests/test_http_request.py:548: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_post_nonascii_unicode">test_http_request.py::FormRequestTest::test_from_response_post_nonascii_unicode</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_post_nonascii_unicode</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_post_nonascii_unicode>

    def test_from_response_post_nonascii_unicode(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="test £" value="val1">
            <input type="hidden" name="test £" value="val2">
            <input type="hidden" name="test2" value="xxx µ">
            </form>""",
            url="http://www.example.com/this/list.html",
        )

/testbed/tests/test_http_request.py:589: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9628d0a0>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="test £" value="val1">\n            <in...hidden" name="test £" value="val2">\n            <input type="hidden" name="test2" value="xxx µ">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_radio">test_http_request.py::FormRequestTest::test_from_response_radio</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_radio</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_radio>

    def test_from_response_radio(self):
>       res = _buildresponse(
            """<form>
            <input type="radio" name="i1" value="i1v1">
            <input type="radio" name="i1" value="iv2" checked>
            <input type="radio" name="i2" checked>
            <input type="radio" name="i2">
            <input type="radio" name="i3" value="i3v1">
            <input type="radio" name="i3">
            <input type="radio" value="i4v1">
            <input type="radio">
            </form>"""
        )

/testbed/tests/test_http_request.py:1140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9628dbe0>
body = '<form>\n            <input type="radio" name="i1" value="i1v1">\n            <input type="radio" name="i1" value="iv2...adio" name="i3">\n            <input type="radio" value="i4v1">\n            <input type="radio">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_select">test_http_request.py::FormRequestTest::test_from_response_select</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_select</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_select>

    def test_from_response_select(self):
>       res = _buildresponse(
            """<form>
            <select name="i1">
                <option value="i1v1">option 1</option>
                <option value="i1v2" selected>option 2</option>
            </select>
            <select name="i2">
                <option value="i2v1">option 1</option>
                <option value="i2v2">option 2</option>
            </select>
            <select>
                <option value="i3v1">option 1</option>
                <option value="i3v2">option 2</option>
            </select>
            <select name="i4" multiple>
                <option value="i4v1">option 1</option>
                <option value="i4v2" selected>option 2</option>
                <option value="i4v3" selected>option 3</option>
            </select>
            <select name="i5" multiple>
                <option value="i5v1">option 1</option>
                <option value="i5v2">option 2</option>
            </select>
            <select name="i6"></select>
            <select name="i7"/>
            </form>"""
        )

/testbed/tests/test_http_request.py:1108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9628cf20>
body = '<form>\n            <select name="i1">\n                <option value="i1v1">option 1</option>\n                <opti...\n            </select>\n            <select name="i6"></select>\n            <select name="i7"/>\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_submit_first_clickable">test_http_request.py::FormRequestTest::test_from_response_submit_first_clickable</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_submit_first_clickable</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_submit_first_clickable>

    def test_from_response_submit_first_clickable(self):
>       response = _buildresponse(
            """<form action="get.php" method="GET">
            <input type="submit" name="clickable1" value="clicked1">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="3">
            <input type="submit" name="clickable2" value="clicked2">
            </form>"""
        )

/testbed/tests/test_http_request.py:739: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962d3aa0>
body = '<form action="get.php" method="GET">\n            <input type="submit" name="clickable1" value="clicked1">\n         ...dden" name="two" value="3">\n            <input type="submit" name="clickable2" value="clicked2">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_submit_not_first_clickable">test_http_request.py::FormRequestTest::test_from_response_submit_not_first_clickable</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_submit_not_first_clickable</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_submit_not_first_clickable>

    def test_from_response_submit_not_first_clickable(self):
>       response = _buildresponse(
            """<form action="get.php" method="GET">
            <input type="submit" name="clickable1" value="clicked1">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="3">
            <input type="submit" name="clickable2" value="clicked2">
            </form>"""
        )

/testbed/tests/test_http_request.py:755: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9628dbb0>
body = '<form action="get.php" method="GET">\n            <input type="submit" name="clickable1" value="clicked1">\n         ...dden" name="two" value="3">\n            <input type="submit" name="clickable2" value="clicked2">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_submit_novalue">test_http_request.py::FormRequestTest::test_from_response_submit_novalue</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_submit_novalue</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_submit_novalue>

    def test_from_response_submit_novalue(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="test1" value="val1">
            <input type="hidden" name="test2" value="val2">
            <input type="submit" name="button1">Submit</button>
            </form>""",
            url="http://www.example.com/this/list.html",
        )

/testbed/tests/test_http_request.py:1323: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9628d250>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="test1" value="val1">\n            <inp...dden" name="test2" value="val2">\n            <input type="submit" name="button1">Submit</button>\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_unicode_clickdata">test_http_request.py::FormRequestTest::test_from_response_unicode_clickdata</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_unicode_clickdata</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_unicode_clickdata>

    def test_from_response_unicode_clickdata(self):
>       response = _buildresponse(
            """<form action="get.php" method="GET">
            <input type="submit" name="price in \u00a3" value="\u00a3 1000">
            <input type="submit" name="price in \u20ac" value="\u20ac 2000">
            <input type="hidden" name="poundsign" value="\u00a3">
            <input type="hidden" name="eurosign" value="\u20ac">
            </form>"""
        )

/testbed/tests/test_http_request.py:826: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9628f410>
body = '<form action="get.php" method="GET">\n            <input type="submit" name="price in £" value="£ 1000">\n           ..."hidden" name="poundsign" value="£">\n            <input type="hidden" name="eurosign" value="€">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_unicode_clickdata_latin1">test_http_request.py::FormRequestTest::test_from_response_unicode_clickdata_latin1</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_unicode_clickdata_latin1</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_unicode_clickdata_latin1>

    def test_from_response_unicode_clickdata_latin1(self):
>       response = _buildresponse(
            """<form action="get.php" method="GET">
            <input type="submit" name="price in \u00a3" value="\u00a3 1000">
            <input type="submit" name="price in \u00a5" value="\u00a5 2000">
            <input type="hidden" name="poundsign" value="\u00a3">
            <input type="hidden" name="yensign" value="\u00a5">
            </form>""",
            encoding="latin1",
        )

/testbed/tests/test_http_request.py:841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9624d4f0>
body = '<form action="get.php" method="GET">\n            <input type="submit" name="price in £" value="£ 1000">\n           ...="hidden" name="poundsign" value="£">\n            <input type="hidden" name="yensign" value="¥">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_unicode_xpath">test_http_request.py::FormRequestTest::test_from_response_unicode_xpath</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_unicode_xpath</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_unicode_xpath>

    def test_from_response_unicode_xpath(self):
        response = _buildresponse(b'<form name="\xd1\x8a"></form>')
>       r = self.request_class.from_response(
            response, formxpath="//form[@name='\u044a']"
        )
E       AttributeError: type object 'FormRequest' has no attribute 'from_response'

/testbed/tests/test_http_request.py:1267: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_valid_form_methods">test_http_request.py::FormRequestTest::test_from_response_valid_form_methods</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_valid_form_methods</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_valid_form_methods>

    def test_from_response_valid_form_methods(self):
        form_methods = [
            [method, method] for method in self.request_class.valid_form_methods
        ]
        form_methods.append(["UNKNOWN", "GET"])

        for method, expected in form_methods:
>           response = _buildresponse(
                f'<form action="post.php" method="{method}">'
                '<input type="hidden" name="one" value="1">'
                "</form>"
            )

/testbed/tests/test_http_request.py:1420: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9624f950>
body = '<form action="post.php" method="GET"><input type="hidden" name="one" value="1"></form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_from_response_xpath">test_http_request.py::FormRequestTest::test_from_response_xpath</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_from_response_xpath</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_from_response_xpath>

    def test_from_response_xpath(self):
>       response = _buildresponse(
            """<form action="post.php" method="POST">
            <input type="hidden" name="one" value="1">
            <input type="hidden" name="two" value="2">
            </form>
            <form action="post2.php" method="POST">
            <input type="hidden" name="three" value="3">
            <input type="hidden" name="four" value="4">
            </form>"""
        )

/testbed/tests/test_http_request.py:1236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9628ecf0>
body = '<form action="post.php" method="POST">\n            <input type="hidden" name="one" value="1">\n            <input ty...ut type="hidden" name="three" value="3">\n            <input type="hidden" name="four" value="4">\n            </form>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_headers">test_http_request.py::FormRequestTest::test_headers</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_headers</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_headers>

    def test_headers(self):
        # Different ways of setting headers attribute
        url = "http://www.scrapy.org"
        headers = {b"Accept": "gzip", b"Custom-Header": "nothing to tell you"}
        r = self.request_class(url=url, headers=headers)
        p = self.request_class(url=url, headers=r.headers)

        self.assertEqual(r.headers, p.headers)
        self.assertFalse(r.headers is headers)
        self.assertFalse(p.headers is r.headers)

        # headers must not be unicode
        h = Headers({"key1": "val1", "key2": "val2"})
        h["newkey"] = "newval"
        for k, v in h.items():
>           self.assertIsInstance(k, bytes)
E           AssertionError: 'key1' is not an instance of <class 'bytes'>

/testbed/tests/test_http_request.py:84: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_html_base_form_action">test_http_request.py::FormRequestTest::test_html_base_form_action</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_html_base_form_action</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_html_base_form_action>

    def test_html_base_form_action(self):
>       response = _buildresponse(
            """
            <html>
                <head>
                    <base href=" http://b.com/">
                </head>
                <body>
                    <form action="test_form">
                    </form>
                </body>
            </html>
            """,
            url="http://a.com/",
        )

/testbed/tests/test_http_request.py:1363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb9624e420>
body = '\n            <html>\n                <head>\n                    <base href=" http://b.com/">\n                </hea...    <form action="test_form">\n                    </form>\n                </body>\n            </html>\n            '

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_immutable_attributes">test_http_request.py::FormRequestTest::test_immutable_attributes</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_immutable_attributes</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_immutable_attributes>

    def test_immutable_attributes(self):
        r = self.request_class("http://example.com")
>       self.assertRaises(AttributeError, setattr, r, "url", "http://example2.com")

/testbed/tests/test_http_request.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def wrapper(self, value):
        private_name = f"_{name}"
        if not hasattr(self, private_name):
>           warnings.warn(f"Property {name} is deprecated.", category=warn_category, stacklevel=2)
E           TypeError: category must be a Warning subclass, not 'str'

/testbed/scrapy/http/common.py:10: TypeError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_init">test_http_request.py::FormRequestTest::test_init</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_init</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_init>

    def test_init(self):
        # Request requires url in the __init__ method
        self.assertRaises(Exception, self.request_class)

        # url argument must be basestring
        self.assertRaises(TypeError, self.request_class, 123)
        r = self.request_class("http://www.example.com")

        r = self.request_class("http://www.example.com")
        assert isinstance(r.url, str)
        self.assertEqual(r.url, "http://www.example.com")
        self.assertEqual(r.method, self.default_method)

        assert isinstance(r.headers, Headers)
        self.assertEqual(r.headers, self.default_headers)
        self.assertEqual(r.meta, self.default_meta)

        meta = {"lala": "lolo"}
        headers = {b"caca": b"coco"}
        r = self.request_class(
            "http://www.example.com", meta=meta, headers=headers, body="a body"
        )

        assert r.meta is not meta
        self.assertEqual(r.meta, meta)
        assert r.headers is not headers
>       self.assertEqual(r.headers[b"caca"], b"coco")

/testbed/tests/test_http_request.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/headers.py:23: in __getitem__
    return super().__getitem__(key)[-1]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {b'caca': b'coco'}, key = b'caca'

    def __getitem__(self, key):
>       return dict.__getitem__(self, self.normkey(key))
E       KeyError: None

/testbed/scrapy/utils/datatypes.py:31: KeyError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_multi_key_values">test_http_request.py::FormRequestTest::test_multi_key_values</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_multi_key_values</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_multi_key_values>

    def test_multi_key_values(self):
        # using multiples values for a single key
        data = {"price": "\xa3 100", "colours": ["red", "blue", "green"]}
>       r3 = self.request_class("http://www.example.com", formdata=data)

/testbed/tests/test_http_request.py:510: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <POST http://www.example.com>
formdata = {'colours': ['red', 'blue', 'green'], 'price': '£ 100'}
args = ('http://www.example.com',), kwargs = {'method': 'POST'}
items = dict_items([('price', '£ 100'), ('colours', ['red', 'blue', 'green'])])

    def __init__(self, *args, formdata: FormdataType=None, **kwargs) -> None:
        if formdata and kwargs.get('method') is None:
            kwargs['method'] = 'POST'
        super().__init__(*args, **kwargs)
        if formdata:
            items = formdata.items() if isinstance(formdata, dict) else formdata
>           form_query_str = _urlencode(items, self.encoding)
E           NameError: name '_urlencode' is not defined

/testbed/scrapy/http/request/form.py:31: NameError
</pre>
</details>
<h3 id="test_http_requestpyformrequesttesttest_spaces_in_action">test_http_request.py::FormRequestTest::test_spaces_in_action</h3>
<details><summary> <pre>test_http_request.py::FormRequestTest::test_spaces_in_action</pre></summary><pre>
self = <tests.test_http_request.FormRequestTest testMethod=test_spaces_in_action>

    def test_spaces_in_action(self):
>       resp = _buildresponse('<body><form action=" path\n"></form></body>')

/testbed/tests/test_http_request.py:1381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1433: in _buildresponse
    return HtmlResponse(**kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb962d4290>
body = '<body><form action=" path\n"></form></body>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_requestpyxmlrpcrequesttesttest_ajax_url">test_http_request.py::XmlRpcRequestTest::test_ajax_url</h3>
<details><summary> <pre>test_http_request.py::XmlRpcRequestTest::test_ajax_url</pre></summary><pre>
self = <tests.test_http_request.XmlRpcRequestTest testMethod=test_ajax_url>

    def test_ajax_url(self):
        # ascii url
        r = self.request_class(url="http://www.example.com/ajax.html#!key=value")
>       self.assertEqual(
            r.url, "http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue"
        )
E       AssertionError: 'http://www.example.com/ajax.html?_escaped_fragment_=key=value' != 'http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'
E       - http://www.example.com/ajax.html?_escaped_fragment_=key=value
E       ?                                                        ^
E       + http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue
E       ?                                                        ^^^

/testbed/tests/test_http_request.py:191: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyxmlrpcrequesttesttest_from_curl">test_http_request.py::XmlRpcRequestTest::test_from_curl</h3>
<details><summary> <pre>test_http_request.py::XmlRpcRequestTest::test_from_curl</pre></summary><pre>
self = <tests.test_http_request.XmlRpcRequestTest testMethod=test_from_curl>

    def test_from_curl(self):
        # Note: more curated tests regarding curl conversion are in
        # `test_utils_curl.py`
        curl_command = (
            "curl 'http://httpbin.org/post' -X POST -H 'Cookie: _gauges_unique"
            "_year=1; _gauges_unique=1; _gauges_unique_month=1; _gauges_unique"
            "_hour=1; _gauges_unique_day=1' -H 'Origin: http://httpbin.org' -H"
            " 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en-US,en;q"
            "=0.9,ru;q=0.8,es;q=0.7' -H 'Upgrade-Insecure-Requests: 1' -H 'Use"
            "r-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTM"
            "L, like Gecko) Ubuntu Chromium/62.0.3202.75 Chrome/62.0.3202.75 S"
            "afari/537.36' -H 'Content-Type: application /x-www-form-urlencode"
            "d' -H 'Accept: text/html,application/xhtml+xml,application/xml;q="
            "0.9,image/webp,image/apng,*/*;q=0.8' -H 'Cache-Control: max-age=0"
            "' -H 'Referer: http://httpbin.org/forms/post' -H 'Connection: kee"
            "p-alive' --data 'custname=John+Smith&custtel=500&custemail=jsmith"
            "%40example.org&size=small&topping=cheese&topping=onion&delivery=1"
            "2%3A15&comments=' --compressed"
        )
>       r = self.request_class.from_curl(curl_command)

/testbed/tests/test_http_request.py:356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.rpc.XmlRpcRequest'>
curl_command = "curl 'http://httpbin.org/post' -X POST -H 'Cookie: _gauges_unique_year=1; _gauges_unique=1; _gauges_unique_month=1; _...el=500&custemail=jsmith%40example.org&size=small&topping=cheese&topping=onion&delivery=12%3A15&comments=' --compressed"
ignore_unknown_options = True, kwargs = {}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyxmlrpcrequesttesttest_from_curl_ignore_unknown_options">test_http_request.py::XmlRpcRequestTest::test_from_curl_ignore_unknown_options</h3>
<details><summary> <pre>test_http_request.py::XmlRpcRequestTest::test_from_curl_ignore_unknown_options</pre></summary><pre>
self = <tests.test_http_request.XmlRpcRequestTest testMethod=test_from_curl_ignore_unknown_options>

    def test_from_curl_ignore_unknown_options(self):
        # By default: it works and ignores the unknown options: --foo and -z
        with warnings.catch_warnings():  # avoid warning when executing tests
            warnings.simplefilter("ignore")
>           r = self.request_class.from_curl(
                'curl -X DELETE "http://example.org" --foo -z',
            )

/testbed/tests/test_http_request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.rpc.XmlRpcRequest'>
curl_command = 'curl -X DELETE "http://example.org" --foo -z'
ignore_unknown_options = True, kwargs = {}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyxmlrpcrequesttesttest_from_curl_with_kwargs">test_http_request.py::XmlRpcRequestTest::test_from_curl_with_kwargs</h3>
<details><summary> <pre>test_http_request.py::XmlRpcRequestTest::test_from_curl_with_kwargs</pre></summary><pre>
self = <tests.test_http_request.XmlRpcRequestTest testMethod=test_from_curl_with_kwargs>

    def test_from_curl_with_kwargs(self):
>       r = self.request_class.from_curl(
            'curl -X PATCH "http://example.org"', method="POST", meta={"key": "value"}
        )

/testbed/tests/test_http_request.py:399: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.rpc.XmlRpcRequest'>
curl_command = 'curl -X PATCH "http://example.org"'
ignore_unknown_options = True
kwargs = {'meta': {'key': 'value'}, 'method': 'POST'}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyxmlrpcrequesttesttest_headers">test_http_request.py::XmlRpcRequestTest::test_headers</h3>
<details><summary> <pre>test_http_request.py::XmlRpcRequestTest::test_headers</pre></summary><pre>
self = <tests.test_http_request.XmlRpcRequestTest testMethod=test_headers>

    def test_headers(self):
        # Different ways of setting headers attribute
        url = "http://www.scrapy.org"
        headers = {b"Accept": "gzip", b"Custom-Header": "nothing to tell you"}
        r = self.request_class(url=url, headers=headers)
        p = self.request_class(url=url, headers=r.headers)

        self.assertEqual(r.headers, p.headers)
        self.assertFalse(r.headers is headers)
        self.assertFalse(p.headers is r.headers)

        # headers must not be unicode
        h = Headers({"key1": "val1", "key2": "val2"})
        h["newkey"] = "newval"
        for k, v in h.items():
>           self.assertIsInstance(k, bytes)
E           AssertionError: 'key1' is not an instance of <class 'bytes'>

/testbed/tests/test_http_request.py:84: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyxmlrpcrequesttesttest_immutable_attributes">test_http_request.py::XmlRpcRequestTest::test_immutable_attributes</h3>
<details><summary> <pre>test_http_request.py::XmlRpcRequestTest::test_immutable_attributes</pre></summary><pre>
self = <tests.test_http_request.XmlRpcRequestTest testMethod=test_immutable_attributes>

    def test_immutable_attributes(self):
        r = self.request_class("http://example.com")
>       self.assertRaises(AttributeError, setattr, r, "url", "http://example2.com")

/testbed/tests/test_http_request.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def wrapper(self, value):
        private_name = f"_{name}"
        if not hasattr(self, private_name):
>           warnings.warn(f"Property {name} is deprecated.", category=warn_category, stacklevel=2)
E           TypeError: category must be a Warning subclass, not 'str'

/testbed/scrapy/http/common.py:10: TypeError
</pre>
</details>
<h3 id="test_http_requestpyxmlrpcrequesttesttest_init">test_http_request.py::XmlRpcRequestTest::test_init</h3>
<details><summary> <pre>test_http_request.py::XmlRpcRequestTest::test_init</pre></summary><pre>
self = <tests.test_http_request.XmlRpcRequestTest testMethod=test_init>

    def test_init(self):
        # Request requires url in the __init__ method
        self.assertRaises(Exception, self.request_class)

        # url argument must be basestring
        self.assertRaises(TypeError, self.request_class, 123)
        r = self.request_class("http://www.example.com")

        r = self.request_class("http://www.example.com")
        assert isinstance(r.url, str)
        self.assertEqual(r.url, "http://www.example.com")
        self.assertEqual(r.method, self.default_method)

        assert isinstance(r.headers, Headers)
>       self.assertEqual(r.headers, self.default_headers)
E       AssertionError: {'Content-Type': 'text/xml'} != {b'Content-Type': [b'text/xml']}

/testbed/tests/test_http_request.py:41: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyxmlrpcrequesttesttest_latin1">test_http_request.py::XmlRpcRequestTest::test_latin1</h3>
<details><summary> <pre>test_http_request.py::XmlRpcRequestTest::test_latin1</pre></summary><pre>
self = <tests.test_http_request.XmlRpcRequestTest testMethod=test_latin1>

    def test_latin1(self):
>       self._test_request(params=("pas£",), encoding="latin1")

/testbed/tests/test_http_request.py:1475: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1454: in _test_request
    self.assertEqual(r.headers[b"Content-Type"], b"text/xml")
/testbed/scrapy/http/headers.py:23: in __getitem__
    return super().__getitem__(key)[-1]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {'Content-Type': 'text/xml'}, key = b'Content-Type'

    def __getitem__(self, key):
>       return dict.__getitem__(self, self.normkey(key))
E       KeyError: None

/testbed/scrapy/utils/datatypes.py:31: KeyError
</pre>
</details>
<h3 id="test_http_requestpyxmlrpcrequesttesttest_replace">test_http_request.py::XmlRpcRequestTest::test_replace</h3>
<details><summary> <pre>test_http_request.py::XmlRpcRequestTest::test_replace</pre></summary><pre>
self = <tests.test_http_request.XmlRpcRequestTest testMethod=test_replace>

    def test_replace(self):
        """Test Request.replace() method"""
        r1 = self.request_class("http://www.example.com", method="GET")
        hdrs = Headers(r1.headers)
        hdrs[b"key"] = b"value"
        r2 = r1.replace(method="POST", body="New body", headers=hdrs)
        self.assertEqual(r1.url, r2.url)
        self.assertEqual((r1.method, r2.method), ("GET", "POST"))
        self.assertEqual((r1.body, r2.body), (b"", b"New body"))
>       self.assertEqual((r1.headers, r2.headers), (self.default_headers, hdrs))
E       AssertionError: Tuples differ: ({'Content-Type': 'text/xml'}, {'Content-Type': 'text/xml', None: None}) != ({b'Content-Type': [b'text/xml']}, {'Content-Type': 'text/xml', None: None})
E       
E       First differing element 0:
E       {'Content-Type': 'text/xml'}
E       {b'Content-Type': [b'text/xml']}
E       
E       - ({'Content-Type': 'text/xml'}, {None: None, 'Content-Type': 'text/xml'})
E       + ({b'Content-Type': [b'text/xml']}, {None: None, 'Content-Type': 'text/xml'})
E       ?   +                ++          +

/testbed/tests/test_http_request.py:266: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyxmlrpcrequesttesttest_xmlrpc_dumps">test_http_request.py::XmlRpcRequestTest::test_xmlrpc_dumps</h3>
<details><summary> <pre>test_http_request.py::XmlRpcRequestTest::test_xmlrpc_dumps</pre></summary><pre>
self = <tests.test_http_request.XmlRpcRequestTest testMethod=test_xmlrpc_dumps>

    def test_xmlrpc_dumps(self):
>       self._test_request(params=("value",))

/testbed/tests/test_http_request.py:1466: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_request.py:1454: in _test_request
    self.assertEqual(r.headers[b"Content-Type"], b"text/xml")
/testbed/scrapy/http/headers.py:23: in __getitem__
    return super().__getitem__(key)[-1]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {'Content-Type': 'text/xml'}, key = b'Content-Type'

    def __getitem__(self, key):
>       return dict.__getitem__(self, self.normkey(key))
E       KeyError: None

/testbed/scrapy/utils/datatypes.py:31: KeyError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_ajax_url">test_http_request.py::JsonRequestTest::test_ajax_url</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_ajax_url</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_ajax_url>

    def test_ajax_url(self):
        # ascii url
        r = self.request_class(url="http://www.example.com/ajax.html#!key=value")
>       self.assertEqual(
            r.url, "http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue"
        )
E       AssertionError: 'http://www.example.com/ajax.html?_escaped_fragment_=key=value' != 'http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'
E       - http://www.example.com/ajax.html?_escaped_fragment_=key=value
E       ?                                                        ^
E       + http://www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue
E       ?                                                        ^^^

/testbed/tests/test_http_request.py:191: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_body_none_data">test_http_request.py::JsonRequestTest::test_body_none_data</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_body_none_data</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_body_none_data>

    def test_body_none_data(self):
        data = {
            "name": "value",
        }
        with warnings.catch_warnings(record=True) as _warnings:
            r7 = self.request_class(url="http://www.example.com/", body=None, data=data)
>           self.assertEqual(r7.body, to_bytes(json.dumps(data)))
E           AssertionError: b'' != b'{"name": "value"}'

/testbed/tests/test_http_request.py:1561: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_copy">test_http_request.py::JsonRequestTest::test_copy</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_copy</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_copy>

    def test_copy(self):
        """Test Request copy"""

        def somecallback():
            pass

        r1 = self.request_class(
            "http://www.example.com",
            flags=["f1", "f2"],
            callback=somecallback,
            errback=somecallback,
        )
        r1.meta["foo"] = "bar"
        r1.cb_kwargs["key"] = "value"
>       r2 = r1.copy()

/testbed/tests/test_http_request.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/request/__init__.py:163: in copy
    return self.replace()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <GET http://www.example.com>, args = ()
kwargs = {'body': b'', 'callback': <function RequestTest.test_copy.<locals>.somecallback at 0x7fcb976defc0>, 'cb_kwargs': {'key': 'value'}, 'cookies': {}, ...}
x = 'dumps_kwargs'

    def replace(self, *args, **kwargs) -> "Request":
        """Create a new Request with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'JsonRequest' object has no attribute 'dumps_kwargs'. Did you mean: '_dumps_kwargs'?

/testbed/scrapy/http/request/__init__.py:168: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_copy_inherited_classes">test_http_request.py::JsonRequestTest::test_copy_inherited_classes</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_copy_inherited_classes</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_copy_inherited_classes>

    def test_copy_inherited_classes(self):
        """Test Request children copies preserve their class"""

        class CustomRequest(self.request_class):
            pass

        r1 = CustomRequest("http://www.example.com")
>       r2 = r1.copy()

/testbed/tests/test_http_request.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/request/__init__.py:163: in copy
    return self.replace()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <GET http://www.example.com>, args = ()
kwargs = {'body': b'', 'callback': None, 'cb_kwargs': {}, 'cookies': {}, ...}
x = 'dumps_kwargs'

    def replace(self, *args, **kwargs) -> "Request":
        """Create a new Request with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'CustomRequest' object has no attribute 'dumps_kwargs'. Did you mean: '_dumps_kwargs'?

/testbed/scrapy/http/request/__init__.py:168: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_data">test_http_request.py::JsonRequestTest::test_data</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_data</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_data>

    def test_data(self):
        r1 = self.request_class(url="http://www.example.com/")
        self.assertEqual(r1.body, b"")

        body = b"body"
        r2 = self.request_class(url="http://www.example.com/", body=body)
        self.assertEqual(r2.body, body)

        data = {
            "name": "value",
        }
        r3 = self.request_class(url="http://www.example.com/", data=data)
>       self.assertEqual(r3.body, to_bytes(json.dumps(data)))
E       AssertionError: b'' != b'{"name": "value"}'

/testbed/tests/test_http_request.py:1502: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_dumps_kwargs">test_http_request.py::JsonRequestTest::test_dumps_kwargs</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_dumps_kwargs</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_dumps_kwargs>

    def test_dumps_kwargs(self):
        """Test that dumps_kwargs are passed to json.dumps"""
        data = {
            "name": "value",
        }
        dumps_kwargs = {
            "ensure_ascii": True,
            "allow_nan": True,
        }
        with mock.patch("json.dumps", return_value=b"") as mock_dumps:
            self.request_class(
                url="http://www.example.com/", data=data, dumps_kwargs=dumps_kwargs
            )
>           kwargs = mock_dumps.call_args[1]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/tests/test_http_request.py:1594: TypeError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_dumps_sort_keys">test_http_request.py::JsonRequestTest::test_dumps_sort_keys</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_dumps_sort_keys</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_dumps_sort_keys>

    def test_dumps_sort_keys(self):
        """Test that sort_keys=True is passed to json.dumps by default"""
        data = {
            "name": "value",
        }
        with mock.patch("json.dumps", return_value=b"") as mock_dumps:
            self.request_class(url="http://www.example.com/", data=data)
>           kwargs = mock_dumps.call_args[1]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/tests/test_http_request.py:1578: TypeError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_from_curl">test_http_request.py::JsonRequestTest::test_from_curl</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_from_curl</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_from_curl>

    def test_from_curl(self):
        # Note: more curated tests regarding curl conversion are in
        # `test_utils_curl.py`
        curl_command = (
            "curl 'http://httpbin.org/post' -X POST -H 'Cookie: _gauges_unique"
            "_year=1; _gauges_unique=1; _gauges_unique_month=1; _gauges_unique"
            "_hour=1; _gauges_unique_day=1' -H 'Origin: http://httpbin.org' -H"
            " 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en-US,en;q"
            "=0.9,ru;q=0.8,es;q=0.7' -H 'Upgrade-Insecure-Requests: 1' -H 'Use"
            "r-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTM"
            "L, like Gecko) Ubuntu Chromium/62.0.3202.75 Chrome/62.0.3202.75 S"
            "afari/537.36' -H 'Content-Type: application /x-www-form-urlencode"
            "d' -H 'Accept: text/html,application/xhtml+xml,application/xml;q="
            "0.9,image/webp,image/apng,*/*;q=0.8' -H 'Cache-Control: max-age=0"
            "' -H 'Referer: http://httpbin.org/forms/post' -H 'Connection: kee"
            "p-alive' --data 'custname=John+Smith&custtel=500&custemail=jsmith"
            "%40example.org&size=small&topping=cheese&topping=onion&delivery=1"
            "2%3A15&comments=' --compressed"
        )
>       r = self.request_class.from_curl(curl_command)

/testbed/tests/test_http_request.py:356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.json_request.JsonRequest'>
curl_command = "curl 'http://httpbin.org/post' -X POST -H 'Cookie: _gauges_unique_year=1; _gauges_unique=1; _gauges_unique_month=1; _...el=500&custemail=jsmith%40example.org&size=small&topping=cheese&topping=onion&delivery=12%3A15&comments=' --compressed"
ignore_unknown_options = True, kwargs = {}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_from_curl_ignore_unknown_options">test_http_request.py::JsonRequestTest::test_from_curl_ignore_unknown_options</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_from_curl_ignore_unknown_options</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_from_curl_ignore_unknown_options>

    def test_from_curl_ignore_unknown_options(self):
        # By default: it works and ignores the unknown options: --foo and -z
        with warnings.catch_warnings():  # avoid warning when executing tests
            warnings.simplefilter("ignore")
>           r = self.request_class.from_curl(
                'curl -X DELETE "http://example.org" --foo -z',
            )

/testbed/tests/test_http_request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.json_request.JsonRequest'>
curl_command = 'curl -X DELETE "http://example.org" --foo -z'
ignore_unknown_options = True, kwargs = {}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_from_curl_with_kwargs">test_http_request.py::JsonRequestTest::test_from_curl_with_kwargs</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_from_curl_with_kwargs</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_from_curl_with_kwargs>

    def test_from_curl_with_kwargs(self):
>       r = self.request_class.from_curl(
            'curl -X PATCH "http://example.org"', method="POST", meta={"key": "value"}
        )

/testbed/tests/test_http_request.py:399: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'scrapy.http.request.json_request.JsonRequest'>
curl_command = 'curl -X PATCH "http://example.org"'
ignore_unknown_options = True
kwargs = {'meta': {'key': 'value'}, 'method': 'POST'}, request_kwargs = None

    @classmethod
    def from_curl(
        cls: Type[RequestTypeVar],
        curl_command: str,
        ignore_unknown_options: bool = True,
        **kwargs,
    ) -> RequestTypeVar:
        """Create a Request object from a string containing a `cURL
        <https://curl.haxx.se/>`_ command. It populates the HTTP method, the
        URL, the headers, the cookies and the body. It accepts the same
        arguments as the :class:`Request` class, taking preference and
        overriding the values of the same arguments contained in the cURL
        command.

        Unrecognized options are ignored by default. To raise an error when
        finding unknown options call this method by passing
        ``ignore_unknown_options=False``.

        .. caution:: Using :meth:`from_curl` from :class:`~scrapy.http.Request`
                     subclasses, such as :class:`~scrapy.http.JSONRequest`, or
                     :class:`~scrapy.http.XmlRpcRequest`, as well as having
                     :ref:`downloader middlewares <topics-downloader-middleware>`
                     and
                     :ref:`spider middlewares <topics-spider-middleware>`
                     enabled, such as
                     :class:`~scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware`,
                     :class:`~scrapy.downloadermiddlewares.useragent.UserAgentMiddleware`,
                     or
                     :class:`~scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware`,
                     may modify the :class:`~scrapy.http.Request` object.

        To translate a cURL command into a Scrapy request,
        you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.
        """
        request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)
>       request_kwargs.update(kwargs)
E       AttributeError: 'NoneType' object has no attribute 'update'

/testbed/scrapy/http/request/__init__.py:207: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_headers">test_http_request.py::JsonRequestTest::test_headers</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_headers</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_headers>

    def test_headers(self):
        # Different ways of setting headers attribute
        url = "http://www.scrapy.org"
        headers = {b"Accept": "gzip", b"Custom-Header": "nothing to tell you"}
        r = self.request_class(url=url, headers=headers)
        p = self.request_class(url=url, headers=r.headers)

        self.assertEqual(r.headers, p.headers)
        self.assertFalse(r.headers is headers)
        self.assertFalse(p.headers is r.headers)

        # headers must not be unicode
        h = Headers({"key1": "val1", "key2": "val2"})
        h["newkey"] = "newval"
        for k, v in h.items():
>           self.assertIsInstance(k, bytes)
E           AssertionError: 'key1' is not an instance of <class 'bytes'>

/testbed/tests/test_http_request.py:84: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_immutable_attributes">test_http_request.py::JsonRequestTest::test_immutable_attributes</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_immutable_attributes</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_immutable_attributes>

    def test_immutable_attributes(self):
        r = self.request_class("http://example.com")
>       self.assertRaises(AttributeError, setattr, r, "url", "http://example2.com")

/testbed/tests/test_http_request.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def wrapper(self, value):
        private_name = f"_{name}"
        if not hasattr(self, private_name):
>           warnings.warn(f"Property {name} is deprecated.", category=warn_category, stacklevel=2)
E           TypeError: category must be a Warning subclass, not 'str'

/testbed/scrapy/http/common.py:10: TypeError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_init">test_http_request.py::JsonRequestTest::test_init</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_init</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_init>

    def test_init(self):
        # Request requires url in the __init__ method
        self.assertRaises(Exception, self.request_class)

        # url argument must be basestring
        self.assertRaises(TypeError, self.request_class, 123)
        r = self.request_class("http://www.example.com")

        r = self.request_class("http://www.example.com")
        assert isinstance(r.url, str)
        self.assertEqual(r.url, "http://www.example.com")
        self.assertEqual(r.method, self.default_method)

        assert isinstance(r.headers, Headers)
>       self.assertEqual(r.headers, self.default_headers)
E       AssertionError: {'Content-Type': 'application/json', 'Acce[49 chars].01'} != {b'Content-Type': [b'application/json'], b[57 chars]01']}

/testbed/tests/test_http_request.py:41: AssertionError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_replace">test_http_request.py::JsonRequestTest::test_replace</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_replace</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_replace>

    def test_replace(self):
        """Test Request.replace() method"""
        r1 = self.request_class("http://www.example.com", method="GET")
        hdrs = Headers(r1.headers)
        hdrs[b"key"] = b"value"
>       r2 = r1.replace(method="POST", body="New body", headers=hdrs)

/testbed/tests/test_http_request.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <GET http://www.example.com>, args = ()
kwargs = {'body': 'New body', 'callback': None, 'cb_kwargs': {}, 'cookies': {}, ...}
x = 'dumps_kwargs'

    def replace(self, *args, **kwargs) -> "Request":
        """Create a new Request with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'JsonRequest' object has no attribute 'dumps_kwargs'. Did you mean: '_dumps_kwargs'?

/testbed/scrapy/http/request/__init__.py:168: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_replace_data">test_http_request.py::JsonRequestTest::test_replace_data</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_replace_data</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_replace_data>

    def test_replace_data(self):
        data1 = {
            "name1": "value1",
        }
        data2 = {
            "name2": "value2",
        }
        r1 = self.request_class(url="http://www.example.com/", data=data1)
>       r2 = r1.replace(data=data2)

/testbed/tests/test_http_request.py:1606: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <POST http://www.example.com/>, args = ()
kwargs = {'body': b'', 'callback': None, 'cb_kwargs': {}, 'cookies': {}, ...}
x = 'dumps_kwargs'

    def replace(self, *args, **kwargs) -> "Request":
        """Create a new Request with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'JsonRequest' object has no attribute 'dumps_kwargs'. Did you mean: '_dumps_kwargs'?

/testbed/scrapy/http/request/__init__.py:168: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_replace_dumps_kwargs">test_http_request.py::JsonRequestTest::test_replace_dumps_kwargs</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_replace_dumps_kwargs</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_replace_dumps_kwargs>

    def test_replace_dumps_kwargs(self):
        """Test that dumps_kwargs are provided to json.dumps when replace is called"""
        data1 = {
            "name1": "value1",
        }
        data2 = {
            "name2": "value2",
        }
        dumps_kwargs = {
            "ensure_ascii": True,
            "allow_nan": True,
        }
        r1 = self.request_class(
            url="http://www.example.com/", data=data1, dumps_kwargs=dumps_kwargs
        )
        with mock.patch("json.dumps", return_value=b"") as mock_dumps:
>           r1.replace(data=data2)

/testbed/tests/test_http_request.py:1639: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <POST http://www.example.com/>, args = ()
kwargs = {'body': b'', 'callback': None, 'cb_kwargs': {}, 'cookies': {}, ...}
x = 'dumps_kwargs'

    def replace(self, *args, **kwargs) -> "Request":
        """Create a new Request with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'JsonRequest' object has no attribute 'dumps_kwargs'. Did you mean: '_dumps_kwargs'?

/testbed/scrapy/http/request/__init__.py:168: AttributeError
</pre>
</details>
<h3 id="test_http_requestpyjsonrequesttesttest_replace_sort_keys">test_http_request.py::JsonRequestTest::test_replace_sort_keys</h3>
<details><summary> <pre>test_http_request.py::JsonRequestTest::test_replace_sort_keys</pre></summary><pre>
self = <tests.test_http_request.JsonRequestTest testMethod=test_replace_sort_keys>

    def test_replace_sort_keys(self):
        """Test that replace provides sort_keys=True to json.dumps"""
        data1 = {
            "name1": "value1",
        }
        data2 = {
            "name2": "value2",
        }
        r1 = self.request_class(url="http://www.example.com/", data=data1)
        with mock.patch("json.dumps", return_value=b"") as mock_dumps:
>           r1.replace(data=data2)

/testbed/tests/test_http_request.py:1619: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <POST http://www.example.com/>, args = ()
kwargs = {'body': b'', 'callback': None, 'cb_kwargs': {}, 'cookies': {}, ...}
x = 'dumps_kwargs'

    def replace(self, *args, **kwargs) -> "Request":
        """Create a new Request with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'JsonRequest' object has no attribute 'dumps_kwargs'. Did you mean: '_dumps_kwargs'?

/testbed/scrapy/http/request/__init__.py:168: AttributeError
</pre>
</details>
<h3 id="test_http_responsepybaseresponsetesttest_immutable_attributes">test_http_response.py::BaseResponseTest::test_immutable_attributes</h3>
<details><summary> <pre>test_http_response.py::BaseResponseTest::test_immutable_attributes</pre></summary><pre>
self = <tests.test_http_response.BaseResponseTest testMethod=test_immutable_attributes>

    def test_immutable_attributes(self):
        r = self.response_class("http://example.com")
>       self.assertRaises(AttributeError, setattr, r, "url", "http://example2.com")

/testbed/tests/test_http_response.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def wrapper(self, value):
        private_name = f"_{name}"
        if not hasattr(self, private_name):
>           warnings.warn(f"Property {name} is deprecated.", category=warn_category, stacklevel=2)
E           TypeError: category must be a Warning subclass, not 'str'

/testbed/scrapy/http/common.py:10: TypeError
</pre>
</details>
<h3 id="test_http_responsepybaseresponsetesttest_init">test_http_response.py::BaseResponseTest::test_init</h3>
<details><summary> <pre>test_http_response.py::BaseResponseTest::test_init</pre></summary><pre>
self = <tests.test_http_response.BaseResponseTest testMethod=test_init>

    def test_init(self):
        # Response requires url in the constructor
        self.assertRaises(Exception, self.response_class)
        self.assertTrue(
            isinstance(self.response_class("http://example.com/"), self.response_class)
        )
        self.assertRaises(TypeError, self.response_class, b"http://example.com")
        self.assertRaises(
            TypeError, self.response_class, url="http://example.com", body={}
        )
        # body can be str or None
        self.assertTrue(
            isinstance(
                self.response_class("http://example.com/", body=b""),
                self.response_class,
            )
        )
        self.assertTrue(
            isinstance(
                self.response_class("http://example.com/", body=b"body"),
                self.response_class,
            )
        )
        # test presence of all optional parameters
        self.assertTrue(
            isinstance(
                self.response_class(
                    "http://example.com/", body=b"", headers={}, status=200
                ),
                self.response_class,
            )
        )

        r = self.response_class("http://www.example.com")
        assert isinstance(r.url, str)
        self.assertEqual(r.url, "http://www.example.com")
        self.assertEqual(r.status, 200)

        assert isinstance(r.headers, Headers)
        self.assertEqual(r.headers, {})

        headers = {"foo": "bar"}
        body = b"a body"
        r = self.response_class("http://www.example.com", headers=headers, body=body)

        assert r.headers is not headers
>       self.assertEqual(r.headers[b"foo"], b"bar")

/testbed/tests/test_http_response.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/headers.py:23: in __getitem__
    return super().__getitem__(key)[-1]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {'foo': 'bar'}, key = b'foo'

    def __getitem__(self, key):
>       return dict.__getitem__(self, self.normkey(key))
E       KeyError: None

/testbed/scrapy/utils/datatypes.py:31: KeyError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_bom_is_removed_from_body">test_http_response.py::TextResponseTest::test_bom_is_removed_from_body</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_bom_is_removed_from_body</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_bom_is_removed_from_body>

    def test_bom_is_removed_from_body(self):
        # Inferring encoding from body also cache decoded body as sideeffect,
        # this test tries to ensure that calling response.encoding and
        # response.text in indistinct order doesn't affect final
        # response.text in indistinct order doesn't affect final
        # values for encoding and decoded body.
        url = "http://example.com"
        body = b"\xef\xbb\xbfWORD"
        headers = {"Content-type": ["text/html; charset=utf-8"]}

        # Test response without content-type and BOM encoding
        response = self.response_class(url, body=body)
>       self.assertEqual(response.encoding, "utf-8")
E       AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:543: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_cache_json_response">test_http_response.py::TextResponseTest::test_cache_json_response</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_cache_json_response</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_cache_json_response>

    def test_cache_json_response(self):
        json_valid_bodies = [b"""{"ip": "109.187.217.200"}""", b"""null"""]
        for json_body in json_valid_bodies:
            json_response = self.response_class(
                "http://www.example.com", body=json_body
            )

            with mock.patch("json.loads") as mock_json:
                for _ in range(2):
                    json_response.json()
>               mock_json.assert_called_once_with(json_body)

/testbed/tests/test_http_response.py:847: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='loads' id='140512373090512'>
args = (b'{"ip": "109.187.217.200"}',), kwargs = {}
msg = "Expected 'loads' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'loads' to be called once. Called 0 times.

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/unittest/mock.py:958: AssertionError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_copy">test_http_response.py::TextResponseTest::test_copy</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_copy</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_copy>

    def test_copy(self):
        """Test Response copy"""

        r1 = self.response_class("http://www.example.com", body=b"Some body")
        r1.flags.append("cached")
>       r2 = r1.copy()

/testbed/tests/test_http_response.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/__init__.py:118: in copy
    return self.replace()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'Some body', 'certificate': None, 'flags': ['cached'], 'headers': {}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_copy_inherited_classes">test_http_response.py::TextResponseTest::test_copy_inherited_classes</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_copy_inherited_classes</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_copy_inherited_classes>

    def test_copy_inherited_classes(self):
        """Test Response children copies preserve their class"""

        class CustomResponse(self.response_class):
            pass

        r1 = CustomResponse("http://www.example.com")
>       r2 = r1.copy()

/testbed/tests/test_http_response.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/__init__.py:118: in copy
    return self.replace()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'', 'certificate': None, 'flags': [], 'headers': {}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'CustomResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_declared_encoding_invalid">test_http_response.py::TextResponseTest::test_declared_encoding_invalid</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_declared_encoding_invalid</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_declared_encoding_invalid>

    def test_declared_encoding_invalid(self):
        """Check that unknown declared encodings are ignored"""
        r = self.response_class(
            "http://www.example.com",
            headers={"Content-type": ["text/html; charset=UNKNOWN"]},
            body=b"\xc2\xa3",
        )
>       self.assertEqual(r._declared_encoding(), None)
E       AttributeError: 'TextResponse' object has no attribute '_declared_encoding'

/testbed/tests/test_http_response.py:504: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_encoding">test_http_response.py::TextResponseTest::test_encoding</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_encoding</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_encoding>

    def test_encoding(self):
        r1 = self.response_class(
            "http://www.example.com",
            body=b"\xc2\xa3",
            headers={"Content-type": ["text/html; charset=utf-8"]},
        )
>       r2 = self.response_class(
            "http://www.example.com", encoding="utf-8", body="\xa3"
        )

/testbed/tests/test_http_response.py:426: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'TextResponse' object has no attribute '_url'") raised in repr()] TextResponse object at 0x7fcb96c6cbf0>
body = '£'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_none_url">test_http_response.py::TextResponseTest::test_follow_None_url</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_None_url</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_None_url>

    def test_follow_None_url(self):
        r = self.response_class("http://example.com")
>       self.assertRaises(ValueError, r.follow, None)
E       AssertionError: ValueError not raised by follow

/testbed/tests/test_http_response.py:219: AssertionError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_all_css">test_http_response.py::TextResponseTest::test_follow_all_css</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_all_css</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_all_css>

    def test_follow_all_css(self):
        expected = [
            "http://example.com/sample3.html",
            "http://example.com/innertag.html",
        ]
        response = self._links_response()
>       extracted = [r.url for r in response.follow_all(css='a[href*="example.com"]')]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:778: TypeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_all_css_skip_invalid">test_http_response.py::TextResponseTest::test_follow_all_css_skip_invalid</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_all_css_skip_invalid</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_all_css_skip_invalid>

    def test_follow_all_css_skip_invalid(self):
        expected = [
            "http://example.com/page/1/",
            "http://example.com/page/3/",
            "http://example.com/page/4/",
        ]
        response = self._links_response_no_href()
>       extracted1 = [r.url for r in response.follow_all(css=".pagination a")]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:788: TypeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_all_empty">test_http_response.py::TextResponseTest::test_follow_all_empty</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_all_empty</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_all_empty>

    def test_follow_all_empty(self):
        r = self.response_class("http://example.com")
>       self.assertEqual([], list(r.follow_all([])))
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:277: TypeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_all_flags">test_http_response.py::TextResponseTest::test_follow_all_flags</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_all_flags</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_all_flags>

    def test_follow_all_flags(self):
        re = self.response_class("http://www.example.com/")
        urls = [
            "http://www.example.com/",
            "http://www.example.com/2",
            "http://www.example.com/foo",
        ]
        fol = re.follow_all(urls, flags=["cached", "allowed"])
>       for req in fol:
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:769: TypeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_all_invalid">test_http_response.py::TextResponseTest::test_follow_all_invalid</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_all_invalid</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_all_invalid>

    def test_follow_all_invalid(self):
        r = self.response_class("http://example.com")
        if self.response_class == Response:
            with self.assertRaises(TypeError):
                list(r.follow_all(urls=None))
            with self.assertRaises(TypeError):
                list(r.follow_all(urls=12345))
            with self.assertRaises(ValueError):
                list(r.follow_all(urls=[None]))
        else:
            with self.assertRaises(ValueError):
>               list(r.follow_all(urls=None))
E               TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:290: TypeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_all_too_many_arguments">test_http_response.py::TextResponseTest::test_follow_all_too_many_arguments</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_all_too_many_arguments</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_all_too_many_arguments>

    def test_follow_all_too_many_arguments(self):
        response = self._links_response()
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

/testbed/tests/test_http_response.py:821: AssertionError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_all_xpath">test_http_response.py::TextResponseTest::test_follow_all_xpath</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_all_xpath</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_all_xpath>

    def test_follow_all_xpath(self):
        expected = [
            "http://example.com/sample3.html",
            "http://example.com/innertag.html",
        ]
        response = self._links_response()
        extracted = response.follow_all(xpath='//a[contains(@href, "example.com")]')
>       self.assertEqual(expected, [r.url for r in extracted])
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:800: TypeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_all_xpath_skip_invalid">test_http_response.py::TextResponseTest::test_follow_all_xpath_skip_invalid</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_all_xpath_skip_invalid</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_all_xpath_skip_invalid>

    def test_follow_all_xpath_skip_invalid(self):
        expected = [
            "http://example.com/page/1/",
            "http://example.com/page/3/",
            "http://example.com/page/4/",
        ]
        response = self._links_response_no_href()
        extracted1 = [
>           r.url for r in response.follow_all(xpath='//div[@id="pagination"]/a')
        ]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:810: TypeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_encoding">test_http_response.py::TextResponseTest::test_follow_encoding</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_encoding</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_encoding>

    def test_follow_encoding(self):
        resp1 = self.response_class(
            "http://example.com",
            encoding="utf8",
            body='<html><body><a href="foo?привет">click me</a></body></html>'.encode(
                "utf8"
            ),
        )
        req = self._assert_followed_url(
>           resp1.css("a")[0],
            "http://example.com/foo?%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82",
            response=resp1,
        )

/testbed/tests/test_http_response.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_flags">test_http_response.py::TextResponseTest::test_follow_flags</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_flags</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_flags>

    def test_follow_flags(self):
        res = self.response_class("http://example.com/")
        fol = res.follow("http://example.com/", flags=["cached", "allowed"])
>       self.assertEqual(fol.flags, ["cached", "allowed"])
E       AttributeError: 'NoneType' object has no attribute 'flags'

/testbed/tests/test_http_response.py:759: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_link">test_http_response.py::TextResponseTest::test_follow_link</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_link</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_link>

    def test_follow_link(self):
>       self._assert_followed_url(
            Link("http://example.com/foo"), "http://example.com/foo"
        )

/testbed/tests/test_http_response.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.TextResponseTest testMethod=test_follow_link>
follow_obj = Link(url='http://example.com/foo', text='', fragment='', nofollow=False)
target_url = 'http://example.com/foo', response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_selector">test_http_response.py::TextResponseTest::test_follow_selector</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_selector</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_selector>

    def test_follow_selector(self):
        resp = self._links_response()
        urls = [
            "http://example.com/sample2.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html#foo",
            "http://www.google.com/something",
            "http://example.com/innertag.html",
        ]

        # select <a> elements
>       for sellist in [resp.css("a"), resp.xpath("//a")]:

/testbed/tests/test_http_response.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_selector_attribute">test_http_response.py::TextResponseTest::test_follow_selector_attribute</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_selector_attribute</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_selector_attribute>

    def test_follow_selector_attribute(self):
        resp = self._links_response()
>       for src in resp.css("img::attr(src)"):

/testbed/tests/test_http_response.py:703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('img::attr(src)',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_selector_invalid">test_http_response.py::TextResponseTest::test_follow_selector_invalid</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_selector_invalid</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_selector_invalid>

    def test_follow_selector_invalid(self):
        resp = self._links_response()
        self.assertRaisesRegex(
            ValueError,
            "Unsupported",
            resp.follow,
>           resp.xpath("count(//div)")[0],
        )

/testbed/tests/test_http_response.py:698: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('count(//div)',), kw = {}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_selector_list">test_http_response.py::TextResponseTest::test_follow_selector_list</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_selector_list</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_selector_list>

    def test_follow_selector_list(self):
        resp = self._links_response()
>       self.assertRaisesRegex(ValueError, "SelectorList", resp.follow, resp.css("a"))

/testbed/tests/test_http_response.py:690: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_selector_no_href">test_http_response.py::TextResponseTest::test_follow_selector_no_href</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_selector_no_href</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_selector_no_href>

    def test_follow_selector_no_href(self):
        resp = self.response_class(
            url="http://example.com",
            body=b"<html><body><a name=123>click me</a></body></html>",
        )
>       self.assertRaisesRegex(ValueError, "no href", resp.follow, resp.css("a")[0])

/testbed/tests/test_http_response.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_url_absolute">test_http_response.py::TextResponseTest::test_follow_url_absolute</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_url_absolute</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_url_absolute>

    def test_follow_url_absolute(self):
>       self._assert_followed_url("http://foo.example.com", "http://foo.example.com")

/testbed/tests/test_http_response.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.TextResponseTest testMethod=test_follow_url_absolute>
follow_obj = 'http://foo.example.com', target_url = 'http://foo.example.com'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_url_relative">test_http_response.py::TextResponseTest::test_follow_url_relative</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_url_relative</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_url_relative>

    def test_follow_url_relative(self):
>       self._assert_followed_url("foo", "http://example.com/foo")

/testbed/tests/test_http_response.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.TextResponseTest testMethod=test_follow_url_relative>
follow_obj = 'foo', target_url = 'http://example.com/foo'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_whitespace_link">test_http_response.py::TextResponseTest::test_follow_whitespace_link</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_whitespace_link</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_whitespace_link>

    @mark.xfail(
        parse_version(w3lib_version) < parse_version("2.1.1"),
        reason="https://github.com/scrapy/w3lib/pull/207",
        strict=True,
    )
    def test_follow_whitespace_link(self):
>       self._assert_followed_url(
            Link("http://example.com/foo "), "http://example.com/foo"
        )

/testbed/tests/test_http_response.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.TextResponseTest testMethod=test_follow_whitespace_link>
follow_obj = Link(url='http://example.com/foo ', text='', fragment='', nofollow=False)
target_url = 'http://example.com/foo', response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_whitespace_selector">test_http_response.py::TextResponseTest::test_follow_whitespace_selector</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_whitespace_selector</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_whitespace_selector>

    def test_follow_whitespace_selector(self):
        resp = self.response_class(
            "http://example.com",
            body=b"""<html><body><a href=" foo\n">click me</a></body></html>""",
        )
        self._assert_followed_url(
>           resp.css("a")[0], "http://example.com/foo", response=resp
        )

/testbed/tests/test_http_response.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_follow_whitespace_url">test_http_response.py::TextResponseTest::test_follow_whitespace_url</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_follow_whitespace_url</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_follow_whitespace_url>

    @mark.xfail(
        parse_version(w3lib_version) < parse_version("2.1.1"),
        reason="https://github.com/scrapy/w3lib/pull/207",
        strict=True,
    )
    def test_follow_whitespace_url(self):
>       self._assert_followed_url("foo ", "http://example.com/foo")

/testbed/tests/test_http_response.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.TextResponseTest testMethod=test_follow_whitespace_url>
follow_obj = 'foo ', target_url = 'http://example.com/foo'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_immutable_attributes">test_http_response.py::TextResponseTest::test_immutable_attributes</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_immutable_attributes</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_immutable_attributes>

    def test_immutable_attributes(self):
        r = self.response_class("http://example.com")
>       self.assertRaises(AttributeError, setattr, r, "url", "http://example2.com")

/testbed/tests/test_http_response.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def wrapper(self, value):
        private_name = f"_{name}"
        if not hasattr(self, private_name):
>           warnings.warn(f"Property {name} is deprecated.", category=warn_category, stacklevel=2)
E           TypeError: category must be a Warning subclass, not 'str'

/testbed/scrapy/http/common.py:10: TypeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_init">test_http_response.py::TextResponseTest::test_init</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_init</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_init>

    def test_init(self):
        # Response requires url in the constructor
        self.assertRaises(Exception, self.response_class)
        self.assertTrue(
            isinstance(self.response_class("http://example.com/"), self.response_class)
        )
        self.assertRaises(TypeError, self.response_class, b"http://example.com")
        self.assertRaises(
            TypeError, self.response_class, url="http://example.com", body={}
        )
        # body can be str or None
        self.assertTrue(
            isinstance(
                self.response_class("http://example.com/", body=b""),
                self.response_class,
            )
        )
        self.assertTrue(
            isinstance(
                self.response_class("http://example.com/", body=b"body"),
                self.response_class,
            )
        )
        # test presence of all optional parameters
        self.assertTrue(
            isinstance(
                self.response_class(
                    "http://example.com/", body=b"", headers={}, status=200
                ),
                self.response_class,
            )
        )

        r = self.response_class("http://www.example.com")
        assert isinstance(r.url, str)
        self.assertEqual(r.url, "http://www.example.com")
        self.assertEqual(r.status, 200)

        assert isinstance(r.headers, Headers)
        self.assertEqual(r.headers, {})

        headers = {"foo": "bar"}
        body = b"a body"
        r = self.response_class("http://www.example.com", headers=headers, body=body)

        assert r.headers is not headers
>       self.assertEqual(r.headers[b"foo"], b"bar")

/testbed/tests/test_http_response.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/headers.py:23: in __getitem__
    return super().__getitem__(key)[-1]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {'foo': 'bar'}, key = b'foo'

    def __getitem__(self, key):
>       return dict.__getitem__(self, self.normkey(key))
E       KeyError: None

/testbed/scrapy/utils/datatypes.py:31: KeyError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_invalid_utf8_encoded_body_with_valid_utf8_bom">test_http_response.py::TextResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_invalid_utf8_encoded_body_with_valid_utf8_BOM>

    def test_invalid_utf8_encoded_body_with_valid_utf8_BOM(self):
        r6 = self.response_class(
            "http://www.example.com",
            headers={"Content-type": ["text/html; charset=utf-8"]},
            body=b"\xef\xbb\xbfWORD\xe3\xab",
        )
>       self.assertEqual(r6.encoding, "utf-8")
E       AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:522: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_json_response">test_http_response.py::TextResponseTest::test_json_response</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_json_response</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_json_response>

    def test_json_response(self):
        json_body = b"""{"ip": "109.187.217.200"}"""
        json_response = self.response_class("http://www.example.com", body=json_body)
>       self.assertEqual(json_response.json(), {"ip": "109.187.217.200"})
E       AssertionError: None != {'ip': '109.187.217.200'}

/testbed/tests/test_http_response.py:830: AssertionError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_replace">test_http_response.py::TextResponseTest::test_replace</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_replace</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_replace>

    def test_replace(self):
>       super().test_replace()

/testbed/tests/test_http_response.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_response.py:150: in test_replace
    r2 = r1.replace(status=301, body=b"New body", headers=hdrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'New body', 'certificate': None, 'flags': [], 'headers': {'key': 'value'}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_replace_wrong_encoding">test_http_response.py::TextResponseTest::test_replace_wrong_encoding</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_replace_wrong_encoding</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_replace_wrong_encoding>

    def test_replace_wrong_encoding(self):
        """Test invalid chars are replaced properly"""
        r = self.response_class(
            "http://www.example.com",
            encoding="utf-8",
            body=b"PREFIX\xe3\xabSUFFIX",
        )
        # XXX: Policy for replacing invalid chars may suffer minor variations
        # but it should always contain the unicode replacement char ('\ufffd')
>       assert "\ufffd" in r.text, repr(r.text)
E       TypeError: argument of type 'NoneType' is not iterable

/testbed/tests/test_http_response.py:568: TypeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_selector">test_http_response.py::TextResponseTest::test_selector</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_selector</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_selector>

    def test_selector(self):
        body = b"<html><head><title>Some page</title><body></body></html>"
        response = self.response_class("http://www.example.com", body=body)

>       self.assertIsInstance(response.selector, Selector)
E       AttributeError: 'TextResponse' object has no attribute 'selector'

/testbed/tests/test_http_response.py:588: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_selector_shortcuts">test_http_response.py::TextResponseTest::test_selector_shortcuts</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_selector_shortcuts</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_selector_shortcuts>

    def test_selector_shortcuts(self):
        body = b"<html><head><title>Some page</title><body></body></html>"
        response = self.response_class("http://www.example.com", body=body)

        self.assertEqual(
>           response.xpath("//title/text()").getall(),
            response.selector.xpath("//title/text()").getall(),
        )

/testbed/tests/test_http_response.py:604: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, a = ('//title/text()',), kw = {}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_selector_shortcuts_kwargs">test_http_response.py::TextResponseTest::test_selector_shortcuts_kwargs</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_selector_shortcuts_kwargs</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_selector_shortcuts_kwargs>

    def test_selector_shortcuts_kwargs(self):
        body = b'<html><head><title>Some page</title><body><p class="content">A nice paragraph.</p></body></html>'
        response = self.response_class("http://www.example.com", body=body)

        self.assertEqual(
>           response.xpath(
                "normalize-space(//p[@class=$pclass])", pclass="content"
            ).getall(),
            response.xpath('normalize-space(//p[@class="content"])').getall(),
        )

/testbed/tests/test_http_response.py:617: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>
a = ('normalize-space(//p[@class=$pclass])',), kw = {'pclass': 'content'}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_shortcut_attributes">test_http_response.py::TextResponseTest::test_shortcut_attributes</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_shortcut_attributes</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_shortcut_attributes>

    def test_shortcut_attributes(self):
        r = self.response_class("http://example.com", body=b"hello")
        if self.response_class == Response:
            msg = "Response content isn't text"
            self.assertRaisesRegex(AttributeError, msg, getattr, r, "text")
            self.assertRaisesRegex(NotSupported, msg, r.css, "body")
            self.assertRaisesRegex(NotSupported, msg, r.xpath, "//body")
            self.assertRaisesRegex(NotSupported, msg, r.jmespath, "body")
        else:
            r.text
>           r.css("body")

/testbed/tests/test_http_response.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('body',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_unicode_body">test_http_response.py::TextResponseTest::test_unicode_body</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_unicode_body</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_unicode_body>

    def test_unicode_body(self):
        unicode_string = (
            "\u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0439 "
            "\u0442\u0435\u043a\u0441\u0442"
        )
        self.assertRaises(
            TypeError,
            self.response_class,
            "http://www.example.com",
            body="unicode body",
        )

        original_string = unicode_string.encode("cp1251")
        r1 = self.response_class(
            "http://www.example.com", body=original_string, encoding="cp1251"
        )

        # check response.text
>       self.assertTrue(isinstance(r1.text, str))
E       AssertionError: False is not true

/testbed/tests/test_http_response.py:417: AssertionError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_unicode_url">test_http_response.py::TextResponseTest::test_unicode_url</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_unicode_url</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_unicode_url>

    def test_unicode_url(self):
        # instantiate with unicode url without encoding (should set default encoding)
        resp = self.response_class("http://www.example.com/")
>       self._assert_response_encoding(resp, self.response_class._DEFAULT_ENCODING)

/testbed/tests/test_http_response.py:374: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.TextResponseTest testMethod=test_unicode_url>
response = <200 http://www.example.com/>, encoding = 'ascii'

    def _assert_response_encoding(self, response, encoding):
>       self.assertEqual(response.encoding, resolve_encoding(encoding))
E       AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:178: AttributeError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_urljoin">test_http_response.py::TextResponseTest::test_urljoin</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_urljoin</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_urljoin>

    def test_urljoin(self):
        """Test urljoin shortcut (only for existence, since behavior equals urljoin)"""
        joined = self.response_class("http://www.example.com").urljoin("/test")
        absolute = "http://www.example.com/test"
>       self.assertEqual(joined, absolute)
E       AssertionError: None != 'http://www.example.com/test'

/testbed/tests/test_http_response.py:189: AssertionError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_urljoin_with_base_url">test_http_response.py::TextResponseTest::test_urljoin_with_base_url</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_urljoin_with_base_url</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_urljoin_with_base_url>

    def test_urljoin_with_base_url(self):
        """Test urljoin shortcut which also evaluates base-url through get_base_url()."""
        body = b'<html><body><base href="https://example.net"></body></html>'
        joined = self.response_class("http://www.example.com", body=body).urljoin(
            "/test"
        )
        absolute = "https://example.net/test"
>       self.assertEqual(joined, absolute)
E       AssertionError: None != 'https://example.net/test'

/testbed/tests/test_http_response.py:640: AssertionError
</pre>
</details>
<h3 id="test_http_responsepytextresponsetesttest_utf16">test_http_response.py::TextResponseTest::test_utf16</h3>
<details><summary> <pre>test_http_response.py::TextResponseTest::test_utf16</pre></summary><pre>
self = <tests.test_http_response.TextResponseTest testMethod=test_utf16>

    def test_utf16(self):
        """Test utf-16 because UnicodeDammit is known to have problems with"""
        r = self.response_class(
            "http://www.example.com",
            body=b"\xff\xfeh\x00i\x00",
            encoding="utf-16",
        )
>       self._assert_response_values(r, "utf-16", "hi")

/testbed/tests/test_http_response.py:514: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.TextResponseTest testMethod=test_utf16>
response = <200 http://www.example.com>, encoding = 'utf-16', body = 'hi'

    def _assert_response_values(self, response, encoding, body):
        if isinstance(body, str):
            body_unicode = body
            body_bytes = body.encode(encoding)
        else:
            body_unicode = body.decode(encoding)
            body_bytes = body

        assert isinstance(response.body, bytes)
>       assert isinstance(response.text, str)
E       AssertionError

/testbed/tests/test_http_response.py:172: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_bom_is_removed_from_body">test_http_response.py::HtmlResponseTest::test_bom_is_removed_from_body</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_bom_is_removed_from_body</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_bom_is_removed_from_body>

    def test_bom_is_removed_from_body(self):
        # Inferring encoding from body also cache decoded body as sideeffect,
        # this test tries to ensure that calling response.encoding and
        # response.text in indistinct order doesn't affect final
        # response.text in indistinct order doesn't affect final
        # values for encoding and decoded body.
        url = "http://example.com"
        body = b"\xef\xbb\xbfWORD"
        headers = {"Content-type": ["text/html; charset=utf-8"]}

        # Test response without content-type and BOM encoding
        response = self.response_class(url, body=body)
>       self.assertEqual(response.encoding, "utf-8")
E       AttributeError: 'HtmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:543: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_cache_json_response">test_http_response.py::HtmlResponseTest::test_cache_json_response</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_cache_json_response</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_cache_json_response>

    def test_cache_json_response(self):
        json_valid_bodies = [b"""{"ip": "109.187.217.200"}""", b"""null"""]
        for json_body in json_valid_bodies:
            json_response = self.response_class(
                "http://www.example.com", body=json_body
            )

            with mock.patch("json.loads") as mock_json:
                for _ in range(2):
                    json_response.json()
>               mock_json.assert_called_once_with(json_body)

/testbed/tests/test_http_response.py:847: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='loads' id='140512372823952'>
args = (b'{"ip": "109.187.217.200"}',), kwargs = {}
msg = "Expected 'loads' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'loads' to be called once. Called 0 times.

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/unittest/mock.py:958: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_copy">test_http_response.py::HtmlResponseTest::test_copy</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_copy</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_copy>

    def test_copy(self):
        """Test Response copy"""

        r1 = self.response_class("http://www.example.com", body=b"Some body")
        r1.flags.append("cached")
>       r2 = r1.copy()

/testbed/tests/test_http_response.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/__init__.py:118: in copy
    return self.replace()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'Some body', 'certificate': None, 'flags': ['cached'], 'headers': {}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'HtmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_copy_inherited_classes">test_http_response.py::HtmlResponseTest::test_copy_inherited_classes</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_copy_inherited_classes</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_copy_inherited_classes>

    def test_copy_inherited_classes(self):
        """Test Response children copies preserve their class"""

        class CustomResponse(self.response_class):
            pass

        r1 = CustomResponse("http://www.example.com")
>       r2 = r1.copy()

/testbed/tests/test_http_response.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/__init__.py:118: in copy
    return self.replace()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'', 'certificate': None, 'flags': [], 'headers': {}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'CustomResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_declared_encoding_invalid">test_http_response.py::HtmlResponseTest::test_declared_encoding_invalid</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_declared_encoding_invalid</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_declared_encoding_invalid>

    def test_declared_encoding_invalid(self):
        """Check that unknown declared encodings are ignored"""
        r = self.response_class(
            "http://www.example.com",
            headers={"Content-type": ["text/html; charset=UNKNOWN"]},
            body=b"\xc2\xa3",
        )
>       self.assertEqual(r._declared_encoding(), None)
E       AttributeError: 'HtmlResponse' object has no attribute '_declared_encoding'

/testbed/tests/test_http_response.py:504: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_encoding">test_http_response.py::HtmlResponseTest::test_encoding</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_encoding</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_encoding>

    def test_encoding(self):
        r1 = self.response_class(
            "http://www.example.com",
            body=b"\xc2\xa3",
            headers={"Content-type": ["text/html; charset=utf-8"]},
        )
>       r2 = self.response_class(
            "http://www.example.com", encoding="utf-8", body="\xa3"
        )

/testbed/tests/test_http_response.py:426: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'HtmlResponse' object has no attribute '_url'") raised in repr()] HtmlResponse object at 0x7fcb961a6960>
body = '£'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_none_url">test_http_response.py::HtmlResponseTest::test_follow_None_url</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_None_url</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_None_url>

    def test_follow_None_url(self):
        r = self.response_class("http://example.com")
>       self.assertRaises(ValueError, r.follow, None)
E       AssertionError: ValueError not raised by follow

/testbed/tests/test_http_response.py:219: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_all_css">test_http_response.py::HtmlResponseTest::test_follow_all_css</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_all_css</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_all_css>

    def test_follow_all_css(self):
        expected = [
            "http://example.com/sample3.html",
            "http://example.com/innertag.html",
        ]
        response = self._links_response()
>       extracted = [r.url for r in response.follow_all(css='a[href*="example.com"]')]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:778: TypeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_all_css_skip_invalid">test_http_response.py::HtmlResponseTest::test_follow_all_css_skip_invalid</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_all_css_skip_invalid</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_all_css_skip_invalid>

    def test_follow_all_css_skip_invalid(self):
        expected = [
            "http://example.com/page/1/",
            "http://example.com/page/3/",
            "http://example.com/page/4/",
        ]
        response = self._links_response_no_href()
>       extracted1 = [r.url for r in response.follow_all(css=".pagination a")]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:788: TypeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_all_empty">test_http_response.py::HtmlResponseTest::test_follow_all_empty</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_all_empty</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_all_empty>

    def test_follow_all_empty(self):
        r = self.response_class("http://example.com")
>       self.assertEqual([], list(r.follow_all([])))
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:277: TypeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_all_flags">test_http_response.py::HtmlResponseTest::test_follow_all_flags</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_all_flags</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_all_flags>

    def test_follow_all_flags(self):
        re = self.response_class("http://www.example.com/")
        urls = [
            "http://www.example.com/",
            "http://www.example.com/2",
            "http://www.example.com/foo",
        ]
        fol = re.follow_all(urls, flags=["cached", "allowed"])
>       for req in fol:
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:769: TypeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_all_invalid">test_http_response.py::HtmlResponseTest::test_follow_all_invalid</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_all_invalid</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_all_invalid>

    def test_follow_all_invalid(self):
        r = self.response_class("http://example.com")
        if self.response_class == Response:
            with self.assertRaises(TypeError):
                list(r.follow_all(urls=None))
            with self.assertRaises(TypeError):
                list(r.follow_all(urls=12345))
            with self.assertRaises(ValueError):
                list(r.follow_all(urls=[None]))
        else:
            with self.assertRaises(ValueError):
>               list(r.follow_all(urls=None))
E               TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:290: TypeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_all_too_many_arguments">test_http_response.py::HtmlResponseTest::test_follow_all_too_many_arguments</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_all_too_many_arguments</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_all_too_many_arguments>

    def test_follow_all_too_many_arguments(self):
        response = self._links_response()
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

/testbed/tests/test_http_response.py:821: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_all_xpath">test_http_response.py::HtmlResponseTest::test_follow_all_xpath</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_all_xpath</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_all_xpath>

    def test_follow_all_xpath(self):
        expected = [
            "http://example.com/sample3.html",
            "http://example.com/innertag.html",
        ]
        response = self._links_response()
        extracted = response.follow_all(xpath='//a[contains(@href, "example.com")]')
>       self.assertEqual(expected, [r.url for r in extracted])
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:800: TypeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_all_xpath_skip_invalid">test_http_response.py::HtmlResponseTest::test_follow_all_xpath_skip_invalid</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_all_xpath_skip_invalid</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_all_xpath_skip_invalid>

    def test_follow_all_xpath_skip_invalid(self):
        expected = [
            "http://example.com/page/1/",
            "http://example.com/page/3/",
            "http://example.com/page/4/",
        ]
        response = self._links_response_no_href()
        extracted1 = [
>           r.url for r in response.follow_all(xpath='//div[@id="pagination"]/a')
        ]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:810: TypeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_encoding">test_http_response.py::HtmlResponseTest::test_follow_encoding</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_encoding</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_encoding>

    def test_follow_encoding(self):
        resp1 = self.response_class(
            "http://example.com",
            encoding="utf8",
            body='<html><body><a href="foo?привет">click me</a></body></html>'.encode(
                "utf8"
            ),
        )
        req = self._assert_followed_url(
>           resp1.css("a")[0],
            "http://example.com/foo?%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82",
            response=resp1,
        )

/testbed/tests/test_http_response.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_flags">test_http_response.py::HtmlResponseTest::test_follow_flags</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_flags</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_flags>

    def test_follow_flags(self):
        res = self.response_class("http://example.com/")
        fol = res.follow("http://example.com/", flags=["cached", "allowed"])
>       self.assertEqual(fol.flags, ["cached", "allowed"])
E       AttributeError: 'NoneType' object has no attribute 'flags'

/testbed/tests/test_http_response.py:759: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_link">test_http_response.py::HtmlResponseTest::test_follow_link</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_link</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_link>

    def test_follow_link(self):
>       self._assert_followed_url(
            Link("http://example.com/foo"), "http://example.com/foo"
        )

/testbed/tests/test_http_response.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_link>
follow_obj = Link(url='http://example.com/foo', text='', fragment='', nofollow=False)
target_url = 'http://example.com/foo', response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_selector">test_http_response.py::HtmlResponseTest::test_follow_selector</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_selector</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_selector>

    def test_follow_selector(self):
        resp = self._links_response()
        urls = [
            "http://example.com/sample2.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html#foo",
            "http://www.google.com/something",
            "http://example.com/innertag.html",
        ]

        # select <a> elements
>       for sellist in [resp.css("a"), resp.xpath("//a")]:

/testbed/tests/test_http_response.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_selector_attribute">test_http_response.py::HtmlResponseTest::test_follow_selector_attribute</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_selector_attribute</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_selector_attribute>

    def test_follow_selector_attribute(self):
        resp = self._links_response()
>       for src in resp.css("img::attr(src)"):

/testbed/tests/test_http_response.py:703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('img::attr(src)',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_selector_invalid">test_http_response.py::HtmlResponseTest::test_follow_selector_invalid</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_selector_invalid</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_selector_invalid>

    def test_follow_selector_invalid(self):
        resp = self._links_response()
        self.assertRaisesRegex(
            ValueError,
            "Unsupported",
            resp.follow,
>           resp.xpath("count(//div)")[0],
        )

/testbed/tests/test_http_response.py:698: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('count(//div)',), kw = {}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_selector_list">test_http_response.py::HtmlResponseTest::test_follow_selector_list</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_selector_list</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_selector_list>

    def test_follow_selector_list(self):
        resp = self._links_response()
>       self.assertRaisesRegex(ValueError, "SelectorList", resp.follow, resp.css("a"))

/testbed/tests/test_http_response.py:690: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_selector_no_href">test_http_response.py::HtmlResponseTest::test_follow_selector_no_href</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_selector_no_href</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_selector_no_href>

    def test_follow_selector_no_href(self):
        resp = self.response_class(
            url="http://example.com",
            body=b"<html><body><a name=123>click me</a></body></html>",
        )
>       self.assertRaisesRegex(ValueError, "no href", resp.follow, resp.css("a")[0])

/testbed/tests/test_http_response.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_url_absolute">test_http_response.py::HtmlResponseTest::test_follow_url_absolute</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_url_absolute</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_url_absolute>

    def test_follow_url_absolute(self):
>       self._assert_followed_url("http://foo.example.com", "http://foo.example.com")

/testbed/tests/test_http_response.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_url_absolute>
follow_obj = 'http://foo.example.com', target_url = 'http://foo.example.com'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_url_relative">test_http_response.py::HtmlResponseTest::test_follow_url_relative</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_url_relative</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_url_relative>

    def test_follow_url_relative(self):
>       self._assert_followed_url("foo", "http://example.com/foo")

/testbed/tests/test_http_response.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_url_relative>
follow_obj = 'foo', target_url = 'http://example.com/foo'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_whitespace_link">test_http_response.py::HtmlResponseTest::test_follow_whitespace_link</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_whitespace_link</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_whitespace_link>

    @mark.xfail(
        parse_version(w3lib_version) < parse_version("2.1.1"),
        reason="https://github.com/scrapy/w3lib/pull/207",
        strict=True,
    )
    def test_follow_whitespace_link(self):
>       self._assert_followed_url(
            Link("http://example.com/foo "), "http://example.com/foo"
        )

/testbed/tests/test_http_response.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_whitespace_link>
follow_obj = Link(url='http://example.com/foo ', text='', fragment='', nofollow=False)
target_url = 'http://example.com/foo', response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_whitespace_selector">test_http_response.py::HtmlResponseTest::test_follow_whitespace_selector</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_whitespace_selector</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_whitespace_selector>

    def test_follow_whitespace_selector(self):
        resp = self.response_class(
            "http://example.com",
            body=b"""<html><body><a href=" foo\n">click me</a></body></html>""",
        )
        self._assert_followed_url(
>           resp.css("a")[0], "http://example.com/foo", response=resp
        )

/testbed/tests/test_http_response.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_follow_whitespace_url">test_http_response.py::HtmlResponseTest::test_follow_whitespace_url</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_follow_whitespace_url</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_whitespace_url>

    @mark.xfail(
        parse_version(w3lib_version) < parse_version("2.1.1"),
        reason="https://github.com/scrapy/w3lib/pull/207",
        strict=True,
    )
    def test_follow_whitespace_url(self):
>       self._assert_followed_url("foo ", "http://example.com/foo")

/testbed/tests/test_http_response.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.HtmlResponseTest testMethod=test_follow_whitespace_url>
follow_obj = 'foo ', target_url = 'http://example.com/foo'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_html5_meta_charset">test_http_response.py::HtmlResponseTest::test_html5_meta_charset</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_html5_meta_charset</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_html5_meta_charset>

    def test_html5_meta_charset(self):
        body = b"""<html><head><meta charset="gb2312" /><title>Some page</title><body>bla bla</body>"""
        r1 = self.response_class("http://www.example.com", body=body)
>       self._assert_response_values(r1, "gb2312", body)

/testbed/tests/test_http_response.py:888: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.HtmlResponseTest testMethod=test_html5_meta_charset>
response = <200 http://www.example.com>, encoding = 'gb2312'
body = b'<html><head><meta charset="gb2312" /><title>Some page</title><body>bla bla</body>'

    def _assert_response_values(self, response, encoding, body):
        if isinstance(body, str):
            body_unicode = body
            body_bytes = body.encode(encoding)
        else:
            body_unicode = body.decode(encoding)
            body_bytes = body

        assert isinstance(response.body, bytes)
>       assert isinstance(response.text, str)
E       AssertionError

/testbed/tests/test_http_response.py:172: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_html_encoding">test_http_response.py::HtmlResponseTest::test_html_encoding</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_html_encoding</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_html_encoding>

    def test_html_encoding(self):
        body = b"""<html><head><title>Some page</title>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        </head><body>Price: \xa3100</body></html>'
        """
        r1 = self.response_class("http://www.example.com", body=body)
>       self._assert_response_values(r1, "iso-8859-1", body)

/testbed/tests/test_http_response.py:859: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.HtmlResponseTest testMethod=test_html_encoding>
response = <200 http://www.example.com>, encoding = 'iso-8859-1'
body = b'<html><head><title>Some page</title>\n        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">\n        </head><body>Price: \xa3100</body></html>\'\n        '

    def _assert_response_values(self, response, encoding, body):
        if isinstance(body, str):
            body_unicode = body
            body_bytes = body.encode(encoding)
        else:
            body_unicode = body.decode(encoding)
            body_bytes = body

        assert isinstance(response.body, bytes)
>       assert isinstance(response.text, str)
E       AssertionError

/testbed/tests/test_http_response.py:172: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_immutable_attributes">test_http_response.py::HtmlResponseTest::test_immutable_attributes</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_immutable_attributes</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_immutable_attributes>

    def test_immutable_attributes(self):
        r = self.response_class("http://example.com")
>       self.assertRaises(AttributeError, setattr, r, "url", "http://example2.com")

/testbed/tests/test_http_response.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def wrapper(self, value):
        private_name = f"_{name}"
        if not hasattr(self, private_name):
>           warnings.warn(f"Property {name} is deprecated.", category=warn_category, stacklevel=2)
E           TypeError: category must be a Warning subclass, not 'str'

/testbed/scrapy/http/common.py:10: TypeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_init">test_http_response.py::HtmlResponseTest::test_init</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_init</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_init>

    def test_init(self):
        # Response requires url in the constructor
        self.assertRaises(Exception, self.response_class)
        self.assertTrue(
            isinstance(self.response_class("http://example.com/"), self.response_class)
        )
        self.assertRaises(TypeError, self.response_class, b"http://example.com")
        self.assertRaises(
            TypeError, self.response_class, url="http://example.com", body={}
        )
        # body can be str or None
        self.assertTrue(
            isinstance(
                self.response_class("http://example.com/", body=b""),
                self.response_class,
            )
        )
        self.assertTrue(
            isinstance(
                self.response_class("http://example.com/", body=b"body"),
                self.response_class,
            )
        )
        # test presence of all optional parameters
        self.assertTrue(
            isinstance(
                self.response_class(
                    "http://example.com/", body=b"", headers={}, status=200
                ),
                self.response_class,
            )
        )

        r = self.response_class("http://www.example.com")
        assert isinstance(r.url, str)
        self.assertEqual(r.url, "http://www.example.com")
        self.assertEqual(r.status, 200)

        assert isinstance(r.headers, Headers)
        self.assertEqual(r.headers, {})

        headers = {"foo": "bar"}
        body = b"a body"
        r = self.response_class("http://www.example.com", headers=headers, body=body)

        assert r.headers is not headers
>       self.assertEqual(r.headers[b"foo"], b"bar")

/testbed/tests/test_http_response.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/headers.py:23: in __getitem__
    return super().__getitem__(key)[-1]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {'foo': 'bar'}, key = b'foo'

    def __getitem__(self, key):
>       return dict.__getitem__(self, self.normkey(key))
E       KeyError: None

/testbed/scrapy/utils/datatypes.py:31: KeyError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_invalid_utf8_encoded_body_with_valid_utf8_bom">test_http_response.py::HtmlResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_invalid_utf8_encoded_body_with_valid_utf8_BOM>

    def test_invalid_utf8_encoded_body_with_valid_utf8_BOM(self):
        r6 = self.response_class(
            "http://www.example.com",
            headers={"Content-type": ["text/html; charset=utf-8"]},
            body=b"\xef\xbb\xbfWORD\xe3\xab",
        )
>       self.assertEqual(r6.encoding, "utf-8")
E       AttributeError: 'HtmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:522: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_json_response">test_http_response.py::HtmlResponseTest::test_json_response</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_json_response</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_json_response>

    def test_json_response(self):
        json_body = b"""{"ip": "109.187.217.200"}"""
        json_response = self.response_class("http://www.example.com", body=json_body)
>       self.assertEqual(json_response.json(), {"ip": "109.187.217.200"})
E       AssertionError: None != {'ip': '109.187.217.200'}

/testbed/tests/test_http_response.py:830: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_replace">test_http_response.py::HtmlResponseTest::test_replace</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_replace</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_replace>

    def test_replace(self):
>       super().test_replace()

/testbed/tests/test_http_response.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_response.py:150: in test_replace
    r2 = r1.replace(status=301, body=b"New body", headers=hdrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'New body', 'certificate': None, 'flags': [], 'headers': {'key': 'value'}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'HtmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_replace_wrong_encoding">test_http_response.py::HtmlResponseTest::test_replace_wrong_encoding</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_replace_wrong_encoding</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_replace_wrong_encoding>

    def test_replace_wrong_encoding(self):
        """Test invalid chars are replaced properly"""
        r = self.response_class(
            "http://www.example.com",
            encoding="utf-8",
            body=b"PREFIX\xe3\xabSUFFIX",
        )
        # XXX: Policy for replacing invalid chars may suffer minor variations
        # but it should always contain the unicode replacement char ('\ufffd')
>       assert "\ufffd" in r.text, repr(r.text)
E       TypeError: argument of type 'NoneType' is not iterable

/testbed/tests/test_http_response.py:568: TypeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_selector">test_http_response.py::HtmlResponseTest::test_selector</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_selector</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_selector>

    def test_selector(self):
        body = b"<html><head><title>Some page</title><body></body></html>"
        response = self.response_class("http://www.example.com", body=body)

>       self.assertIsInstance(response.selector, Selector)
E       AttributeError: 'HtmlResponse' object has no attribute 'selector'

/testbed/tests/test_http_response.py:588: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_selector_shortcuts">test_http_response.py::HtmlResponseTest::test_selector_shortcuts</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_selector_shortcuts</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_selector_shortcuts>

    def test_selector_shortcuts(self):
        body = b"<html><head><title>Some page</title><body></body></html>"
        response = self.response_class("http://www.example.com", body=body)

        self.assertEqual(
>           response.xpath("//title/text()").getall(),
            response.selector.xpath("//title/text()").getall(),
        )

/testbed/tests/test_http_response.py:604: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, a = ('//title/text()',), kw = {}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_selector_shortcuts_kwargs">test_http_response.py::HtmlResponseTest::test_selector_shortcuts_kwargs</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_selector_shortcuts_kwargs</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_selector_shortcuts_kwargs>

    def test_selector_shortcuts_kwargs(self):
        body = b'<html><head><title>Some page</title><body><p class="content">A nice paragraph.</p></body></html>'
        response = self.response_class("http://www.example.com", body=body)

        self.assertEqual(
>           response.xpath(
                "normalize-space(//p[@class=$pclass])", pclass="content"
            ).getall(),
            response.xpath('normalize-space(//p[@class="content"])').getall(),
        )

/testbed/tests/test_http_response.py:617: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>
a = ('normalize-space(//p[@class=$pclass])',), kw = {'pclass': 'content'}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_shortcut_attributes">test_http_response.py::HtmlResponseTest::test_shortcut_attributes</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_shortcut_attributes</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_shortcut_attributes>

    def test_shortcut_attributes(self):
        r = self.response_class("http://example.com", body=b"hello")
        if self.response_class == Response:
            msg = "Response content isn't text"
            self.assertRaisesRegex(AttributeError, msg, getattr, r, "text")
            self.assertRaisesRegex(NotSupported, msg, r.css, "body")
            self.assertRaisesRegex(NotSupported, msg, r.xpath, "//body")
            self.assertRaisesRegex(NotSupported, msg, r.jmespath, "body")
        else:
            r.text
>           r.css("body")

/testbed/tests/test_http_response.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('body',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_unicode_body">test_http_response.py::HtmlResponseTest::test_unicode_body</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_unicode_body</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_unicode_body>

    def test_unicode_body(self):
        unicode_string = (
            "\u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0439 "
            "\u0442\u0435\u043a\u0441\u0442"
        )
        self.assertRaises(
            TypeError,
            self.response_class,
            "http://www.example.com",
            body="unicode body",
        )

        original_string = unicode_string.encode("cp1251")
        r1 = self.response_class(
            "http://www.example.com", body=original_string, encoding="cp1251"
        )

        # check response.text
>       self.assertTrue(isinstance(r1.text, str))
E       AssertionError: False is not true

/testbed/tests/test_http_response.py:417: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_unicode_url">test_http_response.py::HtmlResponseTest::test_unicode_url</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_unicode_url</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_unicode_url>

    def test_unicode_url(self):
        # instantiate with unicode url without encoding (should set default encoding)
        resp = self.response_class("http://www.example.com/")
>       self._assert_response_encoding(resp, self.response_class._DEFAULT_ENCODING)

/testbed/tests/test_http_response.py:374: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.HtmlResponseTest testMethod=test_unicode_url>
response = <200 http://www.example.com/>, encoding = 'ascii'

    def _assert_response_encoding(self, response, encoding):
>       self.assertEqual(response.encoding, resolve_encoding(encoding))
E       AttributeError: 'HtmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:178: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_urljoin">test_http_response.py::HtmlResponseTest::test_urljoin</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_urljoin</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_urljoin>

    def test_urljoin(self):
        """Test urljoin shortcut (only for existence, since behavior equals urljoin)"""
        joined = self.response_class("http://www.example.com").urljoin("/test")
        absolute = "http://www.example.com/test"
>       self.assertEqual(joined, absolute)
E       AssertionError: None != 'http://www.example.com/test'

/testbed/tests/test_http_response.py:189: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_urljoin_with_base_url">test_http_response.py::HtmlResponseTest::test_urljoin_with_base_url</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_urljoin_with_base_url</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_urljoin_with_base_url>

    def test_urljoin_with_base_url(self):
        """Test urljoin shortcut which also evaluates base-url through get_base_url()."""
        body = b'<html><body><base href="https://example.net"></body></html>'
        joined = self.response_class("http://www.example.com", body=body).urljoin(
            "/test"
        )
        absolute = "https://example.net/test"
>       self.assertEqual(joined, absolute)
E       AssertionError: None != 'https://example.net/test'

/testbed/tests/test_http_response.py:640: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyhtmlresponsetesttest_utf16">test_http_response.py::HtmlResponseTest::test_utf16</h3>
<details><summary> <pre>test_http_response.py::HtmlResponseTest::test_utf16</pre></summary><pre>
self = <tests.test_http_response.HtmlResponseTest testMethod=test_utf16>

    def test_utf16(self):
        """Test utf-16 because UnicodeDammit is known to have problems with"""
        r = self.response_class(
            "http://www.example.com",
            body=b"\xff\xfeh\x00i\x00",
            encoding="utf-16",
        )
>       self._assert_response_values(r, "utf-16", "hi")

/testbed/tests/test_http_response.py:514: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.HtmlResponseTest testMethod=test_utf16>
response = <200 http://www.example.com>, encoding = 'utf-16', body = 'hi'

    def _assert_response_values(self, response, encoding, body):
        if isinstance(body, str):
            body_unicode = body
            body_bytes = body.encode(encoding)
        else:
            body_unicode = body.decode(encoding)
            body_bytes = body

        assert isinstance(response.body, bytes)
>       assert isinstance(response.text, str)
E       AssertionError

/testbed/tests/test_http_response.py:172: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_bom_is_removed_from_body">test_http_response.py::XmlResponseTest::test_bom_is_removed_from_body</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_bom_is_removed_from_body</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_bom_is_removed_from_body>

    def test_bom_is_removed_from_body(self):
        # Inferring encoding from body also cache decoded body as sideeffect,
        # this test tries to ensure that calling response.encoding and
        # response.text in indistinct order doesn't affect final
        # response.text in indistinct order doesn't affect final
        # values for encoding and decoded body.
        url = "http://example.com"
        body = b"\xef\xbb\xbfWORD"
        headers = {"Content-type": ["text/html; charset=utf-8"]}

        # Test response without content-type and BOM encoding
        response = self.response_class(url, body=body)
>       self.assertEqual(response.encoding, "utf-8")
E       AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:543: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_cache_json_response">test_http_response.py::XmlResponseTest::test_cache_json_response</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_cache_json_response</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_cache_json_response>

    def test_cache_json_response(self):
        json_valid_bodies = [b"""{"ip": "109.187.217.200"}""", b"""null"""]
        for json_body in json_valid_bodies:
            json_response = self.response_class(
                "http://www.example.com", body=json_body
            )

            with mock.patch("json.loads") as mock_json:
                for _ in range(2):
                    json_response.json()
>               mock_json.assert_called_once_with(json_body)

/testbed/tests/test_http_response.py:847: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='loads' id='140512373161328'>
args = (b'{"ip": "109.187.217.200"}',), kwargs = {}
msg = "Expected 'loads' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'loads' to be called once. Called 0 times.

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/unittest/mock.py:958: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_copy">test_http_response.py::XmlResponseTest::test_copy</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_copy</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_copy>

    def test_copy(self):
        """Test Response copy"""

        r1 = self.response_class("http://www.example.com", body=b"Some body")
        r1.flags.append("cached")
>       r2 = r1.copy()

/testbed/tests/test_http_response.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/__init__.py:118: in copy
    return self.replace()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'Some body', 'certificate': None, 'flags': ['cached'], 'headers': {}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_copy_inherited_classes">test_http_response.py::XmlResponseTest::test_copy_inherited_classes</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_copy_inherited_classes</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_copy_inherited_classes>

    def test_copy_inherited_classes(self):
        """Test Response children copies preserve their class"""

        class CustomResponse(self.response_class):
            pass

        r1 = CustomResponse("http://www.example.com")
>       r2 = r1.copy()

/testbed/tests/test_http_response.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/__init__.py:118: in copy
    return self.replace()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'', 'certificate': None, 'flags': [], 'headers': {}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'CustomResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_declared_encoding_invalid">test_http_response.py::XmlResponseTest::test_declared_encoding_invalid</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_declared_encoding_invalid</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_declared_encoding_invalid>

    def test_declared_encoding_invalid(self):
        """Check that unknown declared encodings are ignored"""
        r = self.response_class(
            "http://www.example.com",
            headers={"Content-type": ["text/html; charset=UNKNOWN"]},
            body=b"\xc2\xa3",
        )
>       self.assertEqual(r._declared_encoding(), None)
E       AttributeError: 'XmlResponse' object has no attribute '_declared_encoding'

/testbed/tests/test_http_response.py:504: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_encoding">test_http_response.py::XmlResponseTest::test_encoding</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_encoding</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_encoding>

    def test_encoding(self):
        r1 = self.response_class(
            "http://www.example.com",
            body=b"\xc2\xa3",
            headers={"Content-type": ["text/html; charset=utf-8"]},
        )
>       r2 = self.response_class(
            "http://www.example.com", encoding="utf-8", body="\xa3"
        )

/testbed/tests/test_http_response.py:426: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'XmlResponse' object has no attribute '_url'") raised in repr()] XmlResponse object at 0x7fcb9616a7e0>
body = '£'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_none_url">test_http_response.py::XmlResponseTest::test_follow_None_url</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_None_url</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_None_url>

    def test_follow_None_url(self):
        r = self.response_class("http://example.com")
>       self.assertRaises(ValueError, r.follow, None)
E       AssertionError: ValueError not raised by follow

/testbed/tests/test_http_response.py:219: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_all_css">test_http_response.py::XmlResponseTest::test_follow_all_css</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_all_css</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_all_css>

    def test_follow_all_css(self):
        expected = [
            "http://example.com/sample3.html",
            "http://example.com/innertag.html",
        ]
        response = self._links_response()
>       extracted = [r.url for r in response.follow_all(css='a[href*="example.com"]')]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:778: TypeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_all_css_skip_invalid">test_http_response.py::XmlResponseTest::test_follow_all_css_skip_invalid</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_all_css_skip_invalid</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_all_css_skip_invalid>

    def test_follow_all_css_skip_invalid(self):
        expected = [
            "http://example.com/page/1/",
            "http://example.com/page/3/",
            "http://example.com/page/4/",
        ]
        response = self._links_response_no_href()
>       extracted1 = [r.url for r in response.follow_all(css=".pagination a")]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:788: TypeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_all_empty">test_http_response.py::XmlResponseTest::test_follow_all_empty</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_all_empty</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_all_empty>

    def test_follow_all_empty(self):
        r = self.response_class("http://example.com")
>       self.assertEqual([], list(r.follow_all([])))
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:277: TypeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_all_flags">test_http_response.py::XmlResponseTest::test_follow_all_flags</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_all_flags</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_all_flags>

    def test_follow_all_flags(self):
        re = self.response_class("http://www.example.com/")
        urls = [
            "http://www.example.com/",
            "http://www.example.com/2",
            "http://www.example.com/foo",
        ]
        fol = re.follow_all(urls, flags=["cached", "allowed"])
>       for req in fol:
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:769: TypeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_all_invalid">test_http_response.py::XmlResponseTest::test_follow_all_invalid</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_all_invalid</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_all_invalid>

    def test_follow_all_invalid(self):
        r = self.response_class("http://example.com")
        if self.response_class == Response:
            with self.assertRaises(TypeError):
                list(r.follow_all(urls=None))
            with self.assertRaises(TypeError):
                list(r.follow_all(urls=12345))
            with self.assertRaises(ValueError):
                list(r.follow_all(urls=[None]))
        else:
            with self.assertRaises(ValueError):
>               list(r.follow_all(urls=None))
E               TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:290: TypeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_all_too_many_arguments">test_http_response.py::XmlResponseTest::test_follow_all_too_many_arguments</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_all_too_many_arguments</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_all_too_many_arguments>

    def test_follow_all_too_many_arguments(self):
        response = self._links_response()
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

/testbed/tests/test_http_response.py:821: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_all_xpath">test_http_response.py::XmlResponseTest::test_follow_all_xpath</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_all_xpath</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_all_xpath>

    def test_follow_all_xpath(self):
        expected = [
            "http://example.com/sample3.html",
            "http://example.com/innertag.html",
        ]
        response = self._links_response()
        extracted = response.follow_all(xpath='//a[contains(@href, "example.com")]')
>       self.assertEqual(expected, [r.url for r in extracted])
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:800: TypeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_all_xpath_skip_invalid">test_http_response.py::XmlResponseTest::test_follow_all_xpath_skip_invalid</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_all_xpath_skip_invalid</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_all_xpath_skip_invalid>

    def test_follow_all_xpath_skip_invalid(self):
        expected = [
            "http://example.com/page/1/",
            "http://example.com/page/3/",
            "http://example.com/page/4/",
        ]
        response = self._links_response_no_href()
        extracted1 = [
>           r.url for r in response.follow_all(xpath='//div[@id="pagination"]/a')
        ]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:810: TypeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_encoding">test_http_response.py::XmlResponseTest::test_follow_encoding</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_encoding</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_encoding>

    def test_follow_encoding(self):
        resp1 = self.response_class(
            "http://example.com",
            encoding="utf8",
            body='<html><body><a href="foo?привет">click me</a></body></html>'.encode(
                "utf8"
            ),
        )
        req = self._assert_followed_url(
>           resp1.css("a")[0],
            "http://example.com/foo?%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82",
            response=resp1,
        )

/testbed/tests/test_http_response.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_flags">test_http_response.py::XmlResponseTest::test_follow_flags</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_flags</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_flags>

    def test_follow_flags(self):
        res = self.response_class("http://example.com/")
        fol = res.follow("http://example.com/", flags=["cached", "allowed"])
>       self.assertEqual(fol.flags, ["cached", "allowed"])
E       AttributeError: 'NoneType' object has no attribute 'flags'

/testbed/tests/test_http_response.py:759: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_link">test_http_response.py::XmlResponseTest::test_follow_link</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_link</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_link>

    def test_follow_link(self):
>       self._assert_followed_url(
            Link("http://example.com/foo"), "http://example.com/foo"
        )

/testbed/tests/test_http_response.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_link>
follow_obj = Link(url='http://example.com/foo', text='', fragment='', nofollow=False)
target_url = 'http://example.com/foo', response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_selector">test_http_response.py::XmlResponseTest::test_follow_selector</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_selector</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_selector>

    def test_follow_selector(self):
        resp = self._links_response()
        urls = [
            "http://example.com/sample2.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html#foo",
            "http://www.google.com/something",
            "http://example.com/innertag.html",
        ]

        # select <a> elements
>       for sellist in [resp.css("a"), resp.xpath("//a")]:

/testbed/tests/test_http_response.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_selector_attribute">test_http_response.py::XmlResponseTest::test_follow_selector_attribute</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_selector_attribute</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_selector_attribute>

    def test_follow_selector_attribute(self):
        resp = self._links_response()
>       for src in resp.css("img::attr(src)"):

/testbed/tests/test_http_response.py:703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('img::attr(src)',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_selector_invalid">test_http_response.py::XmlResponseTest::test_follow_selector_invalid</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_selector_invalid</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_selector_invalid>

    def test_follow_selector_invalid(self):
        resp = self._links_response()
        self.assertRaisesRegex(
            ValueError,
            "Unsupported",
            resp.follow,
>           resp.xpath("count(//div)")[0],
        )

/testbed/tests/test_http_response.py:698: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('count(//div)',), kw = {}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_selector_list">test_http_response.py::XmlResponseTest::test_follow_selector_list</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_selector_list</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_selector_list>

    def test_follow_selector_list(self):
        resp = self._links_response()
>       self.assertRaisesRegex(ValueError, "SelectorList", resp.follow, resp.css("a"))

/testbed/tests/test_http_response.py:690: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_selector_no_href">test_http_response.py::XmlResponseTest::test_follow_selector_no_href</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_selector_no_href</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_selector_no_href>

    def test_follow_selector_no_href(self):
        resp = self.response_class(
            url="http://example.com",
            body=b"<html><body><a name=123>click me</a></body></html>",
        )
>       self.assertRaisesRegex(ValueError, "no href", resp.follow, resp.css("a")[0])

/testbed/tests/test_http_response.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_url_absolute">test_http_response.py::XmlResponseTest::test_follow_url_absolute</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_url_absolute</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_url_absolute>

    def test_follow_url_absolute(self):
>       self._assert_followed_url("http://foo.example.com", "http://foo.example.com")

/testbed/tests/test_http_response.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_url_absolute>
follow_obj = 'http://foo.example.com', target_url = 'http://foo.example.com'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_url_relative">test_http_response.py::XmlResponseTest::test_follow_url_relative</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_url_relative</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_url_relative>

    def test_follow_url_relative(self):
>       self._assert_followed_url("foo", "http://example.com/foo")

/testbed/tests/test_http_response.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_url_relative>
follow_obj = 'foo', target_url = 'http://example.com/foo'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_whitespace_link">test_http_response.py::XmlResponseTest::test_follow_whitespace_link</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_whitespace_link</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_whitespace_link>

    @mark.xfail(
        parse_version(w3lib_version) < parse_version("2.1.1"),
        reason="https://github.com/scrapy/w3lib/pull/207",
        strict=True,
    )
    def test_follow_whitespace_link(self):
>       self._assert_followed_url(
            Link("http://example.com/foo "), "http://example.com/foo"
        )

/testbed/tests/test_http_response.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_whitespace_link>
follow_obj = Link(url='http://example.com/foo ', text='', fragment='', nofollow=False)
target_url = 'http://example.com/foo', response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_whitespace_selector">test_http_response.py::XmlResponseTest::test_follow_whitespace_selector</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_whitespace_selector</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_whitespace_selector>

    def test_follow_whitespace_selector(self):
        resp = self.response_class(
            "http://example.com",
            body=b"""<html><body><a href=" foo\n">click me</a></body></html>""",
        )
        self._assert_followed_url(
>           resp.css("a")[0], "http://example.com/foo", response=resp
        )

/testbed/tests/test_http_response.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_follow_whitespace_url">test_http_response.py::XmlResponseTest::test_follow_whitespace_url</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_follow_whitespace_url</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_whitespace_url>

    @mark.xfail(
        parse_version(w3lib_version) < parse_version("2.1.1"),
        reason="https://github.com/scrapy/w3lib/pull/207",
        strict=True,
    )
    def test_follow_whitespace_url(self):
>       self._assert_followed_url("foo ", "http://example.com/foo")

/testbed/tests/test_http_response.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.XmlResponseTest testMethod=test_follow_whitespace_url>
follow_obj = 'foo ', target_url = 'http://example.com/foo'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_immutable_attributes">test_http_response.py::XmlResponseTest::test_immutable_attributes</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_immutable_attributes</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_immutable_attributes>

    def test_immutable_attributes(self):
        r = self.response_class("http://example.com")
>       self.assertRaises(AttributeError, setattr, r, "url", "http://example2.com")

/testbed/tests/test_http_response.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def wrapper(self, value):
        private_name = f"_{name}"
        if not hasattr(self, private_name):
>           warnings.warn(f"Property {name} is deprecated.", category=warn_category, stacklevel=2)
E           TypeError: category must be a Warning subclass, not 'str'

/testbed/scrapy/http/common.py:10: TypeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_init">test_http_response.py::XmlResponseTest::test_init</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_init</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_init>

    def test_init(self):
        # Response requires url in the constructor
        self.assertRaises(Exception, self.response_class)
        self.assertTrue(
            isinstance(self.response_class("http://example.com/"), self.response_class)
        )
        self.assertRaises(TypeError, self.response_class, b"http://example.com")
        self.assertRaises(
            TypeError, self.response_class, url="http://example.com", body={}
        )
        # body can be str or None
        self.assertTrue(
            isinstance(
                self.response_class("http://example.com/", body=b""),
                self.response_class,
            )
        )
        self.assertTrue(
            isinstance(
                self.response_class("http://example.com/", body=b"body"),
                self.response_class,
            )
        )
        # test presence of all optional parameters
        self.assertTrue(
            isinstance(
                self.response_class(
                    "http://example.com/", body=b"", headers={}, status=200
                ),
                self.response_class,
            )
        )

        r = self.response_class("http://www.example.com")
        assert isinstance(r.url, str)
        self.assertEqual(r.url, "http://www.example.com")
        self.assertEqual(r.status, 200)

        assert isinstance(r.headers, Headers)
        self.assertEqual(r.headers, {})

        headers = {"foo": "bar"}
        body = b"a body"
        r = self.response_class("http://www.example.com", headers=headers, body=body)

        assert r.headers is not headers
>       self.assertEqual(r.headers[b"foo"], b"bar")

/testbed/tests/test_http_response.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/headers.py:23: in __getitem__
    return super().__getitem__(key)[-1]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {'foo': 'bar'}, key = b'foo'

    def __getitem__(self, key):
>       return dict.__getitem__(self, self.normkey(key))
E       KeyError: None

/testbed/scrapy/utils/datatypes.py:31: KeyError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_invalid_utf8_encoded_body_with_valid_utf8_bom">test_http_response.py::XmlResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_invalid_utf8_encoded_body_with_valid_utf8_BOM>

    def test_invalid_utf8_encoded_body_with_valid_utf8_BOM(self):
        r6 = self.response_class(
            "http://www.example.com",
            headers={"Content-type": ["text/html; charset=utf-8"]},
            body=b"\xef\xbb\xbfWORD\xe3\xab",
        )
>       self.assertEqual(r6.encoding, "utf-8")
E       AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:522: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_json_response">test_http_response.py::XmlResponseTest::test_json_response</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_json_response</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_json_response>

    def test_json_response(self):
        json_body = b"""{"ip": "109.187.217.200"}"""
        json_response = self.response_class("http://www.example.com", body=json_body)
>       self.assertEqual(json_response.json(), {"ip": "109.187.217.200"})
E       AssertionError: None != {'ip': '109.187.217.200'}

/testbed/tests/test_http_response.py:830: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_replace">test_http_response.py::XmlResponseTest::test_replace</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_replace</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_replace>

    def test_replace(self):
>       super().test_replace()

/testbed/tests/test_http_response.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_response.py:150: in test_replace
    r2 = r1.replace(status=301, body=b"New body", headers=hdrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'New body', 'certificate': None, 'flags': [], 'headers': {'key': 'value'}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_replace_encoding">test_http_response.py::XmlResponseTest::test_replace_encoding</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_replace_encoding</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_replace_encoding>

    def test_replace_encoding(self):
        # make sure replace() keeps the previous encoding unless overridden explicitly
        body = b"""<?xml version="1.0" encoding="iso-8859-1"?><xml></xml>"""
        body2 = b"""<?xml version="1.0" encoding="utf-8"?><xml></xml>"""
        r5 = self.response_class("http://www.example.com", body=body)
>       r6 = r5.replace(body=body2)

/testbed/tests/test_http_response.py:915: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'<?xml version="1.0" encoding="utf-8"?><xml></xml>', 'certificate': None, 'flags': [], 'headers': {}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_replace_wrong_encoding">test_http_response.py::XmlResponseTest::test_replace_wrong_encoding</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_replace_wrong_encoding</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_replace_wrong_encoding>

    def test_replace_wrong_encoding(self):
        """Test invalid chars are replaced properly"""
        r = self.response_class(
            "http://www.example.com",
            encoding="utf-8",
            body=b"PREFIX\xe3\xabSUFFIX",
        )
        # XXX: Policy for replacing invalid chars may suffer minor variations
        # but it should always contain the unicode replacement char ('\ufffd')
>       assert "\ufffd" in r.text, repr(r.text)
E       TypeError: argument of type 'NoneType' is not iterable

/testbed/tests/test_http_response.py:568: TypeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_selector">test_http_response.py::XmlResponseTest::test_selector</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_selector</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_selector>

    def test_selector(self):
        body = b'<?xml version="1.0" encoding="utf-8"?><xml><elem>value</elem></xml>'
        response = self.response_class("http://www.example.com", body=body)

>       self.assertIsInstance(response.selector, Selector)
E       AttributeError: 'XmlResponse' object has no attribute 'selector'

/testbed/tests/test_http_response.py:925: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_selector_shortcuts">test_http_response.py::XmlResponseTest::test_selector_shortcuts</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_selector_shortcuts</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_selector_shortcuts>

    def test_selector_shortcuts(self):
        body = b'<?xml version="1.0" encoding="utf-8"?><xml><elem>value</elem></xml>'
        response = self.response_class("http://www.example.com", body=body)

        self.assertEqual(
>           response.xpath("//elem/text()").getall(),
            response.selector.xpath("//elem/text()").getall(),
        )

/testbed/tests/test_http_response.py:937: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, a = ('//elem/text()',), kw = {}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_selector_shortcuts_kwargs">test_http_response.py::XmlResponseTest::test_selector_shortcuts_kwargs</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_selector_shortcuts_kwargs</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_selector_shortcuts_kwargs>

    def test_selector_shortcuts_kwargs(self):
        body = b"""<?xml version="1.0" encoding="utf-8"?>
        <xml xmlns:somens="http://scrapy.org">
        <somens:elem>value</somens:elem>
        </xml>"""
        response = self.response_class("http://www.example.com", body=body)

        self.assertEqual(
>           response.xpath(
                "//s:elem/text()", namespaces={"s": "http://scrapy.org"}
            ).getall(),
            response.selector.xpath(
                "//s:elem/text()", namespaces={"s": "http://scrapy.org"}
            ).getall(),
        )

/testbed/tests/test_http_response.py:949: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, a = ('//s:elem/text()',)
kw = {'namespaces': {'s': 'http://scrapy.org'}}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_shortcut_attributes">test_http_response.py::XmlResponseTest::test_shortcut_attributes</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_shortcut_attributes</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_shortcut_attributes>

    def test_shortcut_attributes(self):
        r = self.response_class("http://example.com", body=b"hello")
        if self.response_class == Response:
            msg = "Response content isn't text"
            self.assertRaisesRegex(AttributeError, msg, getattr, r, "text")
            self.assertRaisesRegex(NotSupported, msg, r.css, "body")
            self.assertRaisesRegex(NotSupported, msg, r.xpath, "//body")
            self.assertRaisesRegex(NotSupported, msg, r.jmespath, "body")
        else:
            r.text
>           r.css("body")

/testbed/tests/test_http_response.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('body',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_unicode_body">test_http_response.py::XmlResponseTest::test_unicode_body</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_unicode_body</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_unicode_body>

    def test_unicode_body(self):
        unicode_string = (
            "\u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0439 "
            "\u0442\u0435\u043a\u0441\u0442"
        )
        self.assertRaises(
            TypeError,
            self.response_class,
            "http://www.example.com",
            body="unicode body",
        )

        original_string = unicode_string.encode("cp1251")
        r1 = self.response_class(
            "http://www.example.com", body=original_string, encoding="cp1251"
        )

        # check response.text
>       self.assertTrue(isinstance(r1.text, str))
E       AssertionError: False is not true

/testbed/tests/test_http_response.py:417: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_unicode_url">test_http_response.py::XmlResponseTest::test_unicode_url</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_unicode_url</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_unicode_url>

    def test_unicode_url(self):
        # instantiate with unicode url without encoding (should set default encoding)
        resp = self.response_class("http://www.example.com/")
>       self._assert_response_encoding(resp, self.response_class._DEFAULT_ENCODING)

/testbed/tests/test_http_response.py:374: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.XmlResponseTest testMethod=test_unicode_url>
response = <200 http://www.example.com/>, encoding = 'ascii'

    def _assert_response_encoding(self, response, encoding):
>       self.assertEqual(response.encoding, resolve_encoding(encoding))
E       AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:178: AttributeError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_urljoin">test_http_response.py::XmlResponseTest::test_urljoin</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_urljoin</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_urljoin>

    def test_urljoin(self):
        """Test urljoin shortcut (only for existence, since behavior equals urljoin)"""
        joined = self.response_class("http://www.example.com").urljoin("/test")
        absolute = "http://www.example.com/test"
>       self.assertEqual(joined, absolute)
E       AssertionError: None != 'http://www.example.com/test'

/testbed/tests/test_http_response.py:189: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_urljoin_with_base_url">test_http_response.py::XmlResponseTest::test_urljoin_with_base_url</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_urljoin_with_base_url</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_urljoin_with_base_url>

    def test_urljoin_with_base_url(self):
        """Test urljoin shortcut which also evaluates base-url through get_base_url()."""
        body = b'<html><body><base href="https://example.net"></body></html>'
        joined = self.response_class("http://www.example.com", body=body).urljoin(
            "/test"
        )
        absolute = "https://example.net/test"
>       self.assertEqual(joined, absolute)
E       AssertionError: None != 'https://example.net/test'

/testbed/tests/test_http_response.py:640: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_utf16">test_http_response.py::XmlResponseTest::test_utf16</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_utf16</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_utf16>

    def test_utf16(self):
        """Test utf-16 because UnicodeDammit is known to have problems with"""
        r = self.response_class(
            "http://www.example.com",
            body=b"\xff\xfeh\x00i\x00",
            encoding="utf-16",
        )
>       self._assert_response_values(r, "utf-16", "hi")

/testbed/tests/test_http_response.py:514: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.XmlResponseTest testMethod=test_utf16>
response = <200 http://www.example.com>, encoding = 'utf-16', body = 'hi'

    def _assert_response_values(self, response, encoding, body):
        if isinstance(body, str):
            body_unicode = body
            body_bytes = body.encode(encoding)
        else:
            body_unicode = body.decode(encoding)
            body_bytes = body

        assert isinstance(response.body, bytes)
>       assert isinstance(response.text, str)
E       AssertionError

/testbed/tests/test_http_response.py:172: AssertionError
</pre>
</details>
<h3 id="test_http_responsepyxmlresponsetesttest_xml_encoding">test_http_response.py::XmlResponseTest::test_xml_encoding</h3>
<details><summary> <pre>test_http_response.py::XmlResponseTest::test_xml_encoding</pre></summary><pre>
self = <tests.test_http_response.XmlResponseTest testMethod=test_xml_encoding>

    def test_xml_encoding(self):
        body = b"<xml></xml>"
        r1 = self.response_class("http://www.example.com", body=body)
>       self._assert_response_values(r1, self.response_class._DEFAULT_ENCODING, body)

/testbed/tests/test_http_response.py:897: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.XmlResponseTest testMethod=test_xml_encoding>
response = <200 http://www.example.com>, encoding = 'ascii'
body = b'<xml></xml>'

    def _assert_response_values(self, response, encoding, body):
        if isinstance(body, str):
            body_unicode = body
            body_bytes = body.encode(encoding)
        else:
            body_unicode = body.decode(encoding)
            body_bytes = body

        assert isinstance(response.body, bytes)
>       assert isinstance(response.text, str)
E       AssertionError

/testbed/tests/test_http_response.py:172: AssertionError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_bom_is_removed_from_body">test_http_response.py::CustomResponseTest::test_bom_is_removed_from_body</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_bom_is_removed_from_body</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_bom_is_removed_from_body>

    def test_bom_is_removed_from_body(self):
        # Inferring encoding from body also cache decoded body as sideeffect,
        # this test tries to ensure that calling response.encoding and
        # response.text in indistinct order doesn't affect final
        # response.text in indistinct order doesn't affect final
        # values for encoding and decoded body.
        url = "http://example.com"
        body = b"\xef\xbb\xbfWORD"
        headers = {"Content-type": ["text/html; charset=utf-8"]}

        # Test response without content-type and BOM encoding
        response = self.response_class(url, body=body)
>       self.assertEqual(response.encoding, "utf-8")
E       AttributeError: 'CustomResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:543: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_cache_json_response">test_http_response.py::CustomResponseTest::test_cache_json_response</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_cache_json_response</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_cache_json_response>

    def test_cache_json_response(self):
        json_valid_bodies = [b"""{"ip": "109.187.217.200"}""", b"""null"""]
        for json_body in json_valid_bodies:
            json_response = self.response_class(
                "http://www.example.com", body=json_body
            )

            with mock.patch("json.loads") as mock_json:
                for _ in range(2):
                    json_response.json()
>               mock_json.assert_called_once_with(json_body)

/testbed/tests/test_http_response.py:847: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='loads' id='140512372636992'>
args = (b'{"ip": "109.187.217.200"}',), kwargs = {}
msg = "Expected 'loads' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'loads' to be called once. Called 0 times.

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/unittest/mock.py:958: AssertionError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_copy">test_http_response.py::CustomResponseTest::test_copy</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_copy</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_copy>

    def test_copy(self):
>       super().test_copy()

/testbed/tests/test_http_response.py:980: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_response.py:92: in test_copy
    r2 = r1.copy()
/testbed/scrapy/http/response/__init__.py:118: in copy
    return self.replace()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'Some body', 'certificate': None, 'flags': ['cached'], 'headers': {}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'CustomResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_copy_inherited_classes">test_http_response.py::CustomResponseTest::test_copy_inherited_classes</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_copy_inherited_classes</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_copy_inherited_classes>

    def test_copy_inherited_classes(self):
        """Test Response children copies preserve their class"""

        class CustomResponse(self.response_class):
            pass

        r1 = CustomResponse("http://www.example.com")
>       r2 = r1.copy()

/testbed/tests/test_http_response.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/__init__.py:118: in copy
    return self.replace()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'', 'certificate': None, 'flags': [], 'headers': {}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'CustomResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_declared_encoding_invalid">test_http_response.py::CustomResponseTest::test_declared_encoding_invalid</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_declared_encoding_invalid</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_declared_encoding_invalid>

    def test_declared_encoding_invalid(self):
        """Check that unknown declared encodings are ignored"""
        r = self.response_class(
            "http://www.example.com",
            headers={"Content-type": ["text/html; charset=UNKNOWN"]},
            body=b"\xc2\xa3",
        )
>       self.assertEqual(r._declared_encoding(), None)
E       AttributeError: 'CustomResponse' object has no attribute '_declared_encoding'

/testbed/tests/test_http_response.py:504: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_encoding">test_http_response.py::CustomResponseTest::test_encoding</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_encoding</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_encoding>

    def test_encoding(self):
        r1 = self.response_class(
            "http://www.example.com",
            body=b"\xc2\xa3",
            headers={"Content-type": ["text/html; charset=utf-8"]},
        )
>       r2 = self.response_class(
            "http://www.example.com", encoding="utf-8", body="\xa3"
        )

/testbed/tests/test_http_response.py:426: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_response.py:973: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'CustomResponse' object has no attribute '_url'") raised in repr()] CustomResponse object at 0x7fcb960b32f0>
body = '£'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_none_url">test_http_response.py::CustomResponseTest::test_follow_None_url</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_None_url</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_None_url>

    def test_follow_None_url(self):
        r = self.response_class("http://example.com")
>       self.assertRaises(ValueError, r.follow, None)
E       AssertionError: ValueError not raised by follow

/testbed/tests/test_http_response.py:219: AssertionError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_all_css">test_http_response.py::CustomResponseTest::test_follow_all_css</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_all_css</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_all_css>

    def test_follow_all_css(self):
        expected = [
            "http://example.com/sample3.html",
            "http://example.com/innertag.html",
        ]
        response = self._links_response()
>       extracted = [r.url for r in response.follow_all(css='a[href*="example.com"]')]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:778: TypeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_all_css_skip_invalid">test_http_response.py::CustomResponseTest::test_follow_all_css_skip_invalid</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_all_css_skip_invalid</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_all_css_skip_invalid>

    def test_follow_all_css_skip_invalid(self):
        expected = [
            "http://example.com/page/1/",
            "http://example.com/page/3/",
            "http://example.com/page/4/",
        ]
        response = self._links_response_no_href()
>       extracted1 = [r.url for r in response.follow_all(css=".pagination a")]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:788: TypeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_all_empty">test_http_response.py::CustomResponseTest::test_follow_all_empty</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_all_empty</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_all_empty>

    def test_follow_all_empty(self):
        r = self.response_class("http://example.com")
>       self.assertEqual([], list(r.follow_all([])))
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:277: TypeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_all_flags">test_http_response.py::CustomResponseTest::test_follow_all_flags</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_all_flags</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_all_flags>

    def test_follow_all_flags(self):
        re = self.response_class("http://www.example.com/")
        urls = [
            "http://www.example.com/",
            "http://www.example.com/2",
            "http://www.example.com/foo",
        ]
        fol = re.follow_all(urls, flags=["cached", "allowed"])
>       for req in fol:
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:769: TypeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_all_invalid">test_http_response.py::CustomResponseTest::test_follow_all_invalid</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_all_invalid</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_all_invalid>

    def test_follow_all_invalid(self):
        r = self.response_class("http://example.com")
        if self.response_class == Response:
            with self.assertRaises(TypeError):
                list(r.follow_all(urls=None))
            with self.assertRaises(TypeError):
                list(r.follow_all(urls=12345))
            with self.assertRaises(ValueError):
                list(r.follow_all(urls=[None]))
        else:
            with self.assertRaises(ValueError):
>               list(r.follow_all(urls=None))
E               TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:290: TypeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_all_too_many_arguments">test_http_response.py::CustomResponseTest::test_follow_all_too_many_arguments</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_all_too_many_arguments</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_all_too_many_arguments>

    def test_follow_all_too_many_arguments(self):
        response = self._links_response()
>       with self.assertRaises(ValueError):
E       AssertionError: ValueError not raised

/testbed/tests/test_http_response.py:821: AssertionError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_all_xpath">test_http_response.py::CustomResponseTest::test_follow_all_xpath</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_all_xpath</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_all_xpath>

    def test_follow_all_xpath(self):
        expected = [
            "http://example.com/sample3.html",
            "http://example.com/innertag.html",
        ]
        response = self._links_response()
        extracted = response.follow_all(xpath='//a[contains(@href, "example.com")]')
>       self.assertEqual(expected, [r.url for r in extracted])
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:800: TypeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_all_xpath_skip_invalid">test_http_response.py::CustomResponseTest::test_follow_all_xpath_skip_invalid</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_all_xpath_skip_invalid</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_all_xpath_skip_invalid>

    def test_follow_all_xpath_skip_invalid(self):
        expected = [
            "http://example.com/page/1/",
            "http://example.com/page/3/",
            "http://example.com/page/4/",
        ]
        response = self._links_response_no_href()
        extracted1 = [
>           r.url for r in response.follow_all(xpath='//div[@id="pagination"]/a')
        ]
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_http_response.py:810: TypeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_encoding">test_http_response.py::CustomResponseTest::test_follow_encoding</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_encoding</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_encoding>

    def test_follow_encoding(self):
        resp1 = self.response_class(
            "http://example.com",
            encoding="utf8",
            body='<html><body><a href="foo?привет">click me</a></body></html>'.encode(
                "utf8"
            ),
        )
        req = self._assert_followed_url(
>           resp1.css("a")[0],
            "http://example.com/foo?%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82",
            response=resp1,
        )

/testbed/tests/test_http_response.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_flags">test_http_response.py::CustomResponseTest::test_follow_flags</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_flags</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_flags>

    def test_follow_flags(self):
        res = self.response_class("http://example.com/")
        fol = res.follow("http://example.com/", flags=["cached", "allowed"])
>       self.assertEqual(fol.flags, ["cached", "allowed"])
E       AttributeError: 'NoneType' object has no attribute 'flags'

/testbed/tests/test_http_response.py:759: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_link">test_http_response.py::CustomResponseTest::test_follow_link</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_link</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_link>

    def test_follow_link(self):
>       self._assert_followed_url(
            Link("http://example.com/foo"), "http://example.com/foo"
        )

/testbed/tests/test_http_response.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_link>
follow_obj = Link(url='http://example.com/foo', text='', fragment='', nofollow=False)
target_url = 'http://example.com/foo', response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_selector">test_http_response.py::CustomResponseTest::test_follow_selector</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_selector</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_selector>

    def test_follow_selector(self):
        resp = self._links_response()
        urls = [
            "http://example.com/sample2.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html",
            "http://example.com/sample3.html#foo",
            "http://www.google.com/something",
            "http://example.com/innertag.html",
        ]

        # select <a> elements
>       for sellist in [resp.css("a"), resp.xpath("//a")]:

/testbed/tests/test_http_response.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_selector_attribute">test_http_response.py::CustomResponseTest::test_follow_selector_attribute</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_selector_attribute</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_selector_attribute>

    def test_follow_selector_attribute(self):
        resp = self._links_response()
>       for src in resp.css("img::attr(src)"):

/testbed/tests/test_http_response.py:703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('img::attr(src)',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_selector_invalid">test_http_response.py::CustomResponseTest::test_follow_selector_invalid</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_selector_invalid</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_selector_invalid>

    def test_follow_selector_invalid(self):
        resp = self._links_response()
        self.assertRaisesRegex(
            ValueError,
            "Unsupported",
            resp.follow,
>           resp.xpath("count(//div)")[0],
        )

/testbed/tests/test_http_response.py:698: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('count(//div)',), kw = {}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_selector_list">test_http_response.py::CustomResponseTest::test_follow_selector_list</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_selector_list</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_selector_list>

    def test_follow_selector_list(self):
        resp = self._links_response()
>       self.assertRaisesRegex(ValueError, "SelectorList", resp.follow, resp.css("a"))

/testbed/tests/test_http_response.py:690: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com/index>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_selector_no_href">test_http_response.py::CustomResponseTest::test_follow_selector_no_href</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_selector_no_href</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_selector_no_href>

    def test_follow_selector_no_href(self):
        resp = self.response_class(
            url="http://example.com",
            body=b"<html><body><a name=123>click me</a></body></html>",
        )
>       self.assertRaisesRegex(ValueError, "no href", resp.follow, resp.css("a")[0])

/testbed/tests/test_http_response.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_url_absolute">test_http_response.py::CustomResponseTest::test_follow_url_absolute</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_url_absolute</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_url_absolute>

    def test_follow_url_absolute(self):
>       self._assert_followed_url("http://foo.example.com", "http://foo.example.com")

/testbed/tests/test_http_response.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_url_absolute>
follow_obj = 'http://foo.example.com', target_url = 'http://foo.example.com'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_url_relative">test_http_response.py::CustomResponseTest::test_follow_url_relative</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_url_relative</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_url_relative>

    def test_follow_url_relative(self):
>       self._assert_followed_url("foo", "http://example.com/foo")

/testbed/tests/test_http_response.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_url_relative>
follow_obj = 'foo', target_url = 'http://example.com/foo'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_whitespace_link">test_http_response.py::CustomResponseTest::test_follow_whitespace_link</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_whitespace_link</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_whitespace_link>

    @mark.xfail(
        parse_version(w3lib_version) < parse_version("2.1.1"),
        reason="https://github.com/scrapy/w3lib/pull/207",
        strict=True,
    )
    def test_follow_whitespace_link(self):
>       self._assert_followed_url(
            Link("http://example.com/foo "), "http://example.com/foo"
        )

/testbed/tests/test_http_response.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_whitespace_link>
follow_obj = Link(url='http://example.com/foo ', text='', fragment='', nofollow=False)
target_url = 'http://example.com/foo', response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_whitespace_selector">test_http_response.py::CustomResponseTest::test_follow_whitespace_selector</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_whitespace_selector</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_whitespace_selector>

    def test_follow_whitespace_selector(self):
        resp = self.response_class(
            "http://example.com",
            body=b"""<html><body><a href=" foo\n">click me</a></body></html>""",
        )
        self._assert_followed_url(
>           resp.css("a")[0], "http://example.com/foo", response=resp
        )

/testbed/tests/test_http_response.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('a',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_follow_whitespace_url">test_http_response.py::CustomResponseTest::test_follow_whitespace_url</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_follow_whitespace_url</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_whitespace_url>

    @mark.xfail(
        parse_version(w3lib_version) < parse_version("2.1.1"),
        reason="https://github.com/scrapy/w3lib/pull/207",
        strict=True,
    )
    def test_follow_whitespace_url(self):
>       self._assert_followed_url("foo ", "http://example.com/foo")

/testbed/tests/test_http_response.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.CustomResponseTest testMethod=test_follow_whitespace_url>
follow_obj = 'foo ', target_url = 'http://example.com/foo'
response = <200 http://example.com/index>

    def _assert_followed_url(self, follow_obj, target_url, response=None):
        if response is None:
            response = self._links_response()
        req = response.follow(follow_obj)
>       self.assertEqual(req.url, target_url)
E       AttributeError: 'NoneType' object has no attribute 'url'

/testbed/tests/test_http_response.py:332: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_immutable_attributes">test_http_response.py::CustomResponseTest::test_immutable_attributes</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_immutable_attributes</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_immutable_attributes>

    def test_immutable_attributes(self):
        r = self.response_class("http://example.com")
>       self.assertRaises(AttributeError, setattr, r, "url", "http://example2.com")

/testbed/tests/test_http_response.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def wrapper(self, value):
        private_name = f"_{name}"
        if not hasattr(self, private_name):
>           warnings.warn(f"Property {name} is deprecated.", category=warn_category, stacklevel=2)
E           TypeError: category must be a Warning subclass, not 'str'

/testbed/scrapy/http/common.py:10: TypeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_init">test_http_response.py::CustomResponseTest::test_init</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_init</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_init>

    def test_init(self):
        # Response requires url in the constructor
        self.assertRaises(Exception, self.response_class)
        self.assertTrue(
            isinstance(self.response_class("http://example.com/"), self.response_class)
        )
        self.assertRaises(TypeError, self.response_class, b"http://example.com")
        self.assertRaises(
            TypeError, self.response_class, url="http://example.com", body={}
        )
        # body can be str or None
        self.assertTrue(
            isinstance(
                self.response_class("http://example.com/", body=b""),
                self.response_class,
            )
        )
        self.assertTrue(
            isinstance(
                self.response_class("http://example.com/", body=b"body"),
                self.response_class,
            )
        )
        # test presence of all optional parameters
        self.assertTrue(
            isinstance(
                self.response_class(
                    "http://example.com/", body=b"", headers={}, status=200
                ),
                self.response_class,
            )
        )

        r = self.response_class("http://www.example.com")
        assert isinstance(r.url, str)
        self.assertEqual(r.url, "http://www.example.com")
        self.assertEqual(r.status, 200)

        assert isinstance(r.headers, Headers)
        self.assertEqual(r.headers, {})

        headers = {"foo": "bar"}
        body = b"a body"
        r = self.response_class("http://www.example.com", headers=headers, body=body)

        assert r.headers is not headers
>       self.assertEqual(r.headers[b"foo"], b"bar")

/testbed/tests/test_http_response.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/headers.py:23: in __getitem__
    return super().__getitem__(key)[-1]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {'foo': 'bar'}, key = b'foo'

    def __getitem__(self, key):
>       return dict.__getitem__(self, self.normkey(key))
E       KeyError: None

/testbed/scrapy/utils/datatypes.py:31: KeyError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_invalid_utf8_encoded_body_with_valid_utf8_bom">test_http_response.py::CustomResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_invalid_utf8_encoded_body_with_valid_utf8_BOM</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_invalid_utf8_encoded_body_with_valid_utf8_BOM>

    def test_invalid_utf8_encoded_body_with_valid_utf8_BOM(self):
        r6 = self.response_class(
            "http://www.example.com",
            headers={"Content-type": ["text/html; charset=utf-8"]},
            body=b"\xef\xbb\xbfWORD\xe3\xab",
        )
>       self.assertEqual(r6.encoding, "utf-8")
E       AttributeError: 'CustomResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:522: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_json_response">test_http_response.py::CustomResponseTest::test_json_response</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_json_response</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_json_response>

    def test_json_response(self):
        json_body = b"""{"ip": "109.187.217.200"}"""
        json_response = self.response_class("http://www.example.com", body=json_body)
>       self.assertEqual(json_response.json(), {"ip": "109.187.217.200"})
E       AssertionError: None != {'ip': '109.187.217.200'}

/testbed/tests/test_http_response.py:830: AssertionError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_replace">test_http_response.py::CustomResponseTest::test_replace</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_replace</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_replace>

    def test_replace(self):
>       super().test_replace()

/testbed/tests/test_http_response.py:996: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_http_response.py:358: in test_replace
    super().test_replace()
/testbed/tests/test_http_response.py:150: in test_replace
    r2 = r1.replace(status=301, body=b"New body", headers=hdrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, args = ()
kwargs = {'body': b'New body', 'certificate': None, 'flags': [], 'headers': {'key': 'value'}, ...}
x = 'encoding'

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those given new values"""
        for x in self.attributes:
>           kwargs.setdefault(x, getattr(self, x))
E           AttributeError: 'CustomResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/http/response/__init__.py:123: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_replace_wrong_encoding">test_http_response.py::CustomResponseTest::test_replace_wrong_encoding</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_replace_wrong_encoding</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_replace_wrong_encoding>

    def test_replace_wrong_encoding(self):
        """Test invalid chars are replaced properly"""
        r = self.response_class(
            "http://www.example.com",
            encoding="utf-8",
            body=b"PREFIX\xe3\xabSUFFIX",
        )
        # XXX: Policy for replacing invalid chars may suffer minor variations
        # but it should always contain the unicode replacement char ('\ufffd')
>       assert "\ufffd" in r.text, repr(r.text)
E       TypeError: argument of type 'NoneType' is not iterable

/testbed/tests/test_http_response.py:568: TypeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_selector">test_http_response.py::CustomResponseTest::test_selector</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_selector</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_selector>

    def test_selector(self):
        body = b"<html><head><title>Some page</title><body></body></html>"
        response = self.response_class("http://www.example.com", body=body)

>       self.assertIsInstance(response.selector, Selector)
E       AttributeError: 'CustomResponse' object has no attribute 'selector'

/testbed/tests/test_http_response.py:588: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_selector_shortcuts">test_http_response.py::CustomResponseTest::test_selector_shortcuts</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_selector_shortcuts</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_selector_shortcuts>

    def test_selector_shortcuts(self):
        body = b"<html><head><title>Some page</title><body></body></html>"
        response = self.response_class("http://www.example.com", body=body)

        self.assertEqual(
>           response.xpath("//title/text()").getall(),
            response.selector.xpath("//title/text()").getall(),
        )

/testbed/tests/test_http_response.py:604: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>, a = ('//title/text()',), kw = {}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_selector_shortcuts_kwargs">test_http_response.py::CustomResponseTest::test_selector_shortcuts_kwargs</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_selector_shortcuts_kwargs</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_selector_shortcuts_kwargs>

    def test_selector_shortcuts_kwargs(self):
        body = b'<html><head><title>Some page</title><body><p class="content">A nice paragraph.</p></body></html>'
        response = self.response_class("http://www.example.com", body=body)

        self.assertEqual(
>           response.xpath(
                "normalize-space(//p[@class=$pclass])", pclass="content"
            ).getall(),
            response.xpath('normalize-space(//p[@class="content"])').getall(),
        )

/testbed/tests/test_http_response.py:617: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://www.example.com>
a = ('normalize-space(//p[@class=$pclass])',), kw = {'pclass': 'content'}

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:155: NotSupported
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_shortcut_attributes">test_http_response.py::CustomResponseTest::test_shortcut_attributes</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_shortcut_attributes</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_shortcut_attributes>

    def test_shortcut_attributes(self):
        r = self.response_class("http://example.com", body=b"hello")
        if self.response_class == Response:
            msg = "Response content isn't text"
            self.assertRaisesRegex(AttributeError, msg, getattr, r, "text")
            self.assertRaisesRegex(NotSupported, msg, r.css, "body")
            self.assertRaisesRegex(NotSupported, msg, r.xpath, "//body")
            self.assertRaisesRegex(NotSupported, msg, r.jmespath, "body")
        else:
            r.text
>           r.css("body")

/testbed/tests/test_http_response.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <200 http://example.com>, a = ('body',), kw = {}

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
>       raise NotSupported("Response content isn't text")
E       scrapy.exceptions.NotSupported: Response content isn't text

/testbed/scrapy/http/response/__init__.py:143: NotSupported
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_unicode_body">test_http_response.py::CustomResponseTest::test_unicode_body</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_unicode_body</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_unicode_body>

    def test_unicode_body(self):
        unicode_string = (
            "\u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0439 "
            "\u0442\u0435\u043a\u0441\u0442"
        )
        self.assertRaises(
            TypeError,
            self.response_class,
            "http://www.example.com",
            body="unicode body",
        )

        original_string = unicode_string.encode("cp1251")
        r1 = self.response_class(
            "http://www.example.com", body=original_string, encoding="cp1251"
        )

        # check response.text
>       self.assertTrue(isinstance(r1.text, str))
E       AssertionError: False is not true

/testbed/tests/test_http_response.py:417: AssertionError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_unicode_url">test_http_response.py::CustomResponseTest::test_unicode_url</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_unicode_url</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_unicode_url>

    def test_unicode_url(self):
        # instantiate with unicode url without encoding (should set default encoding)
        resp = self.response_class("http://www.example.com/")
>       self._assert_response_encoding(resp, self.response_class._DEFAULT_ENCODING)

/testbed/tests/test_http_response.py:374: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.CustomResponseTest testMethod=test_unicode_url>
response = <200 http://www.example.com/>, encoding = 'ascii'

    def _assert_response_encoding(self, response, encoding):
>       self.assertEqual(response.encoding, resolve_encoding(encoding))
E       AttributeError: 'CustomResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/tests/test_http_response.py:178: AttributeError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_urljoin">test_http_response.py::CustomResponseTest::test_urljoin</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_urljoin</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_urljoin>

    def test_urljoin(self):
        """Test urljoin shortcut (only for existence, since behavior equals urljoin)"""
        joined = self.response_class("http://www.example.com").urljoin("/test")
        absolute = "http://www.example.com/test"
>       self.assertEqual(joined, absolute)
E       AssertionError: None != 'http://www.example.com/test'

/testbed/tests/test_http_response.py:189: AssertionError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_urljoin_with_base_url">test_http_response.py::CustomResponseTest::test_urljoin_with_base_url</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_urljoin_with_base_url</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_urljoin_with_base_url>

    def test_urljoin_with_base_url(self):
        """Test urljoin shortcut which also evaluates base-url through get_base_url()."""
        body = b'<html><body><base href="https://example.net"></body></html>'
        joined = self.response_class("http://www.example.com", body=body).urljoin(
            "/test"
        )
        absolute = "https://example.net/test"
>       self.assertEqual(joined, absolute)
E       AssertionError: None != 'https://example.net/test'

/testbed/tests/test_http_response.py:640: AssertionError
</pre>
</details>
<h3 id="test_http_responsepycustomresponsetesttest_utf16">test_http_response.py::CustomResponseTest::test_utf16</h3>
<details><summary> <pre>test_http_response.py::CustomResponseTest::test_utf16</pre></summary><pre>
self = <tests.test_http_response.CustomResponseTest testMethod=test_utf16>

    def test_utf16(self):
        """Test utf-16 because UnicodeDammit is known to have problems with"""
        r = self.response_class(
            "http://www.example.com",
            body=b"\xff\xfeh\x00i\x00",
            encoding="utf-16",
        )
>       self._assert_response_values(r, "utf-16", "hi")

/testbed/tests/test_http_response.py:514: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_http_response.CustomResponseTest testMethod=test_utf16>
response = <200 http://www.example.com>, encoding = 'utf-16', body = 'hi'

    def _assert_response_values(self, response, encoding, body):
        if isinstance(body, str):
            body_unicode = body
            body_bytes = body.encode(encoding)
        else:
            body_unicode = body.decode(encoding)
            body_bytes = body

        assert isinstance(response.body, bytes)
>       assert isinstance(response.text, str)
E       AssertionError

/testbed/tests/test_http_response.py:172: AssertionError
</pre>
</details>
<h3 id="test_itempyitemtesttest_copy">test_item.py::ItemTest::test_copy</h3>
<details><summary> <pre>test_item.py::ItemTest::test_copy</pre></summary><pre>
self = <tests.test_item.ItemTest testMethod=test_copy>

    def test_copy(self):
        class TestItem(Item):
            name = Field()

        item = TestItem({"name": "lower"})
>       copied_item = item.copy()

/testbed/tests/test_item.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = {'name': 'lower'}, name = 'copy'

    def __getattr__(self, name):
        if name in self.fields:
            raise AttributeError(f'Use item[{name!r}] to get field value')
>       raise AttributeError(name)
E       AttributeError: copy

/testbed/scrapy/item.py:85: AttributeError
</pre>
</details>
<h3 id="test_itempyitemtesttest_deepcopy">test_item.py::ItemTest::test_deepcopy</h3>
<details><summary> <pre>test_item.py::ItemTest::test_deepcopy</pre></summary><pre>
self = <tests.test_item.ItemTest testMethod=test_deepcopy>

    def test_deepcopy(self):
        class TestItem(Item):
            tags = Field()

        item = TestItem({"tags": ["tag1"]})
        copied_item = item.deepcopy()
        item["tags"].append("tag2")
>       assert item["tags"] != copied_item["tags"]
E       TypeError: 'NoneType' object is not subscriptable

/testbed/tests/test_item.py:262: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_area_tag_with_unicode_present">test_linkextractors.py::LxmlLinkExtractorTestCase::test_area_tag_with_unicode_present</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_area_tag_with_unicode_present</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_area_tag_with_unicode_present>

    def test_area_tag_with_unicode_present(self):
        body = b"""<html><body>\xbe\xa9<map><area href="http://example.org/foo" /></map></body></html>"""
        response = HtmlResponse("http://example.org", body=body, encoding="utf-8")
        lx = self.extractor_cls()
>       lx.extract_links(response)

/testbed/tests/test_linkextractors.py:351: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.org>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_attrs">test_linkextractors.py::LxmlLinkExtractorTestCase::test_attrs</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_attrs</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_attrs>

    def test_attrs(self):
        lx = self.extractor_cls(attrs="href")
        page4_url = "http://example.com/page%204.html"

        self.assertEqual(
>           lx.extract_links(self.response),
            [
                Link(url="http://example.com/sample1.html", text=""),
                Link(url="http://example.com/sample2.html", text="sample 2"),
                Link(url="http://example.com/sample3.html", text="sample 3 text"),
                Link(
                    url="http://example.com/sample3.html#foo",
                    text="sample 3 repetition with fragment",
                ),
                Link(url="http://www.google.com/something", text=""),
                Link(url="http://example.com/innertag.html", text="inner tag"),
                Link(url=page4_url, text="href with whitespaces"),
            ],
        )

/testbed/tests/test_linkextractors.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_base_url_with_restrict_xpaths">test_linkextractors.py::LxmlLinkExtractorTestCase::test_base_url_with_restrict_xpaths</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_base_url_with_restrict_xpaths</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_base_url_with_restrict_xpaths>

    def test_base_url_with_restrict_xpaths(self):
        html = b"""<html><head><title>Page title<title><base href="http://otherdomain.com/base/" />
        <body><p><a href="item/12.html">Item 12</a></p>
        </body></html>"""
        response = HtmlResponse("http://example.org/somepage/index.html", body=html)
        lx = self.extractor_cls(restrict_xpaths="//p")
        self.assertEqual(
>           lx.extract_links(response),
            [Link(url="http://otherdomain.com/base/item/12.html", text="Item 12")],
        )

/testbed/tests/test_linkextractors.py:453: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.org/somepage/index.html>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_encoded_url">test_linkextractors.py::LxmlLinkExtractorTestCase::test_encoded_url</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_encoded_url</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_encoded_url>

    def test_encoded_url(self):
        body = b"""<html><body><div><a href="?page=2">BinB</a></body></html>"""
        response = HtmlResponse(
            "http://known.fm/AC%2FDC/", body=body, encoding="utf8"
        )
        lx = self.extractor_cls()
        self.assertEqual(
>           lx.extract_links(response),
            [
                Link(
                    url="http://known.fm/AC%2FDC/?page=2",
                    text="BinB",
                    fragment="",
                    nofollow=False,
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:373: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://known.fm/AC%2FDC/>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_encoded_url_in_restricted_xpath">test_linkextractors.py::LxmlLinkExtractorTestCase::test_encoded_url_in_restricted_xpath</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_encoded_url_in_restricted_xpath</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_encoded_url_in_restricted_xpath>

    def test_encoded_url_in_restricted_xpath(self):
        body = b"""<html><body><div><a href="?page=2">BinB</a></body></html>"""
        response = HtmlResponse(
            "http://known.fm/AC%2FDC/", body=body, encoding="utf8"
        )
        lx = self.extractor_cls(restrict_xpaths="//div")
        self.assertEqual(
>           lx.extract_links(response),
            [
                Link(
                    url="http://known.fm/AC%2FDC/?page=2",
                    text="BinB",
                    fragment="",
                    nofollow=False,
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:391: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://known.fm/AC%2FDC/>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_extract_all_links">test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_all_links</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_all_links</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_extract_all_links>

    def test_extract_all_links(self):
        lx = self.extractor_cls()
        page4_url = "http://example.com/page%204.html"

        self.assertEqual(
>           [link for link in lx.extract_links(self.response)],
            [
                Link(url="http://example.com/sample1.html", text=""),
                Link(url="http://example.com/sample2.html", text="sample 2"),
                Link(url="http://example.com/sample3.html", text="sample 3 text"),
                Link(
                    url="http://example.com/sample3.html#foo",
                    text="sample 3 repetition with fragment",
                ),
                Link(url="http://www.google.com/something", text=""),
                Link(url="http://example.com/innertag.html", text="inner tag"),
                Link(url=page4_url, text="href with whitespaces"),
            ],
        )

/testbed/tests/test_linkextractors.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allow">test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_extract_filter_allow>

    def test_extract_filter_allow(self):
        lx = self.extractor_cls(allow=("sample",))
        self.assertEqual(
>           [link for link in lx.extract_links(self.response)],
            [
                Link(url="http://example.com/sample1.html", text=""),
                Link(url="http://example.com/sample2.html", text="sample 2"),
                Link(url="http://example.com/sample3.html", text="sample 3 text"),
                Link(
                    url="http://example.com/sample3.html#foo",
                    text="sample 3 repetition with fragment",
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allow_and_deny">test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_and_deny</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_and_deny</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_extract_filter_allow_and_deny>

    def test_extract_filter_allow_and_deny(self):
        lx = self.extractor_cls(allow=("sample",), deny=("3",))
        self.assertEqual(
>           [link for link in lx.extract_links(self.response)],
            [
                Link(url="http://example.com/sample1.html", text=""),
                Link(url="http://example.com/sample2.html", text="sample 2"),
            ],
        )

/testbed/tests/test_linkextractors.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allow_no_duplicates_canonicalize">test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_no_duplicates_canonicalize</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_no_duplicates_canonicalize</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_extract_filter_allow_no_duplicates_canonicalize>

    def test_extract_filter_allow_no_duplicates_canonicalize(self):
        lx = self.extractor_cls(allow=("sample",), unique=True, canonicalize=True)
        self.assertEqual(
>           [link for link in lx.extract_links(self.response)],
            [
                Link(url="http://example.com/sample1.html", text=""),
                Link(url="http://example.com/sample2.html", text="sample 2"),
                Link(url="http://example.com/sample3.html", text="sample 3 text"),
            ],
        )

/testbed/tests/test_linkextractors.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allow_with_duplicates">test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_with_duplicates</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_with_duplicates</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_extract_filter_allow_with_duplicates>

    def test_extract_filter_allow_with_duplicates(self):
        lx = self.extractor_cls(allow=("sample",), unique=False)
        self.assertEqual(
>           [link for link in lx.extract_links(self.response)],
            [
                Link(url="http://example.com/sample1.html", text=""),
                Link(url="http://example.com/sample2.html", text="sample 2"),
                Link(url="http://example.com/sample3.html", text="sample 3 text"),
                Link(
                    url="http://example.com/sample3.html",
                    text="sample 3 repetition",
                ),
                Link(
                    url="http://example.com/sample3.html",
                    text="sample 3 repetition",
                ),
                Link(
                    url="http://example.com/sample3.html#foo",
                    text="sample 3 repetition with fragment",
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allow_with_duplicates_canonicalize">test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_with_duplicates_canonicalize</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allow_with_duplicates_canonicalize</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_extract_filter_allow_with_duplicates_canonicalize>

    def test_extract_filter_allow_with_duplicates_canonicalize(self):
        lx = self.extractor_cls(allow=("sample",), unique=False, canonicalize=True)
        self.assertEqual(
>           [link for link in lx.extract_links(self.response)],
            [
                Link(url="http://example.com/sample1.html", text=""),
                Link(url="http://example.com/sample2.html", text="sample 2"),
                Link(url="http://example.com/sample3.html", text="sample 3 text"),
                Link(
                    url="http://example.com/sample3.html",
                    text="sample 3 repetition",
                ),
                Link(
                    url="http://example.com/sample3.html",
                    text="sample 3 repetition",
                ),
                Link(
                    url="http://example.com/sample3.html",
                    text="sample 3 repetition with fragment",
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_extract_filter_allowed_domains">test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allowed_domains</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_extract_filter_allowed_domains</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_extract_filter_allowed_domains>

    def test_extract_filter_allowed_domains(self):
        lx = self.extractor_cls(allow_domains=("google.com",))
        self.assertEqual(
>           [link for link in lx.extract_links(self.response)],
            [
                Link(url="http://www.google.com/something", text=""),
            ],
        )

/testbed/tests/test_linkextractors.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_extraction_using_single_values">test_linkextractors.py::LxmlLinkExtractorTestCase::test_extraction_using_single_values</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_extraction_using_single_values</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_extraction_using_single_values>

    def test_extraction_using_single_values(self):
        """Test the extractor's behaviour among different situations"""

        lx = self.extractor_cls(allow="sample")
        self.assertEqual(
>           [link for link in lx.extract_links(self.response)],
            [
                Link(url="http://example.com/sample1.html", text=""),
                Link(url="http://example.com/sample2.html", text="sample 2"),
                Link(url="http://example.com/sample3.html", text="sample 3 text"),
                Link(
                    url="http://example.com/sample3.html#foo",
                    text="sample 3 repetition with fragment",
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_ftp_links">test_linkextractors.py::LxmlLinkExtractorTestCase::test_ftp_links</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_ftp_links</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_ftp_links>

    def test_ftp_links(self):
        body = b"""
        <html><body>
        <div><a href="ftp://www.external.com/">An Item</a></div>
        </body></html>"""
        response = HtmlResponse(
            "http://www.example.com/index.html", body=body, encoding="utf8"
        )
        lx = self.extractor_cls()
        self.assertEqual(
>           lx.extract_links(response),
            [
                Link(
                    url="ftp://www.external.com/",
                    text="An Item",
                    fragment="",
                    nofollow=False,
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:732: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://www.example.com/index.html>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_ignored_extensions">test_linkextractors.py::LxmlLinkExtractorTestCase::test_ignored_extensions</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_ignored_extensions</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_ignored_extensions>

    def test_ignored_extensions(self):
        # jpg is ignored by default
        html = b"""<a href="page.html">asd</a> and <a href="photo.jpg">"""
        response = HtmlResponse("http://example.org/", body=html)
        lx = self.extractor_cls()
        self.assertEqual(
>           lx.extract_links(response),
            [
                Link(url="http://example.org/page.html", text="asd"),
            ],
        )

/testbed/tests/test_linkextractors.py:408: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.org/>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_link_extractor_aggregation">test_linkextractors.py::LxmlLinkExtractorTestCase::test_link_extractor_aggregation</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_link_extractor_aggregation</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_link_extractor_aggregation>

    def test_link_extractor_aggregation(self):
        """When a parameter like restrict_css is used, the underlying
        implementation calls its internal link extractor once per selector
        matching the specified restrictions, and then aggregates the
        extracted links.

        Test that aggregation respects the unique and canonicalize
        parameters.
        """
        # unique=True (default), canonicalize=False (default)
        lx = self.extractor_cls(restrict_css=("div",))
        response = HtmlResponse(
            "https://example.com",
            body=b"""
                <div>
                    <a href="/a">a1</a>
                    <a href="/b?a=1&b=2">b1</a>
                </div>
                <div>
                    <a href="/a">a2</a>
                    <a href="/b?b=2&a=1">b2</a>
                </div>
            """,
        )
>       actual = lx.extract_links(response)

/testbed/tests/test_linkextractors.py:771: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 https://example.com>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_link_restrict_text">test_linkextractors.py::LxmlLinkExtractorTestCase::test_link_restrict_text</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_link_restrict_text</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_link_restrict_text>

    def test_link_restrict_text(self):
        html = b"""
        <a href="http://example.org/item1.html">Pic of a cat</a>
        <a href="http://example.org/item2.html">Pic of a dog</a>
        <a href="http://example.org/item3.html">Pic of a cow</a>
        """
        response = HtmlResponse("http://example.org/index.html", body=html)
        # Simple text inclusion test
        lx = self.extractor_cls(restrict_text="dog")
        self.assertEqual(
>           [link for link in lx.extract_links(response)],
            [
                Link(
                    url="http://example.org/item2.html",
                    text="Pic of a dog",
                    nofollow=False,
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:893: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.org/index.html>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_link_wrong_href">test_linkextractors.py::LxmlLinkExtractorTestCase::test_link_wrong_href</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_link_wrong_href</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_link_wrong_href>

    def test_link_wrong_href(self):
        html = b"""
        <a href="http://example.org/item1.html">Item 1</a>
        <a href="http://[example.org/item2.html">Item 2</a>
        <a href="http://example.org/item3.html">Item 3</a>
        """
        response = HtmlResponse("http://example.org/index.html", body=html)
        lx = self.extractor_cls()
        self.assertEqual(
>           [link for link in lx.extract_links(response)],
            [
                Link(
                    url="http://example.org/item1.html", text="Item 1", nofollow=False
                ),
                Link(
                    url="http://example.org/item3.html", text="Item 3", nofollow=False
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:872: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.org/index.html>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_matches">test_linkextractors.py::LxmlLinkExtractorTestCase::test_matches</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_matches</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_matches>

    def test_matches(self):
        url1 = "http://lotsofstuff.com/stuff1/index"
        url2 = "http://evenmorestuff.com/uglystuff/index"

        lx = self.extractor_cls(allow=(r"stuff1",))
>       self.assertEqual(lx.matches(url1), True)
E       AttributeError: 'LxmlLinkExtractor' object has no attribute 'matches'

/testbed/tests/test_linkextractors.py:238: AttributeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_nofollow">test_linkextractors.py::LxmlLinkExtractorTestCase::test_nofollow</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_nofollow</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_nofollow>

    def test_nofollow(self):
        '''Test the extractor's behaviour for links with rel="nofollow"'''

        html = b"""<html><head><title>Page title<title>
        <body>
        <div class='links'>
        <p><a href="/about.html">About us</a></p>
        </div>
        <div>
        <p><a href="/follow.html">Follow this link</a></p>
        </div>
        <div>
        <p><a href="/nofollow.html" rel="nofollow">Dont follow this one</a></p>
        </div>
        <div>
        <p><a href="/nofollow2.html" rel="blah">Choose to follow or not</a></p>
        </div>
        <div>
        <p><a href="http://google.com/something" rel="external nofollow">External link not to follow</a></p>
        </div>
        </body></html>"""
        response = HtmlResponse("http://example.org/somepage/index.html", body=html)

        lx = self.extractor_cls()
        self.assertEqual(
>           lx.extract_links(response),
            [
                Link(url="http://example.org/about.html", text="About us"),
                Link(url="http://example.org/follow.html", text="Follow this link"),
                Link(
                    url="http://example.org/nofollow.html",
                    text="Dont follow this one",
                    nofollow=True,
                ),
                Link(
                    url="http://example.org/nofollow2.html",
                    text="Choose to follow or not",
                ),
                Link(
                    url="http://google.com/something",
                    text="External link not to follow",
                    nofollow=True,
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.org/somepage/index.html>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_process_value">test_linkextractors.py::LxmlLinkExtractorTestCase::test_process_value</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_process_value</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_process_value>

            def test_process_value(self):
                """Test restrict_xpaths with encodings"""
                html = b"""
    <a href="javascript:goToPage('../other/page.html','photo','width=600,height=540,scrollbars'); return false">Text</a>
    <a href="/about.html">About us</a>
                """
                response = HtmlResponse(
                    "http://example.org/somepage/index.html",
                    body=html,
                    encoding="windows-1252",
                )

                def process_value(value):
                    m = re.search(r"javascript:goToPage\('(.*?)'", value)
                    if m:
                        return m.group(1)

                lx = self.extractor_cls(process_value=process_value)
                self.assertEqual(
>                   lx.extract_links(response),
                    [Link(url="http://example.org/other/page.html", text="Text")],
                )

/testbed/tests/test_linkextractors.py:442: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.org/somepage/index.html>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_restrict_css">test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_css</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_css</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_restrict_css>

    def test_restrict_css(self):
        lx = self.extractor_cls(restrict_css=("#subwrapper a",))
        self.assertEqual(
>           lx.extract_links(self.response),
            [Link(url="http://example.com/sample2.html", text="sample 2")],
        )

/testbed/tests/test_linkextractors.py:329: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_restrict_css_and_restrict_xpaths_together">test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_css_and_restrict_xpaths_together</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_css_and_restrict_xpaths_together</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_restrict_css_and_restrict_xpaths_together>

    def test_restrict_css_and_restrict_xpaths_together(self):
        lx = self.extractor_cls(
            restrict_xpaths=('//div[@id="subwrapper"]',),
            restrict_css=("#subwrapper + a",),
        )
        self.assertEqual(
>           [link for link in lx.extract_links(self.response)],
            [
                Link(url="http://example.com/sample1.html", text=""),
                Link(url="http://example.com/sample2.html", text="sample 2"),
                Link(url="http://example.com/sample3.html", text="sample 3 text"),
            ],
        )

/testbed/tests/test_linkextractors.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_restrict_xpaths">test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_restrict_xpaths>

    def test_restrict_xpaths(self):
        lx = self.extractor_cls(restrict_xpaths=('//div[@id="subwrapper"]',))
        self.assertEqual(
>           [link for link in lx.extract_links(self.response)],
            [
                Link(url="http://example.com/sample1.html", text=""),
                Link(url="http://example.com/sample2.html", text="sample 2"),
            ],
        )

/testbed/tests/test_linkextractors.py:267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_restrict_xpaths_concat_in_handle_data">test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths_concat_in_handle_data</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths_concat_in_handle_data</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_restrict_xpaths_concat_in_handle_data>

    def test_restrict_xpaths_concat_in_handle_data(self):
        """html entities cause SGMLParser to call handle_data hook twice"""
        body = b"""<html><body><div><a href="/foo">&gt;\xbe\xa9&lt;\xb6\xab</a></body></html>"""
        response = HtmlResponse("http://example.org", body=body, encoding="gb18030")
        lx = self.extractor_cls(restrict_xpaths="//div")
        self.assertEqual(
>           lx.extract_links(response),
            [
                Link(
                    url="http://example.org/foo",
                    text=">\u4eac<\u4e1c",
                    fragment="",
                    nofollow=False,
                )
            ],
        )

/testbed/tests/test_linkextractors.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.org>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_restrict_xpaths_encoding">test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths_encoding</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths_encoding</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_restrict_xpaths_encoding>

    def test_restrict_xpaths_encoding(self):
        """Test restrict_xpaths with encodings"""
        html = b"""<html><head><title>Page title<title>
        <body><p><a href="item/12.html">Item 12</a></p>
        <div class='links'>
        <p><a href="/about.html">About us\xa3</a></p>
        </div>
        <div>
        <p><a href="/nofollow.html">This shouldn't be followed</a></p>
        </div>
        </body></html>"""
        response = HtmlResponse(
            "http://example.org/somepage/index.html",
            body=html,
            encoding="windows-1252",
        )

        lx = self.extractor_cls(restrict_xpaths="//div[@class='links']")
        self.assertEqual(
>           lx.extract_links(response),
            [Link(url="http://example.org/about.html", text="About us\xa3")],
        )

/testbed/tests/test_linkextractors.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.org/somepage/index.html>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_restrict_xpaths_with_html_entities">test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths_with_html_entities</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_restrict_xpaths_with_html_entities</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_restrict_xpaths_with_html_entities>

    def test_restrict_xpaths_with_html_entities(self):
>       super().test_restrict_xpaths_with_html_entities()

/testbed/tests/test_linkextractors.py:933: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_linkextractors.py:304: in test_restrict_xpaths_with_html_entities
    links = self.extractor_cls(restrict_xpaths="//p").extract_links(response)
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.org/somepage/index.html>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_skip_bad_links">test_linkextractors.py::LxmlLinkExtractorTestCase::test_skip_bad_links</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_skip_bad_links</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_skip_bad_links>

    @mark.skipif(
        Version(w3lib_version) < Version("2.0.0"),
        reason=(
            "Before w3lib 2.0.0, w3lib.url.safe_url_string would not complain "
            "about an invalid port value."
        ),
    )
    def test_skip_bad_links(self):
        html = b"""
        <a href="http://example.org:non-port">Why would you do this?</a>
        <a href="http://example.org/item2.html">Good Link</a>
        <a href="http://example.org/item3.html">Good Link 2</a>
        """
        response = HtmlResponse("http://example.org/index.html", body=html)
        lx = self.extractor_cls()
        self.assertEqual(
>           [link for link in lx.extract_links(response)],
            [
                Link(
                    url="http://example.org/item2.html",
                    text="Good Link",
                    nofollow=False,
                ),
                Link(
                    url="http://example.org/item3.html",
                    text="Good Link 2",
                    nofollow=False,
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:951: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.org/index.html>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_tags">test_linkextractors.py::LxmlLinkExtractorTestCase::test_tags</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_tags</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_tags>

    def test_tags(self):
        html = (
            b'<html><area href="sample1.html"></area>'
            b'<a href="sample2.html">sample 2</a><img src="sample2.jpg"/></html>'
        )
        response = HtmlResponse("http://example.com/index.html", body=html)

        lx = self.extractor_cls(tags=None)
>       self.assertEqual(lx.extract_links(response), [])

/testbed/tests/test_linkextractors.py:508: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index.html>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_tags_attrs">test_linkextractors.py::LxmlLinkExtractorTestCase::test_tags_attrs</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_tags_attrs</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_tags_attrs>

    def test_tags_attrs(self):
        html = b"""
        <html><body>
        <div id="item1" data-url="get?id=1"><a href="#">Item 1</a></div>
        <div id="item2" data-url="get?id=2"><a href="#">Item 2</a></div>
        </body></html>
        """
        response = HtmlResponse("http://example.com/index.html", body=html)

        lx = self.extractor_cls(tags="div", attrs="data-url")
        self.assertEqual(
>           lx.extract_links(response),
            [
                Link(
                    url="http://example.com/get?id=1",
                    text="Item 1",
                    fragment="",
                    nofollow=False,
                ),
                Link(
                    url="http://example.com/get?id=2",
                    text="Item 2",
                    fragment="",
                    nofollow=False,
                ),
            ],
        )

/testbed/tests/test_linkextractors.py:557: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index.html>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_urls_type">test_linkextractors.py::LxmlLinkExtractorTestCase::test_urls_type</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_urls_type</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_urls_type>

    def test_urls_type(self):
        """Test that the resulting urls are str objects"""
        lx = self.extractor_cls()
        self.assertTrue(
            all(
                isinstance(link.url, str)
>               for link in lx.extract_links(self.response)
            )
        )

/testbed/tests/test_linkextractors.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_linkextractorspylxmllinkextractortestcasetest_xhtml">test_linkextractors.py::LxmlLinkExtractorTestCase::test_xhtml</h3>
<details><summary> <pre>test_linkextractors.py::LxmlLinkExtractorTestCase::test_xhtml</pre></summary><pre>
self = <tests.test_linkextractors.LxmlLinkExtractorTestCase testMethod=test_xhtml>

        def test_xhtml(self):
            xhtml = b"""
    <?xml version="1.0"?>
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <title>XHTML document title</title>
    </head>
    <body>
        <div class='links'>
        <p><a href="/about.html">About us</a></p>
        </div>
        <div>
        <p><a href="/follow.html">Follow this link</a></p>
        </div>
        <div>
        <p><a href="/nofollow.html" rel="nofollow">Dont follow this one</a></p>
        </div>
        <div>
        <p><a href="/nofollow2.html" rel="blah">Choose to follow or not</a></p>
        </div>
        <div>
        <p><a href="http://google.com/something" rel="external nofollow">External link not to follow</a></p>
        </div>
    </body>
    </html>
            """

            response = HtmlResponse("http://example.com/index.xhtml", body=xhtml)

            lx = self.extractor_cls()
            self.assertEqual(
>               lx.extract_links(response),
                [
                    Link(
                        url="http://example.com/about.html",
                        text="About us",
                        fragment="",
                        nofollow=False,
                    ),
                    Link(
                        url="http://example.com/follow.html",
                        text="Follow this link",
                        fragment="",
                        nofollow=False,
                    ),
                    Link(
                        url="http://example.com/nofollow.html",
                        text="Dont follow this one",
                        fragment="",
                        nofollow=True,
                    ),
                    Link(
                        url="http://example.com/nofollow2.html",
                        text="Choose to follow or not",
                        fragment="",
                        nofollow=False,
                    ),
                    Link(
                        url="http://google.com/something",
                        text="External link not to follow",
                        nofollow=True,
                    ),
                ],
            )

/testbed/tests/test_linkextractors.py:626: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/linkextractors/lxmlhtml.py:88: in extract_links
    base_url = get_base_url(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://example.com/index.xhtml>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_add_css_re">test_loader.py::SelectortemLoaderTest::test_add_css_re</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_add_css_re</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_add_css_re>

    def test_add_css_re(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95f93f50>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_add_xpath_re">test_loader.py::SelectortemLoaderTest::test_add_xpath_re</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_add_xpath_re</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_add_xpath_re>

    def test_add_xpath_re(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95f93700>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_get_css">test_loader.py::SelectortemLoaderTest::test_get_css</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_get_css</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_get_css>

    def test_get_css(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:418: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc6dd0>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_get_xpath">test_loader.py::SelectortemLoaderTest::test_get_xpath</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_get_xpath</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_get_xpath>

    def test_get_xpath(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc69e0>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_init_method_with_base_response">test_loader.py::SelectortemLoaderTest::test_init_method_with_base_response</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_init_method_with_base_response</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_init_method_with_base_response>

    def test_init_method_with_base_response(self):
        """Selector should be None after initialization"""
        response = Response("https://scrapy.org")
>       l = TestItemLoader(response=response)

/testbed/tests/test_loader.py:323: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc6ac0>
response = <200 https://scrapy.org>, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_init_method_with_response">test_loader.py::SelectortemLoaderTest::test_init_method_with_response</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_init_method_with_response</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_init_method_with_response>

    def test_init_method_with_response(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:327: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc7230>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_init_method_with_response_css">test_loader.py::SelectortemLoaderTest::test_init_method_with_response_css</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_init_method_with_response_css</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_init_method_with_response_css>

    def test_init_method_with_response_css(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:334: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc70e0>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_init_method_with_selector">test_loader.py::SelectortemLoaderTest::test_init_method_with_selector</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_init_method_with_selector</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_init_method_with_selector>

    def test_init_method_with_selector(self):
>       sel = Selector(text="<html><body><div>marta</div></body></html>")

/testbed/tests/test_loader.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc6eb0>
response = None, text = '<html><body><div>marta</div></body></html>'
type = None, root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_init_method_with_selector_css">test_loader.py::SelectortemLoaderTest::test_init_method_with_selector_css</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_init_method_with_selector_css</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_init_method_with_selector_css>

    def test_init_method_with_selector_css(self):
>       sel = Selector(text="<html><body><div>marta</div></body></html>")

/testbed/tests/test_loader.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc6b30>
response = None, text = '<html><body><div>marta</div></body></html>'
type = None, root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_replace_css">test_loader.py::SelectortemLoaderTest::test_replace_css</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_replace_css</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_replace_css>

    def test_replace_css(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:402: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc6e40>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_replace_css_multi_fields">test_loader.py::SelectortemLoaderTest::test_replace_css_multi_fields</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_replace_css_multi_fields</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_replace_css_multi_fields>

    def test_replace_css_multi_fields(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc6890>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_replace_css_re">test_loader.py::SelectortemLoaderTest::test_replace_css_re</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_replace_css_re</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_replace_css_re>

    def test_replace_css_re(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:442: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb962afe00>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_replace_xpath">test_loader.py::SelectortemLoaderTest::test_replace_xpath</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_replace_xpath</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_replace_xpath>

    def test_replace_xpath(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc73f0>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_replace_xpath_multi_fields">test_loader.py::SelectortemLoaderTest::test_replace_xpath_multi_fields</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_replace_xpath_multi_fields</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_replace_xpath_multi_fields>

    def test_replace_xpath_multi_fields(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:379: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc7460>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpyselectortemloadertesttest_replace_xpath_re">test_loader.py::SelectortemLoaderTest::test_replace_xpath_re</h3>
<details><summary> <pre>test_loader.py::SelectortemLoaderTest::test_replace_xpath_re</pre></summary><pre>
self = <tests.test_loader.SelectortemLoaderTest testMethod=test_replace_xpath_re>

    def test_replace_xpath_re(self):
>       l = TestItemLoader(response=self.response)

/testbed/tests/test_loader.py:386: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95bc7620>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpysubselectorloadertesttest_nested_css">test_loader.py::SubselectorLoaderTest::test_nested_css</h3>
<details><summary> <pre>test_loader.py::SubselectorLoaderTest::test_nested_css</pre></summary><pre>
self = <tests.test_loader.SubselectorLoaderTest testMethod=test_nested_css>

    def test_nested_css(self):
>       l = NestedItemLoader(response=self.response)

/testbed/tests/test_loader.py:491: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95f938c0>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpysubselectorloadertesttest_nested_load_item">test_loader.py::SubselectorLoaderTest::test_nested_load_item</h3>
<details><summary> <pre>test_loader.py::SubselectorLoaderTest::test_nested_load_item</pre></summary><pre>
self = <tests.test_loader.SubselectorLoaderTest testMethod=test_nested_load_item>

    def test_nested_load_item(self):
>       l = NestedItemLoader(response=self.response)

/testbed/tests/test_loader.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb962afe00>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpysubselectorloadertesttest_nested_ordering">test_loader.py::SubselectorLoaderTest::test_nested_ordering</h3>
<details><summary> <pre>test_loader.py::SubselectorLoaderTest::test_nested_ordering</pre></summary><pre>
self = <tests.test_loader.SubselectorLoaderTest testMethod=test_nested_ordering>

    def test_nested_ordering(self):
>       l = NestedItemLoader(response=self.response)

/testbed/tests/test_loader.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb9603ef90>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpysubselectorloadertesttest_nested_replace">test_loader.py::SubselectorLoaderTest::test_nested_replace</h3>
<details><summary> <pre>test_loader.py::SubselectorLoaderTest::test_nested_replace</pre></summary><pre>
self = <tests.test_loader.SubselectorLoaderTest testMethod=test_nested_replace>

    def test_nested_replace(self):
>       l = NestedItemLoader(response=self.response)

/testbed/tests/test_loader.py:510: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95f93850>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loaderpysubselectorloadertesttest_nested_xpath">test_loader.py::SubselectorLoaderTest::test_nested_xpath</h3>
<details><summary> <pre>test_loader.py::SubselectorLoaderTest::test_nested_xpath</pre></summary><pre>
self = <tests.test_loader.SubselectorLoaderTest testMethod=test_nested_xpath>

    def test_nested_xpath(self):
>       l = NestedItemLoader(response=self.response)

/testbed/tests/test_loader.py:471: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/loader/__init__.py:87: in __init__
    selector = self.default_selector_class(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95f93700>
response = <200 >, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_loader_deprecatedpydeprecatedutilityfunctionstestcasetest_deprecated_extract_regex">test_loader_deprecated.py::DeprecatedUtilityFunctionsTestCase::test_deprecated_extract_regex</h3>
<details><summary> <pre>test_loader_deprecated.py::DeprecatedUtilityFunctionsTestCase::test_deprecated_extract_regex</pre></summary><pre>
self = <tests.test_loader_deprecated.DeprecatedUtilityFunctionsTestCase testMethod=test_deprecated_extract_regex>

    def test_deprecated_extract_regex(self):
        with warnings.catch_warnings(record=True) as w:
            extract_regex(r"\w+", "this is a test")

>           assert len(w) == 1
E           AssertionError

/testbed/tests/test_loader_deprecated.py:740: AssertionError
</pre>
</details>
<h3 id="test_loader_deprecatedpydeprecatedutilityfunctionstestcasetest_deprecated_wrap_loader_context">test_loader_deprecated.py::DeprecatedUtilityFunctionsTestCase::test_deprecated_wrap_loader_context</h3>
<details><summary> <pre>test_loader_deprecated.py::DeprecatedUtilityFunctionsTestCase::test_deprecated_wrap_loader_context</pre></summary><pre>
self = <tests.test_loader_deprecated.DeprecatedUtilityFunctionsTestCase testMethod=test_deprecated_wrap_loader_context>

    def test_deprecated_wrap_loader_context(self):
        def function(*args):
            return None

        with warnings.catch_warnings(record=True) as w:
            wrap_loader_context(function, context={})

>           assert len(w) == 1
E           AssertionError

/testbed/tests/test_loader_deprecated.py:733: AssertionError
</pre>
</details>
<h3 id="test_mailpymailsendertesttest_create_sender_factory_with_host">test_mail.py::MailSenderTest::test_create_sender_factory_with_host</h3>
<details><summary> <pre>test_mail.py::MailSenderTest::test_create_sender_factory_with_host</pre></summary><pre>
self = <tests.test_mail.MailSenderTest testMethod=test_create_sender_factory_with_host>

    def test_create_sender_factory_with_host(self):
>       mailsender = MailSender(debug=False, smtphost="smtp.testhost.com")

/testbed/tests/test_mail.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.mail.MailSender object at 0x7fcb95ff5d00>
smtphost = 'smtp.testhost.com', mailfrom = 'scrapy@localhost', smtpuser = None
smtppass = None, smtpport = 25, smtptls = False, smtpssl = False, debug = False

    def __init__(self, smtphost='localhost', mailfrom='scrapy@localhost', smtpuser=None, smtppass=None, smtpport=25, smtptls=False, smtpssl=False, debug=False):
        self.smtphost = smtphost
        self.smtpport = smtpport
>       self.smtpuser = _to_bytes_or_none(smtpuser)
E       NameError: name '_to_bytes_or_none' is not defined

/testbed/scrapy/mail.py:27: NameError
</pre>
</details>
<h3 id="test_mailpymailsendertesttest_send">test_mail.py::MailSenderTest::test_send</h3>
<details><summary> <pre>test_mail.py::MailSenderTest::test_send</pre></summary><pre>
self = <tests.test_mail.MailSenderTest testMethod=test_send>

    def test_send(self):
>       mailsender = MailSender(debug=True)

/testbed/tests/test_mail.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.mail.MailSender object at 0x7fcb95ff4830>, smtphost = 'localhost'
mailfrom = 'scrapy@localhost', smtpuser = None, smtppass = None, smtpport = 25
smtptls = False, smtpssl = False, debug = True

    def __init__(self, smtphost='localhost', mailfrom='scrapy@localhost', smtpuser=None, smtppass=None, smtpport=25, smtptls=False, smtpssl=False, debug=False):
        self.smtphost = smtphost
        self.smtpport = smtpport
>       self.smtpuser = _to_bytes_or_none(smtpuser)
E       NameError: name '_to_bytes_or_none' is not defined

/testbed/scrapy/mail.py:27: NameError
</pre>
</details>
<h3 id="test_mailpymailsendertesttest_send_attach">test_mail.py::MailSenderTest::test_send_attach</h3>
<details><summary> <pre>test_mail.py::MailSenderTest::test_send_attach</pre></summary><pre>
self = <tests.test_mail.MailSenderTest testMethod=test_send_attach>

    def test_send_attach(self):
        attach = BytesIO()
        attach.write(b"content")
        attach.seek(0)
        attachs = [("attachment", "text/plain", attach)]

>       mailsender = MailSender(debug=True)

/testbed/tests/test_mail.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.mail.MailSender object at 0x7fcb95bd9d90>, smtphost = 'localhost'
mailfrom = 'scrapy@localhost', smtpuser = None, smtppass = None, smtpport = 25
smtptls = False, smtpssl = False, debug = True

    def __init__(self, smtphost='localhost', mailfrom='scrapy@localhost', smtpuser=None, smtppass=None, smtpport=25, smtptls=False, smtpssl=False, debug=False):
        self.smtphost = smtphost
        self.smtpport = smtpport
>       self.smtpuser = _to_bytes_or_none(smtpuser)
E       NameError: name '_to_bytes_or_none' is not defined

/testbed/scrapy/mail.py:27: NameError
</pre>
</details>
<h3 id="test_mailpymailsendertesttest_send_attach_utf8">test_mail.py::MailSenderTest::test_send_attach_utf8</h3>
<details><summary> <pre>test_mail.py::MailSenderTest::test_send_attach_utf8</pre></summary><pre>
self = <tests.test_mail.MailSenderTest testMethod=test_send_attach_utf8>

    def test_send_attach_utf8(self):
        subject = "sübjèçt"
        body = "bödÿ-àéïöñß"
        attach = BytesIO()
        attach.write(body.encode("utf-8"))
        attach.seek(0)
        attachs = [("attachment", "text/plain", attach)]

>       mailsender = MailSender(debug=True)

/testbed/tests/test_mail.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.mail.MailSender object at 0x7fcb95bdb560>, smtphost = 'localhost'
mailfrom = 'scrapy@localhost', smtpuser = None, smtppass = None, smtpport = 25
smtptls = False, smtpssl = False, debug = True

    def __init__(self, smtphost='localhost', mailfrom='scrapy@localhost', smtpuser=None, smtppass=None, smtpport=25, smtptls=False, smtpssl=False, debug=False):
        self.smtphost = smtphost
        self.smtpport = smtpport
>       self.smtpuser = _to_bytes_or_none(smtpuser)
E       NameError: name '_to_bytes_or_none' is not defined

/testbed/scrapy/mail.py:27: NameError
</pre>
</details>
<h3 id="test_mailpymailsendertesttest_send_html">test_mail.py::MailSenderTest::test_send_html</h3>
<details><summary> <pre>test_mail.py::MailSenderTest::test_send_html</pre></summary><pre>
self = <tests.test_mail.MailSenderTest testMethod=test_send_html>

    def test_send_html(self):
>       mailsender = MailSender(debug=True)

/testbed/tests/test_mail.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.mail.MailSender object at 0x7fcb95bd94c0>, smtphost = 'localhost'
mailfrom = 'scrapy@localhost', smtpuser = None, smtppass = None, smtpport = 25
smtptls = False, smtpssl = False, debug = True

    def __init__(self, smtphost='localhost', mailfrom='scrapy@localhost', smtpuser=None, smtppass=None, smtpport=25, smtptls=False, smtpssl=False, debug=False):
        self.smtphost = smtphost
        self.smtpport = smtpport
>       self.smtpuser = _to_bytes_or_none(smtpuser)
E       NameError: name '_to_bytes_or_none' is not defined

/testbed/scrapy/mail.py:27: NameError
</pre>
</details>
<h3 id="test_mailpymailsendertesttest_send_single_values_to_and_cc">test_mail.py::MailSenderTest::test_send_single_values_to_and_cc</h3>
<details><summary> <pre>test_mail.py::MailSenderTest::test_send_single_values_to_and_cc</pre></summary><pre>
self = <tests.test_mail.MailSenderTest testMethod=test_send_single_values_to_and_cc>

    def test_send_single_values_to_and_cc(self):
>       mailsender = MailSender(debug=True)

/testbed/tests/test_mail.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.mail.MailSender object at 0x7fcb95bda180>, smtphost = 'localhost'
mailfrom = 'scrapy@localhost', smtpuser = None, smtppass = None, smtpport = 25
smtptls = False, smtpssl = False, debug = True

    def __init__(self, smtphost='localhost', mailfrom='scrapy@localhost', smtpuser=None, smtppass=None, smtpport=25, smtptls=False, smtpssl=False, debug=False):
        self.smtphost = smtphost
        self.smtpport = smtpport
>       self.smtpuser = _to_bytes_or_none(smtpuser)
E       NameError: name '_to_bytes_or_none' is not defined

/testbed/scrapy/mail.py:27: NameError
</pre>
</details>
<h3 id="test_mailpymailsendertesttest_send_utf8">test_mail.py::MailSenderTest::test_send_utf8</h3>
<details><summary> <pre>test_mail.py::MailSenderTest::test_send_utf8</pre></summary><pre>
self = <tests.test_mail.MailSenderTest testMethod=test_send_utf8>

    def test_send_utf8(self):
        subject = "sübjèçt"
        body = "bödÿ-àéïöñß"
>       mailsender = MailSender(debug=True)

/testbed/tests/test_mail.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.mail.MailSender object at 0x7fcb95bdb200>, smtphost = 'localhost'
mailfrom = 'scrapy@localhost', smtpuser = None, smtppass = None, smtpport = 25
smtptls = False, smtpssl = False, debug = True

    def __init__(self, smtphost='localhost', mailfrom='scrapy@localhost', smtpuser=None, smtppass=None, smtpport=25, smtptls=False, smtpssl=False, debug=False):
        self.smtphost = smtphost
        self.smtpport = smtpport
>       self.smtpuser = _to_bytes_or_none(smtpuser)
E       NameError: name '_to_bytes_or_none' is not defined

/testbed/scrapy/mail.py:27: NameError
</pre>
</details>
<h3 id="test_middlewarepymiddlewaremanagertesttest_enabled">test_middleware.py::MiddlewareManagerTest::test_enabled</h3>
<details><summary> <pre>test_middleware.py::MiddlewareManagerTest::test_enabled</pre></summary><pre>
self = <tests.test_middleware.MiddlewareManagerTest testMethod=test_enabled>

    def test_enabled(self):
        m1, m2, m3 = M1(), M2(), M3()
>       mwman = MiddlewareManager(m1, m2, m3)

/testbed/tests/test_middleware.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.middleware.MiddlewareManager object at 0x7fcb95bd80b0>
middlewares = (<tests.test_middleware.M1 object at 0x7fcb95bd9b80>, <tests.test_middleware.M2 object at 0x7fcb95bd8740>, <tests.test_middleware.M3 object at 0x7fcb95bda1e0>)
mw = <tests.test_middleware.M1 object at 0x7fcb95bd9b80>

    def __init__(self, *middlewares: Any) -> None:
        self.middlewares = middlewares
        self.methods: Dict[str, Deque[Union[None, Callable, Tuple[Callable, Callable]]]] = defaultdict(deque)
        for mw in middlewares:
>           self._add_middleware(mw)
E           AttributeError: 'MiddlewareManager' object has no attribute '_add_middleware'

/testbed/scrapy/middleware.py:25: AttributeError
</pre>
</details>
<h3 id="test_middlewarepymiddlewaremanagertesttest_enabled_from_settings">test_middleware.py::MiddlewareManagerTest::test_enabled_from_settings</h3>
<details><summary> <pre>test_middleware.py::MiddlewareManagerTest::test_enabled_from_settings</pre></summary><pre>
self = <tests.test_middleware.MiddlewareManagerTest testMethod=test_enabled_from_settings>

    def test_enabled_from_settings(self):
        settings = Settings()
>       mwman = TestMiddlewareManager.from_settings(settings)
E       AttributeError: type object 'TestMiddlewareManager' has no attribute 'from_settings'

/testbed/tests/test_middleware.py:87: AttributeError
</pre>
</details>
<h3 id="test_middlewarepymiddlewaremanagertesttest_init">test_middleware.py::MiddlewareManagerTest::test_init</h3>
<details><summary> <pre>test_middleware.py::MiddlewareManagerTest::test_init</pre></summary><pre>
self = <tests.test_middleware.MiddlewareManagerTest testMethod=test_init>

    def test_init(self):
        m1, m2, m3 = M1(), M2(), M3()
>       mwman = TestMiddlewareManager(m1, m2, m3)

/testbed/tests/test_middleware.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/middleware.py:25: in __init__
    self._add_middleware(mw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_middleware.TestMiddlewareManager object at 0x7fcb95cb7050>
mw = <tests.test_middleware.M1 object at 0x7fcb95cb6fc0>

    def _add_middleware(self, mw):
>       super()._add_middleware(mw)
E       AttributeError: 'super' object has no attribute '_add_middleware'

/testbed/tests/test_middleware.py:51: AttributeError
</pre>
</details>
<h3 id="test_middlewarepymiddlewaremanagertesttest_methods">test_middleware.py::MiddlewareManagerTest::test_methods</h3>
<details><summary> <pre>test_middleware.py::MiddlewareManagerTest::test_methods</pre></summary><pre>
self = <tests.test_middleware.MiddlewareManagerTest testMethod=test_methods>

    def test_methods(self):
>       mwman = TestMiddlewareManager(M1(), M2(), M3())

/testbed/tests/test_middleware.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/middleware.py:25: in __init__
    self._add_middleware(mw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_middleware.TestMiddlewareManager object at 0x7fcb95ff42c0>
mw = <tests.test_middleware.M1 object at 0x7fcb95ff42f0>

    def _add_middleware(self, mw):
>       super()._add_middleware(mw)
E       AttributeError: 'super' object has no attribute '_add_middleware'

/testbed/tests/test_middleware.py:51: AttributeError
</pre>
</details>
<h3 id="test_request_dictpyrequestserializationtesttest_callback_not_available">test_request_dict.py::RequestSerializationTest::test_callback_not_available</h3>
<details><summary> <pre>test_request_dict.py::RequestSerializationTest::test_callback_not_available</pre></summary><pre>
self = <tests.test_request_dict.RequestSerializationTest testMethod=test_callback_not_available>

    def test_callback_not_available(self):
        """Callback method is not available in the spider passed to from_dict"""
        spider = TestSpiderDelegation()
        r = Request("http://www.example.com", callback=spider.delegated_callback)
        d = r.to_dict(spider=spider)
>       self.assertRaises(ValueError, request_from_dict, d, spider=Spider("foo"))

/testbed/tests/test_request_dict.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/request.py:193: in request_from_dict
    d['callback'] = _get_method(spider, callback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_method(obj: Any, name: Any) -> Any:
        """Helper function for request_from_dict"""
        if isinstance(name, str):
>           return getattr(obj, name)
E           AttributeError: 'Spider' object has no attribute 'delegated_callback'

/testbed/scrapy/utils/request.py:202: AttributeError
</pre>
</details>
<h3 id="test_request_dictpyrequestserializationtesttest_request_class">test_request_dict.py::RequestSerializationTest::test_request_class</h3>
<details><summary> <pre>test_request_dict.py::RequestSerializationTest::test_request_class</pre></summary><pre>
self = <tests.test_request_dict.RequestSerializationTest testMethod=test_request_class>

    def test_request_class(self):
        r1 = FormRequest("http://www.example.com")
>       self._assert_serializes_ok(r1, spider=self.spider)

/testbed/tests/test_request_dict.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_request_dict.py:47: in _assert_serializes_ok
    request2 = request_from_dict(d, spider=spider)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

d = {'_class': 'scrapy.http.request.form.FormRequest', 'body': b'', 'cb_kwargs': {}, 'cookies': {}, ...}

    def request_from_dict(d: dict, *, spider: Optional[Spider]=None) -> Request:
        """Create a :class:`~scrapy.Request` object from a dict.

        If a spider is given, it will try to resolve the callbacks looking at the
        spider for methods with the same name.
        """
        d = d.copy()
        callback = d.pop('callback', None)
        errback = d.pop('errback', None)
        cls = load_object(d.pop('cls')) if 'cls' in d else Request

        if callback and spider:
            d['callback'] = _get_method(spider, callback)
        if errback and spider:
            d['errback'] = _get_method(spider, errback)

>       return cls(**d)
E       TypeError: Request.__init__() got an unexpected keyword argument '_class'

/testbed/scrapy/utils/request.py:197: TypeError
</pre>
</details>
<h3 id="test_responsetypespyresponsetypestesttest_from_args">test_responsetypes.py::ResponseTypesTest::test_from_args</h3>
<details><summary> <pre>test_responsetypes.py::ResponseTypesTest::test_from_args</pre></summary><pre>
self = <tests.test_responsetypes.ResponseTypesTest testMethod=test_from_args>

    def test_from_args(self):
        # TODO: add more tests that check precedence between the different arguments
        mappings = [
            ({"url": "http://www.example.com/data.csv"}, TextResponse),
            # headers takes precedence over url
            (
                {
                    "headers": Headers({"Content-Type": ["text/html; charset=utf-8"]}),
                    "url": "http://www.example.com/item/",
                },
                HtmlResponse,
            ),
            (
                {
                    "headers": Headers(
                        {"Content-Disposition": ['attachment; filename="data.xml.gz"']}
                    ),
                    "url": "http://www.example.com/page/",
                },
                Response,
            ),
        ]
        for source, cls in mappings:
            retcls = responsetypes.from_args(**source)
>           assert retcls is cls, f"{source} ==> {retcls} != {cls}"
E           AssertionError: {'url': 'http://www.example.com/data.csv'} ==> None != <class 'scrapy.http.response.text.TextResponse'>

/testbed/tests/test_responsetypes.py:111: AssertionError
</pre>
</details>
<h3 id="test_responsetypespyresponsetypestesttest_from_body">test_responsetypes.py::ResponseTypesTest::test_from_body</h3>
<details><summary> <pre>test_responsetypes.py::ResponseTypesTest::test_from_body</pre></summary><pre>
self = <tests.test_responsetypes.ResponseTypesTest testMethod=test_from_body>

    def test_from_body(self):
        mappings = [
            (b"\x03\x02\xdf\xdd\x23", Response),
            (b"Some plain text\ndata with tabs\t and null bytes\0", TextResponse),
            (b"<html><head><title>Hello</title></head>", HtmlResponse),
            # https://codersblock.com/blog/the-smallest-valid-html5-page/
            (b"<!DOCTYPE html>\n<title>.</title>", HtmlResponse),
            (b'<?xml version="1.0" encoding="utf-8"', XmlResponse),
        ]
        for source, cls in mappings:
            retcls = responsetypes.from_body(source)
>           assert retcls is cls, f"{source} ==> {retcls} != {cls}"
E           AssertionError: b'\x03\x02\xdf\xdd#' ==> None != <class 'scrapy.http.response.Response'>

/testbed/tests/test_responsetypes.py:62: AssertionError
</pre>
</details>
<h3 id="test_responsetypespyresponsetypestesttest_from_content_disposition">test_responsetypes.py::ResponseTypesTest::test_from_content_disposition</h3>
<details><summary> <pre>test_responsetypes.py::ResponseTypesTest::test_from_content_disposition</pre></summary><pre>
self = <tests.test_responsetypes.ResponseTypesTest testMethod=test_from_content_disposition>

    def test_from_content_disposition(self):
        mappings = [
            (b'attachment; filename="data.xml"', XmlResponse),
            (b"attachment; filename=data.xml", XmlResponse),
            ("attachment;filename=data£.tar.gz".encode("utf-8"), Response),
            ("attachment;filename=dataµ.tar.gz".encode("latin-1"), Response),
            ("attachment;filename=data高.doc".encode("gbk"), Response),
            ("attachment;filename=دورهdata.html".encode("cp720"), HtmlResponse),
            ("attachment;filename=日本語版Wikipedia.xml".encode("iso2022_jp"), XmlResponse),
        ]
        for source, cls in mappings:
>           retcls = responsetypes.from_content_disposition(source)
E           AttributeError: 'ResponseTypes' object has no attribute 'from_content_disposition'

/testbed/tests/test_responsetypes.py:32: AttributeError
</pre>
</details>
<h3 id="test_responsetypespyresponsetypestesttest_from_content_type">test_responsetypes.py::ResponseTypesTest::test_from_content_type</h3>
<details><summary> <pre>test_responsetypes.py::ResponseTypesTest::test_from_content_type</pre></summary><pre>
self = <tests.test_responsetypes.ResponseTypesTest testMethod=test_from_content_type>

    def test_from_content_type(self):
        mappings = [
            ("text/html; charset=UTF-8", HtmlResponse),
            ("text/xml; charset=UTF-8", XmlResponse),
            ("application/xhtml+xml; charset=UTF-8", HtmlResponse),
            ("application/vnd.wap.xhtml+xml; charset=utf-8", HtmlResponse),
            ("application/xml; charset=UTF-8", XmlResponse),
            ("application/octet-stream", Response),
            ("application/x-json; encoding=UTF8;charset=UTF-8", TextResponse),
            ("application/json-amazonui-streaming;charset=UTF-8", TextResponse),
            (b"application/x-download; filename=\x80dummy.txt", Response),
        ]
        for source, cls in mappings:
            retcls = responsetypes.from_content_type(source)
>           assert retcls is cls, f"{source} ==> {retcls} != {cls}"
E           AssertionError: text/html; charset=UTF-8 ==> None != <class 'scrapy.http.response.html.HtmlResponse'>

/testbed/tests/test_responsetypes.py:49: AssertionError
</pre>
</details>
<h3 id="test_responsetypespyresponsetypestesttest_from_filename">test_responsetypes.py::ResponseTypesTest::test_from_filename</h3>
<details><summary> <pre>test_responsetypes.py::ResponseTypesTest::test_from_filename</pre></summary><pre>
self = <tests.test_responsetypes.ResponseTypesTest testMethod=test_from_filename>

    def test_from_filename(self):
        mappings = [
            ("data.bin", Response),
            ("file.txt", TextResponse),
            ("file.xml.gz", Response),
            ("file.xml", XmlResponse),
            ("file.html", HtmlResponse),
            ("file.unknownext", Response),
        ]
        for source, cls in mappings:
            retcls = responsetypes.from_filename(source)
>           assert retcls is cls, f"{source} ==> {retcls} != {cls}"
E           AssertionError: data.bin ==> None != <class 'scrapy.http.response.Response'>

/testbed/tests/test_responsetypes.py:19: AssertionError
</pre>
</details>
<h3 id="test_responsetypespyresponsetypestesttest_from_headers">test_responsetypes.py::ResponseTypesTest::test_from_headers</h3>
<details><summary> <pre>test_responsetypes.py::ResponseTypesTest::test_from_headers</pre></summary><pre>
self = <tests.test_responsetypes.ResponseTypesTest testMethod=test_from_headers>

    def test_from_headers(self):
        mappings = [
            ({"Content-Type": ["text/html; charset=utf-8"]}, HtmlResponse),
            (
                {
                    "Content-Type": ["text/html; charset=utf-8"],
                    "Content-Encoding": ["gzip"],
                },
                Response,
            ),
            (
                {
                    "Content-Type": ["application/octet-stream"],
                    "Content-Disposition": ["attachment; filename=data.txt"],
                },
                TextResponse,
            ),
        ]
        for source, cls in mappings:
            source = Headers(source)
            retcls = responsetypes.from_headers(source)
>           assert retcls is cls, f"{source} ==> {retcls} != {cls}"
E           AssertionError: {'Content-Type': ['text/html; charset=utf-8']} ==> None != <class 'scrapy.http.response.html.HtmlResponse'>

/testbed/tests/test_responsetypes.py:85: AssertionError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_badly_encoded_body">test_selector.py::SelectorTestCase::test_badly_encoded_body</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_badly_encoded_body</pre></summary><pre>
self = <tests.test_selector.SelectorTestCase testMethod=test_badly_encoded_body>

    def test_badly_encoded_body(self):
        # \xe9 alone isn't valid utf8 sequence
        r1 = TextResponse(
            "http://www.example.com",
            body=b"<html><p>an Jos\xe9 de</p><html>",
            encoding="utf-8",
        )
>       Selector(r1).xpath("//text()").getall()

/testbed/tests/test_selector.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95c83cb0>
response = <200 http://www.example.com>, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_flavor_detection">test_selector.py::SelectorTestCase::test_flavor_detection</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_flavor_detection</pre></summary><pre>
self = <tests.test_selector.SelectorTestCase testMethod=test_flavor_detection>

    def test_flavor_detection(self):
        text = b'<div><img src="a.jpg"><p>Hello</div>'
>       sel = Selector(XmlResponse("http://example.com", body=text, encoding="utf-8"))

/testbed/tests/test_selector.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95c83e00>
response = <200 http://example.com>, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_http_header_encoding_precedence">test_selector.py::SelectorTestCase::test_http_header_encoding_precedence</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_http_header_encoding_precedence</pre></summary><pre>
self = <tests.test_selector.SelectorTestCase testMethod=test_http_header_encoding_precedence>

    def test_http_header_encoding_precedence(self):
        # '\xa3'     = pound symbol in unicode
        # '\xc2\xa3' = pound symbol in utf-8
        # '\xa3'     = pound symbol in latin-1 (iso-8859-1)

        meta = (
            '<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">'
        )
        head = "<head>" + meta + "</head>"
        body_content = '<span id="blank">\xa3</span>'
        body = "<body>" + body_content + "</body>"
        html = "<html>" + head + body + "</html>"
        encoding = "utf-8"
        html_utf8 = html.encode(encoding)

        headers = {"Content-Type": ["text/html; charset=utf-8"]}
        response = HtmlResponse(
            url="http://example.com", headers=headers, body=html_utf8
        )
>       x = Selector(response)

/testbed/tests/test_selector.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95c83f50>
response = <200 http://example.com>, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_root_base_url">test_selector.py::SelectorTestCase::test_root_base_url</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_root_base_url</pre></summary><pre>
self = <tests.test_selector.SelectorTestCase testMethod=test_root_base_url>

    def test_root_base_url(self):
        body = b'<html><form action="/path"><input name="a" /></form></html>'
        url = "http://example.com"
        response = TextResponse(url=url, body=body, encoding="utf-8")
>       sel = Selector(response)

/testbed/tests/test_selector.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95c83150>
response = <200 http://example.com>, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_simple_selection">test_selector.py::SelectorTestCase::test_simple_selection</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_simple_selection</pre></summary><pre>
self = <tests.test_selector.SelectorTestCase testMethod=test_simple_selection>

    def test_simple_selection(self):
        """Simple selector tests"""
        body = b"<p><input name='a'value='1'/><input name='b'value='2'/></p>"
        response = TextResponse(url="http://example.com", body=body, encoding="utf-8")
>       sel = Selector(response)

/testbed/tests/test_selector.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95c14590>
response = <200 http://example.com>, text = None, type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_selectorpyselectortestcasetest_weakref_slots">test_selector.py::SelectorTestCase::test_weakref_slots</h3>
<details><summary> <pre>test_selector.py::SelectorTestCase::test_weakref_slots</pre></summary><pre>
self = <tests.test_selector.SelectorTestCase testMethod=test_weakref_slots>

    def test_weakref_slots(self):
        """Check that classes are using slots and are weak-referenceable"""
>       x = Selector(text="")

/testbed/tests/test_selector.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95c14750>
response = None, text = '', type = None
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_selectorpyjmespathtestcasetest_html_has_json">test_selector.py::JMESPathTestCase::test_html_has_json</h3>
<details><summary> <pre>test_selector.py::JMESPathTestCase::test_html_has_json</pre></summary><pre>
self = <tests.test_selector.JMESPathTestCase testMethod=test_html_has_json>

    @pytest.mark.skipif(
        not PARSEL_18_PLUS, reason="parsel < 1.8 doesn't support jmespath"
    )
    def test_html_has_json(self) -> None:
        body = """
        <div>
            <h1>Information</h1>
            <content>
            {
              "user": [
                        {
                                  "name": "A",
                                  "age": 18
                        },
                        {
                                  "name": "B",
                                  "age": 32
                        },
                        {
                                  "name": "C",
                                  "age": 22
                        },
                        {
                                  "name": "D",
                                  "age": 25
                        }
              ],
              "total": 4,
              "status": "ok"
            }
            </content>
        </div>
        """
>       resp = TextResponse(url="http://example.com", body=body, encoding="utf-8")

/testbed/tests/test_selector.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'TextResponse' object has no attribute '_url'") raised in repr()] TextResponse object at 0x7fcb95c57f80>
body = '\n        <div>\n            <h1>Information</h1>\n            <content>\n            {\n              "user": [\n   ...            "total": 4,\n              "status": "ok"\n            }\n            </content>\n        </div>\n        '

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_selectorpyjmespathtestcasetest_jmestpath_with_re">test_selector.py::JMESPathTestCase::test_jmestpath_with_re</h3>
<details><summary> <pre>test_selector.py::JMESPathTestCase::test_jmestpath_with_re</pre></summary><pre>
self = <tests.test_selector.JMESPathTestCase testMethod=test_jmestpath_with_re>

    @pytest.mark.skipif(
        not PARSEL_18_PLUS, reason="parsel < 1.8 doesn't support jmespath"
    )
    def test_jmestpath_with_re(self) -> None:
        body = """
            <div>
                <h1>Information</h1>
                <content>
                {
                  "user": [
                            {
                                      "name": "A",
                                      "age": 18
                            },
                            {
                                      "name": "B",
                                      "age": 32
                            },
                            {
                                      "name": "C",
                                      "age": 22
                            },
                            {
                                      "name": "D",
                                      "age": 25
                            }
                  ],
                  "total": 4,
                  "status": "ok"
                }
                </content>
            </div>
            """
>       resp = TextResponse(url="http://example.com", body=body, encoding="utf-8")

/testbed/tests/test_selector.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'TextResponse' object has no attribute '_url'") raised in repr()] TextResponse object at 0x7fcb95c54f50>
body = '\n            <div>\n                <h1>Information</h1>\n                <content>\n                {\n            ... 4,\n                  "status": "ok"\n                }\n                </content>\n            </div>\n            '

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_selectorpyjmespathtestcasetest_json_has_html">test_selector.py::JMESPathTestCase::test_json_has_html</h3>
<details><summary> <pre>test_selector.py::JMESPathTestCase::test_json_has_html</pre></summary><pre>
self = <tests.test_selector.JMESPathTestCase testMethod=test_json_has_html>

    @pytest.mark.skipif(
        not PARSEL_18_PLUS, reason="parsel < 1.8 doesn't support jmespath"
    )
    def test_json_has_html(self) -> None:
        """Sometimes the information is returned in a json wrapper"""

        body = """
        {
            "content": [
                {
                    "name": "A",
                    "value": "a"
                },
                {
                    "name": {
                        "age": 18
                    },
                    "value": "b"
                },
                {
                    "name": "C",
                    "value": "c"
                },
                {
                    "name": "<a>D</a>",
                    "value": "<div>d</div>"
                }
            ],
            "html": "<div><a>a<br>b</a>c</div><div><a>d</a>e<b>f</b></div>"
        }
        """
>       resp = TextResponse(url="http://example.com", body=body, encoding="utf-8")

/testbed/tests/test_selector.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'TextResponse' object has no attribute '_url'") raised in repr()] TextResponse object at 0x7fcb95c56780>
body = '\n        {\n            "content": [\n                {\n                    "name": "A",\n                    "valu...   }\n            ],\n            "html": "<div><a>a<br>b</a>c</div><div><a>d</a>e<b>f</b></div>"\n        }\n        '

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="initpybasesettingstesttest_update_iterable"><strong>init</strong>.py::BaseSettingsTest::test_update_iterable</h3>
<details><summary> <pre>__init__.py::BaseSettingsTest::test_update_iterable</pre></summary><pre>
self = <tests.test_settings.BaseSettingsTest testMethod=test_update_iterable>

    @pytest.mark.xfail(
        raises=AttributeError,
        reason="BaseSettings.update doesn't support iterable input",
    )
    def test_update_iterable(self):
        settings = BaseSettings({"key": 0})
>       settings.update([("key", 1)])

/testbed/tests/test_settings/__init__.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.settings.BaseSettings object at 0x7fcb95cde660>
values = [('key', 1)], priority = 'project'

    def update(self, values: _SettingsInputT, priority: Union[int, str] = "project") -> None:  # type: ignore[override]
        """
        Store key/value pairs with a given priority.

        This is a helper function that calls
        :meth:`~scrapy.settings.BaseSettings.set` for every item of ``values``
        with the provided ``priority``.

        If ``values`` is a string, it is assumed to be JSON-encoded and parsed
        into a dict with ``json.loads()`` first. If it is a
        :class:`~scrapy.settings.BaseSettings` instance, the per-key priorities
        will be used and the ``priority`` parameter ignored. This allows
        inserting/updating settings with different priorities with a single
        command.

        :param values: the settings names and values
        :type values: dict or string or :class:`~scrapy.settings.BaseSettings`

        :param priority: the priority of the settings. Should be a key of
            :attr:`~scrapy.settings.SETTINGS_PRIORITIES` or an integer
        :type priority: str or int
        """
        self._assert_mutability()
        if isinstance(values, str):
            values = cast(dict, json.loads(values))
        if values is not None:
            if isinstance(values, BaseSettings):
                for name, value in values.items():
                    self.set(name, value, cast(int, values.getpriority(name)))
            else:
>               for name, value in values.items():
E               AttributeError: 'list' object has no attribute 'items'

/testbed/scrapy/settings/__init__.py:421: AttributeError
</pre>
</details>
<h3 id="initpybasesettingstesttest_update_kwargs"><strong>init</strong>.py::BaseSettingsTest::test_update_kwargs</h3>
<details><summary> <pre>__init__.py::BaseSettingsTest::test_update_kwargs</pre></summary><pre>
self = <tests.test_settings.BaseSettingsTest testMethod=test_update_kwargs>

    @pytest.mark.xfail(
        raises=TypeError, reason="BaseSettings.update doesn't support kwargs input"
    )
    def test_update_kwargs(self):
        settings = BaseSettings({"key": 0})
>       settings.update(key=1)  # pylint: disable=unexpected-keyword-arg
E       TypeError: BaseSettings.update() got an unexpected keyword argument 'key'

/testbed/tests/test_settings/__init__.py:209: TypeError
</pre>
</details>
<h3 id="initpysettingstesttest_passing_objects_as_values"><strong>init</strong>.py::SettingsTest::test_passing_objects_as_values</h3>
<details><summary> <pre>__init__.py::SettingsTest::test_passing_objects_as_values</pre></summary><pre>
self = <tests.test_settings.SettingsTest testMethod=test_passing_objects_as_values>

    def test_passing_objects_as_values(self):
        from scrapy.core.downloader.handlers.file import FileDownloadHandler
        from scrapy.utils.misc import create_instance
>       from scrapy.utils.test import get_crawler

/testbed/tests/test_settings/__init__.py:444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/test.py:14: in <module>
    from scrapy.crawler import Crawler
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from __future__ import annotations
    import logging
    import pprint
    import signal
    import warnings
    from typing import TYPE_CHECKING, Any, Dict, Generator, Optional, Set, Type, Union, cast
    from twisted.internet.defer import Deferred, DeferredList, inlineCallbacks, maybeDeferred
    from zope.interface.exceptions import DoesNotImplement
    try:
        from zope.interface.exceptions import MultipleInvalid
    except ImportError:
        MultipleInvalid = None
    from zope.interface.verify import verifyClass
    from scrapy import Spider, signals
    from scrapy.addons import AddonManager
    from scrapy.core.engine import ExecutionEngine
    from scrapy.exceptions import ScrapyDeprecationWarning
    from scrapy.extension import ExtensionManager
    from scrapy.interfaces import ISpiderLoader
    from scrapy.logformatter import LogFormatter
    from scrapy.settings import BaseSettings, Settings, overridden_settings
    from scrapy.signalmanager import SignalManager
    from scrapy.statscollectors import StatsCollector
>   from scrapy.utils.log import LogCounterHandler, configure_logging, get_scrapy_root_handler, install_scrapy_root_handler, log_reactor_info, log_scrapy_info
E   ImportError: cannot import name 'get_scrapy_root_handler' from 'scrapy.utils.log' (/testbed/scrapy/utils/log.py)

/testbed/scrapy/crawler.py:24: ImportError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestreferermiddlewaretest">test_spidermiddleware_referer.py::TestRefererMiddleware::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRefererMiddleware::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRefererMiddleware testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestreferermiddlewaredefaulttest">test_spidermiddleware_referer.py::TestRefererMiddlewareDefault::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRefererMiddlewareDefault::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRefererMiddlewareDefault testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingsnoreferrertest">test_spidermiddleware_referer.py::TestSettingsNoReferrer::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsNoReferrer::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsNoReferrer testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingsnoreferrerwhendowngradetest">test_spidermiddleware_referer.py::TestSettingsNoReferrerWhenDowngrade::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsNoReferrerWhenDowngrade::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsNoReferrerWhenDowngrade testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingssameorigintest">test_spidermiddleware_referer.py::TestSettingsSameOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsSameOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsSameOrigin testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingsorigintest">test_spidermiddleware_referer.py::TestSettingsOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsOrigin testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingsstrictorigintest">test_spidermiddleware_referer.py::TestSettingsStrictOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsStrictOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsStrictOrigin testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingsoriginwhencrossorigintest">test_spidermiddleware_referer.py::TestSettingsOriginWhenCrossOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsOriginWhenCrossOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsOriginWhenCrossOrigin testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingsstrictoriginwhencrossorigintest">test_spidermiddleware_referer.py::TestSettingsStrictOriginWhenCrossOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsStrictOriginWhenCrossOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsStrictOriginWhenCrossOrigin testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingsunsafeurltest">test_spidermiddleware_referer.py::TestSettingsUnsafeUrl::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsUnsafeUrl::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsUnsafeUrl testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingscustompolicytest">test_spidermiddleware_referer.py::TestSettingsCustomPolicy::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsCustomPolicy::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsCustomPolicy testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetadefaulttest">test_spidermiddleware_referer.py::TestRequestMetaDefault::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaDefault::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaDefault testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetanoreferrertest">test_spidermiddleware_referer.py::TestRequestMetaNoReferrer::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaNoReferrer::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaNoReferrer testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetanoreferrerwhendowngradetest">test_spidermiddleware_referer.py::TestRequestMetaNoReferrerWhenDowngrade::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaNoReferrerWhenDowngrade::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaNoReferrerWhenDowngrade testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetasameorigintest">test_spidermiddleware_referer.py::TestRequestMetaSameOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaSameOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaSameOrigin testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetaorigintest">test_spidermiddleware_referer.py::TestRequestMetaOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaOrigin testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetasrictorigintest">test_spidermiddleware_referer.py::TestRequestMetaSrictOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaSrictOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaSrictOrigin testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetaoriginwhencrossorigintest">test_spidermiddleware_referer.py::TestRequestMetaOriginWhenCrossOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaOriginWhenCrossOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaOriginWhenCrossOrigin testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetastrictoriginwhencrossorigintest">test_spidermiddleware_referer.py::TestRequestMetaStrictOriginWhenCrossOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaStrictOriginWhenCrossOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaStrictOriginWhenCrossOrigin testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetaunsafeurltest">test_spidermiddleware_referer.py::TestRequestMetaUnsafeUrl::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaUnsafeUrl::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaUnsafeUrl testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetaprecedence001test">test_spidermiddleware_referer.py::TestRequestMetaPrecedence001::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaPrecedence001::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaPrecedence001 testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetaprecedence002test">test_spidermiddleware_referer.py::TestRequestMetaPrecedence002::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaPrecedence002::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaPrecedence002 testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetaprecedence003test">test_spidermiddleware_referer.py::TestRequestMetaPrecedence003::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaPrecedence003::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaPrecedence003 testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestrequestmetasettingfallbacktest">test_spidermiddleware_referer.py::TestRequestMetaSettingFallback::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestRequestMetaSettingFallback::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestRequestMetaSettingFallback testMethod=test>

    def test(self):
        origin = "http://www.scrapy.org"
        target = "http://www.example.com"

        for (
            settings,
            response_headers,
            request_meta,
            policy_class,
            check_warning,
        ) in self.params[3:]:
            mw = RefererMiddleware(Settings(settings))

            response = Response(origin, headers=response_headers)
            request = Request(target, meta=request_meta)

            with warnings.catch_warnings(record=True) as w:
                policy = mw.policy(response, request)
>               self.assertIsInstance(policy, policy_class)
E               AssertionError: None is not an instance of <class 'scrapy.spidermiddlewares.referer.UnsafeUrlPolicy'>

/testbed/tests/test_spidermiddleware_referer.py:841: AssertionError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingspolicybynametest_invalid_name">test_spidermiddleware_referer.py::TestSettingsPolicyByName::test_invalid_name</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsPolicyByName::test_invalid_name</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsPolicyByName testMethod=test_invalid_name>

    def test_invalid_name(self):
        settings = Settings({"REFERRER_POLICY": "some-custom-unknown-policy"})
>       with self.assertRaises(RuntimeError):
E       AssertionError: RuntimeError not raised

/testbed/tests/test_spidermiddleware_referer.py:883: AssertionError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingspolicybynametest_valid_name">test_spidermiddleware_referer.py::TestSettingsPolicyByName::test_valid_name</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsPolicyByName::test_valid_name</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsPolicyByName testMethod=test_valid_name>

    def test_valid_name(self):
        for s, p in [
            (POLICY_SCRAPY_DEFAULT, DefaultReferrerPolicy),
            (POLICY_NO_REFERRER, NoReferrerPolicy),
            (POLICY_NO_REFERRER_WHEN_DOWNGRADE, NoReferrerWhenDowngradePolicy),
            (POLICY_SAME_ORIGIN, SameOriginPolicy),
            (POLICY_ORIGIN, OriginPolicy),
            (POLICY_STRICT_ORIGIN, StrictOriginPolicy),
            (POLICY_ORIGIN_WHEN_CROSS_ORIGIN, OriginWhenCrossOriginPolicy),
            (POLICY_STRICT_ORIGIN_WHEN_CROSS_ORIGIN, StrictOriginWhenCrossOriginPolicy),
            (POLICY_UNSAFE_URL, UnsafeUrlPolicy),
        ]:
            settings = Settings({"REFERRER_POLICY": s})
            mw = RefererMiddleware(settings)
>           self.assertEqual(mw.default_policy, p)
E           AssertionError: None != <class 'scrapy.spidermiddlewares.referer.DefaultReferrerPolicy'>

/testbed/tests/test_spidermiddleware_referer.py:863: AssertionError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestsettingspolicybynametest_valid_name_casevariants">test_spidermiddleware_referer.py::TestSettingsPolicyByName::test_valid_name_casevariants</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestSettingsPolicyByName::test_valid_name_casevariants</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestSettingsPolicyByName testMethod=test_valid_name_casevariants>

    def test_valid_name_casevariants(self):
        for s, p in [
            (POLICY_SCRAPY_DEFAULT, DefaultReferrerPolicy),
            (POLICY_NO_REFERRER, NoReferrerPolicy),
            (POLICY_NO_REFERRER_WHEN_DOWNGRADE, NoReferrerWhenDowngradePolicy),
            (POLICY_SAME_ORIGIN, SameOriginPolicy),
            (POLICY_ORIGIN, OriginPolicy),
            (POLICY_STRICT_ORIGIN, StrictOriginPolicy),
            (POLICY_ORIGIN_WHEN_CROSS_ORIGIN, OriginWhenCrossOriginPolicy),
            (POLICY_STRICT_ORIGIN_WHEN_CROSS_ORIGIN, StrictOriginWhenCrossOriginPolicy),
            (POLICY_UNSAFE_URL, UnsafeUrlPolicy),
        ]:
            settings = Settings({"REFERRER_POLICY": s.upper()})
            mw = RefererMiddleware(settings)
>           self.assertEqual(mw.default_policy, p)
E           AssertionError: None != <class 'scrapy.spidermiddlewares.referer.DefaultReferrerPolicy'>

/testbed/tests/test_spidermiddleware_referer.py:879: AssertionError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestpolicyheaderprecedence001test">test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence001::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence001::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestPolicyHeaderPrecedence001 testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestpolicyheaderprecedence002test">test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence002::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence002::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestPolicyHeaderPrecedence002 testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestpolicyheaderprecedence003test">test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence003::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence003::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestPolicyHeaderPrecedence003 testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestpolicyheaderprecedence004test">test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence004::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestPolicyHeaderPrecedence004::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestPolicyHeaderPrecedence004 testMethod=test>

    def test(self):
        for origin, target, referrer in self.scenarii:
            response = self.get_response(origin)
            request = self.get_request(target)
>           out = list(self.mw.process_spider_output(response, [request], self.spider))
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:56: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestreferreronredirecttest">test_spidermiddleware_referer.py::TestReferrerOnRedirect::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestReferrerOnRedirect::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestReferrerOnRedirect testMethod=test>

    def test(self):
        for (
            parent,
            target,
            redirections,
            init_referrer,
            final_referrer,
        ) in self.scenarii:
            response = self.get_response(parent)
            request = self.get_request(target)

            out = list(
>               self.referrermw.process_spider_output(response, [request], self.spider)
            )
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:975: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestreferreronredirectnoreferrertest">test_spidermiddleware_referer.py::TestReferrerOnRedirectNoReferrer::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestReferrerOnRedirectNoReferrer::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestReferrerOnRedirectNoReferrer testMethod=test>

    def test(self):
        for (
            parent,
            target,
            redirections,
            init_referrer,
            final_referrer,
        ) in self.scenarii:
            response = self.get_response(parent)
            request = self.get_request(target)

            out = list(
>               self.referrermw.process_spider_output(response, [request], self.spider)
            )
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:975: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestreferreronredirectsameorigintest">test_spidermiddleware_referer.py::TestReferrerOnRedirectSameOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestReferrerOnRedirectSameOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestReferrerOnRedirectSameOrigin testMethod=test>

    def test(self):
        for (
            parent,
            target,
            redirections,
            init_referrer,
            final_referrer,
        ) in self.scenarii:
            response = self.get_response(parent)
            request = self.get_request(target)

            out = list(
>               self.referrermw.process_spider_output(response, [request], self.spider)
            )
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:975: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestreferreronredirectstrictorigintest">test_spidermiddleware_referer.py::TestReferrerOnRedirectStrictOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestReferrerOnRedirectStrictOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestReferrerOnRedirectStrictOrigin testMethod=test>

    def test(self):
        for (
            parent,
            target,
            redirections,
            init_referrer,
            final_referrer,
        ) in self.scenarii:
            response = self.get_response(parent)
            request = self.get_request(target)

            out = list(
>               self.referrermw.process_spider_output(response, [request], self.spider)
            )
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:975: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestreferreronredirectoriginwhencrossorigintest">test_spidermiddleware_referer.py::TestReferrerOnRedirectOriginWhenCrossOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestReferrerOnRedirectOriginWhenCrossOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestReferrerOnRedirectOriginWhenCrossOrigin testMethod=test>

    def test(self):
        for (
            parent,
            target,
            redirections,
            init_referrer,
            final_referrer,
        ) in self.scenarii:
            response = self.get_response(parent)
            request = self.get_request(target)

            out = list(
>               self.referrermw.process_spider_output(response, [request], self.spider)
            )
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:975: AttributeError
</pre>
</details>
<h3 id="test_spidermiddleware_refererpytestreferreronredirectstrictoriginwhencrossorigintest">test_spidermiddleware_referer.py::TestReferrerOnRedirectStrictOriginWhenCrossOrigin::test</h3>
<details><summary> <pre>test_spidermiddleware_referer.py::TestReferrerOnRedirectStrictOriginWhenCrossOrigin::test</pre></summary><pre>
self = <tests.test_spidermiddleware_referer.TestReferrerOnRedirectStrictOriginWhenCrossOrigin testMethod=test>

    def test(self):
        for (
            parent,
            target,
            redirections,
            init_referrer,
            final_referrer,
        ) in self.scenarii:
            response = self.get_response(parent)
            request = self.get_request(target)

            out = list(
>               self.referrermw.process_spider_output(response, [request], self.spider)
            )
E           AttributeError: 'RefererMiddleware' object has no attribute 'process_spider_output'

/testbed/tests/test_spidermiddleware_referer.py:975: AttributeError
</pre>
</details>
<h3 id="test_utils_asynciopyasynciotesttest_install_asyncio_reactor">test_utils_asyncio.py::AsyncioTest::test_install_asyncio_reactor</h3>
<details><summary> <pre>test_utils_asyncio.py::AsyncioTest::test_install_asyncio_reactor</pre></summary><pre>
self = <tests.test_utils_asyncio.AsyncioTest testMethod=test_install_asyncio_reactor>

    def test_install_asyncio_reactor(self):
        from twisted.internet import reactor as original_reactor

        with warnings.catch_warnings(record=True) as w:
>           install_reactor("twisted.internet.asyncioreactor.AsyncioSelectorReactor")

/testbed/tests/test_utils_asyncio.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/reactor.py:69: in install_reactor
    installReactor(reactor)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

reactor = <twisted.internet.asyncioreactor.AsyncioSelectorReactor object at 0x7fcb95db7950>

    def installReactor(reactor):
        """
        Install reactor C{reactor}.

        @param reactor: An object that provides one or more IReactor* interfaces.
        """
        # this stuff should be common to all reactors.
        import sys

        import twisted.internet

        if "twisted.internet.reactor" in sys.modules:
>           raise error.ReactorAlreadyInstalledError("reactor already installed")
E           twisted.internet.error.ReactorAlreadyInstalledError: reactor already installed

/testbed/.venv/lib/python3.12/site-packages/twisted/internet/main.py:32: ReactorAlreadyInstalledError
</pre>
</details>
<h3 id="test_utils_confpybuildcomponentlisttesttest_backward_compatible_build_dict">test_utils_conf.py::BuildComponentListTest::test_backward_compatible_build_dict</h3>
<details><summary> <pre>test_utils_conf.py::BuildComponentListTest::test_backward_compatible_build_dict</pre></summary><pre>
self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_backward_compatible_build_dict>

    def test_backward_compatible_build_dict(self):
        base = {"one": 1, "two": 2, "three": 3, "five": 5, "six": None}
        custom = {"two": None, "three": 8, "four": 4}
        with pytest.warns(ScrapyDeprecationWarning, match="The 'custom' attribute"):
>           self.assertEqual(
                build_component_list(base, custom, convert=lambda x: x),
                ["one", "four", "five", "three"],
            )
E           AssertionError: Lists differ: ['one', 'two', 'three', 'four', 'five'] != ['one', 'four', 'five', 'three']
E           
E           First differing element 1:
E           'two'
E           'four'
E           
E           First list contains 1 additional elements.
E           First extra element 4:
E           'five'
E           
E           - ['one', 'two', 'three', 'four', 'five']
E           + ['one', 'four', 'five', 'three']

/testbed/tests/test_utils_conf.py:27: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_backward_compatible_build_dict>

    def test_backward_compatible_build_dict(self):
        base = {"one": 1, "two": 2, "three": 3, "five": 5, "six": None}
        custom = {"two": None, "three": 8, "four": 4}
>       with pytest.warns(ScrapyDeprecationWarning, match="The 'custom' attribute"):
E       Failed: DID NOT WARN. No warnings of type (<class 'scrapy.exceptions.ScrapyDeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

/testbed/tests/test_utils_conf.py:26: Failed
</pre>
</details>
<h3 id="test_utils_confpybuildcomponentlisttesttest_duplicate_components_in_basesettings">test_utils_conf.py::BuildComponentListTest::test_duplicate_components_in_basesettings</h3>
<details><summary> <pre>test_utils_conf.py::BuildComponentListTest::test_duplicate_components_in_basesettings</pre></summary><pre>
self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_duplicate_components_in_basesettings>

    def test_duplicate_components_in_basesettings(self):
        # Higher priority takes precedence
        duplicate_bs = BaseSettings({"one": 1, "two": 2}, priority=0)
        duplicate_bs.set("ONE", 4, priority=10)
        self.assertEqual(
            build_component_list(duplicate_bs, convert=lambda x: x.lower()),
            ["two", "one"],
        )
        duplicate_bs.set("one", duplicate_bs["one"], priority=20)
>       self.assertEqual(
            build_component_list(duplicate_bs, convert=lambda x: x.lower()),
            ["one", "two"],
        )
E       AssertionError: Lists differ: ['two', 'one'] != ['one', 'two']
E       
E       First differing element 0:
E       'two'
E       'one'
E       
E       - ['two', 'one']
E       + ['one', 'two']

/testbed/tests/test_utils_conf.py:76: AssertionError
</pre>
</details>
<h3 id="test_utils_confpybuildcomponentlisttesttest_duplicate_components_in_dict">test_utils_conf.py::BuildComponentListTest::test_duplicate_components_in_dict</h3>
<details><summary> <pre>test_utils_conf.py::BuildComponentListTest::test_duplicate_components_in_dict</pre></summary><pre>
self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_duplicate_components_in_dict>

    def test_duplicate_components_in_dict(self):
        duplicate_dict = {"one": 1, "two": 2, "ONE": 4}
        with self.assertRaises(ValueError):
>           with pytest.warns(ScrapyDeprecationWarning, match="The 'custom' attribute"):

/testbed/tests/test_utils_conf.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/_pytest/recwarn.py:317: in __exit__
    fail(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @_with_exception(Failed)
    def fail(reason: str = "", pytrace: bool = True) -> NoReturn:
        """Explicitly fail an executing test with the given message.

        :param reason:
            The message to show the user as reason for the failure.

        :param pytrace:
            If False, msg represents the full failure information and no
            python traceback will be reported.

        :raises pytest.fail.Exception:
            The exception that is raised.
        """
        __tracebackhide__ = True
>       raise Failed(msg=reason, pytrace=pytrace)
E       Failed: DID NOT WARN. No warnings of type (<class 'scrapy.exceptions.ScrapyDeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

/testbed/.venv/lib/python3.12/site-packages/_pytest/outcomes.py:178: Failed
</pre>
</details>
<h3 id="test_utils_confpybuildcomponentlisttesttest_duplicate_components_in_list">test_utils_conf.py::BuildComponentListTest::test_duplicate_components_in_list</h3>
<details><summary> <pre>test_utils_conf.py::BuildComponentListTest::test_duplicate_components_in_list</pre></summary><pre>
self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_duplicate_components_in_list>

    def test_duplicate_components_in_list(self):
        duplicate_list = ["a", "b", "a"]
        with self.assertRaises(ValueError) as cm:
>           with pytest.warns(ScrapyDeprecationWarning, match="The 'custom' attribute"):

/testbed/tests/test_utils_conf.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/_pytest/recwarn.py:317: in __exit__
    fail(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @_with_exception(Failed)
    def fail(reason: str = "", pytrace: bool = True) -> NoReturn:
        """Explicitly fail an executing test with the given message.

        :param reason:
            The message to show the user as reason for the failure.

        :param pytrace:
            If False, msg represents the full failure information and no
            python traceback will be reported.

        :raises pytest.fail.Exception:
            The exception that is raised.
        """
        __tracebackhide__ = True
>       raise Failed(msg=reason, pytrace=pytrace)
E       Failed: DID NOT WARN. No warnings of type (<class 'scrapy.exceptions.ScrapyDeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

/testbed/.venv/lib/python3.12/site-packages/_pytest/outcomes.py:178: Failed
</pre>
</details>
<h3 id="test_utils_confpybuildcomponentlisttesttest_map_dict">test_utils_conf.py::BuildComponentListTest::test_map_dict</h3>
<details><summary> <pre>test_utils_conf.py::BuildComponentListTest::test_map_dict</pre></summary><pre>
self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_map_dict>

    def test_map_dict(self):
        custom = {"one": 1, "two": 2, "three": 3}
        with pytest.warns(ScrapyDeprecationWarning, match="The 'custom' attribute"):
>           self.assertEqual(
                build_component_list({}, custom, convert=lambda x: x.upper()),
                ["ONE", "TWO", "THREE"],
            )
E           AssertionError: Lists differ: [] != ['ONE', 'TWO', 'THREE']
E           
E           Second list contains 3 additional elements.
E           First extra element 0:
E           'ONE'
E           
E           - []
E           + ['ONE', 'TWO', 'THREE']

/testbed/tests/test_utils_conf.py:42: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_map_dict>

    def test_map_dict(self):
        custom = {"one": 1, "two": 2, "three": 3}
>       with pytest.warns(ScrapyDeprecationWarning, match="The 'custom' attribute"):
E       Failed: DID NOT WARN. No warnings of type (<class 'scrapy.exceptions.ScrapyDeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

/testbed/tests/test_utils_conf.py:41: Failed
</pre>
</details>
<h3 id="test_utils_confpybuildcomponentlisttesttest_map_list">test_utils_conf.py::BuildComponentListTest::test_map_list</h3>
<details><summary> <pre>test_utils_conf.py::BuildComponentListTest::test_map_list</pre></summary><pre>
self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_map_list>

    def test_map_list(self):
        custom = ["a", "b", "c"]
        with pytest.warns(ScrapyDeprecationWarning, match="The 'custom' attribute"):
>           self.assertEqual(
                build_component_list(None, custom, lambda x: x.upper()), ["A", "B", "C"]
            )
E           AssertionError: Lists differ: [] != ['A', 'B', 'C']
E           
E           Second list contains 3 additional elements.
E           First extra element 0:
E           'A'
E           
E           - []
E           + ['A', 'B', 'C']

/testbed/tests/test_utils_conf.py:50: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_map_list>

    def test_map_list(self):
        custom = ["a", "b", "c"]
>       with pytest.warns(ScrapyDeprecationWarning, match="The 'custom' attribute"):
E       Failed: DID NOT WARN. No warnings of type (<class 'scrapy.exceptions.ScrapyDeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

/testbed/tests/test_utils_conf.py:49: Failed
</pre>
</details>
<h3 id="test_utils_confpybuildcomponentlisttesttest_return_list">test_utils_conf.py::BuildComponentListTest::test_return_list</h3>
<details><summary> <pre>test_utils_conf.py::BuildComponentListTest::test_return_list</pre></summary><pre>
self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_return_list>

    def test_return_list(self):
        custom = ["a", "b", "c"]
        with pytest.warns(ScrapyDeprecationWarning, match="The 'custom' attribute"):
>           self.assertEqual(
                build_component_list(None, custom, convert=lambda x: x), custom
            )
E           AssertionError: Lists differ: [] != ['a', 'b', 'c']
E           
E           Second list contains 3 additional elements.
E           First extra element 0:
E           'a'
E           
E           - []
E           + ['a', 'b', 'c']

/testbed/tests/test_utils_conf.py:35: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_return_list>

    def test_return_list(self):
        custom = ["a", "b", "c"]
>       with pytest.warns(ScrapyDeprecationWarning, match="The 'custom' attribute"):
E       Failed: DID NOT WARN. No warnings of type (<class 'scrapy.exceptions.ScrapyDeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

/testbed/tests/test_utils_conf.py:34: Failed
</pre>
</details>
<h3 id="test_utils_confpybuildcomponentlisttesttest_valid_numbers">test_utils_conf.py::BuildComponentListTest::test_valid_numbers</h3>
<details><summary> <pre>test_utils_conf.py::BuildComponentListTest::test_valid_numbers</pre></summary><pre>
self = <tests.test_utils_conf.BuildComponentListTest testMethod=test_valid_numbers>

    def test_valid_numbers(self):
        # work well with None and numeric values
        d = {"a": 10, "b": None, "c": 15, "d": 5.0}
        self.assertEqual(build_component_list(d, convert=lambda x: x), ["d", "a", "c"])
        d = {
            "a": 33333333333333333333,
            "b": 11111111111111111111,
            "c": 22222222222222222222,
        }
        self.assertEqual(build_component_list(d, convert=lambda x: x), ["b", "c", "a"])
        # raise exception for invalid values
        d = {"one": "5"}
        with self.assertRaises(ValueError):
>           with pytest.warns(ScrapyDeprecationWarning, match="The 'custom' attribute"):

/testbed/tests/test_utils_conf.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/_pytest/recwarn.py:317: in __exit__
    fail(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @_with_exception(Failed)
    def fail(reason: str = "", pytrace: bool = True) -> NoReturn:
        """Explicitly fail an executing test with the given message.

        :param reason:
            The message to show the user as reason for the failure.

        :param pytrace:
            If False, msg represents the full failure information and no
            python traceback will be reported.

        :raises pytest.fail.Exception:
            The exception that is raised.
        """
        __tracebackhide__ = True
>       raise Failed(msg=reason, pytrace=pytrace)
E       Failed: DID NOT WARN. No warnings of type (<class 'scrapy.exceptions.ScrapyDeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

/testbed/.venv/lib/python3.12/site-packages/_pytest/outcomes.py:178: Failed
</pre>
</details>
<h3 id="test_utils_confpyfeedexportconfigtestcasetest_feed_complete_default_values_from_settings_empty">test_utils_conf.py::FeedExportConfigTestCase::test_feed_complete_default_values_from_settings_empty</h3>
<details><summary> <pre>test_utils_conf.py::FeedExportConfigTestCase::test_feed_complete_default_values_from_settings_empty</pre></summary><pre>
self = <tests.test_utils_conf.FeedExportConfigTestCase testMethod=test_feed_complete_default_values_from_settings_empty>

    def test_feed_complete_default_values_from_settings_empty(self):
        feed = {}
        settings = Settings(
            {
                "FEED_EXPORT_ENCODING": "custom encoding",
                "FEED_EXPORT_FIELDS": ["f1", "f2", "f3"],
                "FEED_EXPORT_INDENT": 42,
                "FEED_STORE_EMPTY": True,
                "FEED_URI_PARAMS": (1, 2, 3, 4),
                "FEED_EXPORT_BATCH_ITEM_COUNT": 2,
            }
        )
        new_feed = feed_complete_default_values_from_settings(feed, settings)
>       self.assertEqual(
            new_feed,
            {
                "encoding": "custom encoding",
                "fields": ["f1", "f2", "f3"],
                "indent": 42,
                "store_empty": True,
                "uri_params": (1, 2, 3, 4),
                "batch_item_count": 2,
                "item_export_kwargs": {},
            },
        )
E       AssertionError: {} != {'encoding': 'custom encoding', 'fields': [126 chars]: {}}
E       - {}
E       + {'batch_item_count': 2,
E       +  'encoding': 'custom encoding',
E       +  'fields': ['f1', 'f2', 'f3'],
E       +  'indent': 42,
E       +  'item_export_kwargs': {},
E       +  'store_empty': True,
E       +  'uri_params': (1, 2, 3, 4)}

/testbed/tests/test_utils_conf.py:202: AssertionError
</pre>
</details>
<h3 id="test_utils_confpyfeedexportconfigtestcasetest_feed_complete_default_values_from_settings_non_empty">test_utils_conf.py::FeedExportConfigTestCase::test_feed_complete_default_values_from_settings_non_empty</h3>
<details><summary> <pre>test_utils_conf.py::FeedExportConfigTestCase::test_feed_complete_default_values_from_settings_non_empty</pre></summary><pre>
self = <tests.test_utils_conf.FeedExportConfigTestCase testMethod=test_feed_complete_default_values_from_settings_non_empty>

    def test_feed_complete_default_values_from_settings_non_empty(self):
        feed = {
            "encoding": "other encoding",
            "fields": None,
        }
        settings = Settings(
            {
                "FEED_EXPORT_ENCODING": "custom encoding",
                "FEED_EXPORT_FIELDS": ["f1", "f2", "f3"],
                "FEED_EXPORT_INDENT": 42,
                "FEED_STORE_EMPTY": True,
                "FEED_EXPORT_BATCH_ITEM_COUNT": 2,
            }
        )
>       new_feed = feed_complete_default_values_from_settings(feed, settings)

/testbed/tests/test_utils_conf.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

feed_options = {'encoding': 'other encoding', 'fields': None}
settings = <scrapy.settings.Settings object at 0x7fcb95d29550>

    def feed_complete_default_values_from_settings(feed_options: Dict[str, Dict[str, Any]], settings: BaseSettings) -> Dict[str, Dict[str, Any]]:
        """
        Receives a dictionary of feed options and settings and returns a new one
        populated by default values from settings.
        """
        result = {}
        for uri, values in feed_options.items():
>           values = values.copy()
E           AttributeError: 'str' object has no attribute 'copy'

/testbed/scrapy/utils/conf.py:162: AttributeError
</pre>
</details>
<h3 id="test_utils_confpyfeedexportconfigtestcasetest_feed_export_config_backward_compatible">test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_backward_compatible</h3>
<details><summary> <pre>test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_backward_compatible</pre></summary><pre>
self = <tests.test_utils_conf.FeedExportConfigTestCase testMethod=test_feed_export_config_backward_compatible>

    def test_feed_export_config_backward_compatible(self):
        with warnings.catch_warnings(record=True) as cw:
            settings = Settings()
            self.assertEqual(
                {"items.dat": {"format": "csv"}},
>               feed_process_params_from_cli(settings, ["items.dat"], "csv"),
            )

/testbed/tests/test_utils_conf.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

settings = <scrapy.settings.Settings object at 0x7fcb95cdfd10>
output = ['items.dat'], output_format = 'csv', overwrite_output = []

    def feed_process_params_from_cli(settings: BaseSettings, output: List[str], output_format: Optional[str]=None, overwrite_output: Optional[List[str]]=None) -> Dict[str, Dict[str, Any]]:
        """
        Receives feed export params (from the 'crawl' or 'runspider' commands),
        checks for inconsistencies in their quantities and returns a dictionary
        suitable to be used as the FEEDS setting.
        """
        valid_output_formats = without_none_values(settings['FEED_EXPORTERS']).keys()
        overwrite_output = overwrite_output or []

        if output_format and output_format not in valid_output_formats:
>           raise UsageError(
                f"Unrecognized output format '{output_format}'. "
                f"Set a supported one ({tuple(valid_output_formats)}) "
                "after a colon at the end of the output URI (i.e. -o/-O "
                "FILE:FORMAT)"
            )
E           scrapy.exceptions.UsageError: Unrecognized output format 'csv'. Set a supported one (()) after a colon at the end of the output URI (i.e. -o/-O FILE:FORMAT)

/testbed/scrapy/utils/conf.py:120: UsageError
</pre>
</details>
<h3 id="test_utils_confpyfeedexportconfigtestcasetest_feed_export_config_explicit_formats">test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_explicit_formats</h3>
<details><summary> <pre>test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_explicit_formats</pre></summary><pre>
self = <tests.test_utils_conf.FeedExportConfigTestCase testMethod=test_feed_export_config_explicit_formats>

    def test_feed_export_config_explicit_formats(self):
        settings = Settings()
        self.assertEqual(
            {
                "items_1.dat": {"format": "json"},
                "items_2.dat": {"format": "xml"},
                "items_3.dat": {"format": "csv"},
            },
>           feed_process_params_from_cli(
                settings, ["items_1.dat:json", "items_2.dat:xml", "items_3.dat:csv"]
            ),
        )

/testbed/tests/test_utils_conf.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

settings = <scrapy.settings.Settings object at 0x7fcb95d68f80>
output = ['items_1.dat:json', 'items_2.dat:xml', 'items_3.dat:csv']
output_format = None, overwrite_output = []

    def feed_process_params_from_cli(settings: BaseSettings, output: List[str], output_format: Optional[str]=None, overwrite_output: Optional[List[str]]=None) -> Dict[str, Dict[str, Any]]:
        """
        Receives feed export params (from the 'crawl' or 'runspider' commands),
        checks for inconsistencies in their quantities and returns a dictionary
        suitable to be used as the FEEDS setting.
        """
        valid_output_formats = without_none_values(settings['FEED_EXPORTERS']).keys()
        overwrite_output = overwrite_output or []

        if output_format and output_format not in valid_output_formats:
            raise UsageError(
                f"Unrecognized output format '{output_format}'. "
                f"Set a supported one ({tuple(valid_output_formats)}) "
                "after a colon at the end of the output URI (i.e. -o/-O "
                "FILE:FORMAT)"
            )

        if len(overwrite_output) > len(output):
            raise UsageError(
                "Cannot have more '-O' than '-o' options"
            )

        if output_format and any(isformat(x) for x in output):
            raise UsageError(
                "If --output-format is used, the output URIs cannot contain formats"
            )

        result = {}
        for i, uri in enumerate(output):
            out_format = output_format or (get_uri_format(uri) if isformat(uri) else None)
            if out_format not in valid_output_formats:
>               raise UsageError(
                    f"Unrecognized output format '{out_format}' in '{uri}'. "
                    f"Set a supported one ({tuple(valid_output_formats)}) "
                    "after a colon at the end of the output URI (i.e. -o/-O "
                    "FILE:FORMAT)"
                )
E               scrapy.exceptions.UsageError: Unrecognized output format 'json' in 'items_1.dat:json'. Set a supported one (()) after a colon at the end of the output URI (i.e. -o/-O FILE:FORMAT)

/testbed/scrapy/utils/conf.py:141: UsageError
</pre>
</details>
<h3 id="test_utils_confpyfeedexportconfigtestcasetest_feed_export_config_implicit_formats">test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_implicit_formats</h3>
<details><summary> <pre>test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_implicit_formats</pre></summary><pre>
self = <tests.test_utils_conf.FeedExportConfigTestCase testMethod=test_feed_export_config_implicit_formats>

    def test_feed_export_config_implicit_formats(self):
        settings = Settings()
        self.assertEqual(
            {
                "items_1.json": {"format": "json"},
                "items_2.xml": {"format": "xml"},
                "items_3.csv": {"format": "csv"},
            },
>           feed_process_params_from_cli(
                settings, ["items_1.json", "items_2.xml", "items_3.csv"]
            ),
        )

/testbed/tests/test_utils_conf.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

settings = <scrapy.settings.Settings object at 0x7fcb95d3b500>
output = ['items_1.json', 'items_2.xml', 'items_3.csv'], output_format = None
overwrite_output = []

    def feed_process_params_from_cli(settings: BaseSettings, output: List[str], output_format: Optional[str]=None, overwrite_output: Optional[List[str]]=None) -> Dict[str, Dict[str, Any]]:
        """
        Receives feed export params (from the 'crawl' or 'runspider' commands),
        checks for inconsistencies in their quantities and returns a dictionary
        suitable to be used as the FEEDS setting.
        """
        valid_output_formats = without_none_values(settings['FEED_EXPORTERS']).keys()
        overwrite_output = overwrite_output or []

        if output_format and output_format not in valid_output_formats:
            raise UsageError(
                f"Unrecognized output format '{output_format}'. "
                f"Set a supported one ({tuple(valid_output_formats)}) "
                "after a colon at the end of the output URI (i.e. -o/-O "
                "FILE:FORMAT)"
            )

        if len(overwrite_output) > len(output):
            raise UsageError(
                "Cannot have more '-O' than '-o' options"
            )

        if output_format and any(isformat(x) for x in output):
            raise UsageError(
                "If --output-format is used, the output URIs cannot contain formats"
            )

        result = {}
        for i, uri in enumerate(output):
            out_format = output_format or (get_uri_format(uri) if isformat(uri) else None)
            if out_format not in valid_output_formats:
>               raise UsageError(
                    f"Unrecognized output format '{out_format}' in '{uri}'. "
                    f"Set a supported one ({tuple(valid_output_formats)}) "
                    "after a colon at the end of the output URI (i.e. -o/-O "
                    "FILE:FORMAT)"
                )
E               scrapy.exceptions.UsageError: Unrecognized output format 'None' in 'items_1.json'. Set a supported one (()) after a colon at the end of the output URI (i.e. -o/-O FILE:FORMAT)

/testbed/scrapy/utils/conf.py:141: UsageError
</pre>
</details>
<h3 id="test_utils_confpyfeedexportconfigtestcasetest_feed_export_config_overwrite">test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_overwrite</h3>
<details><summary> <pre>test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_overwrite</pre></summary><pre>
self = <tests.test_utils_conf.FeedExportConfigTestCase testMethod=test_feed_export_config_overwrite>

    def test_feed_export_config_overwrite(self):
        settings = Settings()
        self.assertEqual(
            {"output.json": {"format": "json", "overwrite": True}},
>           feed_process_params_from_cli(settings, [], None, ["output.json"]),
        )

/testbed/tests/test_utils_conf.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

settings = <scrapy.settings.Settings object at 0x7fcb95dbac60>, output = []
output_format = None, overwrite_output = ['output.json']

    def feed_process_params_from_cli(settings: BaseSettings, output: List[str], output_format: Optional[str]=None, overwrite_output: Optional[List[str]]=None) -> Dict[str, Dict[str, Any]]:
        """
        Receives feed export params (from the 'crawl' or 'runspider' commands),
        checks for inconsistencies in their quantities and returns a dictionary
        suitable to be used as the FEEDS setting.
        """
        valid_output_formats = without_none_values(settings['FEED_EXPORTERS']).keys()
        overwrite_output = overwrite_output or []

        if output_format and output_format not in valid_output_formats:
            raise UsageError(
                f"Unrecognized output format '{output_format}'. "
                f"Set a supported one ({tuple(valid_output_formats)}) "
                "after a colon at the end of the output URI (i.e. -o/-O "
                "FILE:FORMAT)"
            )

        if len(overwrite_output) > len(output):
>           raise UsageError(
                "Cannot have more '-O' than '-o' options"
            )
E           scrapy.exceptions.UsageError: Cannot have more '-O' than '-o' options

/testbed/scrapy/utils/conf.py:128: UsageError
</pre>
</details>
<h3 id="test_utils_confpyfeedexportconfigtestcasetest_feed_export_config_stdout">test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_stdout</h3>
<details><summary> <pre>test_utils_conf.py::FeedExportConfigTestCase::test_feed_export_config_stdout</pre></summary><pre>
self = <tests.test_utils_conf.FeedExportConfigTestCase testMethod=test_feed_export_config_stdout>

    def test_feed_export_config_stdout(self):
        settings = Settings()
        self.assertEqual(
            {"stdout:": {"format": "pickle"}},
>           feed_process_params_from_cli(settings, ["-:pickle"]),
        )

/testbed/tests/test_utils_conf.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

settings = <scrapy.settings.Settings object at 0x7fcb95d871a0>
output = ['-:pickle'], output_format = None, overwrite_output = []

    def feed_process_params_from_cli(settings: BaseSettings, output: List[str], output_format: Optional[str]=None, overwrite_output: Optional[List[str]]=None) -> Dict[str, Dict[str, Any]]:
        """
        Receives feed export params (from the 'crawl' or 'runspider' commands),
        checks for inconsistencies in their quantities and returns a dictionary
        suitable to be used as the FEEDS setting.
        """
        valid_output_formats = without_none_values(settings['FEED_EXPORTERS']).keys()
        overwrite_output = overwrite_output or []

        if output_format and output_format not in valid_output_formats:
            raise UsageError(
                f"Unrecognized output format '{output_format}'. "
                f"Set a supported one ({tuple(valid_output_formats)}) "
                "after a colon at the end of the output URI (i.e. -o/-O "
                "FILE:FORMAT)"
            )

        if len(overwrite_output) > len(output):
            raise UsageError(
                "Cannot have more '-O' than '-o' options"
            )

        if output_format and any(isformat(x) for x in output):
            raise UsageError(
                "If --output-format is used, the output URIs cannot contain formats"
            )

        result = {}
        for i, uri in enumerate(output):
            out_format = output_format or (get_uri_format(uri) if isformat(uri) else None)
            if out_format not in valid_output_formats:
>               raise UsageError(
                    f"Unrecognized output format '{out_format}' in '{uri}'. "
                    f"Set a supported one ({tuple(valid_output_formats)}) "
                    "after a colon at the end of the output URI (i.e. -o/-O "
                    "FILE:FORMAT)"
                )
E               scrapy.exceptions.UsageError: Unrecognized output format 'pickle' in '-:pickle'. Set a supported one (()) after a colon at the end of the output URI (i.e. -o/-O FILE:FORMAT)

/testbed/scrapy/utils/conf.py:141: UsageError
</pre>
</details>
<h3 id="test_utils_consolepyutilsconsoletestcasetest_get_shell_embed_func">test_utils_console.py::UtilsConsoleTestCase::test_get_shell_embed_func</h3>
<details><summary> <pre>test_utils_console.py::UtilsConsoleTestCase::test_get_shell_embed_func</pre></summary><pre>
self = <tests.test_utils_console.UtilsConsoleTestCase testMethod=test_get_shell_embed_func>

    def test_get_shell_embed_func(self):
        shell = get_shell_embed_func(["invalid"])
        self.assertEqual(shell, None)

        shell = get_shell_embed_func(["invalid", "python"])
>       self.assertTrue(callable(shell))
E       AssertionError: False is not true

/testbed/tests/test_utils_console.py:27: AssertionError
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_delete">test_utils_curl.py::CurlToRequestKwargsTest::test_delete</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_delete</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_delete>

    def test_delete(self):
        curl_command = 'curl -X "DELETE" https://www.url.com/page'
        expected_result = {"method": "DELETE", "url": "https://www.url.com/page"}
>       self._test_command(curl_command, expected_result)

/testbed/tests/test_utils_curl.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_utils_curl.py:15: in _test_command
    self.assertEqual(result, expected_result)
E   AssertionError: None != {'method': 'DELETE', 'url': 'https://www.url.com/page'}
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_explicit_get_with_data">test_utils_curl.py::CurlToRequestKwargsTest::test_explicit_get_with_data</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_explicit_get_with_data</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_explicit_get_with_data>

    def test_explicit_get_with_data(self):
        curl_command = "curl httpbin.org/anything -X GET --data asdf"
        expected_result = {
            "method": "GET",
            "url": "http://httpbin.org/anything",
            "body": "asdf",
        }
>       self._test_command(curl_command, expected_result)

/testbed/tests/test_utils_curl.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_utils_curl.py:15: in _test_command
    self.assertEqual(result, expected_result)
E   AssertionError: None != {'method': 'GET', 'url': 'http://httpbin.org/anything', 'body': 'asdf'}
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_get">test_utils_curl.py::CurlToRequestKwargsTest::test_get</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_get</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_get>

    def test_get(self):
        curl_command = "curl http://example.org/"
        expected_result = {"method": "GET", "url": "http://example.org/"}
>       self._test_command(curl_command, expected_result)

/testbed/tests/test_utils_curl.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_utils_curl.py:15: in _test_command
    self.assertEqual(result, expected_result)
E   AssertionError: None != {'method': 'GET', 'url': 'http://example.org/'}
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_get_basic_auth">test_utils_curl.py::CurlToRequestKwargsTest::test_get_basic_auth</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_get_basic_auth</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_get_basic_auth>

    def test_get_basic_auth(self):
        curl_command = 'curl "https://api.test.com/" -u "some_username:some_password"'
        expected_result = {
            "method": "GET",
            "url": "https://api.test.com/",
            "headers": [
                ("Authorization", basic_auth_header("some_username", "some_password"))
            ],
        }
>       self._test_command(curl_command, expected_result)

/testbed/tests/test_utils_curl.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_utils_curl.py:15: in _test_command
    self.assertEqual(result, expected_result)
E   AssertionError: None != {'method': 'GET', 'url': 'https://api.tes[82 chars]k')]}
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_get_complex">test_utils_curl.py::CurlToRequestKwargsTest::test_get_complex</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_get_complex</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_get_complex>

    def test_get_complex(self):
        curl_command = (
            "curl 'http://httpbin.org/get' -H 'Accept-Encoding: gzip, deflate'"
            " -H 'Accept-Language: en-US,en;q=0.9,ru;q=0.8,es;q=0.7' -H 'Upgra"
            "de-Insecure-Requests: 1' -H 'User-Agent: Mozilla/5.0 (X11; Linux "
            "x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/62"
            ".0.3202.75 Chrome/62.0.3202.75 Safari/537.36' -H 'Accept: text/ht"
            "ml,application/xhtml+xml,application/xml;q=0.9,image/webp,image/a"
            "png,*/*;q=0.8' -H 'Referer: http://httpbin.org/' -H 'Cookie: _gau"
            "ges_unique_year=1; _gauges_unique=1; _gauges_unique_month=1; _gau"
            "ges_unique_hour=1; _gauges_unique_day=1' -H 'Connection: keep-ali"
            "ve' --compressed"
        )
        expected_result = {
            "method": "GET",
            "url": "http://httpbin.org/get",
            "headers": [
                ("Accept-Encoding", "gzip, deflate"),
                ("Accept-Language", "en-US,en;q=0.9,ru;q=0.8,es;q=0.7"),
                ("Upgrade-Insecure-Requests", "1"),
                (
                    "User-Agent",
                    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML"
                    ", like Gecko) Ubuntu Chromium/62.0.3202.75 Chrome/62.0.32"
                    "02.75 Safari/537.36",
                ),
                (
                    "Accept",
                    "text/html,application/xhtml+xml,application/xml;q=0.9,ima"
                    "ge/webp,image/apng,*/*;q=0.8",
                ),
                ("Referer", "http://httpbin.org/"),
                ("Connection", "keep-alive"),
            ],
            "cookies": {
                "_gauges_unique_year": "1",
                "_gauges_unique_hour": "1",
                "_gauges_unique_day": "1",
                "_gauges_unique": "1",
                "_gauges_unique_month": "1",
            },
        }
>       self._test_command(curl_command, expected_result)

/testbed/tests/test_utils_curl.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_utils_curl.py:15: in _test_command
    self.assertEqual(result, expected_result)
E   AssertionError: None != {'method': 'GET', 'url': 'http://httpbin.[616 chars]'1'}}
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_get_silent">test_utils_curl.py::CurlToRequestKwargsTest::test_get_silent</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_get_silent</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_get_silent>

    def test_get_silent(self):
        curl_command = 'curl --silent "www.example.com"'
        expected_result = {"method": "GET", "url": "http://www.example.com"}
>       self.assertEqual(curl_to_request_kwargs(curl_command), expected_result)
E       AssertionError: None != {'method': 'GET', 'url': 'http://www.example.com'}

/testbed/tests/test_utils_curl.py:205: AssertionError
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_get_without_scheme">test_utils_curl.py::CurlToRequestKwargsTest::test_get_without_scheme</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_get_without_scheme</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_get_without_scheme>

    def test_get_without_scheme(self):
        curl_command = "curl www.example.org"
        expected_result = {"method": "GET", "url": "http://www.example.org"}
>       self._test_command(curl_command, expected_result)

/testbed/tests/test_utils_curl.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_utils_curl.py:15: in _test_command
    self.assertEqual(result, expected_result)
E   AssertionError: None != {'method': 'GET', 'url': 'http://www.example.org'}
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_ignore_unknown_options">test_utils_curl.py::CurlToRequestKwargsTest::test_ignore_unknown_options</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_ignore_unknown_options</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_ignore_unknown_options>

    def test_ignore_unknown_options(self):
        # case 1: ignore_unknown_options=True:
        with warnings.catch_warnings():  # avoid warning when executing tests
            warnings.simplefilter("ignore")
            curl_command = "curl --bar --baz http://www.example.com"
            expected_result = {"method": "GET", "url": "http://www.example.com"}
>           self.assertEqual(curl_to_request_kwargs(curl_command), expected_result)
E           AssertionError: None != {'method': 'GET', 'url': 'http://www.example.com'}

/testbed/tests/test_utils_curl.py:220: AssertionError
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_must_start_with_curl_error">test_utils_curl.py::CurlToRequestKwargsTest::test_must_start_with_curl_error</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_must_start_with_curl_error</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_must_start_with_curl_error>

    def test_must_start_with_curl_error(self):
>       self.assertRaises(
            ValueError,
            lambda: curl_to_request_kwargs("carl -X POST http://example.org"),
        )
E       AssertionError: ValueError not raised by <lambda>

/testbed/tests/test_utils_curl.py:232: AssertionError
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_patch">test_utils_curl.py::CurlToRequestKwargsTest::test_patch</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_patch</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_patch>

    def test_patch(self):
        curl_command = (
            'curl "https://example.com/api/fake" -u "username:password" -H "Ac'
            'cept: application/vnd.go.cd.v4+json" -H "Content-Type: applicatio'
            'n/json" -X PATCH -d \'{"hostname": "agent02.example.com",  "agent'
            '_config_state": "Enabled", "resources": ["Java","Linux"], "enviro'
            'nments": ["Dev"]}\''
        )
        expected_result = {
            "method": "PATCH",
            "url": "https://example.com/api/fake",
            "headers": [
                ("Accept", "application/vnd.go.cd.v4+json"),
                ("Content-Type", "application/json"),
                ("Authorization", basic_auth_header("username", "password")),
            ],
            "body": '{"hostname": "agent02.example.com",  "agent_config_state"'
            ': "Enabled", "resources": ["Java","Linux"], "environments'
            '": ["Dev"]}',
        }
>       self._test_command(curl_command, expected_result)

/testbed/tests/test_utils_curl.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_utils_curl.py:15: in _test_command
    self.assertEqual(result, expected_result)
E   AssertionError: None != {'method': 'PATCH', 'url': 'https://examp[299 chars]"]}'}
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_post">test_utils_curl.py::CurlToRequestKwargsTest::test_post</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_post</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_post>

    def test_post(self):
        curl_command = (
            "curl 'http://httpbin.org/post' -X POST -H 'Cookie: _gauges_unique"
            "_year=1; _gauges_unique=1; _gauges_unique_month=1; _gauges_unique"
            "_hour=1; _gauges_unique_day=1' -H 'Origin: http://httpbin.org' -H"
            " 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en-US,en;q"
            "=0.9,ru;q=0.8,es;q=0.7' -H 'Upgrade-Insecure-Requests: 1' -H 'Use"
            "r-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTM"
            "L, like Gecko) Ubuntu Chromium/62.0.3202.75 Chrome/62.0.3202.75 S"
            "afari/537.36' -H 'Content-Type: application/x-www-form-urlencoded"
            "' -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0"
            ".9,image/webp,image/apng,*/*;q=0.8' -H 'Cache-Control: max-age=0'"
            " -H 'Referer: http://httpbin.org/forms/post' -H 'Connection: keep"
            "-alive' --data 'custname=John+Smith&custtel=500&custemail=jsmith%"
            "40example.org&size=small&topping=cheese&topping=onion&delivery=12"
            "%3A15&comments=' --compressed"
        )
        expected_result = {
            "method": "POST",
            "url": "http://httpbin.org/post",
            "body": "custname=John+Smith&custtel=500&custemail=jsmith%40exampl"
            "e.org&size=small&topping=cheese&topping=onion&delivery=12"
            "%3A15&comments=",
            "cookies": {
                "_gauges_unique_year": "1",
                "_gauges_unique_hour": "1",
                "_gauges_unique_day": "1",
                "_gauges_unique": "1",
                "_gauges_unique_month": "1",
            },
            "headers": [
                ("Origin", "http://httpbin.org"),
                ("Accept-Encoding", "gzip, deflate"),
                ("Accept-Language", "en-US,en;q=0.9,ru;q=0.8,es;q=0.7"),
                ("Upgrade-Insecure-Requests", "1"),
                (
                    "User-Agent",
                    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML"
                    ", like Gecko) Ubuntu Chromium/62.0.3202.75 Chrome/62.0.32"
                    "02.75 Safari/537.36",
                ),
                ("Content-Type", "application/x-www-form-urlencoded"),
                (
                    "Accept",
                    "text/html,application/xhtml+xml,application/xml;q=0.9,ima"
                    "ge/webp,image/apng,*/*;q=0.8",
                ),
                ("Cache-Control", "max-age=0"),
                ("Referer", "http://httpbin.org/forms/post"),
                ("Connection", "keep-alive"),
            ],
        }
>       self._test_command(curl_command, expected_result)

/testbed/tests/test_utils_curl.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_utils_curl.py:15: in _test_command
    self.assertEqual(result, expected_result)
E   AssertionError: None != {'method': 'POST', 'url': 'http://httpbin[890 chars]e')]}
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_post_data_raw">test_utils_curl.py::CurlToRequestKwargsTest::test_post_data_raw</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_post_data_raw</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_post_data_raw>

    def test_post_data_raw(self):
        curl_command = (
            "curl 'https://www.example.org/' --data-raw 'excerptLength=200&ena"
            "bleDidYouMean=true&sortCriteria=ffirstz32xnamez32x201740686%20asc"
            "ending&queryFunctions=%5B%5D&rankingFunctions=%5B%5D'"
        )
        expected_result = {
            "method": "POST",
            "url": "https://www.example.org/",
            "body": (
                "excerptLength=200&enableDidYouMean=true&sortCriteria=ffirstz3"
                "2xnamez32x201740686%20ascending&queryFunctions=%5B%5D&ranking"
                "Functions=%5B%5D"
            ),
        }
>       self._test_command(curl_command, expected_result)

/testbed/tests/test_utils_curl.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_utils_curl.py:15: in _test_command
    self.assertEqual(result, expected_result)
E   AssertionError: None != {'method': 'POST', 'url': 'https://www.ex[157 chars]%5D'}
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_post_data_raw_with_string_prefix">test_utils_curl.py::CurlToRequestKwargsTest::test_post_data_raw_with_string_prefix</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_post_data_raw_with_string_prefix</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_post_data_raw_with_string_prefix>

    def test_post_data_raw_with_string_prefix(self):
        curl_command = "curl 'https://www.example.org/' --data-raw $'{\"$filters\":\"Filter\u0021\"}'"
        expected_result = {
            "method": "POST",
            "url": "https://www.example.org/",
            "body": '{"$filters":"Filter!"}',
        }
>       self._test_command(curl_command, expected_result)

/testbed/tests/test_utils_curl.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_utils_curl.py:15: in _test_command
    self.assertEqual(result, expected_result)
E   AssertionError: None != {'method': 'POST', 'url': 'https://www.ex[41 chars]!"}'}
</pre>
</details>
<h3 id="test_utils_curlpycurltorequestkwargstesttest_too_few_arguments_error">test_utils_curl.py::CurlToRequestKwargsTest::test_too_few_arguments_error</h3>
<details><summary> <pre>test_utils_curl.py::CurlToRequestKwargsTest::test_too_few_arguments_error</pre></summary><pre>
self = <tests.test_utils_curl.CurlToRequestKwargsTest testMethod=test_too_few_arguments_error>

    def test_too_few_arguments_error(self):
>       self.assertRaisesRegex(
            ValueError,
            r"too few arguments|the following arguments are required:\s*url",
            lambda: curl_to_request_kwargs("curl"),
        )
E       AssertionError: ValueError not raised by <lambda>

/testbed/tests/test_utils_curl.py:208: AssertionError
</pre>
</details>
<h3 id="test_utils_deferpymustbedeferredtesttest_success_function">test_utils_defer.py::MustbeDeferredTest::test_success_function</h3>
<details><summary> <pre>test_utils_defer.py::MustbeDeferredTest::test_success_function</pre></summary><pre>
self = <tests.test_utils_defer.MustbeDeferredTest testMethod=test_success_function>

    def test_success_function(self):
        steps = []

        def _append(v):
            steps.append(v)
            return steps

        dfd = mustbe_deferred(_append, 1)
>       dfd.addCallback(self.assertEqual, [1, 2])  # it is [1] with maybeDeferred
E       AttributeError: 'NoneType' object has no attribute 'addCallback'

/testbed/tests/test_utils_defer.py:31: AttributeError
</pre>
</details>
<h3 id="test_utils_deferpymustbedeferredtesttest_unfired_deferred">test_utils_defer.py::MustbeDeferredTest::test_unfired_deferred</h3>
<details><summary> <pre>test_utils_defer.py::MustbeDeferredTest::test_unfired_deferred</pre></summary><pre>
self = <tests.test_utils_defer.MustbeDeferredTest testMethod=test_unfired_deferred>

    def test_unfired_deferred(self):
        steps = []

        def _append(v):
            steps.append(v)
            dfd = defer.Deferred()
            reactor.callLater(0, dfd.callback, steps)
            return dfd

        dfd = mustbe_deferred(_append, 1)
>       dfd.addCallback(self.assertEqual, [1, 2])  # it is [1] with maybeDeferred
E       AttributeError: 'NoneType' object has no attribute 'addCallback'

/testbed/tests/test_utils_defer.py:45: AttributeError
</pre>
</details>
<h3 id="test_utils_deferpydeferutilstesttest_process_chain">test_utils_defer.py::DeferUtilsTest::test_process_chain</h3>
<details><summary> <pre>test_utils_defer.py::DeferUtilsTest::test_process_chain</pre></summary><pre>
self = <tests.test_utils_defer.DeferUtilsTest testMethod=test_process_chain>

    @defer.inlineCallbacks
    def test_process_chain(self):
        x = yield process_chain([cb1, cb2, cb3], "res", "v1", "v2")
>       self.assertEqual(x, "(cb3 (cb2 (cb1 res v1 v2) v1 v2) v1 v2)")

/testbed/tests/test_utils_defer.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:444: in assertEqual
    super().assertEqual(first, second, msg)
E   twisted.trial.unittest.FailTest: None != '(cb3 (cb2 (cb1 res v1 v2) v1 v2) v1 v2)'
</pre>
</details>
<h3 id="test_utils_deferpydeferutilstesttest_process_chain_both">test_utils_defer.py::DeferUtilsTest::test_process_chain_both</h3>
<details><summary> <pre>test_utils_defer.py::DeferUtilsTest::test_process_chain_both</pre></summary><pre>
self = <tests.test_utils_defer.DeferUtilsTest testMethod=test_process_chain_both>

    @defer.inlineCallbacks
    def test_process_chain_both(self):
        x = yield process_chain_both(
            [cb_fail, cb2, cb3], [None, eb1, None], "res", "v1", "v2"
        )
>       self.assertEqual(x, "(cb3 (eb1 TypeError v1 v2) v1 v2)")

/testbed/tests/test_utils_defer.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:444: in assertEqual
    super().assertEqual(first, second, msg)
E   twisted.trial.unittest.FailTest: None != '(cb3 (eb1 TypeError v1 v2) v1 v2)'
</pre>
</details>
<h3 id="test_utils_deferpydeferutilstesttest_process_parallel">test_utils_defer.py::DeferUtilsTest::test_process_parallel</h3>
<details><summary> <pre>test_utils_defer.py::DeferUtilsTest::test_process_parallel</pre></summary><pre>
self = <tests.test_utils_defer.DeferUtilsTest testMethod=test_process_parallel>

    @defer.inlineCallbacks
    def test_process_parallel(self):
        x = yield process_parallel([cb1, cb2, cb3], "res", "v1", "v2")
>       self.assertEqual(x, ["(cb1 res v1 v2)", "(cb2 res v1 v2)", "(cb3 res v1 v2)"])

/testbed/tests/test_utils_defer.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:444: in assertEqual
    super().assertEqual(first, second, msg)
E   twisted.trial.unittest.FailTest: None != ['(cb1 res v1 v2)', '(cb2 res v1 v2)', '(cb3 res v1 v2)']
</pre>
</details>
<h3 id="test_utils_deferpydeferutilstesttest_process_parallel_failure">test_utils_defer.py::DeferUtilsTest::test_process_parallel_failure</h3>
<details><summary> <pre>test_utils_defer.py::DeferUtilsTest::test_process_parallel_failure</pre></summary><pre>
self = <tests.test_utils_defer.DeferUtilsTest testMethod=test_process_parallel_failure>

    def test_process_parallel_failure(self):
        d = process_parallel([cb1, cb_fail, cb3], "res", "v1", "v2")
>       self.failUnlessFailure(d, TypeError)

/testbed/tests/test_utils_defer.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_utils_defer.DeferUtilsTest testMethod=test_process_parallel_failure>
deferred = None, expectedFailures = (<class 'TypeError'>,)
_cb = <function TestCase.assertFailure.<locals>._cb at 0x7fcb95c9b560>
_eb = <function TestCase.assertFailure.<locals>._eb at 0x7fcb95c9b7e0>

    def assertFailure(self, deferred, *expectedFailures):
        """
        Fail if C{deferred} does not errback with one of C{expectedFailures}.
        Returns the original Deferred with callbacks added. You will need
        to return this Deferred from your test case.
        """

        def _cb(ignore):
            raise self.failureException(
                f"did not catch an error, instead got {ignore!r}"
            )

        def _eb(failure):
            if failure.check(*expectedFailures):
                return failure.value
            else:
                output = "\nExpected: {!r}\nGot:\n{}".format(
                    expectedFailures, str(failure)
                )
                raise self.failureException(output)

>       return deferred.addCallbacks(_cb, _eb)
E       AttributeError: 'NoneType' object has no attribute 'addCallbacks'

/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_asynctest.py:82: AttributeError
</pre>
</details>
<h3 id="test_utils_deferpyitererrbacktesttest_iter_errback_bad">test_utils_defer.py::IterErrbackTest::test_iter_errback_bad</h3>
<details><summary> <pre>test_utils_defer.py::IterErrbackTest::test_iter_errback_bad</pre></summary><pre>
self = <tests.test_utils_defer.IterErrbackTest testMethod=test_iter_errback_bad>

    def test_iter_errback_bad(self):
        def iterbad():
            for x in range(10):
                if x == 5:
                    1 / 0
                yield x

        errors = []
>       out = list(iter_errback(iterbad(), errors.append))
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_utils_defer.py:126: TypeError
</pre>
</details>
<h3 id="test_utils_deferpyitererrbacktesttest_iter_errback_good">test_utils_defer.py::IterErrbackTest::test_iter_errback_good</h3>
<details><summary> <pre>test_utils_defer.py::IterErrbackTest::test_iter_errback_good</pre></summary><pre>
self = <tests.test_utils_defer.IterErrbackTest testMethod=test_iter_errback_good>

    def test_iter_errback_good(self):
        def itergood():
            for x in range(10):
                yield x

        errors = []
>       out = list(iter_errback(itergood(), errors.append))
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_utils_defer.py:114: TypeError
</pre>
</details>
<h3 id="test_utils_deferpyasynccooperatortesttest_delays">test_utils_defer.py::AsyncCooperatorTest::test_delays</h3>
<details><summary> <pre>test_utils_defer.py::AsyncCooperatorTest::test_delays</pre></summary><pre>
self = <tests.test_utils_defer.AsyncCooperatorTest testMethod=test_delays>

    @defer.inlineCallbacks
    def test_delays(self):
        for length in [20, 50, 100]:
            results = []
            ait = self.get_async_iterable_with_delays(length)
            dl = parallel_async(ait, self.CONCURRENT_ITEMS, self.callable, results)
            yield dl
>           self.assertEqual(list(range(length)), sorted(results))

/testbed/tests/test_utils_defer.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:444: in assertEqual
    super().assertEqual(first, second, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_utils_defer.AsyncCooperatorTest testMethod=test_delays>
msg = 'Lists differ: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] != []\n\nFirst list contains 20 ...elements.\nFirst extra element 0:\n0\n\n- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n+ []'

    def fail(self, msg: Optional[object] = None) -> NoReturn:
        """
        Absolutely fail the test.  Do not pass go, do not collect $200.

        @param msg: the message that will be displayed as the reason for the
        failure
        """
>       raise self.failureException(msg)
E       twisted.trial.unittest.FailTest: Lists differ: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] != []
E       
E       First list contains 20 additional elements.
E       First extra element 0:
E       0
E       
E       - [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
E       + []

/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:381: FailTest
</pre>
</details>
<h3 id="test_utils_deferpyasynccooperatortesttest_simple">test_utils_defer.py::AsyncCooperatorTest::test_simple</h3>
<details><summary> <pre>test_utils_defer.py::AsyncCooperatorTest::test_simple</pre></summary><pre>
self = <tests.test_utils_defer.AsyncCooperatorTest testMethod=test_simple>

    @defer.inlineCallbacks
    def test_simple(self):
        for length in [20, 50, 100]:
            results = []
            ait = self.get_async_iterable(length)
            dl = parallel_async(ait, self.CONCURRENT_ITEMS, self.callable, results)
            yield dl
>           self.assertEqual(list(range(length)), sorted(results))

/testbed/tests/test_utils_defer.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:444: in assertEqual
    super().assertEqual(first, second, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_utils_defer.AsyncCooperatorTest testMethod=test_simple>
msg = 'Lists differ: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] != []\n\nFirst list contains 20 ...elements.\nFirst extra element 0:\n0\n\n- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n+ []'

    def fail(self, msg: Optional[object] = None) -> NoReturn:
        """
        Absolutely fail the test.  Do not pass go, do not collect $200.

        @param msg: the message that will be displayed as the reason for the
        failure
        """
>       raise self.failureException(msg)
E       twisted.trial.unittest.FailTest: Lists differ: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] != []
E       
E       First list contains 20 additional elements.
E       First extra element 0:
E       0
E       
E       - [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
E       + []

/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:381: FailTest
</pre>
</details>
<h3 id="test_utils_deprecatepywarnwhensubclassedtesttest_clsdict">test_utils_deprecate.py::WarnWhenSubclassedTest::test_clsdict</h3>
<details><summary> <pre>test_utils_deprecate.py::WarnWhenSubclassedTest::test_clsdict</pre></summary><pre>
self = <tests.test_utils_deprecate.WarnWhenSubclassedTest testMethod=test_clsdict>

    def test_clsdict(self):
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", ScrapyDeprecationWarning)
            Deprecated = create_deprecated_class("Deprecated", NewName, {"foo": "bar"})

>       self.assertEqual(Deprecated.foo, "bar")
E       AttributeError: 'NoneType' object has no attribute 'foo'

/testbed/tests/test_utils_deprecate.py:225: AttributeError
</pre>
</details>
<h3 id="test_utils_deprecatepywarnwhensubclassedtesttest_custom_class_paths">test_utils_deprecate.py::WarnWhenSubclassedTest::test_custom_class_paths</h3>
<details><summary> <pre>test_utils_deprecate.py::WarnWhenSubclassedTest::test_custom_class_paths</pre></summary><pre>
self = <tests.test_utils_deprecate.WarnWhenSubclassedTest testMethod=test_custom_class_paths>

    def test_custom_class_paths(self):
        Deprecated = create_deprecated_class(
            "Deprecated",
            NewName,
            new_class_path="foo.NewClass",
            old_class_path="bar.OldClass",
            warn_category=MyWarning,
        )

        with warnings.catch_warnings(record=True) as w:

>           class UserClass(Deprecated):
E           TypeError: NoneType takes no arguments

/testbed/tests/test_utils_deprecate.py:65: TypeError
</pre>
</details>
<h3 id="test_utils_deprecatepywarnwhensubclassedtesttest_deprecate_subclass_of_deprecated_class">test_utils_deprecate.py::WarnWhenSubclassedTest::test_deprecate_subclass_of_deprecated_class</h3>
<details><summary> <pre>test_utils_deprecate.py::WarnWhenSubclassedTest::test_deprecate_subclass_of_deprecated_class</pre></summary><pre>
self = <tests.test_utils_deprecate.WarnWhenSubclassedTest testMethod=test_deprecate_subclass_of_deprecated_class>

    def test_deprecate_subclass_of_deprecated_class(self):
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            Deprecated = create_deprecated_class(
                "Deprecated", NewName, warn_category=MyWarning
            )
            AlsoDeprecated = create_deprecated_class(
                "AlsoDeprecated",
                Deprecated,
                new_class_path="foo.Bar",
                warn_category=MyWarning,
            )

        w = self._mywarnings(w)
        self.assertEqual(len(w), 0, str(map(str, w)))

        with warnings.catch_warnings(record=True) as w:
>           AlsoDeprecated()
E           TypeError: 'NoneType' object is not callable

/testbed/tests/test_utils_deprecate.py:249: TypeError
</pre>
</details>
<h3 id="test_utils_deprecatepywarnwhensubclassedtesttest_inspect_stack">test_utils_deprecate.py::WarnWhenSubclassedTest::test_inspect_stack</h3>
<details><summary> <pre>test_utils_deprecate.py::WarnWhenSubclassedTest::test_inspect_stack</pre></summary><pre>
self = <tests.test_utils_deprecate.WarnWhenSubclassedTest testMethod=test_inspect_stack>

    def test_inspect_stack(self):
        with mock.patch("inspect.stack", side_effect=IndexError):
            with warnings.catch_warnings(record=True) as w:
                DeprecatedName = create_deprecated_class("DeprecatedName", NewName)

>               class SubClass(DeprecatedName):
E               TypeError: NoneType takes no arguments

/testbed/tests/test_utils_deprecate.py:266: TypeError
</pre>
</details>
<h3 id="test_utils_deprecatepywarnwhensubclassedtesttest_isinstance">test_utils_deprecate.py::WarnWhenSubclassedTest::test_isinstance</h3>
<details><summary> <pre>test_utils_deprecate.py::WarnWhenSubclassedTest::test_isinstance</pre></summary><pre>
self = <tests.test_utils_deprecate.WarnWhenSubclassedTest testMethod=test_isinstance>

    def test_isinstance(self):
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", ScrapyDeprecationWarning)
            DeprecatedName = create_deprecated_class("DeprecatedName", NewName)

            class UpdatedUserClass2(NewName):
                pass

            class UpdatedUserClass2a(NewName):
                pass

>           class OutdatedUserClass2(DeprecatedName):
E           TypeError: NoneType takes no arguments

/testbed/tests/test_utils_deprecate.py:197: TypeError
</pre>
</details>
<h3 id="test_utils_deprecatepywarnwhensubclassedtesttest_issubclass">test_utils_deprecate.py::WarnWhenSubclassedTest::test_issubclass</h3>
<details><summary> <pre>test_utils_deprecate.py::WarnWhenSubclassedTest::test_issubclass</pre></summary><pre>
self = <tests.test_utils_deprecate.WarnWhenSubclassedTest testMethod=test_issubclass>

    def test_issubclass(self):
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", ScrapyDeprecationWarning)
            DeprecatedName = create_deprecated_class("DeprecatedName", NewName)

            class UpdatedUserClass1(NewName):
                pass

            class UpdatedUserClass1a(NewName):
                pass

>           class OutdatedUserClass1(DeprecatedName):
E           TypeError: NoneType takes no arguments

/testbed/tests/test_utils_deprecate.py:161: TypeError
</pre>
</details>
<h3 id="test_utils_deprecatepywarnwhensubclassedtesttest_subclassing_warning_message">test_utils_deprecate.py::WarnWhenSubclassedTest::test_subclassing_warning_message</h3>
<details><summary> <pre>test_utils_deprecate.py::WarnWhenSubclassedTest::test_subclassing_warning_message</pre></summary><pre>
self = <tests.test_utils_deprecate.WarnWhenSubclassedTest testMethod=test_subclassing_warning_message>

    def test_subclassing_warning_message(self):
        Deprecated = create_deprecated_class(
            "Deprecated", NewName, warn_category=MyWarning
        )

        with warnings.catch_warnings(record=True) as w:

>           class UserClass(Deprecated):
E           TypeError: NoneType takes no arguments

/testbed/tests/test_utils_deprecate.py:40: TypeError
</pre>
</details>
<h3 id="test_utils_deprecatepywarnwhensubclassedtesttest_subclassing_warns_once_by_default">test_utils_deprecate.py::WarnWhenSubclassedTest::test_subclassing_warns_once_by_default</h3>
<details><summary> <pre>test_utils_deprecate.py::WarnWhenSubclassedTest::test_subclassing_warns_once_by_default</pre></summary><pre>
self = <tests.test_utils_deprecate.WarnWhenSubclassedTest testMethod=test_subclassing_warns_once_by_default>

    def test_subclassing_warns_once_by_default(self):
        Deprecated = create_deprecated_class(
            "Deprecated", NewName, warn_category=MyWarning
        )

        with warnings.catch_warnings(record=True) as w:

>           class UserClass(Deprecated):
E           TypeError: NoneType takes no arguments

/testbed/tests/test_utils_deprecate.py:101: TypeError
</pre>
</details>
<h3 id="test_utils_deprecatepywarnwhensubclassedtesttest_subclassing_warns_only_on_direct_children">test_utils_deprecate.py::WarnWhenSubclassedTest::test_subclassing_warns_only_on_direct_children</h3>
<details><summary> <pre>test_utils_deprecate.py::WarnWhenSubclassedTest::test_subclassing_warns_only_on_direct_children</pre></summary><pre>
self = <tests.test_utils_deprecate.WarnWhenSubclassedTest testMethod=test_subclassing_warns_only_on_direct_children>

    def test_subclassing_warns_only_on_direct_children(self):
        Deprecated = create_deprecated_class(
            "Deprecated", NewName, warn_once=False, warn_category=MyWarning
        )

        with warnings.catch_warnings(record=True) as w:

>           class UserClass(Deprecated):
E           TypeError: NoneType takes no arguments

/testbed/tests/test_utils_deprecate.py:84: TypeError
</pre>
</details>
<h3 id="test_utils_deprecatepywarnwhensubclassedtesttest_warning_auto_message">test_utils_deprecate.py::WarnWhenSubclassedTest::test_warning_auto_message</h3>
<details><summary> <pre>test_utils_deprecate.py::WarnWhenSubclassedTest::test_warning_auto_message</pre></summary><pre>
self = <tests.test_utils_deprecate.WarnWhenSubclassedTest testMethod=test_warning_auto_message>

    def test_warning_auto_message(self):
        with warnings.catch_warnings(record=True) as w:
            Deprecated = create_deprecated_class("Deprecated", NewName)

>           class UserClass2(Deprecated):
E           TypeError: NoneType takes no arguments

/testbed/tests/test_utils_deprecate.py:143: TypeError
</pre>
</details>
<h3 id="test_utils_deprecatepywarnwhensubclassedtesttest_warning_on_instance">test_utils_deprecate.py::WarnWhenSubclassedTest::test_warning_on_instance</h3>
<details><summary> <pre>test_utils_deprecate.py::WarnWhenSubclassedTest::test_warning_on_instance</pre></summary><pre>
self = <tests.test_utils_deprecate.WarnWhenSubclassedTest testMethod=test_warning_on_instance>

    def test_warning_on_instance(self):
        Deprecated = create_deprecated_class(
            "Deprecated", NewName, warn_category=MyWarning
        )

        # ignore subclassing warnings
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", MyWarning)

>           class UserClass(Deprecated):
E           TypeError: NoneType takes no arguments

/testbed/tests/test_utils_deprecate.py:123: TypeError
</pre>
</details>
<h3 id="test_utils_deprecatepyupdateclasspathtesttest_old_path_gets_fixed">test_utils_deprecate.py::UpdateClassPathTest::test_old_path_gets_fixed</h3>
<details><summary> <pre>test_utils_deprecate.py::UpdateClassPathTest::test_old_path_gets_fixed</pre></summary><pre>
self = <tests.test_utils_deprecate.UpdateClassPathTest testMethod=test_old_path_gets_fixed>

    def test_old_path_gets_fixed(self):
        with warnings.catch_warnings(record=True) as w:
            output = update_classpath("scrapy.contrib.debug.Debug")
>       self.assertEqual(output, "scrapy.extensions.debug.Debug")
E       AssertionError: None != 'scrapy.extensions.debug.Debug'

/testbed/tests/test_utils_deprecate.py:283: AssertionError
</pre>
</details>
<h3 id="test_utils_deprecatepyupdateclasspathtesttest_returns_nonstring">test_utils_deprecate.py::UpdateClassPathTest::test_returns_nonstring</h3>
<details><summary> <pre>test_utils_deprecate.py::UpdateClassPathTest::test_returns_nonstring</pre></summary><pre>
self = <tests.test_utils_deprecate.UpdateClassPathTest testMethod=test_returns_nonstring>

    def test_returns_nonstring(self):
        for notastring in [None, True, [1, 2, 3], object()]:
>           self.assertEqual(update_classpath(notastring), notastring)
E           AssertionError: None != True

/testbed/tests/test_utils_deprecate.py:302: AssertionError
</pre>
</details>
<h3 id="test_utils_deprecatepyupdateclasspathtesttest_sorted_replacement">test_utils_deprecate.py::UpdateClassPathTest::test_sorted_replacement</h3>
<details><summary> <pre>test_utils_deprecate.py::UpdateClassPathTest::test_sorted_replacement</pre></summary><pre>
self = <tests.test_utils_deprecate.UpdateClassPathTest testMethod=test_sorted_replacement>

    def test_sorted_replacement(self):
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", ScrapyDeprecationWarning)
            output = update_classpath("scrapy.contrib.pipeline.Pipeline")
>       self.assertEqual(output, "scrapy.pipelines.Pipeline")
E       AssertionError: None != 'scrapy.pipelines.Pipeline'

/testbed/tests/test_utils_deprecate.py:292: AssertionError
</pre>
</details>
<h3 id="test_utils_deprecatepyupdateclasspathtesttest_unmatched_path_stays_the_same">test_utils_deprecate.py::UpdateClassPathTest::test_unmatched_path_stays_the_same</h3>
<details><summary> <pre>test_utils_deprecate.py::UpdateClassPathTest::test_unmatched_path_stays_the_same</pre></summary><pre>
self = <tests.test_utils_deprecate.UpdateClassPathTest testMethod=test_unmatched_path_stays_the_same>

    def test_unmatched_path_stays_the_same(self):
        with warnings.catch_warnings(record=True) as w:
            output = update_classpath("scrapy.unmatched.Path")
>       self.assertEqual(output, "scrapy.unmatched.Path")
E       AssertionError: None != 'scrapy.unmatched.Path'

/testbed/tests/test_utils_deprecate.py:297: AssertionError
</pre>
</details>
<h3 id="test_utils_displaypytestdisplaytest_pformat">test_utils_display.py::TestDisplay::test_pformat</h3>
<details><summary> <pre>test_utils_display.py::TestDisplay::test_pformat</pre></summary><pre>
self = <tests.test_utils_display.TestDisplay testMethod=test_pformat>
isatty = <MagicMock name='isatty' id='140512368756352'>

    @mock.patch("sys.platform", "linux")
    @mock.patch("sys.stdout.isatty")
    def test_pformat(self, isatty):
        isatty.return_value = True
>       self.assertIn(pformat(self.object), self.colorized_strings)
E       AssertionError: "{'a': 1}" not found in {"{\x1b[33m'\x1b[39;49;00m\x1b[33ma\x1b[39;49;00m\x1b[33m'\x1b[39;49;00m: \x1b[34m1\x1b[39;49;00m}\n", "{\x1b[33m'\x1b[39;49;00m\x1b[33ma\x1b[39;49;00m\x1b[33m'\x1b[39;49;00m: \x1b[34m1\x1b[39;49;00m}\x1b[37m\x1b[39;49;00m\n"}

/testbed/tests/test_utils_display.py:29: AssertionError
</pre>
</details>
<h3 id="test_utils_displaypytestdisplaytest_pformat_dont_colorize">test_utils_display.py::TestDisplay::test_pformat_dont_colorize</h3>
<details><summary> <pre>test_utils_display.py::TestDisplay::test_pformat_dont_colorize</pre></summary><pre>
self = <tests.test_utils_display.TestDisplay testMethod=test_pformat_dont_colorize>
isatty = <MagicMock name='isatty' id='140512371394416'>

    @mock.patch("sys.stdout.isatty")
    def test_pformat_dont_colorize(self, isatty):
        isatty.return_value = True
>       self.assertEqual(pformat(self.object, colorize=False), self.plain_string)

/testbed/tests/test_utils_display.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = {'a': 1}, args = (), kwargs = {'colorize': False}

    def pformat(obj: Any, *args: Any, **kwargs: Any) -> str:
        """Format a Python object into a pretty-printed representation."""
>       return pformat_(obj, *args, **kwargs)
E       TypeError: pformat() got an unexpected keyword argument 'colorize'

/testbed/scrapy/utils/display.py:35: TypeError
</pre>
</details>
<h3 id="test_utils_displaypytestdisplaytest_pformat_old_windows">test_utils_display.py::TestDisplay::test_pformat_old_windows</h3>
<details><summary> <pre>test_utils_display.py::TestDisplay::test_pformat_old_windows</pre></summary><pre>
self = <tests.test_utils_display.TestDisplay testMethod=test_pformat_old_windows>
isatty = <MagicMock name='isatty' id='140512368283184'>
version = <MagicMock name='version' id='140512369272176'>

    @mock.patch("sys.platform", "win32")
    @mock.patch("platform.version")
    @mock.patch("sys.stdout.isatty")
    def test_pformat_old_windows(self, isatty, version):
        isatty.return_value = True
        version.return_value = "10.0.14392"
>       self.assertIn(pformat(self.object), self.colorized_strings)
E       AssertionError: "{'a': 1}" not found in {"{\x1b[33m'\x1b[39;49;00m\x1b[33ma\x1b[39;49;00m\x1b[33m'\x1b[39;49;00m: \x1b[34m1\x1b[39;49;00m}\n", "{\x1b[33m'\x1b[39;49;00m\x1b[33ma\x1b[39;49;00m\x1b[33m'\x1b[39;49;00m: \x1b[34m1\x1b[39;49;00m}\x1b[37m\x1b[39;49;00m\n"}

/testbed/tests/test_utils_display.py:45: AssertionError
</pre>
</details>
<h3 id="test_utils_displaypytestdisplaytest_pformat_windows">test_utils_display.py::TestDisplay::test_pformat_windows</h3>
<details><summary> <pre>test_utils_display.py::TestDisplay::test_pformat_windows</pre></summary><pre>
self = <tests.test_utils_display.TestDisplay testMethod=test_pformat_windows>
isatty = <MagicMock name='isatty' id='140512392012880'>
version = <MagicMock name='version' id='140512368690576'>
terminal_processing = <MagicMock name='_enable_windows_terminal_processing' id='140512368703392'>

    @mock.patch("sys.platform", "win32")
    @mock.patch("scrapy.utils.display._enable_windows_terminal_processing")
    @mock.patch("platform.version")
    @mock.patch("sys.stdout.isatty")
    def test_pformat_windows(self, isatty, version, terminal_processing):
        isatty.return_value = True
        version.return_value = "10.0.14393"
        terminal_processing.return_value = True
>       self.assertIn(pformat(self.object), self.colorized_strings)
E       AssertionError: "{'a': 1}" not found in {"{\x1b[33m'\x1b[39;49;00m\x1b[33ma\x1b[39;49;00m\x1b[33m'\x1b[39;49;00m: \x1b[34m1\x1b[39;49;00m}\n", "{\x1b[33m'\x1b[39;49;00m\x1b[33ma\x1b[39;49;00m\x1b[33m'\x1b[39;49;00m: \x1b[34m1\x1b[39;49;00m}\x1b[37m\x1b[39;49;00m\n"}

/testbed/tests/test_utils_display.py:67: AssertionError
</pre>
</details>
<h3 id="test_utils_gzpygunziptesttest_gunzip_basic">test_utils_gz.py::GunzipTest::test_gunzip_basic</h3>
<details><summary> <pre>test_utils_gz.py::GunzipTest::test_gunzip_basic</pre></summary><pre>
self = <tests.test_utils_gz.GunzipTest testMethod=test_gunzip_basic>

    def test_gunzip_basic(self):
        r1 = Response(
            "http://www.example.com",
            body=(SAMPLEDIR / "feed-sample1.xml.gz").read_bytes(),
        )
>       self.assertTrue(gzip_magic_number(r1))
E       TypeError: 'bytes' object is not callable

/testbed/tests/test_utils_gz.py:19: TypeError
</pre>
</details>
<h3 id="test_utils_gzpygunziptesttest_gunzip_illegal_eof">test_utils_gz.py::GunzipTest::test_gunzip_illegal_eof</h3>
<details><summary> <pre>test_utils_gz.py::GunzipTest::test_gunzip_illegal_eof</pre></summary><pre>
self = <tests.test_utils_gz.GunzipTest testMethod=test_gunzip_illegal_eof>

    def test_gunzip_illegal_eof(self):
        text = html_to_unicode(
>           "charset=cp1252", gunzip((SAMPLEDIR / "unexpected-eof.gz").read_bytes())
        )[1]

/testbed/tests/test_utils_gz.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/gz.py:22: in gunzip
    chunk = f.read(_CHUNK_SIZE)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/gzip.py:324: in read
    return self._buffer.read(size)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/_compression.py:68: in readinto
    data = self.read(len(byte_view))
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/gzip.py:518: in read
    self._read_eof()
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/gzip.py:560: in _read_eof
    crc32, isize = struct.unpack("<II", _read_exact(self._fp, 8))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fp = <gzip._PaddedFile object at 0x7fcb95cb7a70>, n = 8

    def _read_exact(fp, n):
        '''Read exactly *n* bytes from `fp`

        This method is required because fp may be unbuffered,
        i.e. return short reads.
        '''
        data = fp.read(n)
        while len(data) < n:
            b = fp.read(n - len(data))
            if not b:
>               raise EOFError("Compressed file ended before the "
                               "end-of-stream marker was reached")
E               EOFError: Compressed file ended before the end-of-stream marker was reached

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/gzip.py:440: EOFError
</pre>
</details>
<h3 id="test_utils_gzpygunziptesttest_gunzip_no_gzip_file_raises">test_utils_gz.py::GunzipTest::test_gunzip_no_gzip_file_raises</h3>
<details><summary> <pre>test_utils_gz.py::GunzipTest::test_gunzip_no_gzip_file_raises</pre></summary><pre>
self = <tests.test_utils_gz.GunzipTest testMethod=test_gunzip_no_gzip_file_raises>

    def test_gunzip_no_gzip_file_raises(self):
>       self.assertRaises(
            OSError, gunzip, (SAMPLEDIR / "feed-sample1.xml").read_bytes()
        )
E       AssertionError: OSError not raised by gunzip

/testbed/tests/test_utils_gz.py:30: AssertionError
</pre>
</details>
<h3 id="test_utils_gzpygunziptesttest_gunzip_truncated">test_utils_gz.py::GunzipTest::test_gunzip_truncated</h3>
<details><summary> <pre>test_utils_gz.py::GunzipTest::test_gunzip_truncated</pre></summary><pre>
self = <tests.test_utils_gz.GunzipTest testMethod=test_gunzip_truncated>

    def test_gunzip_truncated(self):
>       text = gunzip((SAMPLEDIR / "truncated-crc-error.gz").read_bytes())

/testbed/tests/test_utils_gz.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/gz.py:22: in gunzip
    chunk = f.read(_CHUNK_SIZE)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/gzip.py:324: in read
    return self._buffer.read(size)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/_compression.py:68: in readinto
    data = self.read(len(byte_view))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gzip._GzipReader object at 0x7fcb95cdf550>, size = 32768

    def read(self, size=-1):
        if size < 0:
            return self.readall()
        # size=0 is special because decompress(max_length=0) is not supported
        if not size:
            return b""

        # For certain input data, a single
        # call to decompress() may not return
        # any data. In this case, retry until we get some data or reach EOF.
        while True:
            if self._decompressor.eof:
                # Ending case: we've come to the end of a member in the file,
                # so finish up this member, and read a new gzip header.
                # Check the CRC and file size, and set the flag so we read
                # a new member
                self._read_eof()
                self._new_member = True
                self._decompressor = self._decomp_factory(
                    **self._decomp_args)

            if self._new_member:
                # If the _new_member flag is set, we have to
                # jump to the next member, if there is one.
                self._init_read()
                if not self._read_gzip_header():
                    self._size = self._pos
                    return b""
                self._new_member = False

            # Read a chunk of data from the file
            if self._decompressor.needs_input:
                buf = self._fp.read(READ_BUFFER_SIZE)
                uncompress = self._decompressor.decompress(buf, size)
            else:
                uncompress = self._decompressor.decompress(b"", size)

            if self._decompressor.unused_data != b"":
                # Prepend the already read bytes to the fileobj so they can
                # be seen by _read_eof() and _read_gzip_header()
                self._fp.prepend(self._decompressor.unused_data)

            if uncompress != b"":
                break
            if buf == b"":
>               raise EOFError("Compressed file ended before the "
                               "end-of-stream marker was reached")
E               EOFError: Compressed file ended before the end-of-stream marker was reached

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/gzip.py:547: EOFError
</pre>
</details>
<h3 id="test_utils_gzpygunziptesttest_gunzip_truncated_short">test_utils_gz.py::GunzipTest::test_gunzip_truncated_short</h3>
<details><summary> <pre>test_utils_gz.py::GunzipTest::test_gunzip_truncated_short</pre></summary><pre>
self = <tests.test_utils_gz.GunzipTest testMethod=test_gunzip_truncated_short>

    def test_gunzip_truncated_short(self):
        r1 = Response(
            "http://www.example.com",
            body=(SAMPLEDIR / "truncated-crc-error-short.gz").read_bytes(),
        )
>       self.assertTrue(gzip_magic_number(r1))
E       TypeError: 'bytes' object is not callable

/testbed/tests/test_utils_gz.py:39: TypeError
</pre>
</details>
<h3 id="test_utils_gzpygunziptesttest_is_gzipped_empty">test_utils_gz.py::GunzipTest::test_is_gzipped_empty</h3>
<details><summary> <pre>test_utils_gz.py::GunzipTest::test_is_gzipped_empty</pre></summary><pre>
self = <tests.test_utils_gz.GunzipTest testMethod=test_is_gzipped_empty>

    def test_is_gzipped_empty(self):
        r1 = Response("http://www.example.com")
>       self.assertFalse(gzip_magic_number(r1))
E       TypeError: 'bytes' object is not callable

/testbed/tests/test_utils_gz.py:47: TypeError
</pre>
</details>
<h3 id="test_utils_httpobjpyhttpobjutilstesttest_urlparse_cached">test_utils_httpobj.py::HttpobjUtilsTest::test_urlparse_cached</h3>
<details><summary> <pre>test_utils_httpobj.py::HttpobjUtilsTest::test_urlparse_cached</pre></summary><pre>
self = <tests.test_utils_httpobj.HttpobjUtilsTest testMethod=test_urlparse_cached>

    def test_urlparse_cached(self):
        url = "http://www.example.com/index.html"
        request1 = Request(url)
        request2 = Request(url)
        req1a = urlparse_cached(request1)
        req1b = urlparse_cached(request1)
        req2 = urlparse_cached(request2)
        urlp = urlparse(url)

        assert req1a == req2
>       assert req1a == urlp
E       AssertionError

/testbed/tests/test_utils_httpobj.py:19: AssertionError
</pre>
</details>
<h3 id="test_utils_iteratorspyxmlitertestcasetest_deprecation">test_utils_iterators.py::XmliterTestCase::test_deprecation</h3>
<details><summary> <pre>test_utils_iterators.py::XmliterTestCase::test_deprecation</pre></summary><pre>
self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_deprecation>

    def test_deprecation(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <products>
              <product></product>
            </products>
        """
        with pytest.warns(
            ScrapyDeprecationWarning,
            match="xmliter",
        ):
>           next(self.xmliter(body, "product"))

/testbed/tests/test_utils_iterators.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:66: in xmliter
    yield Selector(text=nodetext, type="xml")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95ea1d30>
response = None, text = '<product></product>', type = 'xml'
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_deprecation>

    def test_deprecation(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <products>
              <product></product>
            </products>
        """
>       with pytest.warns(
            ScrapyDeprecationWarning,
            match="xmliter",
        ):
E       Failed: DID NOT WARN. No warnings of type (<class 'scrapy.exceptions.ScrapyDeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

/testbed/tests/test_utils_iterators.py:266: Failed
</pre>
</details>
<h3 id="test_utils_iteratorspyxmlitertestcasetest_xmliter">test_utils_iterators.py::XmliterTestCase::test_xmliter</h3>
<details><summary> <pre>test_utils_iterators.py::XmliterTestCase::test_xmliter</pre></summary><pre>
self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <products xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                      xsi:noNamespaceSchemaLocation="someschmea.xsd">
              <product id="001">
                <type>Type 1</type>
                <name>Name 1</name>
              </product>
              <product id="002">
                <type>Type 2</type>
                <name>Name 2</name>
              </product>
            </products>
        """

        response = XmlResponse(url="http://example.com", body=body)
        attrs = []
>       for x in self.xmliter(response, "product"):

/testbed/tests/test_utils_iterators.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:63: in xmliter
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d29280>
obj = <200 http://example.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyxmlitertestcasetest_xmliter_encoding">test_utils_iterators.py::XmliterTestCase::test_xmliter_encoding</h3>
<details><summary> <pre>test_utils_iterators.py::XmliterTestCase::test_xmliter_encoding</pre></summary><pre>
self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_encoding>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_encoding(self):
        body = (
            b'<?xml version="1.0" encoding="ISO-8859-9"?>\n'
            b"<xml>\n"
            b"    <item>Some Turkish Characters \xd6\xc7\xde\xdd\xd0\xdc \xfc\xf0\xfd\xfe\xe7\xf6</item>\n"
            b"</xml>\n\n"
        )
        response = XmlResponse("http://www.example.com", body=body)
        self.assertEqual(
>           next(self.xmliter(response, "item")).get(),
            "<item>Some Turkish Characters \xd6\xc7\u015e\u0130\u011e\xdc \xfc\u011f\u0131\u015f\xe7\xf6</item>",
        )

/testbed/tests/test_utils_iterators.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:63: in xmliter
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d2a6c0>
obj = <200 http://www.example.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyxmlitertestcasetest_xmliter_exception">test_utils_iterators.py::XmliterTestCase::test_xmliter_exception</h3>
<details><summary> <pre>test_utils_iterators.py::XmliterTestCase::test_xmliter_exception</pre></summary><pre>
self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_exception>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_exception(self):
        body = (
            '<?xml version="1.0" encoding="UTF-8"?>'
            "<products><product>one</product><product>two</product></products>"
        )

        iter = self.xmliter(body, "product")
>       next(iter)

/testbed/tests/test_utils_iterators.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:66: in xmliter
    yield Selector(text=nodetext, type="xml")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95ec1e10>
response = None, text = '<product>one</product>', type = 'xml'
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_utils_iteratorspyxmlitertestcasetest_xmliter_namespaced_nodename">test_utils_iterators.py::XmliterTestCase::test_xmliter_namespaced_nodename</h3>
<details><summary> <pre>test_utils_iterators.py::XmliterTestCase::test_xmliter_namespaced_nodename</pre></summary><pre>
self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_namespaced_nodename>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_namespaced_nodename(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <rss version="2.0" xmlns:g="http://base.google.com/ns/1.0">
                <channel>
                <title>My Dummy Company</title>
                <link>http://www.mydummycompany.com</link>
                <description>This is a dummy company. We do nothing.</description>
                <item>
                    <title>Item 1</title>
                    <description>This is item 1</description>
                    <link>http://www.mydummycompany.com/items/1</link>
                    <g:image_link>http://www.mydummycompany.com/images/item1.jpg</g:image_link>
                    <g:id>ITEM_1</g:id>
                    <g:price>400</g:price>
                </item>
                </channel>
            </rss>
        """
        response = XmlResponse(url="http://mydummycompany.com", body=body)
        my_iter = self.xmliter(response, "g:image_link")
>       node = next(my_iter)

/testbed/tests/test_utils_iterators.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:63: in xmliter
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d29250>
obj = <200 http://mydummycompany.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyxmlitertestcasetest_xmliter_namespaced_nodename_missing">test_utils_iterators.py::XmliterTestCase::test_xmliter_namespaced_nodename_missing</h3>
<details><summary> <pre>test_utils_iterators.py::XmliterTestCase::test_xmliter_namespaced_nodename_missing</pre></summary><pre>
self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_namespaced_nodename_missing>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_namespaced_nodename_missing(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <rss version="2.0" xmlns:g="http://base.google.com/ns/1.0">
                <channel>
                <title>My Dummy Company</title>
                <link>http://www.mydummycompany.com</link>
                <description>This is a dummy company. We do nothing.</description>
                <item>
                    <title>Item 1</title>
                    <description>This is item 1</description>
                    <link>http://www.mydummycompany.com/items/1</link>
                    <g:image_link>http://www.mydummycompany.com/images/item1.jpg</g:image_link>
                    <g:id>ITEM_1</g:id>
                    <g:price>400</g:price>
                </item>
                </channel>
            </rss>
        """
        response = XmlResponse(url="http://mydummycompany.com", body=body)
        my_iter = self.xmliter(response, "g:link_image")
        with self.assertRaises(StopIteration):
>           next(my_iter)

/testbed/tests/test_utils_iterators.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:63: in xmliter
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d28da0>
obj = <200 http://mydummycompany.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_namespaced_nodename_missing>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_namespaced_nodename_missing(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <rss version="2.0" xmlns:g="http://base.google.com/ns/1.0">
                <channel>
                <title>My Dummy Company</title>
                <link>http://www.mydummycompany.com</link>
                <description>This is a dummy company. We do nothing.</description>
                <item>
                    <title>Item 1</title>
                    <description>This is item 1</description>
                    <link>http://www.mydummycompany.com/items/1</link>
                    <g:image_link>http://www.mydummycompany.com/images/item1.jpg</g:image_link>
                    <g:id>ITEM_1</g:id>
                    <g:price>400</g:price>
                </item>
                </channel>
            </rss>
        """
        response = XmlResponse(url="http://mydummycompany.com", body=body)
        my_iter = self.xmliter(response, "g:link_image")
>       with self.assertRaises(StopIteration):

/testbed/tests/test_utils_iterators.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:355: in __exit__
    self._testCase.fail(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_namespaced_nodename_missing>
msg = 'builtins.AttributeError raised instead of StopIteration:\n Traceback (most recent call last):\n  File "/testbed/.venv...f.encoding = (obj.body, obj.encoding)\nbuiltins.AttributeError: \'XmlResponse\' object has no attribute \'encoding\'\n'

    def fail(self, msg: Optional[object] = None) -> NoReturn:
        """
        Absolutely fail the test.  Do not pass go, do not collect $200.

        @param msg: the message that will be displayed as the reason for the
        failure
        """
>       raise self.failureException(msg)
E       twisted.trial.unittest.FailTest: builtins.AttributeError raised instead of StopIteration:
E        Traceback (most recent call last):
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_asynctest.py", line 124, in _run
E           d = defer.maybeDeferred(
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/internet/defer.py", line 212, in maybeDeferred
E           result = f(*args, **kwargs)
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/internet/utils.py", line 223, in runWithWarningsSuppressed
E           result = f(*a, **kw)
E         File "/testbed/tests/test_utils_iterators.py", line 220, in test_xmliter_namespaced_nodename_missing
E           with self.assertRaises(StopIteration):
E       --- <exception caught here> ---
E         File "/testbed/tests/test_utils_iterators.py", line 221, in test_xmliter_namespaced_nodename_missing
E           next(my_iter)
E         File "/testbed/scrapy/utils/iterators.py", line 63, in xmliter
E           reader = _StreamReader(obj)
E         File "/testbed/scrapy/utils/iterators.py", line 35, in __init__
E           self._text, self.encoding = (obj.body, obj.encoding)
E       builtins.AttributeError: 'XmlResponse' object has no attribute 'encoding'

/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:381: FailTest
</pre>
</details>
<h3 id="test_utils_iteratorspyxmlitertestcasetest_xmliter_namespaces">test_utils_iterators.py::XmliterTestCase::test_xmliter_namespaces</h3>
<details><summary> <pre>test_utils_iterators.py::XmliterTestCase::test_xmliter_namespaces</pre></summary><pre>
self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_namespaces>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_namespaces(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <rss version="2.0" xmlns:g="http://base.google.com/ns/1.0">
                <channel>
                <title>My Dummy Company</title>
                <link>http://www.mydummycompany.com</link>
                <description>This is a dummy company. We do nothing.</description>
                <item>
                    <title>Item 1</title>
                    <description>This is item 1</description>
                    <link>http://www.mydummycompany.com/items/1</link>
                    <g:image_link>http://www.mydummycompany.com/images/item1.jpg</g:image_link>
                    <g:id>ITEM_1</g:id>
                    <g:price>400</g:price>
                </item>
                </channel>
            </rss>
        """
        response = XmlResponse(url="http://mydummycompany.com", body=body)
        my_iter = self.xmliter(response, "item")
>       node = next(my_iter)

/testbed/tests/test_utils_iterators.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:63: in xmliter
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d284d0>
obj = <200 http://mydummycompany.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyxmlitertestcasetest_xmliter_objtype_exception">test_utils_iterators.py::XmliterTestCase::test_xmliter_objtype_exception</h3>
<details><summary> <pre>test_utils_iterators.py::XmliterTestCase::test_xmliter_objtype_exception</pre></summary><pre>
self = <twisted.trial._synctest._AssertRaisesContext object at 0x7fcb95db9130>
obj = <function _Assertions.assertRaises.<locals>.<lambda> at 0x7fcb95c9aca0>

    def _handle(self, obj):
        """
        Call the given object using this object as a context manager.

        @param obj: The object to call and which is expected to raise some
            exception.
        @type obj: L{object}

        @return: Whatever exception is raised by C{obj()}.
        @rtype: L{BaseException}
        """
        with self as context:
>           self._returnValue = obj()

/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:321: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:430: in <lambda>
    return context._handle(lambda: f(*args, **kwargs))
/testbed/scrapy/utils/iterators.py:64: in xmliter
    for match in re.finditer(rf"<{nodename_patt}[\s>].*?</{nodename_patt}>", reader.read(), re.DOTALL):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95db9400>, n = -1

    def read(self, n: int=-1) -> str:
        """Returns a string from the given position and updates the internal pointer."""
        assert n <= 0 or n is None  # only reads all data
        if self._is_first_read:
            self._is_first_read = False
            if not self._is_unicode:
>               self._text = self._text.decode(self.encoding)
E               AttributeError: 'int' object has no attribute 'decode'

/testbed/scrapy/utils/iterators.py:49: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_objtype_exception>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_objtype_exception(self):
        i = self.xmliter(42, "product")
>       self.assertRaises(TypeError, next, i)

/testbed/tests/test_utils_iterators.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:430: in assertRaises
    return context._handle(lambda: f(*args, **kwargs))
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:320: in _handle
    with self as context:
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:355: in __exit__
    self._testCase.fail(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_objtype_exception>
msg = 'builtins.AttributeError raised instead of TypeError:\n Traceback (most recent call last):\n  File "/testbed/.venv/lib...  self._text = self._text.decode(self.encoding)\nbuiltins.AttributeError: \'int\' object has no attribute \'decode\'\n'

    def fail(self, msg: Optional[object] = None) -> NoReturn:
        """
        Absolutely fail the test.  Do not pass go, do not collect $200.

        @param msg: the message that will be displayed as the reason for the
        failure
        """
>       raise self.failureException(msg)
E       twisted.trial.unittest.FailTest: builtins.AttributeError raised instead of TypeError:
E        Traceback (most recent call last):
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/internet/utils.py", line 223, in runWithWarningsSuppressed
E           result = f(*a, **kw)
E         File "/testbed/tests/test_utils_iterators.py", line 239, in test_xmliter_objtype_exception
E           self.assertRaises(TypeError, next, i)
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py", line 430, in assertRaises
E           return context._handle(lambda: f(*args, **kwargs))
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py", line 320, in _handle
E           with self as context:
E       --- <exception caught here> ---
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py", line 321, in _handle
E           self._returnValue = obj()
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py", line 430, in <lambda>
E           return context._handle(lambda: f(*args, **kwargs))
E         File "/testbed/scrapy/utils/iterators.py", line 64, in xmliter
E           for match in re.finditer(rf"<{nodename_patt}[\s>].*?</{nodename_patt}>", reader.read(), re.DOTALL):
E         File "/testbed/scrapy/utils/iterators.py", line 49, in read
E           self._text = self._text.decode(self.encoding)
E       builtins.AttributeError: 'int' object has no attribute 'decode'

/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:381: FailTest
</pre>
</details>
<h3 id="test_utils_iteratorspyxmlitertestcasetest_xmliter_text">test_utils_iterators.py::XmliterTestCase::test_xmliter_text</h3>
<details><summary> <pre>test_utils_iterators.py::XmliterTestCase::test_xmliter_text</pre></summary><pre>
self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_text>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_text(self):
        body = (
            '<?xml version="1.0" encoding="UTF-8"?>'
            "<products><product>one</product><product>two</product></products>"
        )

        self.assertEqual(
>           [x.xpath("text()").getall() for x in self.xmliter(body, "product")],
            [["one"], ["two"]],
        )

/testbed/tests/test_utils_iterators.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:66: in xmliter
    yield Selector(text=nodetext, type="xml")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Selector' object has no attribute 'type'") raised in repr()] Selector object at 0x7fcb95ed8590>
response = None, text = '<product>one</product>', type = 'xml'
root = <object object at 0x7fcb9ad79df0>, kwargs = {}

    def __init__(self, response: Optional[TextResponse]=None, text: Optional[str]=None, type: Optional[str]=None, root: Optional[Any]=_NOT_SET, **kwargs: Any):
        if response is not None and text is not None:
            raise ValueError(f'{self.__class__.__name__}.__init__() received both response and text')
>       st = _st(response, type)
E       NameError: name '_st' is not defined

/testbed/scrapy/selector/unified.py:55: NameError
</pre>
</details>
<h3 id="test_utils_iteratorspyxmlitertestcasetest_xmliter_unicode">test_utils_iterators.py::XmliterTestCase::test_xmliter_unicode</h3>
<details><summary> <pre>test_utils_iterators.py::XmliterTestCase::test_xmliter_unicode</pre></summary><pre>
self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_unicode>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_unicode(self):
        # example taken from https://github.com/scrapy/scrapy/issues/1665
        body = """<?xml version="1.0" encoding="UTF-8"?>
            <þingflokkar>
               <þingflokkur id="26">
                  <heiti />
                  <skammstafanir>
                     <stuttskammstöfun>-</stuttskammstöfun>
                     <löngskammstöfun />
                  </skammstafanir>
                  <tímabil>
                     <fyrstaþing>80</fyrstaþing>
                  </tímabil>
               </þingflokkur>
               <þingflokkur id="21">
                  <heiti>Alþýðubandalag</heiti>
                  <skammstafanir>
                     <stuttskammstöfun>Ab</stuttskammstöfun>
                     <löngskammstöfun>Alþb.</löngskammstöfun>
                  </skammstafanir>
                  <tímabil>
                     <fyrstaþing>76</fyrstaþing>
                     <síðastaþing>123</síðastaþing>
                  </tímabil>
               </þingflokkur>
               <þingflokkur id="27">
                  <heiti>Alþýðuflokkur</heiti>
                  <skammstafanir>
                     <stuttskammstöfun>A</stuttskammstöfun>
                     <löngskammstöfun>Alþfl.</löngskammstöfun>
                  </skammstafanir>
                  <tímabil>
                     <fyrstaþing>27</fyrstaþing>
                     <síðastaþing>120</síðastaþing>
                  </tímabil>
               </þingflokkur>
            </þingflokkar>"""

        for r in (
            # with bytes
            XmlResponse(url="http://example.com", body=body.encode("utf-8")),
            # Unicode body needs encoding information
>           XmlResponse(url="http://example.com", body=body, encoding="utf-8"),
        ):

/testbed/tests/test_utils_iterators.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'XmlResponse' object has no attribute '_url'") raised in repr()] XmlResponse object at 0x7fcb95db88f0>
body = '<?xml version="1.0" encoding="UTF-8"?>\n            <þingflokkar>\n               <þingflokkur id="26">\n            ...síðastaþing>120</síðastaþing>\n                  </tímabil>\n               </þingflokkur>\n            </þingflokkar>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_utils_iteratorspyxmlitertestcasetest_xmliter_unusual_node">test_utils_iterators.py::XmliterTestCase::test_xmliter_unusual_node</h3>
<details><summary> <pre>test_utils_iterators.py::XmliterTestCase::test_xmliter_unusual_node</pre></summary><pre>
self = <tests.test_utils_iterators.XmliterTestCase testMethod=test_xmliter_unusual_node>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_unusual_node(self):
        body = b"""<?xml version="1.0" encoding="UTF-8"?>
            <root>
                <matchme...></matchme...>
                <matchmenot></matchmenot>
            </root>
        """
        response = XmlResponse(url="http://example.com", body=body)
        nodenames = [
>           e.xpath("name()").getall() for e in self.xmliter(response, "matchme...")
        ]

/testbed/tests/test_utils_iterators.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:63: in xmliter
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d84980>
obj = <200 http://example.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter</pre></summary><pre>
self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <products xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                      xsi:noNamespaceSchemaLocation="someschmea.xsd">
              <product id="001">
                <type>Type 1</type>
                <name>Name 1</name>
              </product>
              <product id="002">
                <type>Type 2</type>
                <name>Name 2</name>
              </product>
            </products>
        """

        response = XmlResponse(url="http://example.com", body=body)
        attrs = []
>       for x in self.xmliter(response, "product"):

/testbed/tests/test_utils_iterators.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:91: in xmliter_lxml
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d39d60>
obj = <200 http://example.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_encoding">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_encoding</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_encoding</pre></summary><pre>
self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_encoding>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_encoding(self):
        body = (
            b'<?xml version="1.0" encoding="ISO-8859-9"?>\n'
            b"<xml>\n"
            b"    <item>Some Turkish Characters \xd6\xc7\xde\xdd\xd0\xdc \xfc\xf0\xfd\xfe\xe7\xf6</item>\n"
            b"</xml>\n\n"
        )
        response = XmlResponse("http://www.example.com", body=body)
        self.assertEqual(
>           next(self.xmliter(response, "item")).get(),
            "<item>Some Turkish Characters \xd6\xc7\u015e\u0130\u011e\xdc \xfc\u011f\u0131\u015f\xe7\xf6</item>",
        )

/testbed/tests/test_utils_iterators.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:91: in xmliter_lxml
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d38a10>
obj = <200 http://www.example.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_exception">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_exception</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_exception</pre></summary><pre>
self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_exception>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_exception(self):
        body = (
            '<?xml version="1.0" encoding="UTF-8"?>'
            "<products><product>one</product><product>two</product></products>"
        )

        iter = self.xmliter(body, "product")
>       next(iter)

/testbed/tests/test_utils_iterators.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:96: in xmliter_lxml
    for event, node in parser:
src/lxml/iterparse.pxi:208: in lxml.etree.iterparse.__next__
    ???
src/lxml/iterparse.pxi:193: in lxml.etree.iterparse.__next__
    ???
src/lxml/iterparse.pxi:218: in lxml.etree.iterparse._read_more_events
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb96fb7f80>
n = 32768

    def read(self, n: int=-1) -> str:
        """Returns a string from the given position and updates the internal pointer."""
>       assert n <= 0 or n is None  # only reads all data
E       AssertionError

/testbed/scrapy/utils/iterators.py:45: AssertionError
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_iterate_namespace">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_iterate_namespace</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_iterate_namespace</pre></summary><pre>
self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_iterate_namespace>

    def test_xmliter_iterate_namespace(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <rss version="2.0" xmlns="http://base.google.com/ns/1.0">
                <channel>
                <title>My Dummy Company</title>
                <link>http://www.mydummycompany.com</link>
                <description>This is a dummy company. We do nothing.</description>
                <item>
                    <title>Item 1</title>
                    <description>This is item 1</description>
                    <link>http://www.mydummycompany.com/items/1</link>
                    <image_link>http://www.mydummycompany.com/images/item1.jpg</image_link>
                    <image_link>http://www.mydummycompany.com/images/item2.jpg</image_link>
                </item>
                </channel>
            </rss>
        """
        response = XmlResponse(url="http://mydummycompany.com", body=body)

        no_namespace_iter = self.xmliter(response, "image_link")
>       self.assertEqual(len(list(no_namespace_iter)), 0)

/testbed/tests/test_utils_iterators.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:91: in xmliter_lxml
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95db6060>
obj = <200 http://mydummycompany.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_namespaced_nodename">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaced_nodename</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaced_nodename</pre></summary><pre>
self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_namespaced_nodename>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_namespaced_nodename(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <rss version="2.0" xmlns:g="http://base.google.com/ns/1.0">
                <channel>
                <title>My Dummy Company</title>
                <link>http://www.mydummycompany.com</link>
                <description>This is a dummy company. We do nothing.</description>
                <item>
                    <title>Item 1</title>
                    <description>This is item 1</description>
                    <link>http://www.mydummycompany.com/items/1</link>
                    <g:image_link>http://www.mydummycompany.com/images/item1.jpg</g:image_link>
                    <g:id>ITEM_1</g:id>
                    <g:price>400</g:price>
                </item>
                </channel>
            </rss>
        """
        response = XmlResponse(url="http://mydummycompany.com", body=body)
        my_iter = self.xmliter(response, "g:image_link")
>       node = next(my_iter)

/testbed/tests/test_utils_iterators.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:91: in xmliter_lxml
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d394f0>
obj = <200 http://mydummycompany.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_namespaced_nodename_missing">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaced_nodename_missing</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaced_nodename_missing</pre></summary><pre>
self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_namespaced_nodename_missing>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_namespaced_nodename_missing(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <rss version="2.0" xmlns:g="http://base.google.com/ns/1.0">
                <channel>
                <title>My Dummy Company</title>
                <link>http://www.mydummycompany.com</link>
                <description>This is a dummy company. We do nothing.</description>
                <item>
                    <title>Item 1</title>
                    <description>This is item 1</description>
                    <link>http://www.mydummycompany.com/items/1</link>
                    <g:image_link>http://www.mydummycompany.com/images/item1.jpg</g:image_link>
                    <g:id>ITEM_1</g:id>
                    <g:price>400</g:price>
                </item>
                </channel>
            </rss>
        """
        response = XmlResponse(url="http://mydummycompany.com", body=body)
        my_iter = self.xmliter(response, "g:link_image")
        with self.assertRaises(StopIteration):
>           next(my_iter)

/testbed/tests/test_utils_iterators.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:91: in xmliter_lxml
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95c56d80>
obj = <200 http://mydummycompany.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_namespaced_nodename_missing>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_namespaced_nodename_missing(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <rss version="2.0" xmlns:g="http://base.google.com/ns/1.0">
                <channel>
                <title>My Dummy Company</title>
                <link>http://www.mydummycompany.com</link>
                <description>This is a dummy company. We do nothing.</description>
                <item>
                    <title>Item 1</title>
                    <description>This is item 1</description>
                    <link>http://www.mydummycompany.com/items/1</link>
                    <g:image_link>http://www.mydummycompany.com/images/item1.jpg</g:image_link>
                    <g:id>ITEM_1</g:id>
                    <g:price>400</g:price>
                </item>
                </channel>
            </rss>
        """
        response = XmlResponse(url="http://mydummycompany.com", body=body)
        my_iter = self.xmliter(response, "g:link_image")
>       with self.assertRaises(StopIteration):

/testbed/tests/test_utils_iterators.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:355: in __exit__
    self._testCase.fail(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_namespaced_nodename_missing>
msg = 'builtins.AttributeError raised instead of StopIteration:\n Traceback (most recent call last):\n  File "/testbed/.venv...f.encoding = (obj.body, obj.encoding)\nbuiltins.AttributeError: \'XmlResponse\' object has no attribute \'encoding\'\n'

    def fail(self, msg: Optional[object] = None) -> NoReturn:
        """
        Absolutely fail the test.  Do not pass go, do not collect $200.

        @param msg: the message that will be displayed as the reason for the
        failure
        """
>       raise self.failureException(msg)
E       twisted.trial.unittest.FailTest: builtins.AttributeError raised instead of StopIteration:
E        Traceback (most recent call last):
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_asynctest.py", line 124, in _run
E           d = defer.maybeDeferred(
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/internet/defer.py", line 212, in maybeDeferred
E           result = f(*args, **kwargs)
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/internet/utils.py", line 223, in runWithWarningsSuppressed
E           result = f(*a, **kw)
E         File "/testbed/tests/test_utils_iterators.py", line 220, in test_xmliter_namespaced_nodename_missing
E           with self.assertRaises(StopIteration):
E       --- <exception caught here> ---
E         File "/testbed/tests/test_utils_iterators.py", line 221, in test_xmliter_namespaced_nodename_missing
E           next(my_iter)
E         File "/testbed/scrapy/utils/iterators.py", line 91, in xmliter_lxml
E           reader = _StreamReader(obj)
E         File "/testbed/scrapy/utils/iterators.py", line 35, in __init__
E           self._text, self.encoding = (obj.body, obj.encoding)
E       builtins.AttributeError: 'XmlResponse' object has no attribute 'encoding'

/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:381: FailTest
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_namespaces">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaces</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaces</pre></summary><pre>
self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_namespaces>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_namespaces(self):
        body = b"""
            <?xml version="1.0" encoding="UTF-8"?>
            <rss version="2.0" xmlns:g="http://base.google.com/ns/1.0">
                <channel>
                <title>My Dummy Company</title>
                <link>http://www.mydummycompany.com</link>
                <description>This is a dummy company. We do nothing.</description>
                <item>
                    <title>Item 1</title>
                    <description>This is item 1</description>
                    <link>http://www.mydummycompany.com/items/1</link>
                    <g:image_link>http://www.mydummycompany.com/images/item1.jpg</g:image_link>
                    <g:id>ITEM_1</g:id>
                    <g:price>400</g:price>
                </item>
                </channel>
            </rss>
        """
        response = XmlResponse(url="http://mydummycompany.com", body=body)
        my_iter = self.xmliter(response, "item")
>       node = next(my_iter)

/testbed/tests/test_utils_iterators.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:91: in xmliter_lxml
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d31ac0>
obj = <200 http://mydummycompany.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_namespaces_prefix">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaces_prefix</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_namespaces_prefix</pre></summary><pre>
self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_namespaces_prefix>

    def test_xmliter_namespaces_prefix(self):
        body = b"""
        <?xml version="1.0" encoding="UTF-8"?>
        <root>
            <h:table xmlns:h="http://www.w3.org/TR/html4/">
              <h:tr>
                <h:td>Apples</h:td>
                <h:td>Bananas</h:td>
              </h:tr>
            </h:table>

            <f:table xmlns:f="http://www.w3schools.com/furniture">
              <f:name>African Coffee Table</f:name>
              <f:width>80</f:width>
              <f:length>120</f:length>
            </f:table>

        </root>
        """
        response = XmlResponse(url="http://mydummycompany.com", body=body)
        my_iter = self.xmliter(response, "table", "http://www.w3.org/TR/html4/", "h")

>       node = next(my_iter)

/testbed/tests/test_utils_iterators.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:91: in xmliter_lxml
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d32480>
obj = <200 http://mydummycompany.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_objtype_exception">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_objtype_exception</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_objtype_exception</pre></summary><pre>
self = <twisted.trial._synctest._AssertRaisesContext object at 0x7fcb95cdc350>
obj = <function _Assertions.assertRaises.<locals>.<lambda> at 0x7fcb95c9ac00>

    def _handle(self, obj):
        """
        Call the given object using this object as a context manager.

        @param obj: The object to call and which is expected to raise some
            exception.
        @type obj: L{object}

        @return: Whatever exception is raised by C{obj()}.
        @rtype: L{BaseException}
        """
        with self as context:
>           self._returnValue = obj()

/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:321: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:430: in <lambda>
    return context._handle(lambda: f(*args, **kwargs))
/testbed/scrapy/utils/iterators.py:96: in xmliter_lxml
    for event, node in parser:
src/lxml/iterparse.pxi:208: in lxml.etree.iterparse.__next__
    ???
src/lxml/iterparse.pxi:193: in lxml.etree.iterparse.__next__
    ???
src/lxml/iterparse.pxi:218: in lxml.etree.iterparse._read_more_events
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95cdf6e0>
n = 32768

    def read(self, n: int=-1) -> str:
        """Returns a string from the given position and updates the internal pointer."""
>       assert n <= 0 or n is None  # only reads all data
E       AssertionError

/testbed/scrapy/utils/iterators.py:45: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_objtype_exception>

    def test_xmliter_objtype_exception(self):
        i = self.xmliter(42, "product")
>       self.assertRaises(TypeError, next, i)

/testbed/tests/test_utils_iterators.py:349: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:430: in assertRaises
    return context._handle(lambda: f(*args, **kwargs))
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:320: in _handle
    with self as context:
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:355: in __exit__
    self._testCase.fail(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_objtype_exception>
msg = 'builtins.AssertionError raised instead of TypeError:\n Traceback (most recent call last):\n  File "/testbed/.venv/lib...ls/iterators.py", line 45, in read\n    assert n <= 0 or n is None  # only reads all data\nbuiltins.AssertionError: \n'

    def fail(self, msg: Optional[object] = None) -> NoReturn:
        """
        Absolutely fail the test.  Do not pass go, do not collect $200.

        @param msg: the message that will be displayed as the reason for the
        failure
        """
>       raise self.failureException(msg)
E       twisted.trial.unittest.FailTest: builtins.AssertionError raised instead of TypeError:
E        Traceback (most recent call last):
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/internet/utils.py", line 223, in runWithWarningsSuppressed
E           result = f(*a, **kw)
E         File "/testbed/tests/test_utils_iterators.py", line 349, in test_xmliter_objtype_exception
E           self.assertRaises(TypeError, next, i)
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py", line 430, in assertRaises
E           return context._handle(lambda: f(*args, **kwargs))
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py", line 320, in _handle
E           with self as context:
E       --- <exception caught here> ---
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py", line 321, in _handle
E           self._returnValue = obj()
E         File "/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py", line 430, in <lambda>
E           return context._handle(lambda: f(*args, **kwargs))
E         File "/testbed/scrapy/utils/iterators.py", line 96, in xmliter_lxml
E           for event, node in parser:
E         File "src/lxml/iterparse.pxi", line 208, in lxml.etree.iterparse.__next__
E           
E         File "src/lxml/iterparse.pxi", line 193, in lxml.etree.iterparse.__next__
E           
E         File "src/lxml/iterparse.pxi", line 218, in lxml.etree.iterparse._read_more_events
E           
E         File "/testbed/scrapy/utils/iterators.py", line 45, in read
E           assert n <= 0 or n is None  # only reads all data
E       builtins.AssertionError:

/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:381: FailTest
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_text">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_text</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_text</pre></summary><pre>
self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_text>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_text(self):
        body = (
            '<?xml version="1.0" encoding="UTF-8"?>'
            "<products><product>one</product><product>two</product></products>"
        )

        self.assertEqual(
>           [x.xpath("text()").getall() for x in self.xmliter(body, "product")],
            [["one"], ["two"]],
        )

/testbed/tests/test_utils_iterators.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:96: in xmliter_lxml
    for event, node in parser:
src/lxml/iterparse.pxi:208: in lxml.etree.iterparse.__next__
    ???
src/lxml/iterparse.pxi:193: in lxml.etree.iterparse.__next__
    ???
src/lxml/iterparse.pxi:218: in lxml.etree.iterparse._read_more_events
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d31af0>
n = 32768

    def read(self, n: int=-1) -> str:
        """Returns a string from the given position and updates the internal pointer."""
>       assert n <= 0 or n is None  # only reads all data
E       AssertionError

/testbed/scrapy/utils/iterators.py:45: AssertionError
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_unicode">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_unicode</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_unicode</pre></summary><pre>
self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_unicode>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_unicode(self):
        # example taken from https://github.com/scrapy/scrapy/issues/1665
        body = """<?xml version="1.0" encoding="UTF-8"?>
            <þingflokkar>
               <þingflokkur id="26">
                  <heiti />
                  <skammstafanir>
                     <stuttskammstöfun>-</stuttskammstöfun>
                     <löngskammstöfun />
                  </skammstafanir>
                  <tímabil>
                     <fyrstaþing>80</fyrstaþing>
                  </tímabil>
               </þingflokkur>
               <þingflokkur id="21">
                  <heiti>Alþýðubandalag</heiti>
                  <skammstafanir>
                     <stuttskammstöfun>Ab</stuttskammstöfun>
                     <löngskammstöfun>Alþb.</löngskammstöfun>
                  </skammstafanir>
                  <tímabil>
                     <fyrstaþing>76</fyrstaþing>
                     <síðastaþing>123</síðastaþing>
                  </tímabil>
               </þingflokkur>
               <þingflokkur id="27">
                  <heiti>Alþýðuflokkur</heiti>
                  <skammstafanir>
                     <stuttskammstöfun>A</stuttskammstöfun>
                     <löngskammstöfun>Alþfl.</löngskammstöfun>
                  </skammstafanir>
                  <tímabil>
                     <fyrstaþing>27</fyrstaþing>
                     <síðastaþing>120</síðastaþing>
                  </tímabil>
               </þingflokkur>
            </þingflokkar>"""

        for r in (
            # with bytes
            XmlResponse(url="http://example.com", body=body.encode("utf-8")),
            # Unicode body needs encoding information
>           XmlResponse(url="http://example.com", body=body, encoding="utf-8"),
        ):

/testbed/tests/test_utils_iterators.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/http/response/text.py:33: in __init__
    super().__init__(*args, **kwargs)
/testbed/scrapy/http/response/__init__.py:55: in __init__
    self._set_body(body)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'XmlResponse' object has no attribute '_url'") raised in repr()] XmlResponse object at 0x7fcb95d336e0>
body = '<?xml version="1.0" encoding="UTF-8"?>\n            <þingflokkar>\n               <þingflokkur id="26">\n            ...síðastaþing>120</síðastaþing>\n                  </tímabil>\n               </þingflokkur>\n            </þingflokkar>'

    def _set_body(self, body):
        if body is None:
            self._body = b""
        elif not isinstance(body, bytes):
>           raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse."
            )
E           TypeError: Response body must be bytes. If you want to pass unicode body use TextResponse or HtmlResponse.

/testbed/scrapy/http/response/__init__.py:103: TypeError
</pre>
</details>
<h3 id="test_utils_iteratorspylxmlxmlitertestcasetest_xmliter_unusual_node">test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_unusual_node</h3>
<details><summary> <pre>test_utils_iterators.py::LxmlXmliterTestCase::test_xmliter_unusual_node</pre></summary><pre>
self = <tests.test_utils_iterators.LxmlXmliterTestCase testMethod=test_xmliter_unusual_node>

    @pytest.mark.filterwarnings("ignore::scrapy.exceptions.ScrapyDeprecationWarning")
    def test_xmliter_unusual_node(self):
        body = b"""<?xml version="1.0" encoding="UTF-8"?>
            <root>
                <matchme...></matchme...>
                <matchmenot></matchmenot>
            </root>
        """
        response = XmlResponse(url="http://example.com", body=body)
        nodenames = [
>           e.xpath("name()").getall() for e in self.xmliter(response, "matchme...")
        ]

/testbed/tests/test_utils_iterators.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/iterators.py:91: in xmliter_lxml
    reader = _StreamReader(obj)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.iterators._StreamReader object at 0x7fcb95d31b50>
obj = <200 http://example.com>

    def __init__(self, obj: Union[Response, str, bytes]):
        self._ptr: int = 0
        self._text: Union[str, bytes]
        if isinstance(obj, TextResponse):
>           self._text, self.encoding = (obj.body, obj.encoding)
E           AttributeError: 'XmlResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:35: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyutilscsvtestcasetest_csviter_defaults">test_utils_iterators.py::UtilsCsvTestCase::test_csviter_defaults</h3>
<details><summary> <pre>test_utils_iterators.py::UtilsCsvTestCase::test_csviter_defaults</pre></summary><pre>
self = <tests.test_utils_iterators.UtilsCsvTestCase testMethod=test_csviter_defaults>

    def test_csviter_defaults(self):
        body = get_testdata("feeds", "feed-sample3.csv")
        response = TextResponse(url="http://example.com/", body=body)
        csv = csviter(response)

>       result = [row for row in csv]

/testbed/tests/test_utils_iterators.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <200 http://example.com/>, delimiter = None, headers = None
encoding = None, quotechar = None

    def csviter(obj: Union[Response, str, bytes], delimiter: Optional[str]=None, headers: Optional[List[str]]=None, encoding: Optional[str]=None, quotechar: Optional[str]=None) -> Generator[Dict[str, str], Any, None]:
        """Returns an iterator of dictionaries from the given csv object

        obj can be:
        - a Response object
        - a unicode string
        - a string encoded as utf-8

        delimiter is the character used to separate fields on the given obj.

        headers is an iterable that when provided offers the keys
        for the returned dictionaries, if not the first row is used.

        quotechar is the character used to enclosure fields on the given obj.
        """
        def _getrow(csv_r):
            return [to_unicode(field, encoding) for field in next(csv_r)]

>       encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or "utf-8"
E       AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:122: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyutilscsvtestcasetest_csviter_delimiter">test_utils_iterators.py::UtilsCsvTestCase::test_csviter_delimiter</h3>
<details><summary> <pre>test_utils_iterators.py::UtilsCsvTestCase::test_csviter_delimiter</pre></summary><pre>
self = <tests.test_utils_iterators.UtilsCsvTestCase testMethod=test_csviter_delimiter>

    def test_csviter_delimiter(self):
        body = get_testdata("feeds", "feed-sample3.csv").replace(b",", b"\t")
        response = TextResponse(url="http://example.com/", body=body)
        csv = csviter(response, delimiter="\t")

        self.assertEqual(
>           [row for row in csv],
            [
                {"id": "1", "name": "alpha", "value": "foobar"},
                {"id": "2", "name": "unicode", "value": "\xfan\xedc\xf3d\xe9\u203d"},
                {"id": "3", "name": "multi", "value": "foo\nbar"},
                {"id": "4", "name": "empty", "value": ""},
            ],
        )

/testbed/tests/test_utils_iterators.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <200 http://example.com/>, delimiter = '\t', headers = None
encoding = None, quotechar = None

    def csviter(obj: Union[Response, str, bytes], delimiter: Optional[str]=None, headers: Optional[List[str]]=None, encoding: Optional[str]=None, quotechar: Optional[str]=None) -> Generator[Dict[str, str], Any, None]:
        """Returns an iterator of dictionaries from the given csv object

        obj can be:
        - a Response object
        - a unicode string
        - a string encoded as utf-8

        delimiter is the character used to separate fields on the given obj.

        headers is an iterable that when provided offers the keys
        for the returned dictionaries, if not the first row is used.

        quotechar is the character used to enclosure fields on the given obj.
        """
        def _getrow(csv_r):
            return [to_unicode(field, encoding) for field in next(csv_r)]

>       encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or "utf-8"
E       AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:122: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyutilscsvtestcasetest_csviter_delimiter_binary_response_assume_utf8_encoding">test_utils_iterators.py::UtilsCsvTestCase::test_csviter_delimiter_binary_response_assume_utf8_encoding</h3>
<details><summary> <pre>test_utils_iterators.py::UtilsCsvTestCase::test_csviter_delimiter_binary_response_assume_utf8_encoding</pre></summary><pre>
obj = <200 http://example.com/>, delimiter = '\t'
headers = ['id', 'name', 'value'], encoding = 'utf-8', quotechar = None

    def csviter(obj: Union[Response, str, bytes], delimiter: Optional[str]=None, headers: Optional[List[str]]=None, encoding: Optional[str]=None, quotechar: Optional[str]=None) -> Generator[Dict[str, str], Any, None]:
        """Returns an iterator of dictionaries from the given csv object

        obj can be:
        - a Response object
        - a unicode string
        - a string encoded as utf-8

        delimiter is the character used to separate fields on the given obj.

        headers is an iterable that when provided offers the keys
        for the returned dictionaries, if not the first row is used.

        quotechar is the character used to enclosure fields on the given obj.
        """
        def _getrow(csv_r):
            return [to_unicode(field, encoding) for field in next(csv_r)]

        encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or "utf-8"

        # Python 3's csv.reader expects a file-like object that works in text mode
        lines = StringIO(to_unicode(obj.body if isinstance(obj, Response) else obj, encoding))

        kwargs = {}
        if delimiter:
            kwargs["delimiter"] = delimiter
        if quotechar:
            kwargs["quotechar"] = quotechar

        csv_r = csv.reader(lines, **kwargs)

        if not headers:
            headers = _getrow(csv_r)

        while True:
>           row = _getrow(csv_r)

/testbed/scrapy/utils/iterators.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

csv_r = <_csv.reader object at 0x7fcb95edb1b0>

    def _getrow(csv_r):
>       return [to_unicode(field, encoding) for field in next(csv_r)]
E       StopIteration

/testbed/scrapy/utils/iterators.py:120: StopIteration

The above exception was the direct cause of the following exception:

self = <tests.test_utils_iterators.UtilsCsvTestCase testMethod=test_csviter_delimiter_binary_response_assume_utf8_encoding>

    def test_csviter_delimiter_binary_response_assume_utf8_encoding(self):
        body = get_testdata("feeds", "feed-sample3.csv").replace(b",", b"\t")
        response = Response(url="http://example.com/", body=body)
        csv = csviter(response, delimiter="\t")

        self.assertEqual(
>           [row for row in csv],
            [
                {"id": "1", "name": "alpha", "value": "foobar"},
                {"id": "2", "name": "unicode", "value": "\xfan\xedc\xf3d\xe9\u203d"},
                {"id": "3", "name": "multi", "value": "foo\nbar"},
                {"id": "4", "name": "empty", "value": ""},
            ],
        )
E       RuntimeError: generator raised StopIteration

/testbed/tests/test_utils_iterators.py:444: RuntimeError
</pre>
</details>
<h3 id="test_utils_iteratorspyutilscsvtestcasetest_csviter_encoding">test_utils_iterators.py::UtilsCsvTestCase::test_csviter_encoding</h3>
<details><summary> <pre>test_utils_iterators.py::UtilsCsvTestCase::test_csviter_encoding</pre></summary><pre>
self = <tests.test_utils_iterators.UtilsCsvTestCase testMethod=test_csviter_encoding>

    def test_csviter_encoding(self):
        body1 = get_testdata("feeds", "feed-sample4.csv")
        body2 = get_testdata("feeds", "feed-sample5.csv")

        response = TextResponse(
            url="http://example.com/", body=body1, encoding="latin1"
        )
        csv = csviter(response)
        self.assertEqual(
>           list(csv),
            [
                {"id": "1", "name": "latin1", "value": "test"},
                {"id": "2", "name": "something", "value": "\xf1\xe1\xe9\xf3"},
            ],
        )

/testbed/tests/test_utils_iterators.py:508: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <200 http://example.com/>, delimiter = None, headers = None
encoding = None, quotechar = None

    def csviter(obj: Union[Response, str, bytes], delimiter: Optional[str]=None, headers: Optional[List[str]]=None, encoding: Optional[str]=None, quotechar: Optional[str]=None) -> Generator[Dict[str, str], Any, None]:
        """Returns an iterator of dictionaries from the given csv object

        obj can be:
        - a Response object
        - a unicode string
        - a string encoded as utf-8

        delimiter is the character used to separate fields on the given obj.

        headers is an iterable that when provided offers the keys
        for the returned dictionaries, if not the first row is used.

        quotechar is the character used to enclosure fields on the given obj.
        """
        def _getrow(csv_r):
            return [to_unicode(field, encoding) for field in next(csv_r)]

>       encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or "utf-8"
E       AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:122: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyutilscsvtestcasetest_csviter_exception">test_utils_iterators.py::UtilsCsvTestCase::test_csviter_exception</h3>
<details><summary> <pre>test_utils_iterators.py::UtilsCsvTestCase::test_csviter_exception</pre></summary><pre>
self = <tests.test_utils_iterators.UtilsCsvTestCase testMethod=test_csviter_exception>

    def test_csviter_exception(self):
        body = get_testdata("feeds", "feed-sample3.csv")

        response = TextResponse(url="http://example.com/", body=body)
        iter = csviter(response)
>       next(iter)

/testbed/tests/test_utils_iterators.py:492: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <200 http://example.com/>, delimiter = None, headers = None
encoding = None, quotechar = None

    def csviter(obj: Union[Response, str, bytes], delimiter: Optional[str]=None, headers: Optional[List[str]]=None, encoding: Optional[str]=None, quotechar: Optional[str]=None) -> Generator[Dict[str, str], Any, None]:
        """Returns an iterator of dictionaries from the given csv object

        obj can be:
        - a Response object
        - a unicode string
        - a string encoded as utf-8

        delimiter is the character used to separate fields on the given obj.

        headers is an iterable that when provided offers the keys
        for the returned dictionaries, if not the first row is used.

        quotechar is the character used to enclosure fields on the given obj.
        """
        def _getrow(csv_r):
            return [to_unicode(field, encoding) for field in next(csv_r)]

>       encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or "utf-8"
E       AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:122: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyutilscsvtestcasetest_csviter_falserow">test_utils_iterators.py::UtilsCsvTestCase::test_csviter_falserow</h3>
<details><summary> <pre>test_utils_iterators.py::UtilsCsvTestCase::test_csviter_falserow</pre></summary><pre>
self = <tests.test_utils_iterators.UtilsCsvTestCase testMethod=test_csviter_falserow>

    def test_csviter_falserow(self):
        body = get_testdata("feeds", "feed-sample3.csv")
        body = b"\n".join((body, b"a,b", b"a,b,c,d"))

        response = TextResponse(url="http://example.com/", body=body)
        csv = csviter(response)

        self.assertEqual(
>           [row for row in csv],
            [
                {"id": "1", "name": "alpha", "value": "foobar"},
                {"id": "2", "name": "unicode", "value": "\xfan\xedc\xf3d\xe9\u203d"},
                {"id": "3", "name": "multi", "value": "foo\nbar"},
                {"id": "4", "name": "empty", "value": ""},
            ],
        )

/testbed/tests/test_utils_iterators.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <200 http://example.com/>, delimiter = None, headers = None
encoding = None, quotechar = None

    def csviter(obj: Union[Response, str, bytes], delimiter: Optional[str]=None, headers: Optional[List[str]]=None, encoding: Optional[str]=None, quotechar: Optional[str]=None) -> Generator[Dict[str, str], Any, None]:
        """Returns an iterator of dictionaries from the given csv object

        obj can be:
        - a Response object
        - a unicode string
        - a string encoded as utf-8

        delimiter is the character used to separate fields on the given obj.

        headers is an iterable that when provided offers the keys
        for the returned dictionaries, if not the first row is used.

        quotechar is the character used to enclosure fields on the given obj.
        """
        def _getrow(csv_r):
            return [to_unicode(field, encoding) for field in next(csv_r)]

>       encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or "utf-8"
E       AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:122: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyutilscsvtestcasetest_csviter_headers">test_utils_iterators.py::UtilsCsvTestCase::test_csviter_headers</h3>
<details><summary> <pre>test_utils_iterators.py::UtilsCsvTestCase::test_csviter_headers</pre></summary><pre>
self = <tests.test_utils_iterators.UtilsCsvTestCase testMethod=test_csviter_headers>

    def test_csviter_headers(self):
        sample = get_testdata("feeds", "feed-sample3.csv").splitlines()
        headers, body = sample[0].split(b","), b"\n".join(sample[1:])

        response = TextResponse(url="http://example.com/", body=body)
        csv = csviter(response, headers=[h.decode("utf-8") for h in headers])

        self.assertEqual(
>           [row for row in csv],
            [
                {"id": "1", "name": "alpha", "value": "foobar"},
                {"id": "2", "name": "unicode", "value": "\xfan\xedc\xf3d\xe9\u203d"},
                {"id": "3", "name": "multi", "value": "foo\nbar"},
                {"id": "4", "name": "empty", "value": ""},
            ],
        )

/testbed/tests/test_utils_iterators.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <200 http://example.com/>, delimiter = None
headers = ['id', 'name', 'value'], encoding = None, quotechar = None

    def csviter(obj: Union[Response, str, bytes], delimiter: Optional[str]=None, headers: Optional[List[str]]=None, encoding: Optional[str]=None, quotechar: Optional[str]=None) -> Generator[Dict[str, str], Any, None]:
        """Returns an iterator of dictionaries from the given csv object

        obj can be:
        - a Response object
        - a unicode string
        - a string encoded as utf-8

        delimiter is the character used to separate fields on the given obj.

        headers is an iterable that when provided offers the keys
        for the returned dictionaries, if not the first row is used.

        quotechar is the character used to enclosure fields on the given obj.
        """
        def _getrow(csv_r):
            return [to_unicode(field, encoding) for field in next(csv_r)]

>       encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or "utf-8"
E       AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:122: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyutilscsvtestcasetest_csviter_quotechar">test_utils_iterators.py::UtilsCsvTestCase::test_csviter_quotechar</h3>
<details><summary> <pre>test_utils_iterators.py::UtilsCsvTestCase::test_csviter_quotechar</pre></summary><pre>
self = <tests.test_utils_iterators.UtilsCsvTestCase testMethod=test_csviter_quotechar>

    def test_csviter_quotechar(self):
        body1 = get_testdata("feeds", "feed-sample6.csv")
        body2 = get_testdata("feeds", "feed-sample6.csv").replace(b",", b"|")

        response1 = TextResponse(url="http://example.com/", body=body1)
        csv1 = csviter(response1, quotechar="'")

        self.assertEqual(
>           [row for row in csv1],
            [
                {"id": "1", "name": "alpha", "value": "foobar"},
                {"id": "2", "name": "unicode", "value": "\xfan\xedc\xf3d\xe9\u203d"},
                {"id": "3", "name": "multi", "value": "foo\nbar"},
                {"id": "4", "name": "empty", "value": ""},
            ],
        )

/testbed/tests/test_utils_iterators.py:397: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <200 http://example.com/>, delimiter = None, headers = None
encoding = None, quotechar = "'"

    def csviter(obj: Union[Response, str, bytes], delimiter: Optional[str]=None, headers: Optional[List[str]]=None, encoding: Optional[str]=None, quotechar: Optional[str]=None) -> Generator[Dict[str, str], Any, None]:
        """Returns an iterator of dictionaries from the given csv object

        obj can be:
        - a Response object
        - a unicode string
        - a string encoded as utf-8

        delimiter is the character used to separate fields on the given obj.

        headers is an iterable that when provided offers the keys
        for the returned dictionaries, if not the first row is used.

        quotechar is the character used to enclosure fields on the given obj.
        """
        def _getrow(csv_r):
            return [to_unicode(field, encoding) for field in next(csv_r)]

>       encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or "utf-8"
E       AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:122: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspyutilscsvtestcasetest_csviter_wrong_quotechar">test_utils_iterators.py::UtilsCsvTestCase::test_csviter_wrong_quotechar</h3>
<details><summary> <pre>test_utils_iterators.py::UtilsCsvTestCase::test_csviter_wrong_quotechar</pre></summary><pre>
self = <tests.test_utils_iterators.UtilsCsvTestCase testMethod=test_csviter_wrong_quotechar>

    def test_csviter_wrong_quotechar(self):
        body = get_testdata("feeds", "feed-sample6.csv")
        response = TextResponse(url="http://example.com/", body=body)
        csv = csviter(response)

        self.assertEqual(
>           [row for row in csv],
            [
                {"'id'": "1", "'name'": "'alpha'", "'value'": "'foobar'"},
                {
                    "'id'": "2",
                    "'name'": "'unicode'",
                    "'value'": "'\xfan\xedc\xf3d\xe9\u203d'",
                },
                {"'id'": "'3'", "'name'": "'multi'", "'value'": "'foo"},
                {"'id'": "4", "'name'": "'empty'", "'value'": ""},
            ],
        )

/testbed/tests/test_utils_iterators.py:425: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <200 http://example.com/>, delimiter = None, headers = None
encoding = None, quotechar = None

    def csviter(obj: Union[Response, str, bytes], delimiter: Optional[str]=None, headers: Optional[List[str]]=None, encoding: Optional[str]=None, quotechar: Optional[str]=None) -> Generator[Dict[str, str], Any, None]:
        """Returns an iterator of dictionaries from the given csv object

        obj can be:
        - a Response object
        - a unicode string
        - a string encoded as utf-8

        delimiter is the character used to separate fields on the given obj.

        headers is an iterable that when provided offers the keys
        for the returned dictionaries, if not the first row is used.

        quotechar is the character used to enclosure fields on the given obj.
        """
        def _getrow(csv_r):
            return [to_unicode(field, encoding) for field in next(csv_r)]

>       encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or "utf-8"
E       AttributeError: 'TextResponse' object has no attribute 'encoding'. Did you mean: '_encoding'?

/testbed/scrapy/utils/iterators.py:122: AttributeError
</pre>
</details>
<h3 id="test_utils_iteratorspytesthelpertest_body_or_str">test_utils_iterators.py::TestHelper::test_body_or_str</h3>
<details><summary> <pre>test_utils_iterators.py::TestHelper::test_body_or_str</pre></summary><pre>
self = <tests.test_utils_iterators.TestHelper testMethod=test_body_or_str>

    def test_body_or_str(self):
        for obj in (self.bbody, self.ubody, self.txtresponse, self.response):
            r1 = _body_or_str(obj)
>           self._assert_type_and_value(r1, self.ubody, obj)

/testbed/tests/test_utils_iterators.py:539: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/tests/test_utils_iterators.py:548: in _assert_type_and_value
    self.assertTrue(
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:402: in assertTrue
    super().assertTrue(condition, msg)
E   twisted.trial.unittest.FailTest: False is not true : Got <class 'bytes'>, expected <class 'str'> for b'utf8-body'
</pre>
</details>
<h3 id="initpyutilsmisctestcasetest_arg_to_iter"><strong>init</strong>.py::UtilsMiscTestCase::test_arg_to_iter</h3>
<details><summary> <pre>__init__.py::UtilsMiscTestCase::test_arg_to_iter</pre></summary><pre>
self = <tests.test_utils_misc.UtilsMiscTestCase testMethod=test_arg_to_iter>

    def test_arg_to_iter(self):
        class TestItem(Item):
            name = Field()

        assert hasattr(arg_to_iter(None), "__iter__")
>       assert hasattr(arg_to_iter(100), "__iter__")
E       AssertionError

/testbed/tests/test_utils_misc/__init__.py:83: AssertionError
</pre>
</details>
<h3 id="initpyutilsmisctestcasetest_rel_has_nofollow"><strong>init</strong>.py::UtilsMiscTestCase::test_rel_has_nofollow</h3>
<details><summary> <pre>__init__.py::UtilsMiscTestCase::test_rel_has_nofollow</pre></summary><pre>
self = <tests.test_utils_misc.UtilsMiscTestCase testMethod=test_rel_has_nofollow>

    def test_rel_has_nofollow(self):
        assert rel_has_nofollow("ugc nofollow") is True
>       assert rel_has_nofollow("ugc,nofollow") is True
E       AssertionError

/testbed/tests/test_utils_misc/__init__.py:170: AssertionError
</pre>
</details>
<h3 id="initpyutilsmisctestcasetest_set_environ"><strong>init</strong>.py::UtilsMiscTestCase::test_set_environ</h3>
<details><summary> <pre>__init__.py::UtilsMiscTestCase::test_set_environ</pre></summary><pre>
self = <tests.test_utils_misc.UtilsMiscTestCase testMethod=test_set_environ>

    def test_set_environ(self):
        assert os.environ.get("some_test_environ") is None
        with set_environ(some_test_environ="test_value"):
>           assert os.environ.get("some_test_environ") == "test_value"
E           AssertionError

/testbed/tests/test_utils_misc/__init__.py:159: AssertionError
</pre>
</details>
<h3 id="test_return_with_argument_inside_generatorpyutilsmiscpy3testcasetest_generators_return_none">test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_generators_return_none</h3>
<details><summary> <pre>test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_generators_return_none</pre></summary><pre>
self = <tests.test_utils_misc.test_return_with_argument_inside_generator.UtilsMiscPy3TestCase testMethod=test_generators_return_none>

        def test_generators_return_none(self):
            def f2():
                yield 1
                return None

            def g2():
                yield 1
                return

            def h2():
                yield 1

            def i2():
                yield 1
                yield from generator_that_returns_stuff()

            def j2():
                yield 1

                def helper():
                    return 0

                yield helper()

            def k2():
                """
                docstring
                """
                url = """
    https://example.org
            """
                yield url
                return

            def l2():
                return

>           assert not is_generator_with_return_value(top_level_return_none)

/testbed/tests/test_utils_misc/test_return_with_argument_inside_generator.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

callable = <function top_level_return_none at 0x7fcb96ff9d00>

    def is_generator_with_return_value(callable: Callable) -> bool:
        """
        Returns True if a callable is a generator function which includes a
        'return' statement with a value different than None, False otherwise
        """
        if not inspect.isgeneratorfunction(callable):
            return False

>       if callable in _generator_callbacks_cache:
E       NameError: name '_generator_callbacks_cache' is not defined

/testbed/scrapy/utils/misc.py:202: NameError
</pre>
</details>
<h3 id="test_return_with_argument_inside_generatorpyutilsmiscpy3testcasetest_generators_return_none_with_decorator">test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_generators_return_none_with_decorator</h3>
<details><summary> <pre>test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_generators_return_none_with_decorator</pre></summary><pre>
self = <tests.test_utils_misc.test_return_with_argument_inside_generator.UtilsMiscPy3TestCase testMethod=test_generators_return_none_with_decorator>

        def test_generators_return_none_with_decorator(self):
            def decorator(func):
                def inner_func():
                    func()

                return inner_func

            @decorator
            def f3():
                yield 1
                return None

            @decorator
            def g3():
                yield 1
                return

            @decorator
            def h3():
                yield 1

            @decorator
            def i3():
                yield 1
                yield from generator_that_returns_stuff()

            @decorator
            def j3():
                yield 1

                def helper():
                    return 0

                yield helper()

            @decorator
            def k3():
                """
                docstring
                """
                url = """
    https://example.org
            """
                yield url
                return

            @decorator
            def l3():
                return

>           assert not is_generator_with_return_value(top_level_return_none)

/testbed/tests/test_utils_misc/test_return_with_argument_inside_generator.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

callable = <function top_level_return_none at 0x7fcb96ff9d00>

    def is_generator_with_return_value(callable: Callable) -> bool:
        """
        Returns True if a callable is a generator function which includes a
        'return' statement with a value different than None, False otherwise
        """
        if not inspect.isgeneratorfunction(callable):
            return False

>       if callable in _generator_callbacks_cache:
E       NameError: name '_generator_callbacks_cache' is not defined

/testbed/scrapy/utils/misc.py:202: NameError
</pre>
</details>
<h3 id="test_return_with_argument_inside_generatorpyutilsmiscpy3testcasetest_generators_return_something">test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_generators_return_something</h3>
<details><summary> <pre>test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_generators_return_something</pre></summary><pre>
self = <tests.test_utils_misc.test_return_with_argument_inside_generator.UtilsMiscPy3TestCase testMethod=test_generators_return_something>

        def test_generators_return_something(self):
            def f1():
                yield 1
                return 2

            def g1():
                yield 1
                return "asdf"

            def h1():
                yield 1

                def helper():
                    return 0

                yield helper()
                return 2

            def i1():
                """
                docstring
                """
                url = """
    https://example.org
            """
                yield url
                return 1

>           assert is_generator_with_return_value(top_level_return_something)

/testbed/tests/test_utils_misc/test_return_with_argument_inside_generator.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

callable = <function top_level_return_something at 0x7fcb96ff9c60>

    def is_generator_with_return_value(callable: Callable) -> bool:
        """
        Returns True if a callable is a generator function which includes a
        'return' statement with a value different than None, False otherwise
        """
        if not inspect.isgeneratorfunction(callable):
            return False

>       if callable in _generator_callbacks_cache:
E       NameError: name '_generator_callbacks_cache' is not defined

/testbed/scrapy/utils/misc.py:202: NameError
</pre>
</details>
<h3 id="test_return_with_argument_inside_generatorpyutilsmiscpy3testcasetest_indentation_error">test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_indentation_error</h3>
<details><summary> <pre>test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_indentation_error</pre></summary><pre>
self = <tests.test_utils_misc.test_return_with_argument_inside_generator.UtilsMiscPy3TestCase testMethod=test_indentation_error>

    @mock.patch(
        "scrapy.utils.misc.is_generator_with_return_value", new=_indentation_error
    )
    def test_indentation_error(self):
        with warnings.catch_warnings(record=True) as w:
>           warn_on_generator_with_return_value(None, top_level_return_none)

/testbed/tests/test_utils_misc/test_return_with_argument_inside_generator.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/misc.py:234: in warn_on_generator_with_return_value
    if is_generator_with_return_value(callable):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<function top_level_return_none at 0x7fcb96ff9d00>,), kwargs = {}

    def _indentation_error(*args, **kwargs):
>       raise IndentationError()
E       IndentationError: <no detail available>

/testbed/tests/test_utils_misc/test_return_with_argument_inside_generator.py:13: IndentationError
</pre>
</details>
<h3 id="test_return_with_argument_inside_generatorpyutilsmiscpy3testcasetest_partial">test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_partial</h3>
<details><summary> <pre>test_return_with_argument_inside_generator.py::UtilsMiscPy3TestCase::test_partial</pre></summary><pre>
self = <tests.test_utils_misc.test_return_with_argument_inside_generator.UtilsMiscPy3TestCase testMethod=test_partial>

    def test_partial(self):
        def cb(arg1, arg2):
            yield {}

        partial_cb = partial(cb, arg1=42)
>       assert not is_generator_with_return_value(partial_cb)

/testbed/tests/test_utils_misc/test_return_with_argument_inside_generator.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

callable = functools.partial(<function UtilsMiscPy3TestCase.test_partial.<locals>.cb at 0x7fcb95ecef20>, arg1=42)

    def is_generator_with_return_value(callable: Callable) -> bool:
        """
        Returns True if a callable is a generator function which includes a
        'return' statement with a value different than None, False otherwise
        """
        if not inspect.isgeneratorfunction(callable):
            return False

>       if callable in _generator_callbacks_cache:
E       NameError: name '_generator_callbacks_cache' is not defined

/testbed/scrapy/utils/misc.py:202: NameError
</pre>
</details>
<h3 id="test_utils_projectpyprojectutilstesttest_data_path_inside_project">test_utils_project.py::ProjectUtilsTest::test_data_path_inside_project</h3>
<details><summary> <pre>test_utils_project.py::ProjectUtilsTest::test_data_path_inside_project</pre></summary><pre>
self = <tests.test_utils_project.ProjectUtilsTest testMethod=test_data_path_inside_project>

    def test_data_path_inside_project(self):
        with inside_a_project() as proj_path:
            expected = Path(proj_path, ".scrapy", "somepath")
>           self.assertEqual(expected.resolve(), Path(data_path("somepath")).resolve())
E           AssertionError: PosixPath('/tmp/tmpbvkp1o1c/.scrapy/somepath') != PosixPath('/root/.scrapy/projects/tmpbvkp1o1c/somepath')

/testbed/tests/test_utils_project.py:37: AssertionError
</pre>
</details>
<h3 id="test_utils_projectpyprojectutilstesttest_data_path_outside_project">test_utils_project.py::ProjectUtilsTest::test_data_path_outside_project</h3>
<details><summary> <pre>test_utils_project.py::ProjectUtilsTest::test_data_path_outside_project</pre></summary><pre>
self = <tests.test_utils_project.ProjectUtilsTest testMethod=test_data_path_outside_project>

    def test_data_path_outside_project(self):
>       self.assertEqual(str(Path(".scrapy", "somepath")), data_path("somepath"))
E       AssertionError: '.scrapy/somepath' != '/root/.scrapy/projects/default/somepath'
E       - .scrapy/somepath
E       + /root/.scrapy/projects/default/somepath

/testbed/tests/test_utils_project.py:30: AssertionError
</pre>
</details>
<h3 id="test_utils_projectpygetprojectsettingstestcasetest_invalid_envvar">test_utils_project.py::GetProjectSettingsTestCase::test_invalid_envvar</h3>
<details><summary> <pre>test_utils_project.py::GetProjectSettingsTestCase::test_invalid_envvar</pre></summary><pre>
self = <tests.test_utils_project.GetProjectSettingsTestCase testMethod=test_invalid_envvar>

    def test_invalid_envvar(self):
        envvars = {
            "SCRAPY_FOO": "bar",
        }
        with set_environ(**envvars):
>           settings = get_project_settings()

/testbed/tests/test_utils_project.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def get_project_settings():
        """Get project settings module from environment variable"""
        if ENVVAR not in os.environ:
            project = os.environ.get('SCRAPY_PROJECT', 'default')
            init_env(project)

        settings = Settings()
        settings_module_path = os.environ.get(ENVVAR)
        if settings_module_path:
            settings.setmodule(settings_module_path, priority='project')

        scrapy_cfg = closest_scrapy_cfg()
        if scrapy_cfg is not None:
            config = get_config()
>           for key, value in config.items('settings', default={}):
E           TypeError: RawConfigParser.items() got an unexpected keyword argument 'default'

/testbed/scrapy/utils/project.py:25: TypeError
</pre>
</details>
<h3 id="test_utils_projectpygetprojectsettingstestcasetest_valid_and_invalid_envvars">test_utils_project.py::GetProjectSettingsTestCase::test_valid_and_invalid_envvars</h3>
<details><summary> <pre>test_utils_project.py::GetProjectSettingsTestCase::test_valid_and_invalid_envvars</pre></summary><pre>
self = <tests.test_utils_project.GetProjectSettingsTestCase testMethod=test_valid_and_invalid_envvars>

    def test_valid_and_invalid_envvars(self):
        value = "tests.test_cmdline.settings"
        envvars = {
            "SCRAPY_FOO": "bar",
            "SCRAPY_SETTINGS_MODULE": value,
        }
        with set_environ(**envvars):
>           settings = get_project_settings()

/testbed/tests/test_utils_project.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def get_project_settings():
        """Get project settings module from environment variable"""
        if ENVVAR not in os.environ:
            project = os.environ.get('SCRAPY_PROJECT', 'default')
            init_env(project)

        settings = Settings()
        settings_module_path = os.environ.get(ENVVAR)
        if settings_module_path:
            settings.setmodule(settings_module_path, priority='project')

        scrapy_cfg = closest_scrapy_cfg()
        if scrapy_cfg is not None:
            config = get_config()
>           for key, value in config.items('settings', default={}):
E           TypeError: RawConfigParser.items() got an unexpected keyword argument 'default'

/testbed/scrapy/utils/project.py:25: TypeError
</pre>
</details>
<h3 id="test_utils_projectpygetprojectsettingstestcasetest_valid_envvar">test_utils_project.py::GetProjectSettingsTestCase::test_valid_envvar</h3>
<details><summary> <pre>test_utils_project.py::GetProjectSettingsTestCase::test_valid_envvar</pre></summary><pre>
self = <tests.test_utils_project.GetProjectSettingsTestCase testMethod=test_valid_envvar>

    def test_valid_envvar(self):
        value = "tests.test_cmdline.settings"
        envvars = {
            "SCRAPY_SETTINGS_MODULE": value,
        }
        with warnings.catch_warnings():
            warnings.simplefilter("error")
            with set_environ(**envvars):
>               settings = get_project_settings()

/testbed/tests/test_utils_project.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def get_project_settings():
        """Get project settings module from environment variable"""
        if ENVVAR not in os.environ:
            project = os.environ.get('SCRAPY_PROJECT', 'default')
            init_env(project)

        settings = Settings()
        settings_module_path = os.environ.get(ENVVAR)
        if settings_module_path:
            settings.setmodule(settings_module_path, priority='project')

        scrapy_cfg = closest_scrapy_cfg()
        if scrapy_cfg is not None:
            config = get_config()
>           for key, value in config.items('settings', default={}):
E           TypeError: RawConfigParser.items() got an unexpected keyword argument 'default'

/testbed/scrapy/utils/project.py:25: TypeError
</pre>
</details>
<h3 id="test_utils_pythonpymutablechaintesttest_mutablechain">test_utils_python.py::MutableChainTest::test_mutablechain</h3>
<details><summary> <pre>test_utils_python.py::MutableChainTest::test_mutablechain</pre></summary><pre>
self = <tests.test_utils_python.MutableChainTest testMethod=test_mutablechain>

    def test_mutablechain(self):
        m = MutableChain(range(2), [2, 3], (4, 5))
>       m.extend(range(6, 7))
E       AttributeError: 'MutableChain' object has no attribute 'extend'

/testbed/tests/test_utils_python.py:27: AttributeError
</pre>
</details>
<h3 id="test_utils_pythonpyutilspythontestcasetest_equal_attributes">test_utils_python.py::UtilsPythonTestCase::test_equal_attributes</h3>
<details><summary> <pre>test_utils_python.py::UtilsPythonTestCase::test_equal_attributes</pre></summary><pre>
self = <tests.test_utils_python.UtilsPythonTestCase testMethod=test_equal_attributes>

    def test_equal_attributes(self):
        class Obj:
            pass

        a = Obj()
        b = Obj()
        # no attributes given return False
>       self.assertFalse(equal_attributes(a, b, []))

/testbed/tests/test_utils_python.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:389: in assertFalse
    super().assertFalse(condition, msg)
E   twisted.trial.unittest.FailTest: True is not false
</pre>
</details>
<h3 id="test_utils_pythonpyutilspythontestcasetest_get_func_args">test_utils_python.py::UtilsPythonTestCase::test_get_func_args</h3>
<details><summary> <pre>test_utils_python.py::UtilsPythonTestCase::test_get_func_args</pre></summary><pre>
self = <tests.test_utils_python.UtilsPythonTestCase testMethod=test_get_func_args>

    def test_get_func_args(self):
        def f1(a, b, c):
            pass

        def f2(a, b=None, c=None):
            pass

        def f3(a, b=None, *, c=None):
            pass

        class A:
            def __init__(self, a, b, c):
                pass

            def method(self, a, b, c):
                pass

        class Callable:
            def __call__(self, a, b, c):
                pass

        a = A(1, 2, 3)
        cal = Callable()
        partial_f1 = functools.partial(f1, None)
        partial_f2 = functools.partial(f1, b=None)
        partial_f3 = functools.partial(partial_f2, None)

        self.assertEqual(get_func_args(f1), ["a", "b", "c"])
>       self.assertEqual(get_func_args(f2), ["a", "b", "c"])

/testbed/tests/test_utils_python.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:444: in assertEqual
    super().assertEqual(first, second, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests.test_utils_python.UtilsPythonTestCase testMethod=test_get_func_args>
msg = "Lists differ: ['a'] != ['a', 'b', 'c']\n\nSecond list contains 2 additional elements.\nFirst extra element 1:\n'b'\n\n- ['a']\n+ ['a', 'b', 'c']"

    def fail(self, msg: Optional[object] = None) -> NoReturn:
        """
        Absolutely fail the test.  Do not pass go, do not collect $200.

        @param msg: the message that will be displayed as the reason for the
        failure
        """
>       raise self.failureException(msg)
E       twisted.trial.unittest.FailTest: Lists differ: ['a'] != ['a', 'b', 'c']
E       
E       Second list contains 2 additional elements.
E       First extra element 1:
E       'b'
E       
E       - ['a']
E       + ['a', 'b', 'c']

/testbed/.venv/lib/python3.12/site-packages/twisted/trial/_synctest.py:381: FailTest
</pre>
</details>
<h3 id="test_utils_responsepyresponseutilstesttest_get_base_url">test_utils_response.py::ResponseUtilsTest::test_get_base_url</h3>
<details><summary> <pre>test_utils_response.py::ResponseUtilsTest::test_get_base_url</pre></summary><pre>
self = <tests.test_utils_response.ResponseUtilsTest testMethod=test_get_base_url>

    def test_get_base_url(self):
        resp = HtmlResponse(
            "http://www.example.com",
            body=b"""
        <html>
        <head><base href="http://www.example.com/img/" target="_blank"></head>
        <body>blahablsdfsal&amp;</body>
        </html>""",
        )
>       self.assertEqual(get_base_url(resp), "http://www.example.com/img/")

/testbed/tests/test_utils_response.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://www.example.com>

    def get_base_url(response: 'scrapy.http.response.text.TextResponse') -> str:
        """Return the base url of the given response, joined with the response url"""
        if response not in _baseurl_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:26: TypeError
</pre>
</details>
<h3 id="test_utils_responsepyresponseutilstesttest_get_meta_refresh">test_utils_response.py::ResponseUtilsTest::test_get_meta_refresh</h3>
<details><summary> <pre>test_utils_response.py::ResponseUtilsTest::test_get_meta_refresh</pre></summary><pre>
self = <tests.test_utils_response.ResponseUtilsTest testMethod=test_get_meta_refresh>

    def test_get_meta_refresh(self):
        r1 = HtmlResponse(
            "http://www.example.com",
            body=b"""
        <html>
        <head><title>Dummy</title><meta http-equiv="refresh" content="5;url=http://example.org/newpage" /></head>
        <body>blahablsdfsal&amp;</body>
        </html>""",
        )
        r2 = HtmlResponse(
            "http://www.example.com",
            body=b"""
        <html>
        <head><title>Dummy</title><noScript>
        <meta http-equiv="refresh" content="5;url=http://example.org/newpage" /></head>
        </noSCRIPT>
        <body>blahablsdfsal&amp;</body>
        </html>""",
        )
        r3 = HtmlResponse(
            "http://www.example.com",
            body=b"""
    <noscript><meta http-equiv="REFRESH" content="0;url=http://www.example.com/newpage</noscript>
    <script type="text/javascript">
    if(!checkCookies()){
        document.write('<meta http-equiv="REFRESH" content="0;url=http://www.example.com/newpage">');
    }
    </script>
        """,
        )
>       self.assertEqual(get_meta_refresh(r1), (5.0, "http://example.org/newpage"))

/testbed/tests/test_utils_response.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

response = <200 http://www.example.com>, ignore_tags = ('script', 'noscript')

    def get_meta_refresh(response: 'scrapy.http.response.text.TextResponse', ignore_tags: Iterable[str]=('script', 'noscript')) -> Union[Tuple[None, None], Tuple[float, str]]:
        """Parse the http-equiv refresh parameter from the given response"""
        if response not in _metaref_cache:
>           text = response.text[0:4096]
E           TypeError: 'NoneType' object is not subscriptable

/testbed/scrapy/utils/response.py:37: TypeError
</pre>
</details>
<h3 id="test_utils_responsepyresponseutilstesttest_open_in_browser_redos_head">test_utils_response.py::ResponseUtilsTest::test_open_in_browser_redos_head</h3>
<details><summary> <pre>test_utils_response.py::ResponseUtilsTest::test_open_in_browser_redos_head</pre></summary><pre>
self = <tests.test_utils_response.ResponseUtilsTest testMethod=test_open_in_browser_redos_head>

    def test_open_in_browser_redos_head(self):
        MAX_CPU_TIME = 0.02

        # Exploit input from
        # https://makenowjust-labs.github.io/recheck/playground/
        # for /(<head(?:>|\s.*?>))/ (old pattern to find the head element).
        body = b"<head\t" * 8_000

        response = HtmlResponse("https://example.com", body=body)

        start_time = process_time()

        open_in_browser(response, lambda url: True)

        end_time = process_time()
>       self.assertLess(end_time - start_time, MAX_CPU_TIME)
E       AssertionError: 0.240000000000002 not less than 0.02

/testbed/tests/test_utils_response.py:238: AssertionError
</pre>
</details>
<h3 id="test_utils_responsepyresponseutilstesttest_response_httprepr">test_utils_response.py::ResponseUtilsTest::test_response_httprepr</h3>
<details><summary> <pre>test_utils_response.py::ResponseUtilsTest::test_response_httprepr</pre></summary><pre>
self = <tests.test_utils_response.ResponseUtilsTest testMethod=test_response_httprepr>

    def test_response_httprepr(self):
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", ScrapyDeprecationWarning)

            r1 = Response("http://www.example.com")
>           self.assertEqual(response_httprepr(r1), b"HTTP/1.1 200 OK\r\n\r\n")
E           TypeError: 'NoneType' object is not callable

/testbed/tests/test_utils_response.py:32: TypeError
</pre>
</details>
<h3 id="test_utils_responsepytest_remove_html_commentsa-a">test_utils_response.py::test_remove_html_comments[a&lt;!---a]</h3>
<p><details><summary> <pre>test_utils_response.py::test_remove_html_comments[a&lt;!---a]</pre></summary><pre>
input_body = b'a&lt;!--', output_body = b'a'</p>
<div class="highlight"><pre><span></span><code>@pytest.mark.parametrize(
    &quot;input_body,output_body&quot;,
    (
        (
            b&quot;a&lt;!--&quot;,
            b&quot;a&quot;,
        ),
        (
            b&quot;a&lt;!----&gt;b&quot;,
            b&quot;ab&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&quot;,
            b&quot;ac&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&lt;!--&quot;,
            b&quot;ac&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&lt;!--d&quot;,
            b&quot;ac&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&lt;!----&gt;d&quot;,
            b&quot;acd&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;&lt;!--c--&gt;d&quot;,
            b&quot;ad&quot;,
        ),
    ),
)
def test_remove_html_comments(input_body, output_body):
    assert (
</code></pre></div>
<blockquote>
<div class="highlight"><pre><span></span><code>      _remove_html_comments(input_body) == output_body
    ), f&quot;{_remove_html_comments(input_body)=} == {output_body=}&quot;
</code></pre></div>
</blockquote>
<p>/testbed/tests/test_utils_response.py:276: </p>
<hr />
<p>/testbed/scrapy/utils/response.py:21: in _remove_html_comments
    return re.sub('<!--.*?-->', '', text, flags=re.DOTALL)</p>
<hr />
<p>pattern = '<!--.*?-->', repl = '', string = b'a&lt;!--', count = 0
flags = re.DOTALL</p>
<div class="highlight"><pre><span></span><code>def sub(pattern, repl, string, count=0, flags=0):
    &quot;&quot;&quot;Return the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in string by the
    replacement repl.  repl can be either a string or a callable;
    if a string, backslash escapes in it are processed.  If it is
    a callable, it&#39;s passed the Match object and must return
    a replacement string to be used.&quot;&quot;&quot;
</code></pre></div>
<blockquote>
<div class="highlight"><pre><span></span><code>  return _compile(pattern, flags).sub(repl, string, count)
</code></pre></div>
<p>E       TypeError: cannot use a string pattern on a bytes-like object</p>
</blockquote>
<p>/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/re/<strong>init</strong>.py:186: TypeError
</pre>
</details></p>
<h3 id="test_utils_responsepytest_remove_html_commentsab-ab">test_utils_response.py::test_remove_html_comments[a<!---->b-ab]</h3>
<details><summary> <pre>test_utils_response.py::test_remove_html_comments[a<!---->b-ab]</pre></summary><pre>
input_body = b'a<!---->b', output_body = b'ab'

    @pytest.mark.parametrize(
        "input_body,output_body",
        (
            (
                b"a<!--",
                b"a",
            ),
            (
                b"a<!---->b",
                b"ab",
            ),
            (
                b"a<!--b-->c",
                b"ac",
            ),
            (
                b"a<!--b-->c<!--",
                b"ac",
            ),
            (
                b"a<!--b-->c<!--d",
                b"ac",
            ),
            (
                b"a<!--b-->c<!---->d",
                b"acd",
            ),
            (
                b"a<!--b--><!--c-->d",
                b"ad",
            ),
        ),
    )
    def test_remove_html_comments(input_body, output_body):
        assert (
>           _remove_html_comments(input_body) == output_body
        ), f"{_remove_html_comments(input_body)=} == {output_body=}"

/testbed/tests/test_utils_response.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/response.py:21: in _remove_html_comments
    return re.sub('<!--.*?-->', '', text, flags=re.DOTALL)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pattern = '<!--.*?-->', repl = '', string = b'a<!---->b', count = 0
flags = re.DOTALL

    def sub(pattern, repl, string, count=0, flags=0):
        """Return the string obtained by replacing the leftmost
        non-overlapping occurrences of the pattern in string by the
        replacement repl.  repl can be either a string or a callable;
        if a string, backslash escapes in it are processed.  If it is
        a callable, it's passed the Match object and must return
        a replacement string to be used."""
>       return _compile(pattern, flags).sub(repl, string, count)
E       TypeError: cannot use a string pattern on a bytes-like object

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/re/__init__.py:186: TypeError
</pre>
</details>
<h3 id="test_utils_responsepytest_remove_html_commentsac-ac">test_utils_response.py::test_remove_html_comments[a<!--b-->c-ac]</h3>
<details><summary> <pre>test_utils_response.py::test_remove_html_comments[a<!--b-->c-ac]</pre></summary><pre>
input_body = b'a<!--b-->c', output_body = b'ac'

    @pytest.mark.parametrize(
        "input_body,output_body",
        (
            (
                b"a<!--",
                b"a",
            ),
            (
                b"a<!---->b",
                b"ab",
            ),
            (
                b"a<!--b-->c",
                b"ac",
            ),
            (
                b"a<!--b-->c<!--",
                b"ac",
            ),
            (
                b"a<!--b-->c<!--d",
                b"ac",
            ),
            (
                b"a<!--b-->c<!---->d",
                b"acd",
            ),
            (
                b"a<!--b--><!--c-->d",
                b"ad",
            ),
        ),
    )
    def test_remove_html_comments(input_body, output_body):
        assert (
>           _remove_html_comments(input_body) == output_body
        ), f"{_remove_html_comments(input_body)=} == {output_body=}"

/testbed/tests/test_utils_response.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/response.py:21: in _remove_html_comments
    return re.sub('<!--.*?-->', '', text, flags=re.DOTALL)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pattern = '<!--.*?-->', repl = '', string = b'a<!--b-->c', count = 0
flags = re.DOTALL

    def sub(pattern, repl, string, count=0, flags=0):
        """Return the string obtained by replacing the leftmost
        non-overlapping occurrences of the pattern in string by the
        replacement repl.  repl can be either a string or a callable;
        if a string, backslash escapes in it are processed.  If it is
        a callable, it's passed the Match object and must return
        a replacement string to be used."""
>       return _compile(pattern, flags).sub(repl, string, count)
E       TypeError: cannot use a string pattern on a bytes-like object

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/re/__init__.py:186: TypeError
</pre>
</details>
<h3 id="test_utils_responsepytest_remove_html_commentsac-ac_1">test_utils_response.py::test_remove_html_comments[a<!--b-->c&lt;!---ac]</h3>
<p><details><summary> <pre>test_utils_response.py::test_remove_html_comments[a<!--b-->c&lt;!---ac]</pre></summary><pre>
input_body = b'a<!--b-->c&lt;!--', output_body = b'ac'</p>
<div class="highlight"><pre><span></span><code>@pytest.mark.parametrize(
    &quot;input_body,output_body&quot;,
    (
        (
            b&quot;a&lt;!--&quot;,
            b&quot;a&quot;,
        ),
        (
            b&quot;a&lt;!----&gt;b&quot;,
            b&quot;ab&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&quot;,
            b&quot;ac&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&lt;!--&quot;,
            b&quot;ac&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&lt;!--d&quot;,
            b&quot;ac&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&lt;!----&gt;d&quot;,
            b&quot;acd&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;&lt;!--c--&gt;d&quot;,
            b&quot;ad&quot;,
        ),
    ),
)
def test_remove_html_comments(input_body, output_body):
    assert (
</code></pre></div>
<blockquote>
<div class="highlight"><pre><span></span><code>      _remove_html_comments(input_body) == output_body
    ), f&quot;{_remove_html_comments(input_body)=} == {output_body=}&quot;
</code></pre></div>
</blockquote>
<p>/testbed/tests/test_utils_response.py:276: </p>
<hr />
<p>/testbed/scrapy/utils/response.py:21: in _remove_html_comments
    return re.sub('<!--.*?-->', '', text, flags=re.DOTALL)</p>
<hr />
<p>pattern = '<!--.*?-->', repl = '', string = b'a<!--b-->c&lt;!--', count = 0
flags = re.DOTALL</p>
<div class="highlight"><pre><span></span><code>def sub(pattern, repl, string, count=0, flags=0):
    &quot;&quot;&quot;Return the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in string by the
    replacement repl.  repl can be either a string or a callable;
    if a string, backslash escapes in it are processed.  If it is
    a callable, it&#39;s passed the Match object and must return
    a replacement string to be used.&quot;&quot;&quot;
</code></pre></div>
<blockquote>
<div class="highlight"><pre><span></span><code>  return _compile(pattern, flags).sub(repl, string, count)
</code></pre></div>
<p>E       TypeError: cannot use a string pattern on a bytes-like object</p>
</blockquote>
<p>/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/re/<strong>init</strong>.py:186: TypeError
</pre>
</details></p>
<h3 id="test_utils_responsepytest_remove_html_commentsac-d-ac">test_utils_response.py::test_remove_html_comments[a<!--b-->c&lt;!--d-ac]</h3>
<p><details><summary> <pre>test_utils_response.py::test_remove_html_comments[a<!--b-->c&lt;!--d-ac]</pre></summary><pre>
input_body = b'a<!--b-->c&lt;!--d', output_body = b'ac'</p>
<div class="highlight"><pre><span></span><code>@pytest.mark.parametrize(
    &quot;input_body,output_body&quot;,
    (
        (
            b&quot;a&lt;!--&quot;,
            b&quot;a&quot;,
        ),
        (
            b&quot;a&lt;!----&gt;b&quot;,
            b&quot;ab&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&quot;,
            b&quot;ac&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&lt;!--&quot;,
            b&quot;ac&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&lt;!--d&quot;,
            b&quot;ac&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;c&lt;!----&gt;d&quot;,
            b&quot;acd&quot;,
        ),
        (
            b&quot;a&lt;!--b--&gt;&lt;!--c--&gt;d&quot;,
            b&quot;ad&quot;,
        ),
    ),
)
def test_remove_html_comments(input_body, output_body):
    assert (
</code></pre></div>
<blockquote>
<div class="highlight"><pre><span></span><code>      _remove_html_comments(input_body) == output_body
    ), f&quot;{_remove_html_comments(input_body)=} == {output_body=}&quot;
</code></pre></div>
</blockquote>
<p>/testbed/tests/test_utils_response.py:276: </p>
<hr />
<p>/testbed/scrapy/utils/response.py:21: in _remove_html_comments
    return re.sub('<!--.*?-->', '', text, flags=re.DOTALL)</p>
<hr />
<p>pattern = '<!--.*?-->', repl = '', string = b'a<!--b-->c&lt;!--d', count = 0
flags = re.DOTALL</p>
<div class="highlight"><pre><span></span><code>def sub(pattern, repl, string, count=0, flags=0):
    &quot;&quot;&quot;Return the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in string by the
    replacement repl.  repl can be either a string or a callable;
    if a string, backslash escapes in it are processed.  If it is
    a callable, it&#39;s passed the Match object and must return
    a replacement string to be used.&quot;&quot;&quot;
</code></pre></div>
<blockquote>
<div class="highlight"><pre><span></span><code>  return _compile(pattern, flags).sub(repl, string, count)
</code></pre></div>
<p>E       TypeError: cannot use a string pattern on a bytes-like object</p>
</blockquote>
<p>/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/re/<strong>init</strong>.py:186: TypeError
</pre>
</details></p>
<h3 id="test_utils_responsepytest_remove_html_commentsacd-acd">test_utils_response.py::test_remove_html_comments[a<!--b-->c<!---->d-acd]</h3>
<details><summary> <pre>test_utils_response.py::test_remove_html_comments[a<!--b-->c<!---->d-acd]</pre></summary><pre>
input_body = b'a<!--b-->c<!---->d', output_body = b'acd'

    @pytest.mark.parametrize(
        "input_body,output_body",
        (
            (
                b"a<!--",
                b"a",
            ),
            (
                b"a<!---->b",
                b"ab",
            ),
            (
                b"a<!--b-->c",
                b"ac",
            ),
            (
                b"a<!--b-->c<!--",
                b"ac",
            ),
            (
                b"a<!--b-->c<!--d",
                b"ac",
            ),
            (
                b"a<!--b-->c<!---->d",
                b"acd",
            ),
            (
                b"a<!--b--><!--c-->d",
                b"ad",
            ),
        ),
    )
    def test_remove_html_comments(input_body, output_body):
        assert (
>           _remove_html_comments(input_body) == output_body
        ), f"{_remove_html_comments(input_body)=} == {output_body=}"

/testbed/tests/test_utils_response.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/response.py:21: in _remove_html_comments
    return re.sub('<!--.*?-->', '', text, flags=re.DOTALL)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pattern = '<!--.*?-->', repl = '', string = b'a<!--b-->c<!---->d', count = 0
flags = re.DOTALL

    def sub(pattern, repl, string, count=0, flags=0):
        """Return the string obtained by replacing the leftmost
        non-overlapping occurrences of the pattern in string by the
        replacement repl.  repl can be either a string or a callable;
        if a string, backslash escapes in it are processed.  If it is
        a callable, it's passed the Match object and must return
        a replacement string to be used."""
>       return _compile(pattern, flags).sub(repl, string, count)
E       TypeError: cannot use a string pattern on a bytes-like object

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/re/__init__.py:186: TypeError
</pre>
</details>
<h3 id="test_utils_responsepytest_remove_html_commentsad-ad">test_utils_response.py::test_remove_html_comments[a<!--b--><!--c-->d-ad]</h3>
<details><summary> <pre>test_utils_response.py::test_remove_html_comments[a<!--b--><!--c-->d-ad]</pre></summary><pre>
input_body = b'a<!--b--><!--c-->d', output_body = b'ad'

    @pytest.mark.parametrize(
        "input_body,output_body",
        (
            (
                b"a<!--",
                b"a",
            ),
            (
                b"a<!---->b",
                b"ab",
            ),
            (
                b"a<!--b-->c",
                b"ac",
            ),
            (
                b"a<!--b-->c<!--",
                b"ac",
            ),
            (
                b"a<!--b-->c<!--d",
                b"ac",
            ),
            (
                b"a<!--b-->c<!---->d",
                b"acd",
            ),
            (
                b"a<!--b--><!--c-->d",
                b"ad",
            ),
        ),
    )
    def test_remove_html_comments(input_body, output_body):
        assert (
>           _remove_html_comments(input_body) == output_body
        ), f"{_remove_html_comments(input_body)=} == {output_body=}"

/testbed/tests/test_utils_response.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/response.py:21: in _remove_html_comments
    return re.sub('<!--.*?-->', '', text, flags=re.DOTALL)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pattern = '<!--.*?-->', repl = '', string = b'a<!--b--><!--c-->d', count = 0
flags = re.DOTALL

    def sub(pattern, repl, string, count=0, flags=0):
        """Return the string obtained by replacing the leftmost
        non-overlapping occurrences of the pattern in string by the
        replacement repl.  repl can be either a string or a callable;
        if a string, backslash escapes in it are processed.  If it is
        a callable, it's passed the Match object and must return
        a replacement string to be used."""
>       return _compile(pattern, flags).sub(repl, string, count)
E       TypeError: cannot use a string pattern on a bytes-like object

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/re/__init__.py:186: TypeError
</pre>
</details>
<h3 id="test_utils_serializepyjsonencodertestcasetest_encode_attrs_item">test_utils_serialize.py::JsonEncoderTestCase::test_encode_attrs_item</h3>
<details><summary> <pre>test_utils_serialize.py::JsonEncoderTestCase::test_encode_attrs_item</pre></summary><pre>
self = <tests.test_utils_serialize.JsonEncoderTestCase testMethod=test_encode_attrs_item>

    def test_encode_attrs_item(self):
        @attr.s
        class AttrsItem:
            name = attr.ib(type=str)
            url = attr.ib(type=str)
            price = attr.ib(type=int)

        item = AttrsItem(name="Product", url="http://product.org", price=1)
>       encoded = self.encoder.encode(item)

/testbed/tests/test_utils_serialize.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.serialize.ScrapyJSONEncoder object at 0x7fcb95d298b0>
o = AttrsItem(name='Product', url='http://product.org', price=1)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).

        For example, to support arbitrary iterators, you could
        implement default like this::

            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return super().default(o)

        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type AttrsItem is not JSON serializable

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:180: TypeError
</pre>
</details>
<h3 id="test_utils_serializepyjsonencodertestcasetest_encode_dataclass_item">test_utils_serialize.py::JsonEncoderTestCase::test_encode_dataclass_item</h3>
<details><summary> <pre>test_utils_serialize.py::JsonEncoderTestCase::test_encode_dataclass_item</pre></summary><pre>
self = <tests.test_utils_serialize.JsonEncoderTestCase testMethod=test_encode_dataclass_item>

    def test_encode_dataclass_item(self):
        @dataclasses.dataclass
        class TestDataClass:
            name: str
            url: str
            price: int

        item = TestDataClass(name="Product", url="http://product.org", price=1)
>       encoded = self.encoder.encode(item)

/testbed/tests/test_utils_serialize.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.serialize.ScrapyJSONEncoder object at 0x7fcb95d336e0>
o = JsonEncoderTestCase.test_encode_dataclass_item.<locals>.TestDataClass(name='Product', url='http://product.org', price=1)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).

        For example, to support arbitrary iterators, you could
        implement default like this::

            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return super().default(o)

        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type TestDataClass is not JSON serializable

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:180: TypeError
</pre>
</details>
<h3 id="test_utils_serializepyjsonencodertestcasetest_encode_decode">test_utils_serialize.py::JsonEncoderTestCase::test_encode_decode</h3>
<details><summary> <pre>test_utils_serialize.py::JsonEncoderTestCase::test_encode_decode</pre></summary><pre>
self = <tests.test_utils_serialize.JsonEncoderTestCase testMethod=test_encode_decode>

    def test_encode_decode(self):
        dt = datetime.datetime(2010, 1, 2, 10, 11, 12)
        dts = "2010-01-02 10:11:12"
        d = datetime.date(2010, 1, 2)
        ds = "2010-01-02"
        t = datetime.time(10, 11, 12)
        ts = "10:11:12"
        dec = Decimal("1000.12")
        decs = "1000.12"
        s = {"foo"}
        ss = ["foo"]
        dt_set = {dt}
        dt_sets = [dts]

        for input, output in [
            ("foo", "foo"),
            (d, ds),
            (t, ts),
            (dt, dts),
            (dec, decs),
            (["foo", d], ["foo", ds]),
            (s, ss),
            (dt_set, dt_sets),
        ]:
            self.assertEqual(
>               self.encoder.encode(input), json.dumps(output, sort_keys=True)
            )

/testbed/tests/test_utils_serialize.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.serialize.ScrapyJSONEncoder object at 0x7fcb95cc47a0>
o = datetime.date(2010, 1, 2)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).

        For example, to support arbitrary iterators, you could
        implement default like this::

            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return super().default(o)

        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type date is not JSON serializable

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:180: TypeError
</pre>
</details>
<h3 id="test_utils_serializepyjsonencodertestcasetest_encode_deferred">test_utils_serialize.py::JsonEncoderTestCase::test_encode_deferred</h3>
<details><summary> <pre>test_utils_serialize.py::JsonEncoderTestCase::test_encode_deferred</pre></summary><pre>
self = <tests.test_utils_serialize.JsonEncoderTestCase testMethod=test_encode_deferred>

    def test_encode_deferred(self):
>       self.assertIn("Deferred", self.encoder.encode(defer.Deferred()))

/testbed/tests/test_utils_serialize.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.serialize.ScrapyJSONEncoder object at 0x7fcb95e2a7e0>
o = <Deferred at 0x7fcb95e29f70>

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).

        For example, to support arbitrary iterators, you could
        implement default like this::

            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return super().default(o)

        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type Deferred is not JSON serializable

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:180: TypeError
</pre>
</details>
<h3 id="test_utils_serializepyjsonencodertestcasetest_encode_request">test_utils_serialize.py::JsonEncoderTestCase::test_encode_request</h3>
<details><summary> <pre>test_utils_serialize.py::JsonEncoderTestCase::test_encode_request</pre></summary><pre>
self = <tests.test_utils_serialize.JsonEncoderTestCase testMethod=test_encode_request>

    def test_encode_request(self):
        r = Request("http://www.example.com/lala")
>       rs = self.encoder.encode(r)

/testbed/tests/test_utils_serialize.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.serialize.ScrapyJSONEncoder object at 0x7fcb95e2b410>
o = <GET http://www.example.com/lala>

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).

        For example, to support arbitrary iterators, you could
        implement default like this::

            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return super().default(o)

        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type Request is not JSON serializable

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:180: TypeError
</pre>
</details>
<h3 id="test_utils_serializepyjsonencodertestcasetest_encode_response">test_utils_serialize.py::JsonEncoderTestCase::test_encode_response</h3>
<details><summary> <pre>test_utils_serialize.py::JsonEncoderTestCase::test_encode_response</pre></summary><pre>
self = <tests.test_utils_serialize.JsonEncoderTestCase testMethod=test_encode_response>

    def test_encode_response(self):
        r = Response("http://www.example.com/lala")
>       rs = self.encoder.encode(r)

/testbed/tests/test_utils_serialize.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scrapy.utils.serialize.ScrapyJSONEncoder object at 0x7fcb96fb6d50>
o = <200 http://www.example.com/lala>

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).

        For example, to support arbitrary iterators, you could
        implement default like this::

            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return super().default(o)

        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type Response is not JSON serializable

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/encoder.py:180: TypeError
</pre>
</details>
<h3 id="test_utils_sitemappysitemaptesttest_sitemap_urls_from_robots">test_utils_sitemap.py::SitemapTest::test_sitemap_urls_from_robots</h3>
<details><summary> <pre>test_utils_sitemap.py::SitemapTest::test_sitemap_urls_from_robots</pre></summary><pre>
self = <tests.test_utils_sitemap.SitemapTest testMethod=test_sitemap_urls_from_robots>

        def test_sitemap_urls_from_robots(self):
            robots = """User-agent: *
    Disallow: /aff/
    Disallow: /wl/

    # Search and shopping refining
    Disallow: /s*/*facet
    Disallow: /s*/*tags

    # Sitemap files
    Sitemap: http://example.com/sitemap.xml
    Sitemap: http://example.com/sitemap-product-index.xml
    Sitemap: HTTP://example.com/sitemap-uppercase.xml
    Sitemap: /sitemap-relative-url.xml

    # Forums
    Disallow: /forum/search/
    Disallow: /forum/active/
    """
            self.assertEqual(
>               list(sitemap_urls_from_robots(robots, base_url="http://example.com")),
                [
                    "http://example.com/sitemap.xml",
                    "http://example.com/sitemap-product-index.xml",
                    "http://example.com/sitemap-uppercase.xml",
                    "http://example.com/sitemap-relative-url.xml",
                ],
            )
E           TypeError: 'NoneType' object is not iterable

/testbed/tests/test_utils_sitemap.py:191: TypeError
</pre>
</details>
<h3 id="test_utils_spiderpyutilsspiderstestcasetest_iterate_spider_output">test_utils_spider.py::UtilsSpidersTestCase::test_iterate_spider_output</h3>
<details><summary> <pre>test_utils_spider.py::UtilsSpidersTestCase::test_iterate_spider_output</pre></summary><pre>
self = <tests.test_utils_spider.UtilsSpidersTestCase testMethod=test_iterate_spider_output>

    def test_iterate_spider_output(self):
        i = Item()
        r = Request("http://scrapytest.org")
        o = object()

        self.assertEqual(list(iterate_spider_output(i)), [i])
>       self.assertEqual(list(iterate_spider_output(r)), [r])
E       TypeError: 'Request' object is not iterable

/testbed/tests/test_utils_spider.py:24: TypeError
</pre>
</details>
<h3 id="test_utils_templatepyutilsrendertemplatefiletestcasetest_simple_render">test_utils_template.py::UtilsRenderTemplateFileTestCase::test_simple_render</h3>
<details><summary> <pre>test_utils_template.py::UtilsRenderTemplateFileTestCase::test_simple_render</pre></summary><pre>
self = <tests.test_utils_template.UtilsRenderTemplateFileTestCase testMethod=test_simple_render>

    def test_simple_render(self):
        context = dict(project_name="proj", name="spi", classname="TheSpider")
        template = "from ${project_name}.spiders.${name} import ${classname}"
        rendered = "from proj.spiders.spi import TheSpider"

        template_path = Path(self.tmp_path, "templ.py.tmpl")
        render_path = Path(self.tmp_path, "templ.py")

        template_path.write_text(template, encoding="utf8")
        assert template_path.is_file()  # Failure of test itself

        render_templatefile(template_path, **context)

>       self.assertFalse(template_path.exists())
E       AssertionError: True is not false

/testbed/tests/test_utils_template.py:31: AssertionError
</pre>
</details>
<h3 id="test_utils_trackrefpytrackreftestcasetest_format_live_refs">test_utils_trackref.py::TrackrefTestCase::test_format_live_refs</h3>
<details><summary> <pre>test_utils_trackref.py::TrackrefTestCase::test_format_live_refs</pre></summary><pre>
self = <tests.test_utils_trackref.TrackrefTestCase testMethod=test_format_live_refs>

        def test_format_live_refs(self):
            o1 = Foo()  # NOQA
            o2 = Bar()  # NOQA
            o3 = Foo()  # NOQA
>           self.assertEqual(
                trackref.format_live_refs(),
                """\
    Live References

    Bar                                 1   oldest: 0s ago
    Foo                                 2   oldest: 0s ago
    """,
            )
E           AssertionError: None != 'Live References\n\nBar                  [87 chars]go\n'

/testbed/tests/test_utils_trackref.py:27: AssertionError
</pre>
</details>
<h3 id="test_utils_trackrefpytrackreftestcasetest_get_oldest">test_utils_trackref.py::TrackrefTestCase::test_get_oldest</h3>
<details><summary> <pre>test_utils_trackref.py::TrackrefTestCase::test_get_oldest</pre></summary><pre>
self = <tests.test_utils_trackref.TrackrefTestCase testMethod=test_get_oldest>

    def test_get_oldest(self):
        o1 = Foo()  # NOQA

        o1_time = time()

        o2 = Bar()  # NOQA

        o3_time = time()
        if o3_time <= o1_time:
            sleep(0.01)
            o3_time = time()
        if o3_time <= o1_time:
            raise SkipTest("time.time is not precise enough")

        o3 = Foo()  # NOQA
>       self.assertIs(trackref.get_oldest("Foo"), o1)
E       AssertionError: None is not <tests.test_utils_trackref.Foo object at 0x7fcb95bda450>

/testbed/tests/test_utils_trackref.py:78: AssertionError
</pre>
</details>
<h3 id="test_utils_trackrefpytrackreftestcasetest_iter_all">test_utils_trackref.py::TrackrefTestCase::test_iter_all</h3>
<details><summary> <pre>test_utils_trackref.py::TrackrefTestCase::test_iter_all</pre></summary><pre>
self = <tests.test_utils_trackref.TrackrefTestCase testMethod=test_iter_all>

    def test_iter_all(self):
        o1 = Foo()  # NOQA
        o2 = Bar()  # NOQA
        o3 = Foo()  # NOQA
        self.assertEqual(
>           set(trackref.iter_all("Foo")),
            {o1, o3},
        )
E       TypeError: 'NoneType' object is not iterable

/testbed/tests/test_utils_trackref.py:87: TypeError
</pre>
</details>
<h3 id="test_utils_trackrefpytrackreftestcasetest_print_live_refs_empty">test_utils_trackref.py::TrackrefTestCase::test_print_live_refs_empty</h3>
<details><summary> <pre>test_utils_trackref.py::TrackrefTestCase::test_print_live_refs_empty</pre></summary><pre>
self = <tests.test_utils_trackref.TrackrefTestCase testMethod=test_print_live_refs_empty>
stdout = <_io.StringIO object at 0x7fcb97213dc0>

    @mock.patch("sys.stdout", new_callable=StringIO)
    def test_print_live_refs_empty(self, stdout):
        trackref.print_live_refs()
>       self.assertEqual(stdout.getvalue(), "Live References\n\n\n")
E       AssertionError: '' != 'Live References\n\n\n'
E       + Live References
E       + 
E       +

/testbed/tests/test_utils_trackref.py:49: AssertionError
</pre>
</details>
<h3 id="test_utils_trackrefpytrackreftestcasetest_print_live_refs_with_objects">test_utils_trackref.py::TrackrefTestCase::test_print_live_refs_with_objects</h3>
<details><summary> <pre>test_utils_trackref.py::TrackrefTestCase::test_print_live_refs_with_objects</pre></summary><pre>
self = <tests.test_utils_trackref.TrackrefTestCase testMethod=test_print_live_refs_with_objects>
stdout = <_io.StringIO object at 0x7fcb975d04c0>

        @mock.patch("sys.stdout", new_callable=StringIO)
        def test_print_live_refs_with_objects(self, stdout):
            o1 = Foo()  # NOQA
            trackref.print_live_refs()
>           self.assertEqual(
                stdout.getvalue(),
                """\
    Live References

    Foo                                 1   oldest: 0s ago\n\n""",
            )
E           AssertionError: '' != 'Live References\n\nFoo                                 1   oldest: 0s ago\n\n'
E           + Live References
E           + 
E           + Foo                                 1   oldest: 0s ago
E           +

/testbed/tests/test_utils_trackref.py:55: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyurlutilstesttest_url_has_any_extension">test_utils_url.py::UrlUtilsTest::test_url_has_any_extension</h3>
<details><summary> <pre>test_utils_url.py::UrlUtilsTest::test_url_has_any_extension</pre></summary><pre>
self = <tests.test_utils_url.UrlUtilsTest testMethod=test_url_has_any_extension>

    def test_url_has_any_extension(self):
        deny_extensions = {"." + e for e in arg_to_iter(IGNORED_EXTENSIONS)}
        self.assertTrue(
>           url_has_any_extension(
                "http://www.example.com/archive.tar.gz", deny_extensions
            )
        )

/testbed/tests/test_utils_url.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/testbed/scrapy/utils/url.py:44: in url_has_any_extension
    return any(path.endswith('.' + ext) for ext in extensions)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <set_iterator object at 0x7fcb95e9a6c0>

>   return any(path.endswith('.' + ext) for ext in extensions)
E   TypeError: endswith first arg must be bytes or a tuple of bytes, not str

/testbed/scrapy/utils/url.py:44: TypeError
</pre>
</details>
<h3 id="test_utils_urlpyurlutilstesttest_url_is_from_any_domain">test_utils_url.py::UrlUtilsTest::test_url_is_from_any_domain</h3>
<details><summary> <pre>test_utils_url.py::UrlUtilsTest::test_url_is_from_any_domain</pre></summary><pre>
self = <tests.test_utils_url.UrlUtilsTest testMethod=test_url_is_from_any_domain>

    def test_url_is_from_any_domain(self):
        url = "http://www.wheele-bin-art.co.uk/get/product/123"
        self.assertTrue(url_is_from_any_domain(url, ["wheele-bin-art.co.uk"]))
>       self.assertFalse(url_is_from_any_domain(url, ["art.co.uk"]))
E       AssertionError: True is not false

/testbed/tests/test_utils_url.py:23: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyurlutilstesttest_url_is_from_spider">test_utils_url.py::UrlUtilsTest::test_url_is_from_spider</h3>
<details><summary> <pre>test_utils_url.py::UrlUtilsTest::test_url_is_from_spider</pre></summary><pre>
self = <tests.test_utils_url.UrlUtilsTest testMethod=test_url_is_from_spider>

    def test_url_is_from_spider(self):
        spider = Spider(name="example.com")
>       self.assertTrue(
            url_is_from_spider("http://www.example.com/some/page.html", spider)
        )
E       AssertionError: False is not true

/testbed/tests/test_utils_url.py:48: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyurlutilstesttest_url_is_from_spider_class_attributes">test_utils_url.py::UrlUtilsTest::test_url_is_from_spider_class_attributes</h3>
<details><summary> <pre>test_utils_url.py::UrlUtilsTest::test_url_is_from_spider_class_attributes</pre></summary><pre>
self = <tests.test_utils_url.UrlUtilsTest testMethod=test_url_is_from_spider_class_attributes>

    def test_url_is_from_spider_class_attributes(self):
        class MySpider(Spider):
            name = "example.com"

>       self.assertTrue(
            url_is_from_spider("http://www.example.com/some/page.html", MySpider)
        )
E       AssertionError: False is not true

/testbed/tests/test_utils_url.py:65: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyurlutilstesttest_url_is_from_spider_with_allowed_domains">test_utils_url.py::UrlUtilsTest::test_url_is_from_spider_with_allowed_domains</h3>
<details><summary> <pre>test_utils_url.py::UrlUtilsTest::test_url_is_from_spider_with_allowed_domains</pre></summary><pre>
self = <tests.test_utils_url.UrlUtilsTest testMethod=test_url_is_from_spider_with_allowed_domains>

    def test_url_is_from_spider_with_allowed_domains(self):
        spider = Spider(
            name="example.com", allowed_domains=["example.org", "example.net"]
        )
>       self.assertTrue(
            url_is_from_spider("http://www.example.com/some/page.html", spider)
        )
E       AssertionError: False is not true

/testbed/tests/test_utils_url.py:82: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyurlutilstesttest_url_is_from_spider_with_allowed_domains_class_attributes">test_utils_url.py::UrlUtilsTest::test_url_is_from_spider_with_allowed_domains_class_attributes</h3>
<details><summary> <pre>test_utils_url.py::UrlUtilsTest::test_url_is_from_spider_with_allowed_domains_class_attributes</pre></summary><pre>
self = <tests.test_utils_url.UrlUtilsTest testMethod=test_url_is_from_spider_with_allowed_domains_class_attributes>

    def test_url_is_from_spider_with_allowed_domains_class_attributes(self):
        class MySpider(Spider):
            name = "example.com"
            allowed_domains = ("example.org", "example.net")

>       self.assertTrue(
            url_is_from_spider("http://www.example.com/some/page.html", MySpider)
        )
E       AssertionError: False is not true

/testbed/tests/test_utils_url.py:118: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyaddhttpifnoschemetest_protocol_relative">test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative</h3>
<details><summary> <pre>test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative</pre></summary><pre>
self = <tests.test_utils_url.AddHttpIfNoScheme testMethod=test_protocol_relative>

    def test_protocol_relative(self):
>       self.assertEqual(
            add_http_if_no_scheme("//www.example.com"), "http://www.example.com"
        )
E       AssertionError: 'http:////www.example.com' != 'http://www.example.com'
E       - http:////www.example.com
E       ?      --
E       + http://www.example.com

/testbed/tests/test_utils_url.py:258: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyaddhttpifnoschemetest_protocol_relative_complete_url">test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_complete_url</h3>
<details><summary> <pre>test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_complete_url</pre></summary><pre>
self = <tests.test_utils_url.AddHttpIfNoScheme testMethod=test_protocol_relative_complete_url>

    def test_protocol_relative_complete_url(self):
>       self.assertEqual(
            add_http_if_no_scheme(
                "//username:password@www.example.com:80/some/page/do?a=1&b=2&c=3#frag"
            ),
            "http://username:password@www.example.com:80/some/page/do?a=1&b=2&c=3#frag",
        )
E       AssertionError: 'http:////username:password@www.example.com:80/some/page/do?a=1&b=2&c=3#frag' != 'http://username:password@www.example.com:80/some/page/do?a=1&b=2&c=3#frag'
E       - http:////username:password@www.example.com:80/some/page/do?a=1&b=2&c=3#frag
E       ?      --
E       + http://username:password@www.example.com:80/some/page/do?a=1&b=2&c=3#frag

/testbed/tests/test_utils_url.py:295: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyaddhttpifnoschemetest_protocol_relative_fragment">test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_fragment</h3>
<details><summary> <pre>test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_fragment</pre></summary><pre>
self = <tests.test_utils_url.AddHttpIfNoScheme testMethod=test_protocol_relative_fragment>

    def test_protocol_relative_fragment(self):
>       self.assertEqual(
            add_http_if_no_scheme("//www.example.com/some/page#frag"),
            "http://www.example.com/some/page#frag",
        )
E       AssertionError: 'http:////www.example.com/some/page#frag' != 'http://www.example.com/some/page#frag'
E       - http:////www.example.com/some/page#frag
E       ?      --
E       + http://www.example.com/some/page#frag

/testbed/tests/test_utils_url.py:277: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyaddhttpifnoschemetest_protocol_relative_path">test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_path</h3>
<details><summary> <pre>test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_path</pre></summary><pre>
self = <tests.test_utils_url.AddHttpIfNoScheme testMethod=test_protocol_relative_path>

    def test_protocol_relative_path(self):
>       self.assertEqual(
            add_http_if_no_scheme("//www.example.com/some/page.html"),
            "http://www.example.com/some/page.html",
        )
E       AssertionError: 'http:////www.example.com/some/page.html' != 'http://www.example.com/some/page.html'
E       - http:////www.example.com/some/page.html
E       ?      --
E       + http://www.example.com/some/page.html

/testbed/tests/test_utils_url.py:266: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyaddhttpifnoschemetest_protocol_relative_port">test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_port</h3>
<details><summary> <pre>test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_port</pre></summary><pre>
self = <tests.test_utils_url.AddHttpIfNoScheme testMethod=test_protocol_relative_port>

    def test_protocol_relative_port(self):
>       self.assertEqual(
            add_http_if_no_scheme("//www.example.com:80"), "http://www.example.com:80"
        )
E       AssertionError: 'http:////www.example.com:80' != 'http://www.example.com:80'
E       - http:////www.example.com:80
E       ?      --
E       + http://www.example.com:80

/testbed/tests/test_utils_url.py:272: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyaddhttpifnoschemetest_protocol_relative_query">test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_query</h3>
<details><summary> <pre>test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_query</pre></summary><pre>
self = <tests.test_utils_url.AddHttpIfNoScheme testMethod=test_protocol_relative_query>

    def test_protocol_relative_query(self):
>       self.assertEqual(
            add_http_if_no_scheme("//www.example.com/do?a=1&b=2&c=3"),
            "http://www.example.com/do?a=1&b=2&c=3",
        )
E       AssertionError: 'http:////www.example.com/do?a=1&b=2&c=3' != 'http://www.example.com/do?a=1&b=2&c=3'
E       - http:////www.example.com/do?a=1&b=2&c=3
E       ?      --
E       + http://www.example.com/do?a=1&b=2&c=3

/testbed/tests/test_utils_url.py:283: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyaddhttpifnoschemetest_protocol_relative_username_password">test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_username_password</h3>
<details><summary> <pre>test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_username_password</pre></summary><pre>
self = <tests.test_utils_url.AddHttpIfNoScheme testMethod=test_protocol_relative_username_password>

    def test_protocol_relative_username_password(self):
>       self.assertEqual(
            add_http_if_no_scheme("//username:password@www.example.com"),
            "http://username:password@www.example.com",
        )
E       AssertionError: 'http:////username:password@www.example.com' != 'http://username:password@www.example.com'
E       - http:////username:password@www.example.com
E       ?      --
E       + http://username:password@www.example.com

/testbed/tests/test_utils_url.py:289: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyaddhttpifnoschemetest_protocol_relative_without_subdomain">test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_without_subdomain</h3>
<details><summary> <pre>test_utils_url.py::AddHttpIfNoScheme::test_protocol_relative_without_subdomain</pre></summary><pre>
self = <tests.test_utils_url.AddHttpIfNoScheme testMethod=test_protocol_relative_without_subdomain>

    def test_protocol_relative_without_subdomain(self):
>       self.assertEqual(add_http_if_no_scheme("//example.com"), "http://example.com")
E       AssertionError: 'http:////example.com' != 'http://example.com'
E       - http:////example.com
E       ?      --
E       + http://example.com

/testbed/tests/test_utils_url.py:263: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyguessschemetesttest_uri_003">test_utils_url.py::GuessSchemeTest::test_uri_003</h3>
<details><summary> <pre>test_utils_url.py::GuessSchemeTest::test_uri_003</pre></summary><pre>
self = <tests.test_utils_url.GuessSchemeTest testMethod=test_uri_003>

    def do_expected(self):
        url = guess_scheme(args[0])
>       assert url.startswith(
            args[1]
        ), f"Wrong scheme guessed: for `{args[0]}` got `{url}`, expected `{args[1]}...`"
E       AssertionError: Wrong scheme guessed: for `./index.html` got `http://./index.html`, expected `file://...`

/testbed/tests/test_utils_url.py:320: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyguessschemetesttest_uri_004">test_utils_url.py::GuessSchemeTest::test_uri_004</h3>
<details><summary> <pre>test_utils_url.py::GuessSchemeTest::test_uri_004</pre></summary><pre>
self = <tests.test_utils_url.GuessSchemeTest testMethod=test_uri_004>

    def do_expected(self):
        url = guess_scheme(args[0])
>       assert url.startswith(
            args[1]
        ), f"Wrong scheme guessed: for `{args[0]}` got `{url}`, expected `{args[1]}...`"
E       AssertionError: Wrong scheme guessed: for `../index.html` got `http://../index.html`, expected `file://...`

/testbed/tests/test_utils_url.py:320: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyguessschemetesttest_uri_005">test_utils_url.py::GuessSchemeTest::test_uri_005</h3>
<details><summary> <pre>test_utils_url.py::GuessSchemeTest::test_uri_005</pre></summary><pre>
self = <tests.test_utils_url.GuessSchemeTest testMethod=test_uri_005>

    def do_expected(self):
        url = guess_scheme(args[0])
>       assert url.startswith(
            args[1]
        ), f"Wrong scheme guessed: for `{args[0]}` got `{url}`, expected `{args[1]}...`"
E       AssertionError: Wrong scheme guessed: for `../../index.html` got `http://../../index.html`, expected `file://...`

/testbed/tests/test_utils_url.py:320: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyguessschemetesttest_uri_006">test_utils_url.py::GuessSchemeTest::test_uri_006</h3>
<details><summary> <pre>test_utils_url.py::GuessSchemeTest::test_uri_006</pre></summary><pre>
self = <tests.test_utils_url.GuessSchemeTest testMethod=test_uri_006>

    def do_expected(self):
        url = guess_scheme(args[0])
>       assert url.startswith(
            args[1]
        ), f"Wrong scheme guessed: for `{args[0]}` got `{url}`, expected `{args[1]}...`"
E       AssertionError: Wrong scheme guessed: for `./data/index.html` got `http://./data/index.html`, expected `file://...`

/testbed/tests/test_utils_url.py:320: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyguessschemetesttest_uri_007">test_utils_url.py::GuessSchemeTest::test_uri_007</h3>
<details><summary> <pre>test_utils_url.py::GuessSchemeTest::test_uri_007</pre></summary><pre>
self = <tests.test_utils_url.GuessSchemeTest testMethod=test_uri_007>

    def do_expected(self):
        url = guess_scheme(args[0])
>       assert url.startswith(
            args[1]
        ), f"Wrong scheme guessed: for `{args[0]}` got `{url}`, expected `{args[1]}...`"
E       AssertionError: Wrong scheme guessed: for `.hidden/data/index.html` got `http://.hidden/data/index.html`, expected `file://...`

/testbed/tests/test_utils_url.py:320: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyguessschemetesttest_uri_009">test_utils_url.py::GuessSchemeTest::test_uri_009</h3>
<details><summary> <pre>test_utils_url.py::GuessSchemeTest::test_uri_009</pre></summary><pre>
self = <tests.test_utils_url.GuessSchemeTest testMethod=test_uri_009>

    def do_expected(self):
        url = guess_scheme(args[0])
>       assert url.startswith(
            args[1]
        ), f"Wrong scheme guessed: for `{args[0]}` got `{url}`, expected `{args[1]}...`"
E       AssertionError: Wrong scheme guessed: for `//home/user/www/index.html` got `http:////home/user/www/index.html`, expected `file://...`

/testbed/tests/test_utils_url.py:320: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpystripurltest_credentials">test_utils_url.py::StripUrl::test_credentials</h3>
<details><summary> <pre>test_utils_url.py::StripUrl::test_credentials</pre></summary><pre>
self = <tests.test_utils_url.StripUrl testMethod=test_credentials>

    def test_credentials(self):
        for i, o in [
            (
                "http://username@www.example.com/index.html?somekey=somevalue#section",
                "http://www.example.com/index.html?somekey=somevalue",
            ),
            (
                "https://username:@www.example.com/index.html?somekey=somevalue#section",
                "https://www.example.com/index.html?somekey=somevalue",
            ),
            (
                "ftp://username:password@www.example.com/index.html?somekey=somevalue#section",
                "ftp://www.example.com/index.html?somekey=somevalue",
            ),
        ]:
>           self.assertEqual(strip_url(i, strip_credentials=True), o)
E           AssertionError: None != 'http://www.example.com/index.html?somekey=somevalue'

/testbed/tests/test_utils_url.py:427: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpystripurltest_credentials_encoded_delims">test_utils_url.py::StripUrl::test_credentials_encoded_delims</h3>
<details><summary> <pre>test_utils_url.py::StripUrl::test_credentials_encoded_delims</pre></summary><pre>
self = <tests.test_utils_url.StripUrl testMethod=test_credentials_encoded_delims>

    def test_credentials_encoded_delims(self):
        for i, o in [
            # user: "username@"
            # password: none
            (
                "http://username%40@www.example.com/index.html?somekey=somevalue#section",
                "http://www.example.com/index.html?somekey=somevalue",
            ),
            # user: "username:pass"
            # password: ""
            (
                "https://username%3Apass:@www.example.com/index.html?somekey=somevalue#section",
                "https://www.example.com/index.html?somekey=somevalue",
            ),
            # user: "me"
            # password: "user@domain.com"
            (
                "ftp://me:user%40domain.com@www.example.com/index.html?somekey=somevalue#section",
                "ftp://www.example.com/index.html?somekey=somevalue",
            ),
        ]:
>           self.assertEqual(strip_url(i, strip_credentials=True), o)
E           AssertionError: None != 'http://www.example.com/index.html?somekey=somevalue'

/testbed/tests/test_utils_url.py:450: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpystripurltest_default_ports">test_utils_url.py::StripUrl::test_default_ports</h3>
<details><summary> <pre>test_utils_url.py::StripUrl::test_default_ports</pre></summary><pre>
self = <tests.test_utils_url.StripUrl testMethod=test_default_ports>

    def test_default_ports(self):
        for i, o in [
            (
                "http://username:password@www.example.com:80/index.html",
                "http://username:password@www.example.com/index.html",
            ),
            (
                "http://username:password@www.example.com:8080/index.html",
                "http://username:password@www.example.com:8080/index.html",
            ),
            (
                "http://username:password@www.example.com:443/index.html",
                "http://username:password@www.example.com:443/index.html",
            ),
            (
                "https://username:password@www.example.com:443/index.html",
                "https://username:password@www.example.com/index.html",
            ),
            (
                "https://username:password@www.example.com:442/index.html",
                "https://username:password@www.example.com:442/index.html",
            ),
            (
                "https://username:password@www.example.com:80/index.html",
                "https://username:password@www.example.com:80/index.html",
            ),
            (
                "ftp://username:password@www.example.com:21/file.txt",
                "ftp://username:password@www.example.com/file.txt",
            ),
            (
                "ftp://username:password@www.example.com:221/file.txt",
                "ftp://username:password@www.example.com:221/file.txt",
            ),
        ]:
>           self.assertEqual(
                strip_url(i, strip_default_port=True, strip_credentials=False), o
            )
E           AssertionError: None != 'http://username:password@www.example.com/index.html'

/testbed/tests/test_utils_url.py:524: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpystripurltest_default_ports_creds_off">test_utils_url.py::StripUrl::test_default_ports_creds_off</h3>
<details><summary> <pre>test_utils_url.py::StripUrl::test_default_ports_creds_off</pre></summary><pre>
self = <tests.test_utils_url.StripUrl testMethod=test_default_ports_creds_off>

    def test_default_ports_creds_off(self):
        for i, o in [
            (
                "http://username:password@www.example.com:80/index.html?somekey=somevalue#section",
                "http://www.example.com/index.html?somekey=somevalue",
            ),
            (
                "http://username:password@www.example.com:8080/index.html#section",
                "http://www.example.com:8080/index.html",
            ),
            (
                "http://username:password@www.example.com:443/index.html?somekey=somevalue&someotherkey=sov#section",
                "http://www.example.com:443/index.html?somekey=somevalue&someotherkey=sov",
            ),
            (
                "https://username:password@www.example.com:443/index.html",
                "https://www.example.com/index.html",
            ),
            (
                "https://username:password@www.example.com:442/index.html",
                "https://www.example.com:442/index.html",
            ),
            (
                "https://username:password@www.example.com:80/index.html",
                "https://www.example.com:80/index.html",
            ),
            (
                "ftp://username:password@www.example.com:21/file.txt",
                "ftp://www.example.com/file.txt",
            ),
            (
                "ftp://username:password@www.example.com:221/file.txt",
                "ftp://www.example.com:221/file.txt",
            ),
        ]:
>           self.assertEqual(strip_url(i), o)
E           AssertionError: None != 'http://www.example.com/index.html?somekey=somevalue'

/testbed/tests/test_utils_url.py:487: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpystripurltest_default_ports_keep">test_utils_url.py::StripUrl::test_default_ports_keep</h3>
<details><summary> <pre>test_utils_url.py::StripUrl::test_default_ports_keep</pre></summary><pre>
self = <tests.test_utils_url.StripUrl testMethod=test_default_ports_keep>

    def test_default_ports_keep(self):
        for i, o in [
            (
                "http://username:password@www.example.com:80/index.html?somekey=somevalue&someotherkey=sov#section",
                "http://username:password@www.example.com:80/index.html?somekey=somevalue&someotherkey=sov",
            ),
            (
                "http://username:password@www.example.com:8080/index.html?somekey=somevalue&someotherkey=sov#section",
                "http://username:password@www.example.com:8080/index.html?somekey=somevalue&someotherkey=sov",
            ),
            (
                "http://username:password@www.example.com:443/index.html",
                "http://username:password@www.example.com:443/index.html",
            ),
            (
                "https://username:password@www.example.com:443/index.html",
                "https://username:password@www.example.com:443/index.html",
            ),
            (
                "https://username:password@www.example.com:442/index.html",
                "https://username:password@www.example.com:442/index.html",
            ),
            (
                "https://username:password@www.example.com:80/index.html",
                "https://username:password@www.example.com:80/index.html",
            ),
            (
                "ftp://username:password@www.example.com:21/file.txt",
                "ftp://username:password@www.example.com:21/file.txt",
            ),
            (
                "ftp://username:password@www.example.com:221/file.txt",
                "ftp://username:password@www.example.com:221/file.txt",
            ),
        ]:
>           self.assertEqual(
                strip_url(i, strip_default_port=False, strip_credentials=False), o
            )
E           AssertionError: None != 'http://username:password@www.example.com[45 chars]=sov'

/testbed/tests/test_utils_url.py:563: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpystripurltest_fragments">test_utils_url.py::StripUrl::test_fragments</h3>
<details><summary> <pre>test_utils_url.py::StripUrl::test_fragments</pre></summary><pre>
self = <tests.test_utils_url.StripUrl testMethod=test_fragments>

    def test_fragments(self):
>       self.assertEqual(
            strip_url(
                "http://www.example.com/index.html?somekey=somevalue#section",
                strip_fragment=False,
            ),
            "http://www.example.com/index.html?somekey=somevalue#section",
        )
E       AssertionError: None != 'http://www.example.com/index.html?somekey=somevalue#section'

/testbed/tests/test_utils_url.py:396: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpystripurltest_noop">test_utils_url.py::StripUrl::test_noop</h3>
<details><summary> <pre>test_utils_url.py::StripUrl::test_noop</pre></summary><pre>
self = <tests.test_utils_url.StripUrl testMethod=test_noop>

    def test_noop(self):
>       self.assertEqual(
            strip_url("http://www.example.com/index.html"),
            "http://www.example.com/index.html",
        )
E       AssertionError: None != 'http://www.example.com/index.html'

/testbed/tests/test_utils_url.py:384: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpystripurltest_noop_query_string">test_utils_url.py::StripUrl::test_noop_query_string</h3>
<details><summary> <pre>test_utils_url.py::StripUrl::test_noop_query_string</pre></summary><pre>
self = <tests.test_utils_url.StripUrl testMethod=test_noop_query_string>

    def test_noop_query_string(self):
>       self.assertEqual(
            strip_url("http://www.example.com/index.html?somekey=somevalue"),
            "http://www.example.com/index.html?somekey=somevalue",
        )
E       AssertionError: None != 'http://www.example.com/index.html?somekey=somevalue'

/testbed/tests/test_utils_url.py:390: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpystripurltest_origin_only">test_utils_url.py::StripUrl::test_origin_only</h3>
<details><summary> <pre>test_utils_url.py::StripUrl::test_origin_only</pre></summary><pre>
self = <tests.test_utils_url.StripUrl testMethod=test_origin_only>

    def test_origin_only(self):
        for i, o in [
            (
                "http://username:password@www.example.com/index.html",
                "http://www.example.com/",
            ),
            (
                "http://username:password@www.example.com:80/foo/bar?query=value#somefrag",
                "http://www.example.com/",
            ),
            (
                "http://username:password@www.example.com:8008/foo/bar?query=value#somefrag",
                "http://www.example.com:8008/",
            ),
            (
                "https://username:password@www.example.com:443/index.html",
                "https://www.example.com/",
            ),
        ]:
>           self.assertEqual(strip_url(i, origin_only=True), o)
E           AssertionError: None != 'http://www.example.com/'

/testbed/tests/test_utils_url.py:586: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpystripurltest_path">test_utils_url.py::StripUrl::test_path</h3>
<details><summary> <pre>test_utils_url.py::StripUrl::test_path</pre></summary><pre>
self = <tests.test_utils_url.StripUrl testMethod=test_path>

    def test_path(self):
        for input_url, origin, output_url in [
            ("http://www.example.com/", False, "http://www.example.com/"),
            ("http://www.example.com", False, "http://www.example.com"),
            ("http://www.example.com", True, "http://www.example.com/"),
        ]:
>           self.assertEqual(strip_url(input_url, origin_only=origin), output_url)
E           AssertionError: None != 'http://www.example.com/'

/testbed/tests/test_utils_url.py:410: AssertionError
</pre>
</details>
<h3 id="test_utils_urlpyispathtestcasetest_path">test_utils_url.py::IsPathTestCase::test_path</h3>
<details><summary> <pre>test_utils_url.py::IsPathTestCase::test_path</pre></summary><pre>
self = <tests.test_utils_url.IsPathTestCase testMethod=test_path>

    def test_path(self):
        for input_value, output_value in (
            # https://en.wikipedia.org/wiki/Path_(computing)#Representations_of_paths_by_operating_system_and_shell
            # Unix-like OS, Microsoft Windows / cmd.exe
            ("/home/user/docs/Letter.txt", True),
            ("./inthisdir", True),
            ("../../greatgrandparent", True),
            ("~/.rcinfo", True),
            (r"C:\user\docs\Letter.txt", True),
            ("/user/docs/Letter.txt", True),
            (r"C:\Letter.txt", True),
            (r"\\Server01\user\docs\Letter.txt", True),
            (r"\\?\UNC\Server01\user\docs\Letter.txt", True),
            (r"\\?\C:\user\docs\Letter.txt", True),
            (r"C:\user\docs\somefile.ext:alternate_stream_name", True),
            (r"https://example.com", False),
        ):
>           self.assertEqual(
                _is_filesystem_path(input_value), output_value, input_value
            )
E           AssertionError: False != True : ./inthisdir

/testbed/tests/test_utils_url.py:607: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/scrapy/http/common.py b/scrapy/http/common.py</span>
<span class="gh">index e69de29bb..1f2b97527 100644</span>
<span class="gd">--- a/scrapy/http/common.py</span>
<span class="gi">+++ b/scrapy/http/common.py</span>
<span class="gu">@@ -0,0 +1,12 @@</span>
<span class="gi">+import warnings</span>
<span class="gi">+</span>
<span class="gi">+def obsolete_setter(name: str, warn_category: Warning=DeprecationWarning):</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Use this function to deprecate setter properties.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    def wrapper(self, value):</span>
<span class="gi">+        private_name = f&quot;_{name}&quot;</span>
<span class="gi">+        if not hasattr(self, private_name):</span>
<span class="gi">+            warnings.warn(f&quot;Property {name} is deprecated.&quot;, category=warn_category, stacklevel=2)</span>
<span class="gi">+        setattr(self, private_name, value)</span>
<span class="gi">+    return wrapper</span>
<span class="gh">diff --git a/scrapy/linkextractors/lxmlhtml.py b/scrapy/linkextractors/lxmlhtml.py</span>
<span class="gh">index 41b7484cc..eae4005f6 100644</span>
<span class="gd">--- a/scrapy/linkextractors/lxmlhtml.py</span>
<span class="gi">+++ b/scrapy/linkextractors/lxmlhtml.py</span>
<span class="gu">@@ -19,6 +19,12 @@ logger = logging.getLogger(__name__)</span>
<span class="w"> </span>XHTML_NAMESPACE = &#39;http://www.w3.org/1999/xhtml&#39;
<span class="w"> </span>_collect_string_content = etree.XPath(&#39;string()&#39;)

<span class="gi">+def _identity(x):</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+def _canonicalize_link_url(link):</span>
<span class="gi">+    return canonicalize_url(link.url, keep_fragments=True)</span>
<span class="gi">+</span>
<span class="w"> </span>class LxmlParserLinkExtractor:

<span class="w"> </span>    def __init__(self, tag=&#39;a&#39;, attr=&#39;href&#39;, process=None, unique=False, strip=True, canonicalized=False):
<span class="gu">@@ -34,7 +40,22 @@ class LxmlParserLinkExtractor:</span>

<span class="w"> </span>        The subclass should override it if necessary
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        seen = set()</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        for link in links:</span>
<span class="gi">+            if not link.url:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if self.strip:</span>
<span class="gi">+                link.url = strip_html5_whitespace(link.url)</span>
<span class="gi">+            link.url = self.process_attr(link.url)</span>
<span class="gi">+            if not link.url:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if self.unique:</span>
<span class="gi">+                if self.link_key(link) in seen:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                seen.add(self.link_key(link))</span>
<span class="gi">+            ret.append(link)</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>class LxmlLinkExtractor:
<span class="w"> </span>    _csstranslator = HTMLTranslator()
<span class="gu">@@ -64,4 +85,40 @@ class LxmlLinkExtractor:</span>
<span class="w"> </span>        Duplicate links are omitted if the ``unique`` attribute is set to ``True``,
<span class="w"> </span>        otherwise they are returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
\ No newline at end of file
<span class="gi">+        base_url = get_base_url(response)</span>
<span class="gi">+        parser = self._get_parser(response)</span>
<span class="gi">+        links = []</span>
<span class="gi">+        for el, attr, attr_val in self._iter_links(parser):</span>
<span class="gi">+            if not self._is_valid_url(attr_val):</span>
<span class="gi">+                continue</span>
<span class="gi">+            url = urljoin(base_url, attr_val)</span>
<span class="gi">+            if not url:</span>
<span class="gi">+                continue</span>
<span class="gi">+            url = safe_url_string(url)</span>
<span class="gi">+            if self.canonicalize:</span>
<span class="gi">+                url = canonicalize_url(url)</span>
<span class="gi">+            link = Link(url=url, text=self._get_link_text(el), fragment=&#39;&#39;, nofollow=rel_has_nofollow(el.get(&#39;rel&#39;)))</span>
<span class="gi">+            links.append(link)</span>
<span class="gi">+        return self._process_links(links)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_parser(self, response):</span>
<span class="gi">+        return etree.HTML(response.body)</span>
<span class="gi">+</span>
<span class="gi">+    def _iter_links(self, parser):</span>
<span class="gi">+        for el in parser.iter():</span>
<span class="gi">+            if self.scan_tag(el.tag):</span>
<span class="gi">+                for attr in el.attrib:</span>
<span class="gi">+                    if self.scan_attr(attr):</span>
<span class="gi">+                        yield el, attr, el.get(attr)</span>
<span class="gi">+</span>
<span class="gi">+    def _is_valid_url(self, url):</span>
<span class="gi">+        if url is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not _is_valid_url(url):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if url.startswith(&#39;javascript:&#39;):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def _get_link_text(self, el):</span>
<span class="gi">+        return _collect_string_content(el) or &#39;&#39;</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/asyncgen.py b/scrapy/utils/asyncgen.py</span>
<span class="gh">index af31026b7..70aaeb500 100644</span>
<span class="gd">--- a/scrapy/utils/asyncgen.py</span>
<span class="gi">+++ b/scrapy/utils/asyncgen.py</span>
<span class="gu">@@ -1,5 +1,17 @@</span>
<span class="gd">-from typing import AsyncGenerator, AsyncIterable, Iterable, Union</span>
<span class="gi">+from typing import AsyncGenerator, AsyncIterable, Iterable, List, Union</span>

<span class="w"> </span>async def as_async_generator(it: Union[Iterable, AsyncIterable]) -&gt; AsyncGenerator:
<span class="w"> </span>    &quot;&quot;&quot;Wraps an iterable (sync or async) into an async generator.&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if isinstance(it, AsyncIterable):</span>
<span class="gi">+        async for item in it:</span>
<span class="gi">+            yield item</span>
<span class="gi">+    else:</span>
<span class="gi">+        for item in it:</span>
<span class="gi">+            yield item</span>
<span class="gi">+</span>
<span class="gi">+async def collect_asyncgen(agen: AsyncGenerator) -&gt; List:</span>
<span class="gi">+    &quot;&quot;&quot;Collect all items from an async generator into a list.&quot;&quot;&quot;</span>
<span class="gi">+    result = []</span>
<span class="gi">+    async for item in agen:</span>
<span class="gi">+        result.append(item)</span>
<span class="gi">+    return result</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/conf.py b/scrapy/utils/conf.py</span>
<span class="gh">index a332a42ec..c53bf2ec2 100644</span>
<span class="gd">--- a/scrapy/utils/conf.py</span>
<span class="gi">+++ b/scrapy/utils/conf.py</span>
<span class="gu">@@ -13,30 +13,99 @@ from scrapy.utils.python import without_none_values</span>

<span class="w"> </span>def build_component_list(compdict: MutableMapping[Any, Any], custom: Any=None, convert: Callable[[Any], Any]=update_classpath) -&gt; List[Any]:
<span class="w"> </span>    &quot;&quot;&quot;Compose a component list from a { class: order } dictionary.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _check_components(complist):</span>
<span class="gi">+        if len({convert(c) for c in complist}) != len(complist):</span>
<span class="gi">+            raise ValueError(f&#39;Some paths in {complist!r} convert to the same object, &#39;</span>
<span class="gi">+                           &#39;please update your settings&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def _map_keys(compdict):</span>
<span class="gi">+        if isinstance(compdict, Mapping):</span>
<span class="gi">+            return {convert(k): v for k, v in compdict.items()}</span>
<span class="gi">+        return {convert(k): None for k in compdict}</span>
<span class="gi">+</span>
<span class="gi">+    def _validate_values(compdict):</span>
<span class="gi">+        &quot;&quot;&quot;Fail if a value in the components dict is not a real number or None.&quot;&quot;&quot;</span>
<span class="gi">+        for name, value in compdict.items():</span>
<span class="gi">+            if value is not None and not isinstance(value, numbers.Real):</span>
<span class="gi">+                raise ValueError(f&#39;Invalid value {value} for component {name}, &#39;</span>
<span class="gi">+                               &#39;please provide a real number or None instead&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if custom is None:</span>
<span class="gi">+        custom = {}</span>
<span class="gi">+</span>
<span class="gi">+    if not compdict:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    compdict = without_none_values(_map_keys(compdict))</span>
<span class="gi">+    custom = without_none_values(_map_keys(custom))</span>
<span class="gi">+    _validate_values(compdict)</span>
<span class="gi">+    _validate_values(custom)</span>
<span class="gi">+    _check_components(compdict)</span>
<span class="gi">+    _check_components(custom)</span>
<span class="gi">+</span>
<span class="gi">+    # General strategy: add custom components to the end of the list, but before any</span>
<span class="gi">+    # of the components they may be replacing</span>
<span class="gi">+    components = {k: v for k, v in compdict.items()}</span>
<span class="gi">+    seen = set(components)</span>
<span class="gi">+    my_order = len(components)</span>
<span class="gi">+</span>
<span class="gi">+    for k, v in custom.items():</span>
<span class="gi">+        v = v if v is not None else my_order</span>
<span class="gi">+        if k not in seen:</span>
<span class="gi">+            components[k] = v</span>
<span class="gi">+            seen.add(k)</span>
<span class="gi">+</span>
<span class="gi">+    return [k for k, v in sorted(components.items(), key=itemgetter(1))]</span>

<span class="w"> </span>def arglist_to_dict(arglist: List[str]) -&gt; Dict[str, str]:
<span class="w"> </span>    &quot;&quot;&quot;Convert a list of arguments like [&#39;arg1=val1&#39;, &#39;arg2=val2&#39;, ...] to a
<span class="w"> </span>    dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return dict(x.split(&#39;=&#39;, 1) for x in arglist)</span>

<span class="w"> </span>def closest_scrapy_cfg(path: Union[str, os.PathLike]=&#39;.&#39;, prevpath: Optional[Union[str, os.PathLike]]=None) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Return the path to the closest scrapy.cfg file by traversing the current
<span class="w"> </span>    directory and its parents
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if path == prevpath:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    path = os.path.abspath(path)</span>
<span class="gi">+    cfgfile = os.path.join(path, &#39;scrapy.cfg&#39;)</span>
<span class="gi">+    if os.path.exists(cfgfile):</span>
<span class="gi">+        return cfgfile</span>
<span class="gi">+    return closest_scrapy_cfg(os.path.dirname(path), path)</span>

<span class="w"> </span>def init_env(project: str=&#39;default&#39;, set_syspath: bool=True) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;Initialize environment to use command-line tool from inside a project
<span class="w"> </span>    dir. This sets the Scrapy settings module and modifies the Python path to
<span class="w"> </span>    be able to locate the project module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cfg = get_config()</span>
<span class="gi">+    if cfg.has_option(&#39;settings&#39;, project):</span>
<span class="gi">+        os.environ[&#39;SCRAPY_SETTINGS_MODULE&#39;] = cfg.get(&#39;settings&#39;, project)</span>
<span class="gi">+    if set_syspath and cfg.has_option(&#39;deploy&#39;, &#39;project&#39;):</span>
<span class="gi">+        project = cfg.get(&#39;deploy&#39;, &#39;project&#39;)</span>
<span class="gi">+        if project not in sys.path:</span>
<span class="gi">+            sys.path.append(project)</span>

<span class="w"> </span>def get_config(use_closest: bool=True) -&gt; ConfigParser:
<span class="w"> </span>    &quot;&quot;&quot;Get Scrapy config file as a ConfigParser&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sources = get_sources(use_closest)</span>
<span class="gi">+    cfg = ConfigParser()</span>
<span class="gi">+    cfg.read(sources)</span>
<span class="gi">+    return cfg</span>
<span class="gi">+</span>
<span class="gi">+def get_sources(use_closest: bool=True) -&gt; List[str]:</span>
<span class="gi">+    xdg_config_home = os.environ.get(&#39;XDG_CONFIG_HOME&#39;) or os.path.expanduser(&#39;~/.config&#39;)</span>
<span class="gi">+    sources = [</span>
<span class="gi">+        &#39;/etc/scrapy.cfg&#39;,</span>
<span class="gi">+        r&#39;c:\scrapy\scrapy.cfg&#39;,</span>
<span class="gi">+        os.path.join(xdg_config_home, &#39;scrapy.cfg&#39;),</span>
<span class="gi">+        os.path.expanduser(&#39;~/.scrapy.cfg&#39;),</span>
<span class="gi">+    ]</span>
<span class="gi">+    if use_closest:</span>
<span class="gi">+        sources.append(closest_scrapy_cfg())</span>
<span class="gi">+    return sources</span>

<span class="w"> </span>def feed_process_params_from_cli(settings: BaseSettings, output: List[str], output_format: Optional[str]=None, overwrite_output: Optional[List[str]]=None) -&gt; Dict[str, Dict[str, Any]]:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -44,4 +113,75 @@ def feed_process_params_from_cli(settings: BaseSettings, output: List[str], outp</span>
<span class="w"> </span>    checks for inconsistencies in their quantities and returns a dictionary
<span class="w"> </span>    suitable to be used as the FEEDS setting.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    valid_output_formats = without_none_values(settings[&#39;FEED_EXPORTERS&#39;]).keys()</span>
<span class="gi">+    overwrite_output = overwrite_output or []</span>
<span class="gi">+</span>
<span class="gi">+    if output_format and output_format not in valid_output_formats:</span>
<span class="gi">+        raise UsageError(</span>
<span class="gi">+            f&quot;Unrecognized output format &#39;{output_format}&#39;. &quot;</span>
<span class="gi">+            f&quot;Set a supported one ({tuple(valid_output_formats)}) &quot;</span>
<span class="gi">+            &quot;after a colon at the end of the output URI (i.e. -o/-O &quot;</span>
<span class="gi">+            &quot;FILE:FORMAT)&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if len(overwrite_output) &gt; len(output):</span>
<span class="gi">+        raise UsageError(</span>
<span class="gi">+            &quot;Cannot have more &#39;-O&#39; than &#39;-o&#39; options&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if output_format and any(isformat(x) for x in output):</span>
<span class="gi">+        raise UsageError(</span>
<span class="gi">+            &quot;If --output-format is used, the output URIs cannot contain formats&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for i, uri in enumerate(output):</span>
<span class="gi">+        out_format = output_format or (get_uri_format(uri) if isformat(uri) else None)</span>
<span class="gi">+        if out_format not in valid_output_formats:</span>
<span class="gi">+            raise UsageError(</span>
<span class="gi">+                f&quot;Unrecognized output format &#39;{out_format}&#39; in &#39;{uri}&#39;. &quot;</span>
<span class="gi">+                f&quot;Set a supported one ({tuple(valid_output_formats)}) &quot;</span>
<span class="gi">+                &quot;after a colon at the end of the output URI (i.e. -o/-O &quot;</span>
<span class="gi">+                &quot;FILE:FORMAT)&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        uri = strip_uri_format(uri)</span>
<span class="gi">+        feed_options = {&#39;format&#39;: out_format} if out_format else {}</span>
<span class="gi">+        feed_options.update({&#39;overwrite&#39;: True} if i &lt; len(overwrite_output) else {})</span>
<span class="gi">+        result[uri] = feed_options</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+def feed_complete_default_values_from_settings(feed_options: Dict[str, Dict[str, Any]], settings: BaseSettings) -&gt; Dict[str, Dict[str, Any]]:</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Receives a dictionary of feed options and settings and returns a new one</span>
<span class="gi">+    populated by default values from settings.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for uri, values in feed_options.items():</span>
<span class="gi">+        values = values.copy()</span>
<span class="gi">+        values.setdefault(&#39;format&#39;, settings[&#39;FEED_FORMAT&#39;])</span>
<span class="gi">+        values.setdefault(&#39;overwrite&#39;, settings.getbool(&#39;FEED_OVERWRITE&#39;))</span>
<span class="gi">+        values.setdefault(&#39;store_empty&#39;, settings.getbool(&#39;FEED_STORE_EMPTY&#39;))</span>
<span class="gi">+        values.setdefault(&#39;item_export_kwargs&#39;, {})</span>
<span class="gi">+        values.setdefault(&#39;batch_item_count&#39;, settings.getint(&#39;FEED_EXPORT_BATCH_ITEM_COUNT&#39;))</span>
<span class="gi">+        values.setdefault(&#39;encoding&#39;, settings[&#39;FEED_EXPORT_ENCODING&#39;])</span>
<span class="gi">+        values.setdefault(&#39;fields&#39;, settings.getlist(&#39;FEED_EXPORT_FIELDS&#39;) or None)</span>
<span class="gi">+        values.setdefault(&#39;indent&#39;, settings.getint(&#39;FEED_EXPORT_INDENT&#39;))</span>
<span class="gi">+        values.setdefault(&#39;uri_params&#39;, settings[&#39;FEED_URI_PARAMS&#39;])</span>
<span class="gi">+        result[uri] = values</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+def isformat(uri: str) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Returns True if the given uri includes a format.&quot;&quot;&quot;</span>
<span class="gi">+    return bool(get_uri_format(uri))</span>
<span class="gi">+</span>
<span class="gi">+def get_uri_format(uri: str) -&gt; Optional[str]:</span>
<span class="gi">+    &quot;&quot;&quot;Returns the format included in the given uri, if any.&quot;&quot;&quot;</span>
<span class="gi">+    if &#39;:&#39; not in uri:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return uri.rpartition(&#39;:&#39;)[2] or None</span>
<span class="gi">+</span>
<span class="gi">+def strip_uri_format(uri: str) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Removes the format from the given uri, if any.&quot;&quot;&quot;</span>
<span class="gi">+    return uri.rpartition(&#39;:&#39;)[0] if &#39;:&#39; in uri else uri</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/display.py b/scrapy/utils/display.py</span>
<span class="gh">index 4cc617ad6..f106c841b 100644</span>
<span class="gd">--- a/scrapy/utils/display.py</span>
<span class="gi">+++ b/scrapy/utils/display.py</span>
<span class="gu">@@ -6,4 +6,34 @@ import platform</span>
<span class="w"> </span>import sys
<span class="w"> </span>from pprint import pformat as pformat_
<span class="w"> </span>from typing import Any
<span class="gd">-from packaging.version import Version as parse_version</span>
\ No newline at end of file
<span class="gi">+from packaging.version import Version as parse_version</span>
<span class="gi">+</span>
<span class="gi">+def supports_color() -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Return True if the terminal supports color output.&quot;&quot;&quot;</span>
<span class="gi">+    if platform.system() == &#39;Windows&#39;:</span>
<span class="gi">+        return _enable_windows_terminal_processing()</span>
<span class="gi">+    return hasattr(sys.stdout, &#39;isatty&#39;) and sys.stdout.isatty()</span>
<span class="gi">+</span>
<span class="gi">+def _enable_windows_terminal_processing() -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Enable terminal processing on Windows.&quot;&quot;&quot;</span>
<span class="gi">+    if parse_version(platform.python_version()) &lt; parse_version(&#39;3.6.0&#39;):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        kernel32 = ctypes.windll.kernel32</span>
<span class="gi">+        handle = kernel32.GetStdHandle(-11)  # STD_OUTPUT_HANDLE</span>
<span class="gi">+        mode = ctypes.c_ulong()</span>
<span class="gi">+        kernel32.GetConsoleMode(handle, ctypes.byref(mode))</span>
<span class="gi">+        mode.value |= 4  # ENABLE_VIRTUAL_TERMINAL_PROCESSING</span>
<span class="gi">+        kernel32.SetConsoleMode(handle, mode)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+def pformat(obj: Any, *args: Any, **kwargs: Any) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Format a Python object into a pretty-printed representation.&quot;&quot;&quot;</span>
<span class="gi">+    return pformat_(obj, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+def pprint(obj: Any, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Pretty-print a Python object to stdout.&quot;&quot;&quot;</span>
<span class="gi">+    print(pformat(obj, *args, **kwargs))</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/engine.py b/scrapy/utils/engine.py</span>
<span class="gh">index 59709e908..1e9505003 100644</span>
<span class="gd">--- a/scrapy/utils/engine.py</span>
<span class="gi">+++ b/scrapy/utils/engine.py</span>
<span class="gu">@@ -6,4 +6,35 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>def get_engine_status(engine: &#39;ExecutionEngine&#39;) -&gt; List[Tuple[str, Any]]:
<span class="w"> </span>    &quot;&quot;&quot;Return a report of the current engine status&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    global_stats = engine.stats.get_stats()</span>
<span class="gi">+    spider = engine.spider</span>
<span class="gi">+</span>
<span class="gi">+    # Common report stats</span>
<span class="gi">+    report = [</span>
<span class="gi">+        (&quot;Spider name&quot;, spider.name),</span>
<span class="gi">+        (&quot;Engine status&quot;, &quot;Running&quot; if engine.running else &quot;Stopped&quot;),</span>
<span class="gi">+        (&quot;Spider status&quot;, &quot;Running&quot; if spider.crawling else &quot;Stopped&quot;),</span>
<span class="gi">+        (&quot;Requests in memory&quot;, len(engine.slot.scheduler)),</span>
<span class="gi">+        (&quot;Requests in downloader queue&quot;, len(engine.downloader.slots)),</span>
<span class="gi">+        (&quot;Active requests&quot;, len(engine.slot.active)),</span>
<span class="gi">+        (&quot;Active depth&quot;, engine.scraper.slot.active_size),</span>
<span class="gi">+        (&quot;Items scraped&quot;, global_stats.get(&#39;item_scraped_count&#39;, 0)),</span>
<span class="gi">+        (&quot;Responses received&quot;, global_stats.get(&#39;response_received_count&#39;, 0)),</span>
<span class="gi">+        (&quot;Start time&quot;, engine.start_time),</span>
<span class="gi">+        (&quot;Finish time&quot;, engine.stop_time if not engine.running else time()),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    # Per spider stats</span>
<span class="gi">+    if hasattr(engine.stats, &quot;get_stats&quot;):</span>
<span class="gi">+        report.extend([</span>
<span class="gi">+            (&quot;Pages crawled&quot;, global_stats.get(&#39;response_received_count&#39;, 0)),</span>
<span class="gi">+            (&quot;Pages downloaded&quot;, global_stats.get(&#39;downloader/request_count&#39;, 0)),</span>
<span class="gi">+        ])</span>
<span class="gi">+</span>
<span class="gi">+    return report</span>
<span class="gi">+</span>
<span class="gi">+def print_engine_status(engine: &#39;ExecutionEngine&#39;) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Print a report of the current engine status&quot;&quot;&quot;</span>
<span class="gi">+    status = get_engine_status(engine)</span>
<span class="gi">+    for name, value in status:</span>
<span class="gi">+        print(f&quot;{name:&lt;30} : {value}&quot;)</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/gz.py b/scrapy/utils/gz.py</span>
<span class="gh">index 6a5684846..534ab377e 100644</span>
<span class="gd">--- a/scrapy/utils/gz.py</span>
<span class="gi">+++ b/scrapy/utils/gz.py</span>
<span class="gu">@@ -4,9 +4,29 @@ from io import BytesIO</span>
<span class="w"> </span>from scrapy.http import Response
<span class="w"> </span>from ._compression import _CHUNK_SIZE, _DecompressionMaxSizeExceeded

<span class="gi">+gzip_magic_number = b&#39;\x1f\x8b&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>def gunzip(data: bytes, *, max_size: int=0) -&gt; bytes:
<span class="w"> </span>    &quot;&quot;&quot;Gunzip the given data and return as much data as possible.

<span class="w"> </span>    This is resilient to CRC checksum errors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if len(data) &lt; 2:</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    if data[:2] != gzip_magic_number:</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    f = GzipFile(fileobj=BytesIO(data))</span>
<span class="gi">+    output = BytesIO()</span>
<span class="gi">+    chunk = f.read(_CHUNK_SIZE)</span>
<span class="gi">+    total_size = 0</span>
<span class="gi">+</span>
<span class="gi">+    while chunk:</span>
<span class="gi">+        output.write(chunk)</span>
<span class="gi">+        total_size += len(chunk)</span>
<span class="gi">+        if max_size and total_size &gt; max_size:</span>
<span class="gi">+            raise _DecompressionMaxSizeExceeded(f&quot;Decompressed data exceeded max_size ({max_size} bytes)&quot;)</span>
<span class="gi">+        chunk = f.read(_CHUNK_SIZE)</span>
<span class="gi">+</span>
<span class="gi">+    return output.getvalue()</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/iterators.py b/scrapy/utils/iterators.py</span>
<span class="gh">index 934167a9f..a963c93cf 100644</span>
<span class="gd">--- a/scrapy/utils/iterators.py</span>
<span class="gi">+++ b/scrapy/utils/iterators.py</span>
<span class="gu">@@ -1,3 +1,7 @@</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+This module provides some useful functions for working with</span>
<span class="gi">+scrapy.http.Response objects</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="w"> </span>import csv
<span class="w"> </span>import logging
<span class="w"> </span>import re
<span class="gu">@@ -13,16 +17,14 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    from lxml._types import SupportsReadClose
<span class="w"> </span>logger = logging.getLogger(__name__)

<span class="gd">-def xmliter(obj: Union[Response, str, bytes], nodename: str) -&gt; Generator[Selector, Any, None]:</span>
<span class="gd">-    &quot;&quot;&quot;Return a iterator of Selector&#39;s over all nodes of a XML document,</span>
<span class="gd">-       given the name of the node to iterate. Useful for parsing XML feeds.</span>
<span class="gd">-</span>
<span class="gd">-    obj can be:</span>
<span class="gd">-    - a Response object</span>
<span class="gd">-    - a unicode string</span>
<span class="gd">-    - a string encoded as utf-8</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def _body_or_str(obj: Union[Response, str, bytes]) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Return bytes from a Response object or a string/bytes object&quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(obj, Response):</span>
<span class="gi">+        return obj.body</span>
<span class="gi">+    elif isinstance(obj, str):</span>
<span class="gi">+        return obj.encode(&quot;utf-8&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return obj</span>

<span class="w"> </span>class _StreamReader:

<span class="gu">@@ -32,12 +34,73 @@ class _StreamReader:</span>
<span class="w"> </span>        if isinstance(obj, TextResponse):
<span class="w"> </span>            self._text, self.encoding = (obj.body, obj.encoding)
<span class="w"> </span>        elif isinstance(obj, Response):
<span class="gd">-            self._text, self.encoding = (obj.body, &#39;utf-8&#39;)</span>
<span class="gi">+            self._text, self.encoding = (obj.body, &quot;utf-8&quot;)</span>
<span class="w"> </span>        else:
<span class="gd">-            self._text, self.encoding = (obj, &#39;utf-8&#39;)</span>
<span class="gi">+            self._text, self.encoding = (obj, &quot;utf-8&quot;)</span>
<span class="w"> </span>        self._is_unicode: bool = isinstance(self._text, str)
<span class="w"> </span>        self._is_first_read: bool = True

<span class="gi">+    def read(self, n: int=-1) -&gt; str:</span>
<span class="gi">+        &quot;&quot;&quot;Returns a string from the given position and updates the internal pointer.&quot;&quot;&quot;</span>
<span class="gi">+        assert n &lt;= 0 or n is None  # only reads all data</span>
<span class="gi">+        if self._is_first_read:</span>
<span class="gi">+            self._is_first_read = False</span>
<span class="gi">+            if not self._is_unicode:</span>
<span class="gi">+                self._text = self._text.decode(self.encoding)</span>
<span class="gi">+        return self._text</span>
<span class="gi">+</span>
<span class="gi">+def xmliter(obj: Union[Response, str, bytes], nodename: str) -&gt; Generator[Selector, Any, None]:</span>
<span class="gi">+    &quot;&quot;&quot;Return a iterator of Selector&#39;s over all nodes of a XML document,</span>
<span class="gi">+       given the name of the node to iterate. Useful for parsing XML feeds.</span>
<span class="gi">+</span>
<span class="gi">+    obj can be:</span>
<span class="gi">+    - a Response object</span>
<span class="gi">+    - a unicode string</span>
<span class="gi">+    - a string encoded as utf-8</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    nodename_patt = re.escape(nodename)</span>
<span class="gi">+</span>
<span class="gi">+    reader = _StreamReader(obj)</span>
<span class="gi">+    for match in re.finditer(rf&quot;&lt;{nodename_patt}[\s&gt;].*?&lt;/{nodename_patt}&gt;&quot;, reader.read(), re.DOTALL):</span>
<span class="gi">+        nodetext = match.group()</span>
<span class="gi">+        yield Selector(text=nodetext, type=&quot;xml&quot;)</span>
<span class="gi">+</span>
<span class="gi">+def xmliter_lxml(obj: Union[Response, str, bytes, &quot;SupportsReadClose&quot;], nodename: str, namespace: Optional[str]=None, prefix: str=&quot;descendant::&quot;) -&gt; Generator[etree._Element, Any, None]:</span>
<span class="gi">+    &quot;&quot;&quot;Return a iterator of etree XML nodes from an XML document,</span>
<span class="gi">+    given the name of the node to iterate. Useful for parsing XML feeds.</span>
<span class="gi">+</span>
<span class="gi">+    obj can be:</span>
<span class="gi">+    - a Response object</span>
<span class="gi">+    - a unicode string</span>
<span class="gi">+    - a string encoded as utf-8</span>
<span class="gi">+    - a file-like object</span>
<span class="gi">+</span>
<span class="gi">+    nodename is the name of the node to iterate. To get all nodes of a</span>
<span class="gi">+    document, pass the name of the root node.</span>
<span class="gi">+</span>
<span class="gi">+    namespace is the namespace URI. If not provided, namespace-less matching is used.</span>
<span class="gi">+</span>
<span class="gi">+    prefix is the prefix used for searching the nodes. By default, descendant::/</span>
<span class="gi">+    is used, which is equivalent to selecting all nodes that match the nodename,</span>
<span class="gi">+    even if they are several levels deep. Pass a different prefix for custom matches.</span>
<span class="gi">+    The following are some examples:</span>
<span class="gi">+     - prefix=&quot;.//&quot;: same as default (descendant::) but more commonly used</span>
<span class="gi">+     - prefix=&quot;//&quot;: will search for nodes anywhere in the document</span>
<span class="gi">+     - prefix=&quot;./&quot;: will only match nodes at the same level as the context node</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    reader = _StreamReader(obj)</span>
<span class="gi">+    parser = etree.iterparse(reader, events=(&quot;end&quot;,), recover=True)</span>
<span class="gi">+</span>
<span class="gi">+    tag = f&quot;{{{namespace}}}{nodename}&quot; if namespace else nodename</span>
<span class="gi">+</span>
<span class="gi">+    for event, node in parser:</span>
<span class="gi">+        if node.tag == tag:</span>
<span class="gi">+            yield node</span>
<span class="gi">+            node.clear()</span>
<span class="gi">+            while node.getprevious() is not None:</span>
<span class="gi">+                prev = node.getprevious()</span>
<span class="gi">+                prev.getparent().remove(prev)</span>
<span class="gi">+</span>
<span class="w"> </span>def csviter(obj: Union[Response, str, bytes], delimiter: Optional[str]=None, headers: Optional[List[str]]=None, encoding: Optional[str]=None, quotechar: Optional[str]=None) -&gt; Generator[Dict[str, str], Any, None]:
<span class="w"> </span>    &quot;&quot;&quot;Returns an iterator of dictionaries from the given csv object

<span class="gu">@@ -53,4 +116,32 @@ def csviter(obj: Union[Response, str, bytes], delimiter: Optional[str]=None, hea</span>

<span class="w"> </span>    quotechar is the character used to enclosure fields on the given obj.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    def _getrow(csv_r):</span>
<span class="gi">+        return [to_unicode(field, encoding) for field in next(csv_r)]</span>
<span class="gi">+</span>
<span class="gi">+    encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or &quot;utf-8&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Python 3&#39;s csv.reader expects a file-like object that works in text mode</span>
<span class="gi">+    lines = StringIO(to_unicode(obj.body if isinstance(obj, Response) else obj, encoding))</span>
<span class="gi">+</span>
<span class="gi">+    kwargs = {}</span>
<span class="gi">+    if delimiter:</span>
<span class="gi">+        kwargs[&quot;delimiter&quot;] = delimiter</span>
<span class="gi">+    if quotechar:</span>
<span class="gi">+        kwargs[&quot;quotechar&quot;] = quotechar</span>
<span class="gi">+</span>
<span class="gi">+    csv_r = csv.reader(lines, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if not headers:</span>
<span class="gi">+        headers = _getrow(csv_r)</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        row = _getrow(csv_r)</span>
<span class="gi">+        if len(row) != len(headers):</span>
<span class="gi">+            logger.warning(&quot;ignoring row %(csvlnum)d (length: %(csvrow)d, &quot;</span>
<span class="gi">+                         &quot;should be: %(csvheader)d)&quot;,</span>
<span class="gi">+                         {&quot;csvlnum&quot;: csv_r.line_num, &quot;csvrow&quot;: len(row),</span>
<span class="gi">+                          &quot;csvheader&quot;: len(headers)})</span>
<span class="gi">+            continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield dict(zip(headers, row))</span>
<span class="gh">diff --git a/scrapy/utils/misc.py b/scrapy/utils/misc.py</span>
<span class="gh">index 579540955..459681a8b 100644</span>
<span class="gd">--- a/scrapy/utils/misc.py</span>
<span class="gi">+++ b/scrapy/utils/misc.py</span>
<span class="gu">@@ -27,7 +27,11 @@ def arg_to_iter(arg: Any) -&gt; Iterable[Any]:</span>

<span class="w"> </span>    Exception: if arg is a dict, [arg] will be returned
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if arg is None:</span>
<span class="gi">+        return []</span>
<span class="gi">+    if isinstance(arg, _ITERABLE_SINGLE_VALUES):</span>
<span class="gi">+        return [arg]</span>
<span class="gi">+    return arg</span>

<span class="w"> </span>def load_object(path: Union[str, Callable]) -&gt; Any:
<span class="w"> </span>    &quot;&quot;&quot;Load an object given its absolute object path, and return it.
<span class="gu">@@ -38,7 +42,25 @@ def load_object(path: Union[str, Callable]) -&gt; Any:</span>
<span class="w"> </span>    If ``path`` is not a string, but is a callable object, such as a class or
<span class="w"> </span>    a function, then return it as is.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(path, str):</span>
<span class="gi">+        if callable(path):</span>
<span class="gi">+            return path</span>
<span class="gi">+        raise TypeError(f&quot;Unexpected argument type, expected string or callable, got: {type(path)}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        dot = path.rindex(&#39;.&#39;)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ValueError(f&quot;Error loading object &#39;{path}&#39;: not a full path&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    module, name = path[:dot], path[dot + 1:]</span>
<span class="gi">+    mod = import_module(module)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        obj = getattr(mod, name)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        raise NameError(f&quot;Module &#39;{module}&#39; doesn&#39;t define any object named &#39;{name}&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return obj</span>

<span class="w"> </span>def walk_modules(path: str) -&gt; List[ModuleType]:
<span class="w"> </span>    &quot;&quot;&quot;Loads a module and all its submodules from the given module path and
<span class="gu">@@ -47,7 +69,18 @@ def walk_modules(path: str) -&gt; List[ModuleType]:</span>

<span class="w"> </span>    For example: walk_modules(&#39;scrapy.utils&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mods = []</span>
<span class="gi">+    mod = import_module(path)</span>
<span class="gi">+    mods.append(mod)</span>
<span class="gi">+    if hasattr(mod, &#39;__path__&#39;):</span>
<span class="gi">+        for _, subpath, ispkg in iter_modules(mod.__path__):</span>
<span class="gi">+            fullpath = path + &#39;.&#39; + subpath</span>
<span class="gi">+            if ispkg:</span>
<span class="gi">+                mods += walk_modules(fullpath)</span>
<span class="gi">+            else:</span>
<span class="gi">+                submod = import_module(fullpath)</span>
<span class="gi">+                mods.append(submod)</span>
<span class="gi">+    return mods</span>

<span class="w"> </span>def extract_regex(regex: Union[str, Pattern], text: str, encoding: str=&#39;utf-8&#39;) -&gt; List[str]:
<span class="w"> </span>    &quot;&quot;&quot;Extract a list of unicode strings from the given text/encoding using the following policies:
<span class="gu">@@ -56,7 +89,17 @@ def extract_regex(regex: Union[str, Pattern], text: str, encoding: str=&#39;utf-8&#39;)</span>
<span class="w"> </span>    * if the regex contains multiple numbered groups, all those will be returned (flattened)
<span class="w"> </span>    * if the regex doesn&#39;t contain any group the entire regex matching is returned
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(regex, str):</span>
<span class="gi">+        regex = re.compile(regex, re.UNICODE)</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(text, str):</span>
<span class="gi">+        text = text.decode(encoding)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        strings = [regex.search(text).group(&#39;extract&#39;)]   # named group</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        strings = regex.findall(text)    # full regex or numbered groups</span>
<span class="gi">+    return flatten(strings)</span>

<span class="w"> </span>def md5sum(file: IO) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Calculate the md5 checksum of a file-like object without reading its
<span class="gu">@@ -66,11 +109,19 @@ def md5sum(file: IO) -&gt; str:</span>
<span class="w"> </span>    &gt;&gt;&gt; md5sum(BytesIO(b&#39;file content to hash&#39;))
<span class="w"> </span>    &#39;784406af91dd5a54fbb9c84c2236595a&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    m = hashlib.md5()</span>
<span class="gi">+    while True:</span>
<span class="gi">+        d = file.read(8096)</span>
<span class="gi">+        if not d:</span>
<span class="gi">+            break</span>
<span class="gi">+        m.update(d)</span>
<span class="gi">+    return m.hexdigest()</span>

<span class="w"> </span>def rel_has_nofollow(rel: Optional[str]) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;Return True if link rel attribute has nofollow type&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if rel is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return &#39;nofollow&#39; in rel.split()</span>

<span class="w"> </span>def create_instance(objcls, settings, crawler, *args, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;Construct a class instance using its ``from_crawler`` or
<span class="gu">@@ -89,32 +140,103 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):</span>
<span class="w"> </span>       Raises ``TypeError`` if the resulting instance is ``None`` (e.g. if an
<span class="w"> </span>       extension has not been implemented correctly).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if settings is None and crawler is None:</span>
<span class="gi">+        raise ValueError(&quot;Specify at least one of settings and crawler.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if crawler and hasattr(objcls, &#39;from_crawler&#39;):</span>
<span class="gi">+        instance = objcls.from_crawler(crawler, *args, **kwargs)</span>
<span class="gi">+        method_name = &#39;from_crawler&#39;</span>
<span class="gi">+    elif hasattr(objcls, &#39;from_settings&#39;):</span>
<span class="gi">+        instance = objcls.from_settings(settings or crawler.settings, *args, **kwargs)</span>
<span class="gi">+        method_name = &#39;from_settings&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        instance = objcls(*args, **kwargs)</span>
<span class="gi">+        method_name = &#39;__new__&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if instance is None:</span>
<span class="gi">+        raise TypeError(f&quot;{objcls.__qualname__}.{method_name} returned None&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return instance</span>

<span class="w"> </span>@contextmanager
<span class="w"> </span>def set_environ(**kwargs: str) -&gt; Generator[None, Any, None]:
<span class="w"> </span>    &quot;&quot;&quot;Temporarily set environment variables inside the context manager and
<span class="w"> </span>    fully restore previous environment afterwards
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    curenv = {}</span>
<span class="gi">+    for key in kwargs:</span>
<span class="gi">+        curenv[key] = os.environ.get(key)</span>
<span class="gi">+        if curenv[key] is None:</span>
<span class="gi">+            os.environ.pop(key, None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            os.environ[key] = kwargs[key]</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        for key in kwargs:</span>
<span class="gi">+            if curenv[key] is None:</span>
<span class="gi">+                os.environ.pop(key, None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                os.environ[key] = curenv[key]</span>

<span class="w"> </span>def walk_callable(node: ast.AST) -&gt; Generator[ast.AST, Any, None]:
<span class="w"> </span>    &quot;&quot;&quot;Similar to ``ast.walk``, but walks only function body and skips nested
<span class="w"> </span>    functions defined within the node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-_generator_callbacks_cache = LocalWeakReferencedCache(limit=128)</span>
<span class="gi">+    todo = deque([node])</span>
<span class="gi">+    while todo:</span>
<span class="gi">+        node = todo.popleft()</span>
<span class="gi">+        if isinstance(node, ast.FunctionDef):</span>
<span class="gi">+            continue</span>
<span class="gi">+        todo.extend(ast.iter_child_nodes(node))</span>
<span class="gi">+        yield node</span>

<span class="w"> </span>def is_generator_with_return_value(callable: Callable) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns True if a callable is a generator function which includes a
<span class="w"> </span>    &#39;return&#39; statement with a value different than None, False otherwise
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not inspect.isgeneratorfunction(callable):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if callable in _generator_callbacks_cache:</span>
<span class="gi">+        return _generator_callbacks_cache[callable]</span>
<span class="gi">+</span>
<span class="gi">+    def returns_none(return_node):</span>
<span class="gi">+        value = return_node.value</span>
<span class="gi">+        return (</span>
<span class="gi">+            value is None</span>
<span class="gi">+            or isinstance(value, ast.Constant) and value.value is None</span>
<span class="gi">+            or isinstance(value, ast.Name) and value.id == &#39;None&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def has_return_with_value(ast_tree):</span>
<span class="gi">+        for node in walk_callable(ast_tree):</span>
<span class="gi">+            if isinstance(node, ast.Return) and node.value is not None and not returns_none(node):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    src = inspect.getsource(callable)</span>
<span class="gi">+    try:</span>
<span class="gi">+        ast_tree = ast.parse(src)</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    result = has_return_with_value(ast_tree)</span>
<span class="gi">+    _generator_callbacks_cache[callable] = result</span>
<span class="gi">+    return result</span>

<span class="w"> </span>def warn_on_generator_with_return_value(spider: &#39;Spider&#39;, callable: Callable) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Logs a warning if a callable is a generator function and includes
<span class="w"> </span>    a &#39;return&#39; statement with a value different than None
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if is_generator_with_return_value(callable):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            f&#39;The &quot;{spider.__class__.__name__}.{callable.__name__}&quot; method is &#39;</span>
<span class="gi">+            &#39;a generator and includes a &quot;return&quot; statement with a value &#39;</span>
<span class="gi">+            &#39;different than None. This could lead to unexpected behaviour. Please see &#39;</span>
<span class="gi">+            &#39;https://docs.python.org/3/reference/simple_stmts.html#the-return-statement &#39;</span>
<span class="gi">+            &#39;for details about the semantics of the &quot;return&quot; statement within generators&#39;,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/project.py b/scrapy/utils/project.py</span>
<span class="gh">index 0e9a3b6e8..737061533 100644</span>
<span class="gd">--- a/scrapy/utils/project.py</span>
<span class="gi">+++ b/scrapy/utils/project.py</span>
<span class="gu">@@ -8,13 +8,45 @@ from scrapy.utils.conf import closest_scrapy_cfg, get_config, init_env</span>
<span class="w"> </span>ENVVAR = &#39;SCRAPY_SETTINGS_MODULE&#39;
<span class="w"> </span>DATADIR_CFG_SECTION = &#39;datadir&#39;

<span class="gi">+def get_project_settings():</span>
<span class="gi">+    &quot;&quot;&quot;Get project settings module from environment variable&quot;&quot;&quot;</span>
<span class="gi">+    if ENVVAR not in os.environ:</span>
<span class="gi">+        project = os.environ.get(&#39;SCRAPY_PROJECT&#39;, &#39;default&#39;)</span>
<span class="gi">+        init_env(project)</span>
<span class="gi">+</span>
<span class="gi">+    settings = Settings()</span>
<span class="gi">+    settings_module_path = os.environ.get(ENVVAR)</span>
<span class="gi">+    if settings_module_path:</span>
<span class="gi">+        settings.setmodule(settings_module_path, priority=&#39;project&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    scrapy_cfg = closest_scrapy_cfg()</span>
<span class="gi">+    if scrapy_cfg is not None:</span>
<span class="gi">+        config = get_config()</span>
<span class="gi">+        for key, value in config.items(&#39;settings&#39;, default={}):</span>
<span class="gi">+            settings.set(key.upper(), value, priority=&#39;project&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return settings</span>
<span class="gi">+</span>
<span class="w"> </span>def project_data_dir(project: str=&#39;default&#39;) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Return the current project data dir, creating it if it doesn&#39;t exist&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if project == &#39;default&#39;:</span>
<span class="gi">+        cfg = closest_scrapy_cfg()</span>
<span class="gi">+        if cfg:</span>
<span class="gi">+            project = os.path.basename(os.path.dirname(cfg))</span>
<span class="gi">+    </span>
<span class="gi">+    datadir = os.path.join(os.path.expanduser(&#39;~&#39;), &#39;.scrapy&#39;, &#39;projects&#39;, project)</span>
<span class="gi">+    if not os.path.exists(datadir):</span>
<span class="gi">+        os.makedirs(datadir)</span>
<span class="gi">+    return datadir</span>

<span class="w"> </span>def data_path(path: str, createdir: bool=False) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the given path joined with the .scrapy data directory.
<span class="w"> </span>    If given an absolute path, return it unmodified.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if os.path.isabs(path):</span>
<span class="gi">+        return path</span>
<span class="gi">+    path = os.path.join(project_data_dir(), path)</span>
<span class="gi">+    if createdir and not os.path.exists(os.path.dirname(path)):</span>
<span class="gi">+        os.makedirs(os.path.dirname(path))</span>
<span class="gi">+    return path</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/python.py b/scrapy/utils/python.py</span>
<span class="gh">index f078ad898..58fb20a61 100644</span>
<span class="gd">--- a/scrapy/utils/python.py</span>
<span class="gi">+++ b/scrapy/utils/python.py</span>
<span class="gu">@@ -29,13 +29,23 @@ def flatten(x: Iterable) -&gt; list:</span>
<span class="w"> </span>    &gt;&gt;&gt; flatten([&quot;foo&quot;, [&quot;baz&quot;, 42], &quot;bar&quot;])
<span class="w"> </span>    [&#39;foo&#39;, &#39;baz&#39;, 42, &#39;bar&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for el in x:</span>
<span class="gi">+        if is_listlike(el):</span>
<span class="gi">+            result.extend(flatten(el))</span>
<span class="gi">+        else:</span>
<span class="gi">+            result.append(el)</span>
<span class="gi">+    return result</span>

<span class="w"> </span>def iflatten(x: Iterable) -&gt; Iterable:
<span class="w"> </span>    &quot;&quot;&quot;iflatten(sequence) -&gt; iterator

<span class="w"> </span>    Similar to ``.flatten()``, but returns iterator instead&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for el in x:</span>
<span class="gi">+        if is_listlike(el):</span>
<span class="gi">+            yield from iflatten(el)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield el</span>

<span class="w"> </span>def is_listlike(x: Any) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -58,21 +68,42 @@ def is_listlike(x: Any) -&gt; bool:</span>
<span class="w"> </span>    &gt;&gt;&gt; is_listlike(range(5))
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(x, (str, bytes)):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return isinstance(x, collections.abc.Iterable)</span>

<span class="w"> </span>def unique(list_: Iterable, key: Callable[[Any], Any]=lambda x: x) -&gt; list:
<span class="w"> </span>    &quot;&quot;&quot;efficient function to uniquify a list preserving item order&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for item in list_:</span>
<span class="gi">+        seenkey = key(item)</span>
<span class="gi">+        if seenkey not in seen:</span>
<span class="gi">+            seen.add(seenkey)</span>
<span class="gi">+            result.append(item)</span>
<span class="gi">+    return result</span>

<span class="w"> </span>def to_unicode(text: Union[str, bytes], encoding: Optional[str]=None, errors: str=&#39;strict&#39;) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Return the unicode representation of a bytes object ``text``. If
<span class="w"> </span>    ``text`` is already an unicode object, return it as-is.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(text, str):</span>
<span class="gi">+        return text</span>
<span class="gi">+    if not isinstance(text, bytes):</span>
<span class="gi">+        raise TypeError(&#39;to_unicode must receive a bytes or str object, got %s&#39; % type(text).__name__)</span>
<span class="gi">+    if encoding is None:</span>
<span class="gi">+        encoding = &#39;utf-8&#39;</span>
<span class="gi">+    return text.decode(encoding, errors)</span>

<span class="w"> </span>def to_bytes(text: Union[str, bytes], encoding: Optional[str]=None, errors: str=&#39;strict&#39;) -&gt; bytes:
<span class="w"> </span>    &quot;&quot;&quot;Return the binary representation of ``text``. If ``text``
<span class="w"> </span>    is already a bytes object, return it as-is.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(text, bytes):</span>
<span class="gi">+        return text</span>
<span class="gi">+    if not isinstance(text, str):</span>
<span class="gi">+        raise TypeError(&#39;to_bytes must receive a str or bytes object, got %s&#39; % type(text).__name__)</span>
<span class="gi">+    if encoding is None:</span>
<span class="gi">+        encoding = &#39;utf-8&#39;</span>
<span class="gi">+    return text.encode(encoding, errors)</span>

<span class="w"> </span>def re_rsearch(pattern: Union[str, Pattern], text: str, chunk_size: int=1024) -&gt; Optional[Tuple[int, int]]:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -87,24 +118,65 @@ def re_rsearch(pattern: Union[str, Pattern], text: str, chunk_size: int=1024) -&gt;</span>
<span class="w"> </span>    In case the pattern wasn&#39;t found, None is returned, otherwise it returns a tuple containing
<span class="w"> </span>    the start position of the match, and the ending (regarding the entire text).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(pattern, str):</span>
<span class="gi">+        pattern = re.compile(pattern)</span>
<span class="gi">+</span>
<span class="gi">+    text_len = len(text)</span>
<span class="gi">+    for start in range(text_len - chunk_size, -1, -chunk_size):</span>
<span class="gi">+        chunk = text[start:start + chunk_size]</span>
<span class="gi">+        matches = list(pattern.finditer(chunk))</span>
<span class="gi">+        if matches:</span>
<span class="gi">+            match = matches[-1]</span>
<span class="gi">+            return (start + match.start(), start + match.end())</span>
<span class="gi">+</span>
<span class="gi">+    # Check the remaining chunk at the beginning</span>
<span class="gi">+    remaining = text[0:text_len % chunk_size] if text_len &gt; chunk_size else text</span>
<span class="gi">+    matches = list(pattern.finditer(remaining))</span>
<span class="gi">+    if matches:</span>
<span class="gi">+        match = matches[-1]</span>
<span class="gi">+        return (match.start(), match.end())</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>

<span class="w"> </span>def memoizemethod_noargs(method: Callable) -&gt; Callable:
<span class="w"> </span>    &quot;&quot;&quot;Decorator to cache the result of a method (without arguments) using a
<span class="w"> </span>    weak reference to its object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cache = weakref.WeakKeyDictionary()</span>
<span class="gi">+</span>
<span class="gi">+    @wraps(method)</span>
<span class="gi">+    def new_method(self, *args, **kwargs):</span>
<span class="gi">+        if self not in cache:</span>
<span class="gi">+            cache[self] = method(self, *args, **kwargs)</span>
<span class="gi">+        return cache[self]</span>
<span class="gi">+</span>
<span class="gi">+    return new_method</span>
<span class="w"> </span>_BINARYCHARS = {i for i in range(32) if to_bytes(chr(i)) not in {b&#39;\x00&#39;, b&#39;\t&#39;, b&#39;\n&#39;, b&#39;\r&#39;}}

<span class="w"> </span>def binary_is_text(data: bytes) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;Returns ``True`` if the given ``data`` argument (a ``bytes`` object)
<span class="w"> </span>    does not contain unprintable control characters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(data, bytes):</span>
<span class="gi">+        raise TypeError(&quot;data must be bytes&quot;)</span>
<span class="gi">+    return all(x not in _BINARYCHARS for x in data)</span>

<span class="w"> </span>def get_func_args(func: Callable, stripself: bool=False) -&gt; List[str]:
<span class="w"> </span>    &quot;&quot;&quot;Return the argument name list of a callable object&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if inspect.isfunction(func):</span>
<span class="gi">+        spec = inspect.getfullargspec(func)</span>
<span class="gi">+    elif inspect.isclass(func):</span>
<span class="gi">+        spec = inspect.getfullargspec(func.__init__)</span>
<span class="gi">+    elif inspect.ismethod(func):</span>
<span class="gi">+        spec = inspect.getfullargspec(func)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(f&#39;{type(func)} is not supported&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    args = spec.args[1:] if stripself else spec.args[:]</span>
<span class="gi">+</span>
<span class="gi">+    if spec.defaults:</span>
<span class="gi">+        args = args[:-len(spec.defaults)]</span>
<span class="gi">+    return args</span>

<span class="w"> </span>def get_spec(func: Callable) -&gt; Tuple[List[str], Dict[str, Any]]:
<span class="w"> </span>    &quot;&quot;&quot;Returns (args, kwargs) tuple for a function
<span class="gu">@@ -127,11 +199,42 @@ def get_spec(func: Callable) -&gt; Tuple[List[str], Dict[str, Any]]:</span>
<span class="w"> </span>    &gt;&gt;&gt; get_spec(Test().method)
<span class="w"> </span>    ([&#39;self&#39;, &#39;val&#39;], {&#39;flags&#39;: 0})
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if inspect.isfunction(func) or inspect.ismethod(func):</span>
<span class="gi">+        spec = inspect.getfullargspec(func)</span>
<span class="gi">+    elif inspect.isclass(func):</span>
<span class="gi">+        spec = inspect.getfullargspec(func.__init__)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(f&#39;{type(func)} is not supported&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    defaults = spec.defaults or ()</span>
<span class="gi">+    args = spec.args[:-len(defaults)] if defaults else spec.args</span>
<span class="gi">+    kwargs = dict(zip(spec.args[-len(defaults):], defaults)) if defaults else {}</span>
<span class="gi">+</span>
<span class="gi">+    return args, kwargs</span>

<span class="w"> </span>def equal_attributes(obj1: Any, obj2: Any, attributes: Optional[List[Union[str, Callable]]]) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;Compare two objects attributes&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if attributes is None:</span>
<span class="gi">+        return obj1 == obj2</span>
<span class="gi">+</span>
<span class="gi">+    if len(attributes) == 0:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    for attr in attributes:</span>
<span class="gi">+        if isinstance(attr, str):</span>
<span class="gi">+            if not hasattr(obj1, attr):</span>
<span class="gi">+                return False</span>
<span class="gi">+            if not hasattr(obj2, attr):</span>
<span class="gi">+                return False</span>
<span class="gi">+            if getattr(obj1, attr) != getattr(obj2, attr):</span>
<span class="gi">+                return False</span>
<span class="gi">+        elif callable(attr):</span>
<span class="gi">+            if attr(obj1) != attr(obj2):</span>
<span class="gi">+                return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(&#39;attributes must be a list of strings or callables&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>

<span class="w"> </span>def without_none_values(iterable: Union[Mapping, Iterable]) -&gt; Union[dict, Iterable]:
<span class="w"> </span>    &quot;&quot;&quot;Return a copy of ``iterable`` with all ``None`` entries removed.
<span class="gu">@@ -139,7 +242,9 @@ def without_none_values(iterable: Union[Mapping, Iterable]) -&gt; Union[dict, Itera</span>
<span class="w"> </span>    If ``iterable`` is a mapping, return a dictionary where all pairs that have
<span class="w"> </span>    value ``None`` have been removed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(iterable, Mapping):</span>
<span class="gi">+        return {k: v for k, v in iterable.items() if v is not None}</span>
<span class="gi">+    return type(iterable)(x for x in iterable if x is not None)</span>

<span class="w"> </span>def global_object_name(obj: Any) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -149,8 +254,13 @@ def global_object_name(obj: Any) -&gt; str:</span>
<span class="w"> </span>    &gt;&gt;&gt; global_object_name(Request)
<span class="w"> </span>    &#39;scrapy.http.request.Request&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    module = getattr(obj, &#39;__module__&#39;, None)</span>
<span class="gi">+    name = getattr(obj, &#39;__name__&#39;, None)</span>
<span class="gi">+    if module is None or name is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return f&quot;{module}.{name}&quot;</span>
<span class="w"> </span>if hasattr(sys, &#39;pypy_version_info&#39;):
<span class="gi">+    pass</span>

<span class="w"> </span>class MutableChain(Iterable):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gh">diff --git a/scrapy/utils/reactor.py b/scrapy/utils/reactor.py</span>
<span class="gh">index fbc411938..9d2bee786 100644</span>
<span class="gd">--- a/scrapy/utils/reactor.py</span>
<span class="gi">+++ b/scrapy/utils/reactor.py</span>
<span class="gu">@@ -11,7 +11,19 @@ from scrapy.utils.misc import load_object</span>

<span class="w"> </span>def listen_tcp(portrange, host, factory):
<span class="w"> </span>    &quot;&quot;&quot;Like reactor.listenTCP but tries different ports in a range.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from twisted.internet import reactor</span>
<span class="gi">+    if len(portrange) &gt; 1:</span>
<span class="gi">+        for port in portrange:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return reactor.listenTCP(port, factory, interface=host)</span>
<span class="gi">+            except error.CannotListenError:</span>
<span class="gi">+                if port == portrange[-1]:</span>
<span class="gi">+                    raise</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return reactor.listenTCP(portrange[0], factory, interface=host)</span>
<span class="gi">+        except error.CannotListenError:</span>
<span class="gi">+            raise</span>

<span class="w"> </span>class CallLaterOnce:
<span class="w"> </span>    &quot;&quot;&quot;Schedule a function to be called in the next reactor loop, but only if
<span class="gu">@@ -33,20 +45,64 @@ def set_asyncio_event_loop_policy() -&gt; None:</span>
<span class="w"> </span>    so we restrict their use to the absolutely essential case.
<span class="w"> </span>    This should only be used to install the reactor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        with suppress(ImportError):</span>
<span class="gi">+            from asyncio import WindowsSelectorEventLoopPolicy</span>
<span class="gi">+            asyncio.set_event_loop_policy(WindowsSelectorEventLoopPolicy())</span>

<span class="w"> </span>def install_reactor(reactor_path: str, event_loop_path: Optional[str]=None) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;Installs the :mod:`~twisted.internet.reactor` with the specified
<span class="w"> </span>    import path. Also installs the asyncio event loop with the specified import
<span class="w"> </span>    path if the asyncio reactor is enabled&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if reactor_path == &#39;twisted.internet.asyncio.AsyncioSelectorReactor&#39;:</span>
<span class="gi">+        # Disable asyncio event loop debug mode, it is enabled by default since Python 3.10</span>
<span class="gi">+        # and it causes issues with Scrapy&#39;s implementation of coroutine-based spider callbacks</span>
<span class="gi">+        with catch_warnings():</span>
<span class="gi">+            filterwarnings(&#39;ignore&#39;, category=DeprecationWarning)</span>
<span class="gi">+            set_asyncio_event_loop_policy()</span>
<span class="gi">+            event_loop = set_asyncio_event_loop(event_loop_path)</span>
<span class="gi">+            reactor = asyncioreactor.AsyncioSelectorReactor(event_loop)</span>
<span class="gi">+    else:</span>
<span class="gi">+        reactor = load_object(reactor_path)()</span>
<span class="gi">+</span>
<span class="gi">+    from twisted.internet.main import installReactor</span>
<span class="gi">+    installReactor(reactor)</span>

<span class="w"> </span>def set_asyncio_event_loop(event_loop_path: Optional[str]) -&gt; AbstractEventLoop:
<span class="w"> </span>    &quot;&quot;&quot;Sets and returns the event loop with specified import path.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if event_loop_path is not None:</span>
<span class="gi">+        event_loop = load_object(event_loop_path)()</span>
<span class="gi">+        asyncio.set_event_loop(event_loop)</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            event_loop = asyncio.get_event_loop()</span>
<span class="gi">+        except RuntimeError:</span>
<span class="gi">+            event_loop = asyncio.new_event_loop()</span>
<span class="gi">+            asyncio.set_event_loop(event_loop)</span>
<span class="gi">+    return event_loop</span>

<span class="w"> </span>def verify_installed_reactor(reactor_path: str) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;Raises :exc:`Exception` if the installed
<span class="w"> </span>    :mod:`~twisted.internet.reactor` does not match the specified import
<span class="w"> </span>    path.&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    from twisted.internet import reactor</span>
<span class="gi">+    if not reactor.__module__ == reactor_path:</span>
<span class="gi">+        msg = &quot;The installed reactor ({}) does not match the requested one ({})&quot;.format(</span>
<span class="gi">+            reactor.__module__, reactor_path</span>
<span class="gi">+        )</span>
<span class="gi">+        raise Exception(msg)</span>
<span class="gi">+</span>
<span class="gi">+def _get_asyncio_event_loop() -&gt; AbstractEventLoop:</span>
<span class="gi">+    &quot;&quot;&quot;Get the asyncio event loop in a way that works for both Twisted&#39;s</span>
<span class="gi">+    AsyncioSelectorReactor and the asyncio reactor.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    from twisted.internet import reactor</span>
<span class="gi">+    try:</span>
<span class="gi">+        return reactor._asyncioEventloop</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return asyncio.get_event_loop()</span>
<span class="gi">+</span>
<span class="gi">+def is_asyncio_reactor_installed() -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Return True if the installed reactor is AsyncioSelectorReactor.&quot;&quot;&quot;</span>
<span class="gi">+    from twisted.internet import reactor</span>
<span class="gi">+    return reactor.__module__ == &#39;twisted.internet.asyncio&#39;</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/request.py b/scrapy/utils/request.py</span>
<span class="gh">index 1bbbcbe71..ef297c7df 100644</span>
<span class="gd">--- a/scrapy/utils/request.py</span>
<span class="gi">+++ b/scrapy/utils/request.py</span>
<span class="gu">@@ -20,6 +20,26 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>_deprecated_fingerprint_cache: &#39;WeakKeyDictionary[Request, Dict[Tuple[Optional[Tuple[bytes, ...]], bool], str]]&#39;
<span class="w"> </span>_deprecated_fingerprint_cache = WeakKeyDictionary()

<span class="gi">+def _request_fingerprint_as_bytes(request: Request, include_headers: Optional[Iterable[Union[bytes, str]]]=None, keep_fragments: bool=False) -&gt; bytes:</span>
<span class="gi">+    &quot;&quot;&quot;Return the request fingerprint as bytes.&quot;&quot;&quot;</span>
<span class="gi">+    if include_headers:</span>
<span class="gi">+        include_headers = tuple(to_bytes(h.lower()) for h in sorted(include_headers))</span>
<span class="gi">+    cache = _fingerprint_cache.setdefault(request, {})</span>
<span class="gi">+    cache_key = (include_headers, keep_fragments)</span>
<span class="gi">+    if cache_key not in cache:</span>
<span class="gi">+        fp = hashlib.sha1()</span>
<span class="gi">+        fp.update(to_bytes(request.method))</span>
<span class="gi">+        fp.update(to_bytes(canonicalize_url(request.url, keep_fragments=keep_fragments)))</span>
<span class="gi">+        fp.update(request.body or b&#39;&#39;)</span>
<span class="gi">+        if include_headers:</span>
<span class="gi">+            for hdr in include_headers:</span>
<span class="gi">+                if hdr in request.headers:</span>
<span class="gi">+                    fp.update(hdr)</span>
<span class="gi">+                    for v in request.headers.getlist(hdr):</span>
<span class="gi">+                        fp.update(v)</span>
<span class="gi">+        cache[cache_key] = fp.digest()</span>
<span class="gi">+    return cache[cache_key]</span>
<span class="gi">+</span>
<span class="w"> </span>def request_fingerprint(request: Request, include_headers: Optional[Iterable[Union[bytes, str]]]=None, keep_fragments: bool=False) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the request fingerprint as an hexadecimal string.
<span class="gu">@@ -51,7 +71,13 @@ def request_fingerprint(request: Request, include_headers: Optional[Iterable[Uni</span>
<span class="w"> </span>    If you want to include them, set the keep_fragments argument to True
<span class="w"> </span>    (for instance when handling requests with a headless browser).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if include_headers:</span>
<span class="gi">+        include_headers = tuple(to_bytes(h.lower()) for h in sorted(include_headers))</span>
<span class="gi">+    cache = _deprecated_fingerprint_cache.setdefault(request, {})</span>
<span class="gi">+    cache_key = (include_headers, keep_fragments)</span>
<span class="gi">+    if cache_key not in cache:</span>
<span class="gi">+        cache[cache_key] = _request_fingerprint_as_bytes(request, include_headers, keep_fragments).hex()</span>
<span class="gi">+    return cache[cache_key]</span>
<span class="w"> </span>_fingerprint_cache: &#39;WeakKeyDictionary[Request, Dict[Tuple[Optional[Tuple[bytes, ...]], bool], bytes]]&#39;
<span class="w"> </span>_fingerprint_cache = WeakKeyDictionary()

<span class="gu">@@ -86,10 +112,11 @@ def fingerprint(request: Request, *, include_headers: Optional[Iterable[Union[by</span>
<span class="w"> </span>    If you want to include them, set the keep_fragments argument to True
<span class="w"> </span>    (for instance when handling requests with a headless browser).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _request_fingerprint_as_bytes(request, include_headers, keep_fragments)</span>

<span class="w"> </span>class RequestFingerprinterProtocol(Protocol):
<span class="gd">-    pass</span>
<span class="gi">+    def __call__(self, request: Request, *, include_headers: Optional[Iterable[Union[bytes, str]]]=None, keep_fragments: bool=False) -&gt; bytes:</span>
<span class="gi">+        ...</span>

<span class="w"> </span>class RequestFingerprinter:
<span class="w"> </span>    &quot;&quot;&quot;Default fingerprinter.
<span class="gu">@@ -118,11 +145,14 @@ class RequestFingerprinter:</span>
<span class="w"> </span>        else:
<span class="w"> </span>            raise ValueError(f&quot;Got an invalid value on setting &#39;REQUEST_FINGERPRINTER_IMPLEMENTATION&#39;: {implementation!r}. Valid values are &#39;2.6&#39; (deprecated) and &#39;2.7&#39;.&quot;)

<span class="gi">+    def __call__(self, request: Request, *, include_headers: Optional[Iterable[Union[bytes, str]]]=None, keep_fragments: bool=False) -&gt; bytes:</span>
<span class="gi">+        return self._fingerprint(request, include_headers=include_headers, keep_fragments=keep_fragments)</span>
<span class="gi">+</span>
<span class="w"> </span>def request_authenticate(request: Request, username: str, password: str) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;Authenticate the given request (in place) using the HTTP basic access
<span class="w"> </span>    authentication mechanism (RFC 2617) and the given username and password
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    request.headers[&#39;Authorization&#39;] = basic_auth_header(username, password)</span>

<span class="w"> </span>def request_httprepr(request: Request) -&gt; bytes:
<span class="w"> </span>    &quot;&quot;&quot;Return the raw HTTP representation (as bytes) of the given request.
<span class="gu">@@ -130,11 +160,23 @@ def request_httprepr(request: Request) -&gt; bytes:</span>
<span class="w"> </span>    bytes that will be send when performing the request (that&#39;s controlled
<span class="w"> </span>    by Twisted).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parsed = urlparse_cached(request)</span>
<span class="gi">+    path = urlunparse((&#39;&#39;, &#39;&#39;, parsed.path or &#39;/&#39;, parsed.params, parsed.query, &#39;&#39;))</span>
<span class="gi">+    s = to_bytes(request.method) + b&quot; &quot; + to_bytes(path) + b&quot; HTTP/1.1\r\n&quot;</span>
<span class="gi">+    s += b&quot;Host: &quot; + to_bytes(parsed.hostname or b&#39;&#39;) + b&quot;\r\n&quot;</span>
<span class="gi">+    if request.headers:</span>
<span class="gi">+        s += request.headers.to_string() + b&quot;\r\n&quot;</span>
<span class="gi">+    s += b&quot;\r\n&quot;</span>
<span class="gi">+    if request.body:</span>
<span class="gi">+        s += request.body</span>
<span class="gi">+    return s</span>

<span class="w"> </span>def referer_str(request: Request) -&gt; Optional[str]:
<span class="w"> </span>    &quot;&quot;&quot;Return Referer HTTP header suitable for logging.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    referrer = request.headers.get(&#39;Referer&#39;)</span>
<span class="gi">+    if referrer:</span>
<span class="gi">+        return to_unicode(referrer)</span>
<span class="gi">+    return None</span>

<span class="w"> </span>def request_from_dict(d: dict, *, spider: Optional[Spider]=None) -&gt; Request:
<span class="w"> </span>    &quot;&quot;&quot;Create a :class:`~scrapy.Request` object from a dict.
<span class="gu">@@ -142,11 +184,23 @@ def request_from_dict(d: dict, *, spider: Optional[Spider]=None) -&gt; Request:</span>
<span class="w"> </span>    If a spider is given, it will try to resolve the callbacks looking at the
<span class="w"> </span>    spider for methods with the same name.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    d = d.copy()</span>
<span class="gi">+    callback = d.pop(&#39;callback&#39;, None)</span>
<span class="gi">+    errback = d.pop(&#39;errback&#39;, None)</span>
<span class="gi">+    cls = load_object(d.pop(&#39;cls&#39;)) if &#39;cls&#39; in d else Request</span>
<span class="gi">+</span>
<span class="gi">+    if callback and spider:</span>
<span class="gi">+        d[&#39;callback&#39;] = _get_method(spider, callback)</span>
<span class="gi">+    if errback and spider:</span>
<span class="gi">+        d[&#39;errback&#39;] = _get_method(spider, errback)</span>
<span class="gi">+</span>
<span class="gi">+    return cls(**d)</span>

<span class="w"> </span>def _get_method(obj: Any, name: Any) -&gt; Any:
<span class="w"> </span>    &quot;&quot;&quot;Helper function for request_from_dict&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(name, str):</span>
<span class="gi">+        return getattr(obj, name)</span>
<span class="gi">+    return name</span>

<span class="w"> </span>def request_to_curl(request: Request) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -155,4 +209,22 @@ def request_to_curl(request: Request) -&gt; str:</span>
<span class="w"> </span>    :param :class:`~scrapy.Request`: Request object to be converted
<span class="w"> </span>    :return: string containing the curl command
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    command = [&quot;curl&quot;]</span>
<span class="gi">+    command.append(request.url)</span>
<span class="gi">+</span>
<span class="gi">+    if request.method != &#39;GET&#39;:</span>
<span class="gi">+        command.extend([&#39;-X&#39;, request.method])</span>
<span class="gi">+</span>
<span class="gi">+    for header_name, header_values in request.headers.items():</span>
<span class="gi">+        for header_value in header_values:</span>
<span class="gi">+            header = f&#39;{header_name.decode(&quot;utf-8&quot;)}: {header_value.decode(&quot;utf-8&quot;)}&#39;</span>
<span class="gi">+            command.extend([&#39;-H&#39;, header])</span>
<span class="gi">+</span>
<span class="gi">+    if request.body:</span>
<span class="gi">+        if isinstance(request.body, str):</span>
<span class="gi">+            body = request.body</span>
<span class="gi">+        else:</span>
<span class="gi">+            body = request.body.decode(&#39;utf-8&#39;)</span>
<span class="gi">+        command.extend([&#39;--data&#39;, body])</span>
<span class="gi">+</span>
<span class="gi">+    return &#39; &#39;.join(f&quot;&#39;{x}&#39;&quot; if &#39; &#39; in x else x for x in command)</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/response.py b/scrapy/utils/response.py</span>
<span class="gh">index 2531e70a4..810d608b0 100644</span>
<span class="gd">--- a/scrapy/utils/response.py</span>
<span class="gi">+++ b/scrapy/utils/response.py</span>
<span class="gu">@@ -16,18 +16,41 @@ from scrapy.utils.decorators import deprecated</span>
<span class="w"> </span>from scrapy.utils.python import to_bytes, to_unicode
<span class="w"> </span>_baseurl_cache: &#39;WeakKeyDictionary[Response, str]&#39; = WeakKeyDictionary()

<span class="gi">+def _remove_html_comments(text: str) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Remove HTML comments from the given text.&quot;&quot;&quot;</span>
<span class="gi">+    return re.sub(&#39;&lt;!--.*?--&gt;&#39;, &#39;&#39;, text, flags=re.DOTALL)</span>
<span class="gi">+</span>
<span class="w"> </span>def get_base_url(response: &#39;scrapy.http.response.text.TextResponse&#39;) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Return the base url of the given response, joined with the response url&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if response not in _baseurl_cache:</span>
<span class="gi">+        text = response.text[0:4096]</span>
<span class="gi">+        text = _remove_html_comments(text)</span>
<span class="gi">+        match = re.search(r&#39;&lt;base\s+href\s*=\s*[&quot;\&#39;]?([^\s&quot;\&#39;]+)&#39;, text, re.I)</span>
<span class="gi">+        base_url = match.group(1) if match else response.url</span>
<span class="gi">+        _baseurl_cache[response] = base_url</span>
<span class="gi">+    return _baseurl_cache[response]</span>
<span class="w"> </span>_metaref_cache: &#39;WeakKeyDictionary[Response, Union[Tuple[None, None], Tuple[float, str]]]&#39; = WeakKeyDictionary()

<span class="w"> </span>def get_meta_refresh(response: &#39;scrapy.http.response.text.TextResponse&#39;, ignore_tags: Iterable[str]=(&#39;script&#39;, &#39;noscript&#39;)) -&gt; Union[Tuple[None, None], Tuple[float, str]]:
<span class="w"> </span>    &quot;&quot;&quot;Parse the http-equiv refresh parameter from the given response&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if response not in _metaref_cache:</span>
<span class="gi">+        text = response.text[0:4096]</span>
<span class="gi">+        text = _remove_html_comments(text)</span>
<span class="gi">+        for tag in ignore_tags:</span>
<span class="gi">+            text = re.sub(f&#39;&lt;{tag}[\s&gt;].*?&lt;/{tag}&gt;&#39;, &#39;&#39;, text, flags=re.DOTALL | re.IGNORECASE)</span>
<span class="gi">+        match = re.search(r&#39;&lt;meta[^&gt;]*http-equiv[^&gt;]*refresh[^&gt;]*content\s*=\s*[&quot;\&#39;]?\s*(\d*)\s*;\s*url=([^&quot;\&#39;&gt;\s]*)&#39;, text, re.IGNORECASE)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            interval, url = match.groups()</span>
<span class="gi">+            _metaref_cache[response] = (float(interval), html.unescape(url))</span>
<span class="gi">+        else:</span>
<span class="gi">+            _metaref_cache[response] = (None, None)</span>
<span class="gi">+    return _metaref_cache[response]</span>

<span class="w"> </span>def response_status_message(status: Union[bytes, float, int, str]) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Return status code plus status text descriptive message&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    status = int(status)</span>
<span class="gi">+    message = http.RESPONSES.get(status, &quot;Unknown Status&quot;)</span>
<span class="gi">+    return f&quot;{status} {to_unicode(message)}&quot;</span>

<span class="w"> </span>@deprecated
<span class="w"> </span>def response_httprepr(response: Response) -&gt; bytes:
<span class="gu">@@ -35,7 +58,16 @@ def response_httprepr(response: Response) -&gt; bytes:</span>
<span class="w"> </span>    is provided only for reference, since it&#39;s not the exact stream of bytes
<span class="w"> </span>    that was received (that&#39;s not exposed by Twisted).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    values = [</span>
<span class="gi">+        b&quot;HTTP/1.1 &quot; + to_bytes(str(response.status)) + b&quot; &quot; + to_bytes(http.RESPONSES.get(response.status, b&#39;&#39;)),</span>
<span class="gi">+    ]</span>
<span class="gi">+    if response.headers:</span>
<span class="gi">+        values.extend(</span>
<span class="gi">+            to_bytes(f&quot;{k.decode(&#39;utf-8&#39;)}: {v[0].decode(&#39;utf-8&#39;)}&quot;) for k, v in response.headers.items()</span>
<span class="gi">+        )</span>
<span class="gi">+    values.append(b&#39;&#39;)</span>
<span class="gi">+    values.append(response.body)</span>
<span class="gi">+    return b&#39;\r\n&#39;.join(values)</span>

<span class="w"> </span>def open_in_browser(response: Union[&#39;scrapy.http.response.html.HtmlResponse&#39;, &#39;scrapy.http.response.text.TextResponse&#39;], _openfunc: Callable[[str], Any]=webbrowser.open) -&gt; Any:
<span class="w"> </span>    &quot;&quot;&quot;Open *response* in a local web browser, adjusting the `base tag`_ for
<span class="gu">@@ -54,4 +86,27 @@ def open_in_browser(response: Union[&#39;scrapy.http.response.html.HtmlResponse&#39;, &#39;s</span>
<span class="w"> </span>            if &quot;item name&quot; not in response.body:
<span class="w"> </span>                open_in_browser(response)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    # Process response content</span>
<span class="gi">+    body = response.body</span>
<span class="gi">+    if isinstance(body, bytes):</span>
<span class="gi">+        body = body.decode(&#39;utf-8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Remove existing base tag if present</span>
<span class="gi">+    body = re.sub(r&#39;&lt;base\s+[^&gt;]*&gt;&#39;, &#39;&#39;, body)</span>
<span class="gi">+</span>
<span class="gi">+    # Add our base tag</span>
<span class="gi">+    match = re.search(r&#39;&lt;head\b[^&gt;]*&gt;&#39;, body, re.IGNORECASE)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        index = match.end()</span>
<span class="gi">+        body = body[:index] + f&#39;&lt;base href=&quot;{response.url}&quot;&gt;&#39; + body[index:]</span>
<span class="gi">+    else:</span>
<span class="gi">+        # If no &lt;head&gt; tag, just add it</span>
<span class="gi">+        body = f&#39;&lt;base href=&quot;{response.url}&quot;&gt;\n&#39; + body</span>
<span class="gi">+</span>
<span class="gi">+    # Create temporary file</span>
<span class="gi">+    fd, fname = tempfile.mkstemp(&#39;.html&#39;)</span>
<span class="gi">+    os.write(fd, body.encode(&#39;utf-8&#39;))</span>
<span class="gi">+    os.close(fd)</span>
<span class="gi">+</span>
<span class="gi">+    # Open in browser</span>
<span class="gi">+    return _openfunc(f&#39;file://{fname}&#39;)</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/spider.py b/scrapy/utils/spider.py</span>
<span class="gh">index 68e1a76e1..ecaad21a6 100644</span>
<span class="gd">--- a/scrapy/utils/spider.py</span>
<span class="gi">+++ b/scrapy/utils/spider.py</span>
<span class="gu">@@ -17,7 +17,14 @@ def iter_spider_classes(module: ModuleType) -&gt; Generator[Type[Spider], Any, None</span>
<span class="w"> </span>    &quot;&quot;&quot;Return an iterator over all spider classes defined in the given module
<span class="w"> </span>    that can be instantiated (i.e. which have name)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for obj in vars(module).values():</span>
<span class="gi">+        if (</span>
<span class="gi">+            inspect.isclass(obj)</span>
<span class="gi">+            and issubclass(obj, Spider)</span>
<span class="gi">+            and obj.__module__ == module.__name__</span>
<span class="gi">+            and getattr(obj, &#39;name&#39;, None)</span>
<span class="gi">+        ):</span>
<span class="gi">+            yield obj</span>

<span class="w"> </span>def spidercls_for_request(spider_loader: SpiderLoader, request: Request, default_spidercls: Optional[Type[Spider]]=None, log_none: bool=False, log_multiple: bool=False) -&gt; Optional[Type[Spider]]:
<span class="w"> </span>    &quot;&quot;&quot;Return a spider class that handles the given Request.
<span class="gu">@@ -30,7 +37,27 @@ def spidercls_for_request(spider_loader: SpiderLoader, request: Request, default</span>
<span class="w"> </span>    default_spidercls passed. It can optionally log if multiple or no spiders
<span class="w"> </span>    are found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    snames = []</span>
<span class="gi">+    for name, spcls in spider_loader._spiders.items():</span>
<span class="gi">+        if spcls.handles_request(request):</span>
<span class="gi">+            snames.append(name)</span>
<span class="gi">+</span>
<span class="gi">+    if len(snames) == 0:</span>
<span class="gi">+        if log_none:</span>
<span class="gi">+            logger.warning(&#39;Unable to find spider that handles: %(request)s&#39;, {&#39;request&#39;: request})</span>
<span class="gi">+        return default_spidercls</span>
<span class="gi">+    elif len(snames) &gt; 1:</span>
<span class="gi">+        if log_multiple:</span>
<span class="gi">+            logger.warning(&#39;More than one spider can handle: %(request)s - %(snames)s&#39;, {&#39;request&#39;: request, &#39;snames&#39;: &#39;, &#39;.join(snames)})</span>
<span class="gi">+        return default_spidercls</span>
<span class="gi">+    else:</span>
<span class="gi">+        return spider_loader.load(snames[0])</span>

<span class="w"> </span>class DefaultSpider(Spider):
<span class="gd">-    name = &#39;default&#39;</span>
\ No newline at end of file
<span class="gi">+    name = &#39;default&#39;</span>
<span class="gi">+</span>
<span class="gi">+def iterate_spider_output(result: Any) -&gt; Iterable[Any]:</span>
<span class="gi">+    &quot;&quot;&quot;Iterate over a spider output, even if it is a deferred or coroutine.&quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(result, (Deferred, CoroutineType)):</span>
<span class="gi">+        result = deferred_from_coro(result)</span>
<span class="gi">+    return arg_to_iter(result)</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/ssl.py b/scrapy/utils/ssl.py</span>
<span class="gh">index 628e05da4..03fb628c2 100644</span>
<span class="gd">--- a/scrapy/utils/ssl.py</span>
<span class="gi">+++ b/scrapy/utils/ssl.py</span>
<span class="gu">@@ -3,4 +3,18 @@ import OpenSSL._util as pyOpenSSLutil</span>
<span class="w"> </span>import OpenSSL.SSL
<span class="w"> </span>import OpenSSL.version
<span class="w"> </span>from OpenSSL.crypto import X509Name
<span class="gd">-from scrapy.utils.python import to_unicode</span>
\ No newline at end of file
<span class="gi">+from scrapy.utils.python import to_unicode</span>
<span class="gi">+</span>
<span class="gi">+def get_openssl_version():</span>
<span class="gi">+    &quot;&quot;&quot;Return the OpenSSL version string.&quot;&quot;&quot;</span>
<span class="gi">+    return OpenSSL.version.__version__</span>
<span class="gi">+</span>
<span class="gi">+def x509name_to_string(x509name: X509Name) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Convert an X509Name object to a string.&quot;&quot;&quot;</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for name_entry in x509name:</span>
<span class="gi">+        field_name = pyOpenSSLutil.lib.OBJ_nid2sn(name_entry.get_object().nid)</span>
<span class="gi">+        field_name = to_unicode(field_name, errors=&#39;ignore&#39;)</span>
<span class="gi">+        field_value = to_unicode(name_entry.get_value(), errors=&#39;ignore&#39;)</span>
<span class="gi">+        result.append(f&#39;{field_name}={field_value}&#39;)</span>
<span class="gi">+    return &#39;/&#39;.join(result)</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/template.py b/scrapy/utils/template.py</span>
<span class="gh">index 351f808e6..d590c776c 100644</span>
<span class="gd">--- a/scrapy/utils/template.py</span>
<span class="gi">+++ b/scrapy/utils/template.py</span>
<span class="gu">@@ -16,4 +16,11 @@ def string_camelcase(string: str) -&gt; str:</span>
<span class="w"> </span>    &#39;MissingImages&#39;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    return &#39;&#39;.join(s.title() for s in CAMELCASE_INVALID_CHARS.split(string))</span>
<span class="gi">+</span>
<span class="gi">+def render_templatefile(path: Union[str, PathLike], **kwargs: Any) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Render a template file using the given parameters&quot;&quot;&quot;</span>
<span class="gi">+    path = Path(path)</span>
<span class="gi">+    text = path.read_text()</span>
<span class="gi">+    text = string.Template(text).substitute(**kwargs)</span>
<span class="gi">+    path.write_text(text)</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/url.py b/scrapy/utils/url.py</span>
<span class="gh">index a6e4832de..018c8d0a1 100644</span>
<span class="gd">--- a/scrapy/utils/url.py</span>
<span class="gi">+++ b/scrapy/utils/url.py</span>
<span class="gu">@@ -15,23 +15,41 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    from scrapy import Spider
<span class="w"> </span>UrlT = Union[str, bytes, ParseResult]

<span class="gi">+def _is_filesystem_path(url: str) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Return True if given URL appears to be a filesystem path.&quot;&quot;&quot;</span>
<span class="gi">+    return bool(re.match(r&#39;^[a-zA-Z]:[/\\]|^/[a-zA-Z0-9$_@.&amp;+-]&#39;, url))</span>
<span class="gi">+</span>
<span class="w"> </span>def url_is_from_any_domain(url: UrlT, domains: Iterable[str]) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;Return True if the url belongs to any of the given domains&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    host = parse_url(url).netloc.lower()</span>
<span class="gi">+    if not host:</span>
<span class="gi">+        return False</span>
<span class="gi">+    domains = [d.lower() for d in domains]</span>
<span class="gi">+    return any(host.endswith(d) for d in domains)</span>

<span class="w"> </span>def url_is_from_spider(url: UrlT, spider: Type[&#39;Spider&#39;]) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;Return True if the url belongs to the given spider&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return url_is_from_any_domain(url, getattr(spider, &#39;allowed_domains&#39;, []))</span>

<span class="w"> </span>def url_has_any_extension(url: UrlT, extensions: Iterable[str]) -&gt; bool:
<span class="w"> </span>    &quot;&quot;&quot;Return True if the url ends with one of the extensions provided&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    url = cast(str, url)</span>
<span class="gi">+    if not isinstance(url, str):</span>
<span class="gi">+        url = url.url if isinstance(url, ParseResult) else to_unicode(url)</span>
<span class="gi">+    url, _ = urldefrag(url)  # remove fragments</span>
<span class="gi">+    path = urlparse(url).path</span>
<span class="gi">+    if not path:</span>
<span class="gi">+        return False</span>
<span class="gi">+    path = _unquotepath(path)</span>
<span class="gi">+    return any(path.endswith(&#39;.&#39; + ext) for ext in extensions)</span>

<span class="w"> </span>def parse_url(url: UrlT, encoding: Optional[str]=None) -&gt; ParseResult:
<span class="w"> </span>    &quot;&quot;&quot;Return urlparsed url from the given argument (which could be an already
<span class="w"> </span>    parsed url)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(url, ParseResult):</span>
<span class="gi">+        return url</span>
<span class="gi">+    return urlparse(to_unicode(url, encoding))</span>

<span class="w"> </span>def escape_ajax(url: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -56,16 +74,29 @@ def escape_ajax(url: str) -&gt; str:</span>
<span class="w"> </span>    &gt;&gt;&gt; escape_ajax(&quot;www.example.com/ajax.html&quot;)
<span class="w"> </span>    &#39;www.example.com/ajax.html&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    defrag, frag = urldefrag(url)</span>
<span class="gi">+    if not frag.startswith(&#39;!&#39;):</span>
<span class="gi">+        return url</span>
<span class="gi">+    return (defrag + (&#39;&amp;&#39; if &#39;?&#39; in defrag else &#39;?&#39;) +</span>
<span class="gi">+            &#39;_escaped_fragment_=&#39; + frag[1:])</span>

<span class="w"> </span>def add_http_if_no_scheme(url: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Add http as the default scheme if it is missing from the url.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = re.match(r&#39;^\w+://&#39;, url, re.I)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        url = &#39;http://&#39; + url</span>
<span class="gi">+    return url</span>

<span class="w"> </span>def guess_scheme(url: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Add an URL scheme if missing: file:// for filepath-like input or
<span class="w"> </span>    http:// otherwise.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = re.match(r&#39;^\w+://&#39;, url, re.I)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        if _is_filesystem_path(url):</span>
<span class="gi">+            url = &#39;file://&#39; + url</span>
<span class="gi">+        else:</span>
<span class="gi">+            url = &#39;http://&#39; + url</span>
<span class="gi">+    return url</span>

<span class="w"> </span>def strip_url(url: str, strip_credentials: bool=True, strip_default_port: bool=True, origin_only: bool=False, strip_fragment: bool=True) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Strip URL string from some of its components:
<span class="gu">@@ -77,4 +108,13 @@ def strip_url(url: str, strip_credentials: bool=True, strip_default_port: bool=T</span>
<span class="w"> </span>      query and fragment components ; it also strips credentials
<span class="w"> </span>    - ``strip_fragment`` drops any #fragment component
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if strip_credentials or origin_only:</span>
<span class="gi">+        url = re.sub(r&#39;^([^:]+://)(?:[^/]*@)?(.*)$&#39;, r&#39;\1\2&#39;, url)</span>
<span class="gi">+    if strip_default_port:</span>
<span class="gi">+        url = re.sub(r&#39;^(https?://[^:/]+):80(?![0-9])&#39;, r&#39;\1&#39;, url)</span>
<span class="gi">+        url = re.sub(r&#39;^(https://[^:/]+):443(?![0-9])&#39;, r&#39;\1&#39;, url)</span>
<span class="gi">+        url = re.sub(r&#39;^(ftp://[^:/]+):21(?![0-9])&#39;, r&#39;\1&#39;, url)</span>
<span class="gi">+    if origin_only:</span>
<span class="gi">+        url = re.sub(r&#39;^([^:]+://[^/]+)(?:/.*)?&#39;, r&#39;\1/&#39;, url)</span>
<span class="gi">+    if strip_fragment:</span>
<span class="gi">+        url = re.sub(r&#39;#.*$&#39;, &#39;&#39;, url)</span>
\ No newline at end of file
<span class="gh">diff --git a/scrapy/utils/versions.py b/scrapy/utils/versions.py</span>
<span class="gh">index c1945b11c..d7c8fcf62 100644</span>
<span class="gd">--- a/scrapy/utils/versions.py</span>
<span class="gi">+++ b/scrapy/utils/versions.py</span>
<span class="gu">@@ -8,4 +8,27 @@ import parsel</span>
<span class="w"> </span>import twisted
<span class="w"> </span>import w3lib
<span class="w"> </span>import scrapy
<span class="gd">-from scrapy.utils.ssl import get_openssl_version</span>
\ No newline at end of file
<span class="gi">+from scrapy.utils.ssl import get_openssl_version</span>
<span class="gi">+</span>
<span class="gi">+def scrapy_components_versions() -&gt; List[Tuple[str, str]]:</span>
<span class="gi">+    &quot;&quot;&quot;Return a list of tuples containing the versions of the main Scrapy components.&quot;&quot;&quot;</span>
<span class="gi">+    lxml_version = &quot;.&quot;.join(map(str, lxml.etree.LXML_VERSION))</span>
<span class="gi">+    libxml2_version = &quot;.&quot;.join(map(str, lxml.etree.LIBXML_VERSION))</span>
<span class="gi">+    try:</span>
<span class="gi">+        twisted_version = twisted.version.short()</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        twisted_version = twisted.__version__</span>
<span class="gi">+</span>
<span class="gi">+    return [</span>
<span class="gi">+        (&quot;Scrapy&quot;, scrapy.__version__),</span>
<span class="gi">+        (&quot;lxml&quot;, lxml_version),</span>
<span class="gi">+        (&quot;libxml2&quot;, libxml2_version),</span>
<span class="gi">+        (&quot;cssselect&quot;, cssselect.__version__),</span>
<span class="gi">+        (&quot;parsel&quot;, parsel.__version__),</span>
<span class="gi">+        (&quot;w3lib&quot;, w3lib.__version__),</span>
<span class="gi">+        (&quot;Twisted&quot;, twisted_version),</span>
<span class="gi">+        (&quot;Python&quot;, sys.version.split()[0]),</span>
<span class="gi">+        (&quot;pyOpenSSL&quot;, get_openssl_version()),</span>
<span class="gi">+        (&quot;cryptography&quot;, cryptography.__version__),</span>
<span class="gi">+        (&quot;Platform&quot;, platform.platform()),</span>
<span class="gi">+    ]</span>
\ No newline at end of file
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>